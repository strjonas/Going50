# Project Files Extraction
# Generated on: 2025-03-27 12:18:24
# Root directories: /Users/jonas/Code/going50, /Users/jonas/Downloads/Studienarbeit - OBDII-2
# File patterns: *.tex, *.md, *.dart, *.yaml, *.json



================================================================================
DIRECTORY: /Users/jonas/Code/going50
================================================================================



################################################################################
FILE: geminiArchitecture.md
################################################################################

# Going50 Flutter Codebase Documentation

This document provides an overview of the architecture, components, data model, and implemented features of the Going50 Flutter codebase, based on the provided `lib` folder structure and file contents.

## 1. Architecture Overview

The Going50 codebase appears to follow a layered architecture, common in Flutter applications, with a separation of concerns into distinct layers:

- **Presentation Layer (`presentation/`)**:  Contains Flutter widgets, screens, and providers responsible for the user interface and user interactions. This layer uses the Provider package for state management.
- **Service Layer (`services/`)**:  Houses services that encapsulate business logic and interact with data sources (local storage, databases, external APIs, device features like Bluetooth and sensors). Services are designed to be independent of the UI and can be reused across different parts of the application. `service_locator.dart` suggests a Service Locator pattern for dependency injection using the `get_it` package.
- **Core Layer (`core_/`)**:  Provides foundational functionalities and utilities used across the application. This includes:
    - `core/theme/`:  App theming (colors, text styles, light/dark themes).
    - `core/constants/`:  Application-wide constants (app info, feature flags, error messages, routes).
    - `core/utils/`:  Utility classes for device capabilities, driving calculations, formatting, and permissions.
- **Data Model Layer (`core_models/`)**: Defines the data structures used throughout the application. These models represent entities like trips, user profiles, driving data, and performance metrics.
- **Behavior Classifier Library (`behavior_classifier_lib/`)**:  A separate library likely responsible for analyzing driving data and detecting driving behaviors (calm driving, idling, etc.). This is designed in a modular way with `detectors/`, `interfaces/`, and `managers/`.
- **OBD Library (`obd_lib/`) and Sensor Library (`sensor_lib/`)**:  Likely responsible for handling OBD-II data communication and sensor data acquisition respectively, although their contents are not provided in detail.
- **Navigation (`navigation/`)**:  Handles app navigation using `TabNavigator` and `AppRouter` for named routes.
- **Firebase (`firebase/`)**:  Integrates Firebase services for features like authentication, cloud storage, and analytics.
- **Data Library (`data_lib/`)**:  Likely contains data access logic, potentially using the `drift` database package for local persistence.

This layered approach promotes modularity, testability, and maintainability. Changes in one layer should ideally have minimal impact on other layers.

## 2. Key Components and their Interactions

Here's a breakdown of key components and how they interact, based on the provided files:

**2.1. `app.dart` (Main Application Setup)**

- **Purpose**:  Entry point of the Flutter application. Sets up the application's theme, providers, navigation, and initial screen based on onboarding status.
- **Key Components**:
    - `App` Widget:  The root widget, manages application state (onboarding completion, loading state).
    - `MultiProvider`:  Sets up Provider state management, making various providers accessible throughout the app.
    - Providers:
        - `DrivingProvider`: Manages driving-related state, interacts with `DrivingService`.
        - `InsightsProvider`: Manages insights and performance metrics, interacts with `DrivingService` and `PerformanceMetricsService`.
        - `UserProvider`: Manages user-related state, interacts with `UserService` and `PreferencesService`.
        - `SocialProvider`: Manages social features, interacts with `SocialService`, `LeaderboardService`, and `SharingService`.
        - `PrivacyService` (Provider): Manages user privacy settings.
    - `MaterialApp`:  Configures the Flutter Material App with theme, routes, and home screen.
    - `TabNavigator`:  Handles tab-based navigation for the main sections of the app (Drive, Insights, Community, Profile).
    - `OnboardingScreen`:  Displayed if onboarding is not complete.
    - `AppRouter`:  Handles named route generation for navigation.
    - `serviceLocator`:  Used to access services registered via `get_it`.
- **Interactions**:
    - `App` widget uses `SharedPreferences` to check onboarding status.
    - Providers are created using services obtained from `serviceLocator`.
    - `MaterialApp` uses `AppRouter` for navigation and `TabNavigator` or `OnboardingScreen` as the home screen based on application state.

**2.2. `services/` (Service Layer)**

- **Purpose**:  Encapsulates business logic and data access. Services are designed to be reusable and independent of the UI.
- **Key Services (inferred from imports in `app.dart` and folder structure):**
    - `DrivingService`:  Handles core driving functionalities (trip recording, data collection, etc.).
    - `PerformanceMetricsService`:  Calculates and manages driver performance metrics.
    - `UserService`:  Manages user profiles and authentication.
    - `PreferencesService`:  Manages user preferences.
    - `PrivacyService`:  Manages user privacy settings.
    - `SocialService`:  Handles core social functionalities.
    - `LeaderboardService`:  Manages leaderboard data.
    - `SharingService`:  Handles content sharing functionalities.
- **Interactions**:
    - Services are instantiated and registered in `service_locator.dart` using `get_it`.
    - Providers in the presentation layer use these services to access data and business logic.
    - Services likely interact with data sources (local database, Firebase, device sensors, OBD-II).

**2.3. `presentation/providers/` (Presentation Providers)**

- **Purpose**:  Manage the state for the presentation layer. Providers act as intermediaries between the UI and the service layer. They use `ChangeNotifierProvider` to notify UI components of state changes.
- **Key Providers (from `app.dart`):**
    - `DrivingProvider`:  State related to driving mode, active trip, etc.
    - `InsightsProvider`:  State related to driving insights, performance metrics, trip history.
    - `UserProvider`:  State related to user profile, settings, authentication.
    - `SocialProvider`:  State related to social features, leaderboard, community content.
- **Interactions**:
    - Providers are created in `app.dart` and made available via `MultiProvider`.
    - UI components (widgets, screens) consume data from providers using `Provider.of` or `Consumer`.
    - Providers call methods in the service layer to perform actions and update state based on service responses.

**2.4. `behavior_classifier_lib/` (Behavior Classifier Library)**

- **Purpose**:  Analyzes driving data to detect and classify different driving behaviors related to eco-driving.
- **Key Components**:
    - `interfaces/BehaviorDetector`:  Abstract base class for all behavior detectors, defining the interface for detection logic.
    - `detectors/`:  Contains concrete implementations of `BehaviorDetector` for specific behaviors:
        - `CalmDrivingDetector`: Detects aggressive acceleration and braking.
        - `SpeedOptimizationDetector`: Detects if speed is within the optimal range.
        - `IdlingDetector`: Detects excessive engine idling.
        - `ShortDistanceDetector`: Detects inefficient short trips.
        - `RPMManagementDetector`: Detects high RPM driving.
        - `StopManagementDetector`: Detects frequent stops and starts.
        - `FollowDistanceDetector`: Detects unsafe following distance.
    - `managers/EcoDrivingManager`:  Manages a collection of `BehaviorDetector` instances, processes driving data, and calculates an overall eco-driving score.
- **Interactions**:
    - `EcoDrivingManager` uses a queue (`dataQueue`) to store recent driving data (`CombinedDrivingData`).
    - `EcoDrivingManager.addDataPoint()` adds new data points to the queue.
    - `EcoDrivingManager.analyzeAll()` iterates through detectors and calls `detectBehavior()` on each, using the data in the queue.
    - `EcoDrivingManager.calculateOverallScore()` and `getDetailedAnalysis()` calculate scores and provide analysis results based on detector outputs.
    - Detectors use `CombinedDrivingData` as input and return `BehaviorDetectionResult` indicating detection status, confidence, severity, and messages.

**2.5. `core_models/` (Core Data Models)**

- **Purpose**:  Defines the data structures used throughout the application. These models are Plain Old Dart Objects (PODOs) that represent entities and data exchanged between layers.
- **Key Models (from provided files and `data_model.md`):**
    - `CombinedDrivingData`:  Aggregates data from OBD-II, phone sensors, and context data. Used as input for behavior detectors.
    - `OBDIIData`:  Model for OBD-II data.
    - `PhoneSensorData`:  Model for phone sensor data (GPS, accelerometer, etc.).
    - `OptionalContextData`: Model for optional contextual data (speed limit, road type, etc.).
    - `BehaviorDetectionResult`:  Result of behavior detection from detectors.
    - `DriverPerformanceMetrics`: Aggregated performance metrics for a driver.
    - `DrivingEvent`: Represents a detected driving event.
    - `DataPrivacySettings`: User's data privacy preferences.
    - `ExternalIntegration` & `SyncStatus`: Models for external platform integrations.
    - `UserProfile`, `UserPreferences`, `Challenge`, `UserChallenge`, `Badge`, `Streak`, `LeaderboardEntry`, `SocialConnection`, `SocialInteraction`, `SharedContent` (inferred from `data_model.md`).
    - `Trip`, `TripDataPoint` (inferred from `data_model.md`).
- **Relationships**:  The `data_model.md` file provides a diagram and descriptions of relationships between these models. For example, `Trip` contains a list of `TripDataPoint` and `DrivingEvent`. `UserProfile` is related to `DataPrivacySettings` and `UserPreferences`.

**2.6. `core/utils/` (Core Utilities)**

- **Purpose**:  Provides utility functions and classes that are used across the application.
- **Key Utilities (from provided files):**
    - `DeviceUtils`:  Checks device capabilities (Bluetooth, sensors, battery, etc.).
    - `DrivingUtils`:  Contains driving-related calculations (speed efficiency, fuel consumption, acceleration, distance, etc.).
    - `FormatterUtils`:  Formats data for display (dates, times, distances, speeds, fuel, currency, file sizes).
    - `PermissionUtils`:  Handles permission requests and checks (location, Bluetooth, sensors).
- **Interactions**:  Utility classes are used by services, providers, and potentially UI components to perform common tasks and calculations. They are designed to be stateless and reusable.

**2.7. `core/constants/` (Core Constants)**

- **Purpose**:  Defines application-wide constants, making configuration and management easier.
- **Key Constants (from `app_constants.dart` and `route_constants.dart`):**
    - `AppInfo`:  Application name, version, build number.
    - `DefaultValues`:  Default values for refresh intervals, eco-score, etc.
    - `FeatureFlags`:  Feature flags to enable/disable features during development.
    - `TimingConstants`:  Timeout values for OBD connection, sensor initialization, etc.
    - `ErrorMessages`:  Common error messages.
    - `TabRoutes`, `DriveRoutes`, `InsightsRoutes`, `CommunityRoutes`, `ProfileRoutes`, `OnboardingRoutes`:  Named routes for navigation.
    - `AppColors`:  Defines the app's color palette.
- **Usage**: Constants are used throughout the codebase to configure application behavior, access app information, and define navigation routes.

## 3. Data Model

The data model is comprehensively documented in `lib/core_models/data_model.md`.  Key aspects of the data model include:

- **Entities**:  The model defines entities like `Trip`, `UserProfile`, `DrivingEvent`, `PerformanceMetrics`, `Challenge`, `Badge`, `SocialConnection`, etc., representing core concepts in the application.
- **Attributes**: Each entity has attributes defining its properties (e.g., `Trip` has `startTime`, `endTime`, `distanceKm`, `ecoScore`).
- **Relationships**:  Entities are related to each other (e.g., `Trip` has a one-to-many relationship with `TripDataPoint` and `DrivingEvent`). `data_model.md` includes an ER diagram visualizing these relationships.
- **Data Types**:  Attributes have specific data types (String, DateTime, double, int, bool, JSON).
- **Purpose**: The data model is designed to capture all relevant information for trip tracking, driving analysis, user management, gamification, social features, and external integrations.
- **Persistence**: The `drift` package dependency in `pubspec.yaml` and mention in `data_model.md` suggest that the data model is intended to be persisted using a local SQLite database.

**Key Data Models for Eco-Driving Analysis:**

- **`CombinedDrivingData`**:  Central data model for real-time driving data, combining OBD-II, sensor, and context data. Used by behavior detectors.
- **`BehaviorDetectionResult`**:  Output of behavior detectors, providing insights into driving patterns.
- **`DriverPerformanceMetrics`**:  Aggregated metrics summarizing driving performance over time, providing user feedback and progress tracking.
- **`DrivingEvent`**:  Records specific instances of eco-driving related events (e.g., hard braking, excessive idling).

## 4. Implemented Features (Based on Code Analysis)

Based on the file names, folder structure, and code content, the following features appear to be implemented or under development:

- **Driving Data Collection**:
    - OBD-II data reading (indicated by `obd_lib/`, `flutter_reactive_ble` dependency, `OBDIIData` model).
    - Phone sensor data collection (GPS, accelerometer, etc., indicated by `sensor_lib/`, `sensors_plus` and `geolocator` dependencies, `PhoneSensorData` model).
    - Combining data from multiple sources (`CombinedDrivingData`).
- **Eco-Driving Behavior Analysis**:
    - Detection of various eco-driving behaviors (calm driving, speed optimization, idling, short trips, RPM management, stop management, follow distance) using `behavior_classifier_lib/`.
    - Calculation of an overall eco-driving score (`EcoDrivingManager`).
    - Generation of driving insights and feedback messages (`BehaviorDetectionResult`, `DriverPerformanceMetrics`).
- **Trip Tracking and History**:
    - Recording of driving trips (`Trip` model, `DrivingService`).
    - Storage of trip data points (`TripDataPoint` model).
    - Trip history and detail views (inferred from `InsightsRoutes`, `InsightsProvider`).
- **User Management**:
    - User profiles (`UserProfile` model, `UserService`, `UserProvider`).
    - User preferences (`UserPreferences` model, `PreferencesService`, `UserProvider`).
    - Data privacy settings (`DataPrivacySettings` model, `PrivacyService`).
    - User authentication (Firebase Auth dependency).
- **Performance Metrics and Insights**:
    - Calculation of driver performance metrics (`PerformanceMetricsService`, `InsightsProvider`, `DriverPerformanceMetrics` model).
    - Display of performance insights and improvement recommendations.
- **Theming and UI**:
    - Light and dark theme support (`AppTheme`, `AppColors`).
    - Tab-based navigation (`TabNavigator`).
    - Onboarding flow (`OnboardingScreen`, `OnboardingRoutes`).
- **Social Features (Basic Structure)**:
    - Leaderboards (`LeaderboardService`, `SocialProvider`, `LeaderboardEntry` model).
    - Social connections (`SocialService`, `SocialProvider`, `SocialConnection` model).
    - Sharing functionality (`SharingService`, `SocialProvider`, `SharedContent` model).
- **Firebase Integration**:
    - Firebase Core, Auth, Firestore, Storage, Messaging, Analytics, Crashlytics dependencies suggest integration with various Firebase services.
- **Local Data Persistence**:
    - `drift` database package for local data storage.
    - `shared_preferences` for storing simple key-value data (onboarding status).
- **Permissions Handling**:
    - `permission_handler` dependency and `PermissionUtils` for managing device permissions (location, Bluetooth, sensors).

**Features Not Explicitly Evident or Potentially Unimplemented (Based on Limited Context):**

- **Gamification Features**: While `data_model.md` mentions `Challenge`, `Badge`, `Streak`, and `UserChallenge` models, the level of implementation and integration of gamification features is unclear from the provided files. Feature flags in `app_constants.dart` suggest gamification is considered a feature to be enabled/disabled.
- **External Integrations**:  `ExternalIntegration` and `SyncStatus` models exist, but the actual integration with external platforms (Uber, Lyft, etc.) and the extent of data synchronization are not clear.
- **Advanced Data Visualization**:  While `fl_chart` dependency is present, the complexity and scope of data visualization features are not fully evident.
- **Background Data Collection**: Feature flags suggest background collection is considered, but the implementation details and robustness are unclear.
- **Comprehensive Testing**:  The presence of `flutter_test` in `dev_dependencies` indicates testing is intended, but the extent and coverage of tests are unknown.
- **Specific Requirements Implementation**: Without access to the project's requirements document, it's impossible to definitively state which requirements are fully implemented, partially implemented, or not implemented at all.

## 5. Limitations and Further Steps

This documentation is based on a limited set of files and folder structure. A complete understanding would require:

- **Access to the full codebase**:  To examine all files and understand the complete implementation.
- **Project Requirements Document**: To verify feature implementation against specific requirements.
- **Running the Application**: To observe the application's behavior and UI directly.
- **Database Schema Definition**: To understand the database structure in detail (Drift schema files).
- **Testing Code**: To assess the quality and coverage of automated tests.

For a more in-depth analysis and documentation, especially regarding feature completeness against requirements, using Agent Mode to access and analyze the entire codebase would be highly beneficial. This would allow for a more comprehensive and accurate assessment of the project's architecture, implementation status, and potential areas for improvement.

This document provides a starting point for understanding the Going50 Flutter codebase. Further investigation and potentially using Agent Mode are recommended for a more complete picture.

################################################################################
FILE: MockReplacementRoadmap.md
################################################################################

<think>Let me analyze the requirements for replacing mock implementations with real ones, particularly for social and gamification features. I need to determine if existing services are sufficient or if external services like Firebase would be needed.

First, let's consider the data storage approach in the app. From the service_locator.dart file, I can see that the app uses DataStorageManager for persistent storage. I need to understand if this is already set up for handling user accounts, social connections, and gamification data.

Key questions to answer:
1. Does the existing DataStorageManager support user authentication?
2. Is there a database schema ready for social connections and gamification data?
3. Are there any references to external services like Firebase in the existing codebase?

Let me think through the components we need to implement:

1. Account Registration:
   - User registration flow with email/password or social sign-in
   - User profile storage
   - Authentication token management

2. Social Features:
   - Friend connections (add, remove, accept requests)
   - Friend discovery
   - Leaderboards with real user data
   - Content sharing

3. Gamification:
   - Achievements based on real driving data
   - Badges for accomplishments
   - Challenges with progress tracking
   - Streaks based on consistent usage

I need to understand if the DataStorageManager already supports these needs or if we need to integrate external services.</think># Implementation Plan for Real Social & Gamification Features

After analyzing the codebase, I can see that the app has most of the infrastructure needed to replace mock implementations with real data. Let me assess the feasibility and outline an implementation plan.

## Current Architecture Assessment

The app uses a `DataStorageManager` class that serves as the main data persistence layer. The services for social features and gamification (like `SocialService`, `LeaderboardService`, `AchievementService`, and `ChallengeService`) are already properly structured but many still use mock data.

### Key Observations:

1. **Authentication**: There doesn't appear to be a comprehensive authentication system integrated yet
2. **Database Backend**: The app has local storage capabilities, but may need a cloud backend for social features
3. **Service Infrastructure**: The services themselves are well-architected, but need to be connected to real data sources

## Feasibility Assessment

### What Can Be Implemented Without External Services:

1. **Local Gamification Features**:
   - Achievements and badges based on actual driving performance
   - Challenge tracking and progress management
   - Streak tracking for consistent usage

2. **Basic User Profile Management**:
   - User profile creation and editing
   - Local profile data storage

### What Would Require External Services:

1. **User Authentication**: A proper account system with secure authentication
2. **Social Connections**: Friend discovery, requests, and connections across users
3. **Global Leaderboards**: Rankings across all app users
4. **Content Sharing**: Sharing achievements and challenges with friends

## Implementation Plan

### Phase 1: Local Data Integration (1-2 weeks)

✅ **Connect Achievement Service to Real Data** 
   - Updated `AchievementService` to retrieve badges from `DataStorageManager`
   - Added `getBadgeProgress` method to calculate progress towards badges
   - Connected `achievements_grid.dart` to use real data from service

✅ **Connect Challenge UI to Challenge Service**
   - Updated `challenges_view.dart` to fetch challenges from `ChallengeService`
   - Implemented proper progress tracking in the UI
   - Fixed methods to use real data from the database

✅ **Fix ChallengeService Initialization**
   - Fixed critical error in `ChallengeService` where challenge IDs were too short for database constraints
   - Implemented deterministic ID generation that creates consistent 36-character IDs across app restarts
   - Preserved the original descriptive IDs by combining them with a padding pattern
   - Ensured service can properly initialize and store/retrieve challenges without creating duplicates

✅ **Fix Challenge Joining Functionality**
   - Fixed issue where joined challenges didn't move from available to active list
   - Added cache invalidation method in `ChallengeService` to ensure fresh data is loaded
   - Fixed bug in challenge definition lookup by using all challenges instead of just available ones
   - Added proper loading states during join operation for better user experience
   - Automatically switched to Active tab after joining to show the user their joined challenge
   - Added cache invalidation to challenge detail screen for consistency
   - Fixed critical bug in `challenge_detail_screen.dart` where a hardcoded 'currentUser' ID was used instead of the actual user ID from UserService
   - Ensured consistent user ID usage between the challenge list and detail screens

✅ **Implemented Challenge Leaving Functionality**
   - Created `leaveChallenge` method in `ChallengeService` to allow users to opt out of challenges they've joined
   - Added `deleteUserChallenge` method to `DataStorageManager` to remove user challenges from the database
   - Implemented proper UI feedback during the leave operation with loading states and success/error notifications
   - Added navigation handling to properly update the challenge list when returning to the main screen

✅ **Refactored Challenge Feature to Reduce Technical Debt**
   - Implemented an event bus pattern through `challengeStateChangeStream` to notify UI components of challenge state changes
   - Centralized challenge UI data formatting to reduce code duplication
   - Removed redundant cache invalidation calls by centralizing cache management in the service layer
   - Created deterministic simulated participant counts for better consistency in the UI
   - Improved error handling and logging across the challenge feature
   - Reduced over-reliance on navigation result patterns for state updates
   - Added proper cleanup of stream subscriptions in widget disposal
   - Simplified UI code by extracting formatting logic into helper methods

✅ **Implement Local Profile Stats**
   - Updated profile statistics to use real driving data from TripService and PerformanceMetricsService
   - Implemented a `getLongestTrip` method in StatisticsSummary to calculate the longest trip based on actual trip data
   - Created a `getBestDrivingStreak` method to display the user's best streak based on consecutive days with trips
   - Added `_calculateBestDrivingStreak` method to DataStorageManager to analyze trip history and calculate streak
   - Updated UserService with `getUserMetrics` to provide access to additional metrics not covered by PerformanceMetrics
   - Replaced mock data with FutureBuilders that load and display real-time user statistics



### Phase 2: Firebase Integration (2-3 weeks)

Based on my analysis, **Firebase would be the best choice** for quickly implementing the social features:

1. ✅ **Set Up Firebase Project (1 day)**
   - Added Firebase dependencies to `pubspec.yaml`
   - Created `FirebaseInitializer` class to manage Firebase initialization
   - Added placeholder `firebase_options.dart` file for FlutterFire CLI
   - Updated `main.dart` to initialize Firebase when app starts
   - Added Firebase initialization error handling to maintain offline functionality

2. ✅ **Implement Firebase Authentication (3-4 days)**
   - Created `AuthenticationService` class for user authentication
   - Updated `UserProfile` model to include Firebase ID and email
   - Extended `DataStorageManager` with Firebase authentication methods
   - Updated `UserService` to handle Firebase user profiles
   - Modified `service_locator.dart` to register Firebase services

3. **Set Up Cloud Firestore (2-3 days)**
   - Design database schema for user profiles, social connections, and shared content
   - Update `DataStorageManager` to sync with Firestore
   - Implement data synchronization strategies

4. **Update User Profile Management (2-3 days)**
   - Connect user profile UI to Firebase user data
   - Implement profile image upload with Firebase Storage
   - Add account linking and management features

### Phase 3: Social Features Implementation (2-3 weeks)

1. **Friend System Implementation (5-6 days)**
   - Update `SocialService` to use Firebase for friend requests and connections
   - Implement user discovery functionality
   - Create friend request and management UI
   - Connect `friends_view.dart` to the actual service

2. **Leaderboard Implementation (3-4 days)**
   - Update `LeaderboardService` to fetch real data from Firebase
   - Implement sorting and filtering based on actual eco-scores
   - Add regional and friend-based filtering
   - Connect UI to the updated service

3. **Profile Sharing (3-4 days)**
   - Implement `SharingService` to share achievements and challenges
   - Create deep linking functionality for shared content
   - Implement content privacy controls based on user settings

4. **Friend Activity Feed (3-4 days)**
   - Create activity tracking for achievement unlocks and challenge completions
   - Implement feed UI to display friend activities
   - Add interaction features (likes, comments)
   #### Transition Plan: Local to Server-Based Challenge System

Our current implementation of the challenge system uses a workaround with deterministic client-side IDs to satisfy database constraints. This is sufficient for local functionality, but needs to transition to a server-based implementation during Firebase integration. Below are the specific implementation steps for this transition:

##### Current Implementation Notes

- Challenge definitions are hard-coded in `ChallengeService._defineSystemChallenges()`
- Using deterministic 36-character IDs to ensure consistency across app restarts
- All challenge logic executes locally on the device
- Progress is stored in local SQLite database through `DataStorageManager`

##### Server Implementation Transition Steps

1. **Design Firestore Schema** (During Phase 2.3)
   - Create `challenges` collection with fields matching our current Challenge model
   - Add server-specific fields: `activeFrom`, `activeTo`, `version`, `targetAudience`
   - Create `user_challenges` subcollection under user documents for progress tracking
   - Design security rules to control read/write access appropriately

2. **Update ChallengeService** (Early Phase 3)
   - Modify to fetch challenges from Firebase when online
   - Implement local caching with `shared_preferences` or Firebase offline persistence
   - Add versioning to handle challenge definition updates
   - Maintain backward compatibility with existing local challenges

3. **Challenge Synchronization Implementation** (Phase 3.1)
   - Add bidirectional sync for challenge progress
   - Implement conflict resolution for offline progress updates
   - Add background sync capabilities using WorkManager/BackgroundFetch

4. **Migration Process** (Phase 3.2)
   - Create Cloud Function to migrate existing user challenge progress
   - Implement version detection to trigger migration for upgrading users
   - Add analytics to track migration success rates

5. **Admin Interface** (Phase 3.3)
   - Create Firebase Admin SDK integration for challenge management
   - Implement CRUD operations for challenges
   - Add scheduling interface for timed challenges
   - Develop analytics dashboard for challenge engagement metrics

This transition will enable global challenge participation, timed events, and centralized analytics that aren't possible with the current local-only implementation.

### Phase 4: Integration & Testing (1-2 weeks)

1. **Data Synchronization Refinement**
   - Implement proper offline support
   - Add conflict resolution for data synchronization
   - Optimize bandwidth usage for mobile data

2. **Security Rules Implementation**
   - Define Firestore security rules to protect user data
   - Implement proper data access controls
   - Test security with penetration testing

3. **Cross-Device Testing**
   - Test social features across different devices
   - Verify push notification delivery
   - Ensure consistent experience across platforms

## Estimated Resources Required

1. **Firebase Services**:
   - Firebase Authentication
   - Cloud Firestore (NoSQL database)
   - Firebase Storage (for profile images)
   - Firebase Cloud Messaging (for social notifications)

2. **Development Time**:
   - Total estimate: 6-10 weeks depending on team size
   - Additional testing time: 1-2 weeks

3. **Third-party Dependencies**:
   - Firebase Flutter packages
   - Image picker and processing libraries
   - Deep linking package for content sharing

## Implementation Recommendations

1. **Start with a Minimum Viable Product**:
   - Begin with basic authentication and profile management
   - Add friend connections before implementing complex social features
   - Focus on stability over feature completeness

2. **Incremental Deployment**:
   - Release features gradually to test with real users
   - Use Firebase A/B testing to evaluate feature acceptance
   - Gather feedback on social interactions

3. **Privacy-First Implementation**:
   - Ensure all social features respect user privacy settings
   - Make sharing opt-in rather than opt-out
   - Provide clear controls for managing shared content

This plan provides a structured approach to replace mock implementations with real data while adding the necessary infrastructure for social features. Firebase is recommended as it provides all the necessary components for authentication, data storage, and real-time features with minimal backend development requirements.

Would you like me to elaborate on any specific aspect of this implementation plan?


################################################################################
FILE: Architecture.md
################################################################################

# Going50 App: Refined Architecture Document

## Application Overview

Going50 is an eco-driving application designed to encourage sustainable driving behavior through real-time feedback, gamification, and social features. The app uses either OBD-II adapters or phone sensors to collect driving data, analyze driving patterns, and provide actionable feedback to improve driving efficiency.

## Design Principles

- **Minimalist & Intuitive**: Clean interfaces with focused content and clear visual hierarchies
- **Progressive Disclosure**: Information presented in layers, starting with core functionality
- **Glanceability**: Minimized distraction during driving with highly visible key information
- **Data Visualization**: Complex data presented through intuitive visualizations
- **Social Integration**: Social elements incorporated throughout to leverage normative feedback
- **Privacy-First**: Data collection and privacy controls made transparent and accessible
- **Low-Friction Onboarding**: Immediate value before requiring account creation
- **Offline-First**: Local data processing with optional cloud features

## Architecture Overview

The application follows a clean architecture pattern with clear separation of concerns:

```
going50/
│
├── lib/                          # Application code
│   ├── main.dart                 # Application entry point
│   ├── app.dart                  # MyApp widget, theme setup, initial routing
│   │
│   ├── core/                     # Core utilities and configurations
│   ├── services/                 # Business logic and data operations
│   ├── presentation/             # All UI-related code (screens, widgets, etc.)
│   ├── navigation/               # Routing and navigation structure
│   │
│   ├── behavior_classifier_lib/  # Driving behavior classification
│   ├── core_models/              # Data models
│   ├── data_lib/                 # Data storage and retrieval
│   ├── obd_lib/                  # OBD interface
│   └── sensor_lib/               # Phone sensor interface
│
├── assets/                       # Static assets (images, fonts, etc.)
└── test/                         # Unit and widget tests
```

## Library Interfaces

### OBD Library (`obd_lib`)

```dart
// Main facade class
class ObdService {
  // Constructor
  ObdService({bool isDebugMode = false, bool initLogging = false});
  
  // Core functionality
  Stream<BluetoothDevice> scanForDevices();
  Future<bool> connect(String deviceId);
  Future<void> disconnect();
  
  // Data collection
  Future<void> startContinuousQueries();
  Future<void> stopQueries();
  Future<ObdData?> requestPid(String pid);
  
  // State and configuration
  bool get isConnected;
  bool get isEngineRunning;
  String? get selectedProfileId;
  Map<String, ObdData> get latestData;
  
  // Configuration management
  void setAdapterProfile(String profileId);
  void enableAutomaticProfileDetection();
  List<Map<String, String>> getAvailableProfiles();
  void addMonitoredPid(String pid);
  void removeMonitoredPid(String pid);
  
  // Event listeners
  void addListener(VoidCallback listener);
  void removeListener(VoidCallback listener);
  
  // Resource management
  void dispose();
}
```

### Sensor Library (`sensor_lib`)

```dart
class SensorService {
  // Constructor
  SensorService({
    SensorConfig? config,
    bool isDebugMode = false,
    bool initLogging = false,
  });
  
  // Core functionality
  Future<void> initialize();
  Future<void> startCollection({int collectionIntervalMs = 500});
  void stopCollection();
  
  // Data access
  Stream<PhoneSensorData> get dataStream;
  Future<PhoneSensorData> getLatestSensorData();
  
  // State
  bool get isCollecting;
  
  // Configuration
  void updateConfig(SensorConfig config);
  
  // Resource management
  void dispose();
}
```

### Behavior Classifier Library (`behavior_classifier_lib`)

```dart
class EcoDrivingManager {
  // Constructor
  EcoDrivingManager({
    List<BehaviorDetector>? detectors,
    int historyWindowSize = 60,
  });
  
  // Core functionality
  void addDataPoint(CombinedDrivingData dataPoint);
  Map<String, BehaviorDetectionResult> analyzeAll();
  double calculateOverallScore();
  
  // Analytics
  Map<String, dynamic> getDetailedAnalysis();
  
  // Reset functionality
  void clearData();
}

// Supporting interface for detection results
class BehaviorDetectionResult {
  final bool detected;
  final double confidence;
  final double? severity;
  final String? message;
  final Map<String, dynamic>? additionalData;
  final int occurrences;
  
  BehaviorDetectionResult({
    required this.detected,
    required this.confidence,
    this.severity,
    this.message,
    this.additionalData,
    this.occurrences = 0,
  });
}
```

### Data Library (`data_lib`)

```dart
class DataStorageManager {
  // Singleton accessor
  factory DataStorageManager() => _instance;
  
  // Initialization
  Future<void> initialize();
  
  // Trip management
  Future<Trip> startNewTrip();
  Future<Trip> endTrip(String tripId, {
    double? distanceKm,
    double? averageSpeedKmh,
    double? maxSpeedKmh,
    double? fuelUsedL,
    int? idlingEvents,
    int? aggressiveAccelerationEvents,
    int? hardBrakingEvents,
    int? excessiveSpeedEvents,
    int? stopEvents,
    double? averageRPM,
    int? ecoScore,
  });
  Future<void> saveTripDataPoint(String tripId, CombinedDrivingData dataPoint);
  Future<void> saveDrivingEvent(String tripId, DrivingEvent event);
  Future<List<Trip>> getAllTrips();
  Future<Trip?> getTrip(String tripId);
  Stream<List<Trip>> watchTrips();
  
  // Metrics management
  Future<void> savePerformanceMetrics(DriverPerformanceMetrics metrics);
  
  // User management
  Future<void> updateUserSettings({
    String? name,
    bool? isPublicProfile,
    bool? allowCloudSync,
  });
  
  // Data export
  Future<File> exportTripData(String tripId);
  Future<File> exportAllUserData();
  
  // Privacy management
  Future<void> saveDataPrivacySettings(DataPrivacySettings settings);
  Future<List<DataPrivacySettings>> getDataPrivacySettings();
  Future<DataPrivacySettings?> getDataPrivacySettingForType(String dataType);
  Future<bool> isOperationAllowed(String dataType, String operation);
  Future<bool> checkPrivacyPermission(String dataType, String operation);
  
  // Gamification
  Future<void> saveChallenge(Challenge challenge);
  Future<List<Challenge>> getAllChallenges();
  Future<void> saveUserChallenge(UserChallenge userChallenge);
  Future<List<UserChallenge>> getUserChallenges();
  
  // Social features
  Future<void> saveSocialConnection(SocialConnection connection);
  Future<List<SocialConnection>> getSocialConnections();
  
  // Resource management
  Future<void> dispose();
}
```

## Detailed Architecture

### Core Layer

```
core/
│
├── constants/                    # Application-wide constants
│   ├── app_constants.dart        # General app constants
│   ├── asset_paths.dart          # Paths to assets
│   ├── route_constants.dart      # Named routes
│   └── ui_constants.dart         # UI-related constants
│
├── enums/                        # Application enums
│   ├── trip_status.dart          # Trip status states
│   ├── connection_status.dart    # Connection status states
│   ├── feedback_type.dart        # Types of feedback
│   └── motivation_type.dart      # User motivation categories
│
├── theme/                        # Theming configuration
│   ├── app_theme.dart            # Main theme definition
│   ├── app_colors.dart           # Color palette
│   └── app_text_styles.dart      # Text styles
│
└── utils/                        # Utility functions
    ├── permission_utils.dart     # Permission handling utilities
    ├── formatter_utils.dart      # Data formatting utilities
    ├── driving_utils.dart        # Driving-related calculations
    └── device_utils.dart         # Device capability detection
```

### Services Layer

```
services/
│
├── service_locator.dart          # Dependency injection setup
│
├── driving/                      # Driving-related services
│   ├── driving_service.dart      # Main driving service facade
│   ├── obd_connection_service.dart # OBD connection management
|   |-- sensor_service # Sensor Lib Handling
│   ├── data_collection_service.dart # Data collection coordination
│   ├── analytics_service.dart    # Driving analytics
│   ├── feedback_service.dart     # Feedback generation
│   └── trip_service.dart         # Trip management
│
├── user/                         # User-related services
│   ├── user_service.dart         # User profile management
│   ├── preferences_service.dart  # User preferences
│   └── privacy_service.dart      # Privacy settings management
│
├── gamification/                 # Gamification services
│   ├── gamification_service.dart # Main gamification service
│   ├── challenge_service.dart    # Challenge management
│   └── achievement_service.dart  # Achievement tracking
│
├── social/                       # Social features
│   ├── social_service.dart       # Social features facade
│   ├── leaderboard_service.dart  # Leaderboard functionality
│   └── sharing_service.dart      # Content sharing
│
└── background/                   # Background processing
    ├── background_service.dart   # Background service facade
    ├── notification_service.dart # Notification management
    └── tracking_service.dart     # Background tracking
```

### Presentation Layer

```
presentation/
│
├── providers/                    # State management
│   ├── driving_provider.dart     # Driving-related state
│   ├── insights_provider.dart    # Insights and history state
│   ├── user_provider.dart        # User profile state
│   └── social_provider.dart      # Social features state
│
├── screens/                      # Application screens
│   ├── onboarding/               # Onboarding screens
│   │   ├── onboarding_screen.dart      # Main onboarding wrapper
│   │   ├── welcome_screen.dart         # Initial welcome
│   │   └── connection_screen.dart      # OBD connection setup
│   │
│   ├── drive/                    # Drive-related screens
│   │   ├── drive_screen.dart           # Main drive tab
│   │   ├── active_drive_screen.dart    # Active driving
│   │   ├── trip_summary_screen.dart    # Post-trip summary
│   │   └── components/                 # Drive components
│   │
│   ├── insights/                 # Insights screens
│   │   ├── insights_screen.dart        # Main insights tab
│   │   ├── trip_history_screen.dart    # Trip history
│   │   ├── trip_detail_screen.dart     # Trip details
│   │   └── components/                 # Insights components
│   │
│   ├── community/                # Community screens
│   │   ├── community_screen.dart       # Main community tab
│   │   ├── leaderboard_screen.dart     # Leaderboards
│   │   ├── challenges_screen.dart      # Challenges
│   │   └── components/                 # Community components
│   │
│   └── profile/                  # Profile screens
│       ├── profile_screen.dart         # Main profile tab
│       ├── settings_screen.dart        # App settings
│       ├── privacy_screen.dart         # Privacy settings
│       └── components/                 # Profile components
│
└── widgets/                      # Reusable widgets
    ├── common/                   # Common widgets
    │   ├── buttons/                  # Button widgets
    │   ├── cards/                    # Card widgets
    │   ├── indicators/               # Status indicators
    │   └── layout/                   # Layout helpers
    │
    ├── drive/                    # Drive-specific widgets
    ├── insights/                 # Insights-specific widgets
    ├── community/                # Community-specific widgets
    └── profile/                  # Profile-specific widgets
```

### Navigation Layer

```
navigation/
│
├── app_router.dart               # Main router configuration
├── tab_navigator.dart            # Tab-based navigation
└── route_names.dart              # Named routes
```

## Core Integration Patterns

### Driving Flow Integration

The main driving flow integrates multiple libraries to provide eco-driving functionality:

1. **OBD Connection**:
   ```dart
   // In ObdConnectionService
   Future<bool> connectToDevice(String deviceId) async {
     bool connected = await _obdService.connect(deviceId);
     if (connected) {
       await _obdService.startContinuousQueries();
     }
     return connected;
   }
   ```

2. **Sensor Integration**:
   ```dart
   // In DataCollectionService
   Future<bool> startCollection() async {
     await _sensorService.initialize();
     await _sensorService.startCollection();
     _sensorService.dataStream.listen(_processSensorData);
     return true;
   }
   ```

3. **Combined Data Processing**:
   ```dart
   // In DataCollectionService
   void _processSensorData(PhoneSensorData sensorData) async {
     final obdData = await _obdConnectionService.getLatestOBDData();
     
     // Create combined data
     final combinedData = CombinedDrivingData(
       timestamp: sensorData.timestamp,
       obdData: obdData,
       sensorData: sensorData,
       // Additional fields...
     );
     
     // Process data
     _dataStreamController.add(combinedData);
     _ecoDrivingManager.addDataPoint(combinedData);
   }
   ```

4. **Behavior Analysis**:
   ```dart
   // In AnalyticsService
   void addDataPoint(CombinedDrivingData dataPoint) {
     _ecoDrivingManager.addDataPoint(dataPoint);
     _updateScores();
   }
   
   void _updateScores() {
     _overallScore = _ecoDrivingManager.calculateOverallScore();
     _detailedScores = _ecoDrivingManager.getDetailedAnalysis();
     notifyListeners();
   }
   ```

5. **Trip Recording**:
   ```dart
   // In TripService
   Future<Trip> startTrip() async {
     final trip = await _dataStorageManager.startNewTrip();
     _currentTrip = trip;
     return trip;
   }
   
   Future<Trip?> endTrip() async {
     if (_currentTrip == null) return null;
     
     // Calculate trip metrics
     final metrics = _calculateTripMetrics();
     
     // End trip in storage
     final completedTrip = await _dataStorageManager.endTrip(
       _currentTrip!.id,
       distanceKm: metrics.distance,
       averageSpeedKmh: metrics.avgSpeed,
       // Additional fields...
     );
     
     _currentTrip = null;
     return completedTrip;
   }
   ```

### UI Integration Pattern

The UI layer uses providers to access services and manage state:

```dart
// In DrivingProvider
class DrivingProvider extends ChangeNotifier {
  final DrivingService _drivingService;
  final AnalyticsService _analyticsService;
  
  // State
  bool get isCollecting => _drivingService.isCollecting;
  bool get isObdConnected => _drivingService.isObdConnected;
  Trip? get currentTrip => _drivingService.currentTrip;
  double get ecoScore => _analyticsService.overallScore;
  
  // Actions
  Future<bool> startTrip() async {
    final success = await _drivingService.startTrip() != null;
    notifyListeners();
    return success;
  }
  
  Future<bool> endTrip() async {
    final success = await _drivingService.endTrip() != null;
    notifyListeners();
    return success;
  }
  
  // OBD functionality
  Future<bool> connectObd(String deviceId) async {
    final success = await _drivingService.connectToObdDevice(deviceId);
    notifyListeners();
    return success;
  }
  
  // Additional methods...
}
```

### Gamification Integration Pattern

Gamification features integrate with driving data and user actions:

```dart
// In GamificationService
class GamificationService {
  final ChallengeService _challengeService;
  final DataStorageManager _dataStorageManager;
  
  // Challenge management
  Future<List<Challenge>> getActiveChallenges() async {
    final challenges = await _dataStorageManager.getAllChallenges();
    return challenges.where((c) => c.isActive).toList();
  }
  
  // Process trip completion for challenges
  Future<void> processTripCompletion(Trip trip) async {
    final userChallenges = await _dataStorageManager.getUserChallenges();
    
    for (final userChallenge in userChallenges) {
      final challenge = await _challengeService.getChallenge(userChallenge.challengeId);
      
      // Update progress based on challenge type
      int newProgress = userChallenge.progress;
      switch (challenge.metricType) {
        case 'distance':
          newProgress += trip.distanceKm?.round() ?? 0;
          break;
        case 'eco_score':
          // Update based on trip's eco score
          break;
        // Additional metrics...
      }
      
      // Update challenge progress
      await _challengeService.updateChallengeProgress(
        userChallenge.id, 
        newProgress, 
        challenge.targetValue
      );
    }
  }
}
```

### Privacy Integration Pattern

Privacy controls are integrated throughout the app:

```dart
// In PrivacyService
class PrivacyService {
  final DataStorageManager _dataStorageManager;
  
  // Check if an operation is allowed
  Future<bool> canPerformOperation(String dataType, String operation) async {
    return _dataStorageManager.isOperationAllowed(dataType, operation);
  }
  
  // Update privacy settings
  Future<void> updatePrivacySetting(
    String dataType, 
    {bool? allowLocalStorage, bool? allowCloudSync, bool? allowSharing}
  ) async {
    // Get current setting
    final currentSetting = await _dataStorageManager.getDataPrivacySettingForType(dataType);
    
    if (currentSetting != null) {
      // Create updated setting
      final updatedSetting = currentSetting.copyWith(
        allowLocalStorage: allowLocalStorage ?? currentSetting.allowLocalStorage,
        allowCloudSync: allowCloudSync ?? currentSetting.allowCloudSync,
        allowSharing: allowSharing ?? currentSetting.allowSharing,
      );
      
      // Save updated setting
      await _dataStorageManager.saveDataPrivacySettings(updatedSetting);
    }
  }
}
```

## Integration With Existing Codebase

The architecture can be implemented incrementally by:

1. **Using Facade Pattern**: Create service facades that use your existing implementation
2. **Component-by-Component Migration**: Replace components one at a time
3. **Parallel Implementations**: Keep old code working while building new components

Example of adapting your current `DrivingService` to fit the new architecture:

```dart
// New facade that uses your existing implementation
class DrivingServiceFacade implements DrivingService {
  final DrivingServiceManager _legacyService;
  
  DrivingServiceFacade(this._legacyService);
  
  @override
  Future<Trip?> startTrip() => _legacyService.startTrip();
  
  @override
  Future<Trip?> endTrip() => _legacyService.endTrip();
  
  @override
  bool get isCollecting => _legacyService.isCollecting;
  
  // Other methods...
}
```

This approach allows you to gradually migrate to the new architecture while maintaining a working application throughout the process.

################################################################################
FILE: AppDataModel.md
################################################################################

# Going50 Eco-Driving App - Comprehensive Implementation Guide

## Overview

Going50 is an eco-driving application designed to promote sustainable driving behaviors through real-time feedback, gamification, and social features. The app uses OBD2 adapters for precise data collection but can also function with phone sensors alone to ensure low adoption barriers.

## Core Models Structure

The data model is organized into several key areas:

1. **Trip Tracking**: Records individual journeys with detailed metrics
2. **Driving Data**: Captures OBD-II and phone sensor data during trips
3. **User Management**: Handles user profiles and preferences
4. **Performance Analysis**: Analyzes driving patterns and provides feedback
5. **Gamification**: Implements challenges, badges, and streaks to encourage engagement
6. **Social Features**: Enables social connections and content sharing
7. **Privacy Controls**: Manages user data privacy preferences

## Model Relationships

![Data Model Relationships](https://mermaid.ink/img/pako:eNqFVE1v2zAM_SuETj2sPrRpgGGnDTm0QzegQC7GLAe2RcdCZcmQ5LRB0f8-ynaSuEE3X0z-PJGPpE7KWQ9Kqo5S9H47vXMm5wQ9vMbI-PbA2HEKLjE3thfgwwdmsadX_AYWe91fHx6Z3znN3c33N3Y0hsTdrHlHWr8FOMiYuYWxQw8eIvuPKZDZpoBkPn54vLm-aS5QmcgWmINhM2LZpR9o6D0m1skzJBzCaHSCCXpvfWUyvf-qDKV9Yjx46E3S0NXmXBvcWdOPHScXxjRZYRrNOV-OXtCFZL1GzYnZ7TDIHcRjYEfX3x1XuHOz1FPRCLvzaV5JdGu8nS00sUuRpzlDRGfynNu15xO6Rss_JUEw09ZZXyTGdASHHdoVfXaGc-3-D8bsECOHYx2XLnLqDbtI3rLjMGQKFgXZY0wctHPejkOKWNXBJ4Xx8BoiCVWjWpwgmhxrPfHKaDbOrSYPu4jZWYOZXdBQ63O5lKGQw2a1Uo3dLlRnxZVb9BCMw_6Sjp44LAvxOsjdXvnVwkJXwJUtFB0GF2aSP7QqS12V6gPV2_Fv0j0KXIUe8wI_XKqgdMfPchldmFnOQ0NvLSUYvs2sNfiYhSmQh0_vVUJFqiKqoYrXoTKqLWZ-WrwQspUFxVZVQXpPT2O_oGNV8LMuTF6JdF63jcuzcpFVZSkOtfS-WOWJ7Xpx-G2oDt-P7ZGjXOoKZXXIZ0QlpymXopuSajjJSmVcveFXJNKZyuKrKE6TH3-8RPE4_ewYK-YDFWWpDrgvCZUumvtj1KQYLKmRq5TnedwGFzZFDyW_OgYVuSDnNe989mKO6_JkJd9_QfIf)

## Detailed Model Descriptions

### 1. Trip Related Models

#### Trip
- **Description**: Represents a single journey taken by a user
- **Key Attributes**:
  - `id`: Unique identifier
  - `startTime`: When the trip began
  - `endTime`: When the trip ended
  - `distanceKm`: Total distance traveled
  - `averageSpeedKmh`: Average speed
  - `maxSpeedKmh`: Maximum speed reached
  - `fuelUsedL`: Estimated fuel consumption
  - Various event counters (idling, aggressive acceleration, etc.)
  - `isCompleted`: Whether the trip has ended
  - `ecoScore`: Overall eco-efficiency score
  - `routeDataJson`: Geographical route data
  - `userId`: Reference to the user who took the trip

#### TripDataPoint
- **Description**: Time-series data recorded during a trip
- **Key Attributes**:
  - `tripId`: Reference to the trip
  - `timestamp`: When the data point was recorded
  - `latitude` & `longitude`: Location coordinates
  - `speed`: Vehicle speed in km/h
  - `acceleration`: Vehicle acceleration in m/s²
  - `rpm`: Engine RPM
  - `throttlePosition`: Accelerator position in percentage
  - `engineLoad`: Engine load in percentage
  - `fuelRate`: Fuel consumption rate in L/h
  - `rawDataJson`: Additional data in JSON format

#### DrivingEvent
- **Description**: Significant events detected during driving
- **Key Attributes**:
  - `tripId`: Reference to the trip
  - `timestamp`: When the event occurred
  - `eventType`: Type of event (e.g., hard braking, aggressive acceleration)
  - `severity`: How severe the event was (0.0 to 1.0)
  - `latitude` & `longitude`: Location where the event occurred
  - `detailsJson`: Additional event details in JSON format

### 2. User Management Models

#### UserProfile
- **Description**: Represents a user of the application
- **Key Attributes**:
  - `id`: Unique identifier
  - `name`: User's name
  - `createdAt`: Account creation date
  - `lastUpdatedAt`: Last profile update date
  - `isPublic`: Whether the profile is publicly visible
  - `allowDataUpload`: Whether the user allows data to be uploaded
  - `preferencesJson`: User preferences in JSON format

#### DataPrivacySettings
- **Description**: User's privacy preferences for different data types
- **Key Attributes**:
  - `userId`: Reference to the user
  - `dataType`: Type of data (trips, location, driving events, etc.)
  - `allowLocalStorage`: Whether data can be stored locally
  - `allowCloudSync`: Whether data can be synced to the cloud
  - `allowSharing`: Whether data can be shared with others
  - `allowAnonymizedAnalytics`: Whether anonymized data can be used for analytics

#### UserPreferences
- **Description**: Detailed user preferences for various app features
- **Key Attributes**:
  - `userId`: Reference to the user
  - `preferenceCategory`: Category of preference (feedback, gamification, UI, etc.)
  - `preferenceName`: Name of the specific preference
  - `preferenceValue`: Value of the preference in JSON format
  - `updatedAt`: When the preference was last updated

### 3. Performance Analysis Models

#### PerformanceMetrics
- **Description**: Aggregated driving performance data over a period
- **Key Attributes**:
  - `userId`: Reference to the user
  - `generatedAt`: When the metrics were calculated
  - `periodStart` & `periodEnd`: Time range for the metrics
  - `totalTrips`: Number of trips in the period
  - `totalDistanceKm`: Total distance driven
  - `totalDrivingTimeMinutes`: Total time spent driving
  - Various score metrics (calm driving, speed optimization, etc.)
  - `overallScore`: Overall eco-driving score
  - `improvementTipsJson`: Personalized tips for improvement

#### FeedbackEffectiveness
- **Description**: Tracks how effective different types of feedback are for a user
- **Key Attributes**:
  - `userId`: Reference to the user
  - `feedbackType`: Type of feedback (gentle reminder, direct instruction, etc.)
  - `drivingBehaviorType`: Behavior targeted by the feedback
  - `timesDelivered`: How many times the feedback was given
  - `timesBehaviorImproved`: How many times the behavior improved after feedback
  - `effectivenessRatio`: Ratio of improvement to delivery
  - `lastUpdated`: When the record was last updated

### 4. Gamification Models

#### Challenge
- **Description**: Represents a challenge that users can undertake
- **Key Attributes**:
  - `title`: Name of the challenge
  - `description`: What the challenge involves
  - `type`: Type of challenge (daily, weekly, achievement)
  - `targetValue`: Target to achieve for completion
  - `metricType`: What metric is being measured
  - `isSystem`: Whether it's a system challenge or user-created
  - `creatorId`: Reference to the creator if user-created
  - `difficultyLevel`: How difficult the challenge is (1-5)
  - `rewardType` & `rewardValue`: What the user gets for completing it

#### UserChallenge
- **Description**: Tracks a user's progress on a specific challenge
- **Key Attributes**:
  - `userId`: Reference to the user
  - `challengeId`: Reference to the challenge
  - `startedAt`: When the user started the challenge
  - `completedAt`: When the user completed the challenge
  - `progress`: Current progress toward completion
  - `isCompleted`: Whether the challenge is complete
  - `rewardClaimed`: Whether the reward has been claimed

#### Badge
- **Description**: Represents achievements earned by users
- **Key Attributes**:
  - `userId`: Reference to the user
  - `badgeType`: Type of badge (eco master, smooth driver, etc.)
  - `earnedDate`: When the badge was earned
  - `level`: Level of the badge (1+)
  - `metadataJson`: Additional badge information

#### Streak
- **Description**: Tracks consecutive activity completion
- **Key Attributes**:
  - `userId`: Reference to the user
  - `streakType`: Type of streak (daily drive, eco score, etc.)
  - `currentCount`: Current streak count
  - `bestCount`: Best streak ever achieved
  - `lastRecorded`: When the streak was last updated
  - `nextDue`: When the next activity is due to maintain the streak
  - `isActive`: Whether the streak is currently active

#### LeaderboardEntry
- **Description**: Represents a user's position on a leaderboard
- **Key Attributes**:
  - `leaderboardType`: Type of leaderboard (global, regional, friends)
  - `timeframe`: Time period (daily, weekly, monthly, all-time)
  - `userId`: Reference to the user
  - `regionCode`: Optional region for regional leaderboards
  - `rank`: User's position on the leaderboard
  - `score`: User's score
  - `recordedAt`: When the entry was recorded
  - `daysRetained`: How many days the rank has been maintained

### 5. Social Feature Models

#### SocialConnection
- **Description**: Represents a connection between users
- **Key Attributes**:
  - `userId`: Reference to the user
  - `connectedUserId`: Reference to the connected user
  - `connectionType`: Type of connection (friend, following)
  - `connectedSince`: When the connection was established
  - `isMutual`: Whether the connection is mutual

#### SocialInteraction
- **Description**: Represents interactions with content
- **Key Attributes**:
  - `userId`: Reference to the user
  - `contentType`: Type of content (trip, achievement, milestone)
  - `contentId`: Reference to the content
  - `interactionType`: Type of interaction (like, comment, share)
  - `content`: Text content for comments
  - `timestamp`: When the interaction occurred

#### SharedContent
- **Description**: Represents content shared by a user
- **Key Attributes**:
  - `userId`: Reference to the user
  - `contentType`: Type of content (trip, achievement, eco score)
  - `contentId`: Reference to the content
  - `shareType`: How it was shared (public, friends, external)
  - `externalPlatform`: If shared externally, where it was shared
  - `shareUrl`: Public URL if generated
  - `sharedAt`: When it was shared
  - `isActive`: Whether the share is still active

### 6. External Integration Models

#### ExternalIntegration
- **Description**: Represents a connection to an external platform
- **Key Attributes**:
  - `userId`: Reference to the user
  - `platformType`: Type of platform (Uber, Lyft, Apple CarPlay, etc.)
  - `externalId`: User ID on the external platform
  - `integrationStatus`: Status of the integration (active, pending, revoked)
  - `connectedAt`: When the integration was established
  - `lastSyncAt`: When data was last synced
  - `accessToken` & `refreshToken`: Authentication tokens
  - `integrationDataJson`: Platform-specific settings

#### SyncStatus
- **Description**: Tracks synchronization status for entities
- **Key Attributes**:
  - `userId`: Reference to the user
  - `entityType`: Type of entity (trip, badge, challenge, etc.)
  - `entityId`: Reference to the entity
  - `targetPlatform`: Platform being synced to
  - `syncStatus`: Status of the sync (pending, synced, failed)
  - `lastAttemptAt`: When sync was last attempted
  - `retryCount`: Number of retry attempts
  - `errorMessage`: Error message if sync failed

## Database Schema

The database is implemented using the drift package (formerly moor), which provides type-safe database access for Flutter applications. The database schema includes tables for all the models described above, with appropriate relationships between them.

Key features of the database implementation:
- Version-controlled schema with migration support
- Foreign key constraints to maintain data integrity
- Batch operations for efficient data manipulation
- Stream-based APIs for reactive UI updates

## Data Flow

1. **Collection**: Data is collected from OBD-II devices and phone sensors during trips
2. **Processing**: Raw data is processed into meaningful metrics
3. **Storage**: Processed data is stored in the local database
4. **Analysis**: Data is analyzed to generate performance metrics and feedback
5. **Presentation**: Insights are presented to the user through the UI
6. **Sharing**: Data can be shared with other users or external platforms (if permitted)

## Privacy Considerations

The data model includes comprehensive privacy controls that allow users to specify:
- What data is stored locally
- What data is synced to the cloud
- What data can be shared with others
- What data can be used for anonymized analytics

## Consistency Verification

The core models in the application and the database service maintain strong consistency, with the database tables closely mirroring the structure of the model classes. The database service provides appropriate methods for CRUD operations on each model, with proper mapping between database rows and model objects. 

################################################################################
FILE: README.md
################################################################################

# 🌿 Going50 | Drive Smart, Live Green 🌎

![Going50 - Eco-Driving Revolution](https://via.placeholder.com/800x200?text=Going50+-+The+Eco-Driving+Revolution)

## The Future of Driving is Here

**Going50** isn't just another driving app — it's a **movement**. Join thousands of forward-thinking drivers who are slashing their carbon footprint while saving money and making a statement. Named after the sweet spot of eco-efficiency (around 50 mph/80 kmh), Going50 turns sustainable driving from boring obligation into your next social trend.

> *"The app that's doing for driving what Oatly did for milk — making eco cool again."*

## Why Going50 is Taking Over

In a world obsessed with speed, we're bringing back the vintage wisdom that slower can be better. Transportation contributes over 25% of global carbon emissions, but here's the secret the fossil fuel industry doesn't want you to know: how you drive matters just as much as what you drive.

### The Clean Revolution

Going50 transforms your daily commute into a game-changing climate action:

- **💨 Instant Impact**: No need to wait for your Tesla order — reduce your emissions by up to 40% TODAY
- **💰 Real Savings**: Watch your fuel costs drop by 10-25% — that's hundreds of dollars back in your pocket
- **🏆 Social Bragging Rights**: Share your eco-score and climbing rank with friends
- **⚡ Zero Compromise**: Arrive at the same time, just smarter — it's about driving quality, not speed

## How It Works - Eco Meets Tech

Going50 merges cutting-edge tech with environmental science in a sleek, intuitive interface:

1. **Connect & Cruise**: Pair with your car (or just use your phone) and drive normally
2. **Smart Analysis**: Our AI examines your driving patterns in real-time
3. **Level Up**: Receive personalized tips to boost your eco-score
4. **Join the Movement**: Compare stats with the Going50 community and climb the leaderboards

## Features That Set Us Apart 🚀

- **🔄 Dual-Source Intelligence**: Gather insights from both OBD-II adapters for precision metrics and phone sensors for universal accessibility
- **🧠 Behavior AI**: Our advanced algorithms detect and coach you on the seven pillars of eco-driving:
  - **🏎️ → 🚶‍♂️ Zen Acceleration**: Master the art of smooth, efficient acceleration and braking
  - **⏱️ Speed Sweet Spot**: Find your vehicle's efficiency zone and cruise in the green
  - **⏸️ Idle Elimination**: Turn unnecessary engine running into climate action
  - **⚙️ RPM Mastery**: Keep your engine in the happiness zone
  - **🛑 Stop Strategy**: Minimize momentum-killing full stops
  - **↔️ Flow Following**: Maintain the perfect distance for fuel economy
  - **🔍 Trip Intelligence**: Identify and combine short trips for maximum impact
- **📊 Eco Analytics**: Track your performance with beautiful, intuitive metrics that show your daily impact
- **🗺️ Journey Journal**: Review past drives with detailed insights on where you're crushing it and where you can level up
- **👤 Personal Climate Hero Profile**: Build your eco-driving identity and showcase your achievements

## Under the Hood - Architecture 🛠️

Going50 is built with a sleek, modular architecture that makes it both powerful and future-proof:

### Core Tech Stack 💎

- **🚗 OBD Whisperer (`obd_lib`)**: Our magic link to your vehicle's brain, speaking the universal language of ELM327 for crystal-clear data collection.
- **📱 Sensor Symphony (`sensor_lib`)**: Transforms your smartphone into an intelligent motion and location detector, working even without OBD connection.
- **🤖 Eco Intelligence Engine (`behavior_classifier_lib`)**: The AI heart that analyzes your driving patterns and turns raw data into actionable wisdom.
- **📦 Data Models (`core_models`)**: Elegant structures that organize vehicle data, sensor readings, and analysis into a seamless ecosystem.

### Service Layer 🔧

- **🎯 Mission Control (`driving_service`)**: The maestro that orchestrates all components for a harmonious driving analysis experience.
- **🔒 Permission Guardian (`permission_service`)**: Handles all the boring permission stuff so you can focus on driving smarter.
- **🔋 Power Optimizer (`battery_optimization_service`)**: Keeps Going50 running efficiently without draining your battery life.
- **🔄 Background Genius (`tracking_service_manager`)**: Ensures your eco-data keeps flowing even when your phone is tucked away.

### Experience Layer ✨

- **🚦 Setup Simplifier (`permission_handler_widget`)**: Gets you from download to driving in minutes, not hours.
- **📊 Live Dashboard**: Your real-time window into eco-driving performance with insights that matter.
- **📜 Trip Time Machine**: Explore your driving history with detailed metrics on each journey.
- **👑 Profile Showcase**: Your personal eco-driving identity and achievement gallery.

## Technical Requirements

### For Users

- Android 8.0+ or iOS 13.0+
- Bluetooth 4.0+ compatible device (for OBD-II connection)
- GPS capability
- Optional: ELM327-compatible OBD-II adapter for enhanced data collection

### For Developers

- Flutter SDK 3.7.0+
- Dart 3.0.0+
- Android Studio or VS Code with Flutter extensions
- Knowledge of BLE (Bluetooth Low Energy) communication
- Understanding of vehicle OBD-II protocols

## Getting Started

### Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/going50.git
   ```

2. Install dependencies:
   ```bash
   cd going50
   flutter pub get
   ```

3. Build and run the application:
   ```bash
   flutter run
   ```

### User Setup

1. Launch the Going50 app
2. Grant required permissions (location, Bluetooth)
3. Optional: Connect an OBD-II adapter to your vehicle's diagnostic port
4. Connect the app to the OBD-II adapter via Bluetooth
5. Start driving and receive real-time eco-driving feedback

## Research Foundation

Going50 is based on extensive research showing that individual driving behaviors significantly impact fuel consumption and emissions. Key findings include:

- Aggressive acceleration and braking can increase fuel consumption by up to 40%
- Maintaining speeds between 50-75 km/h (31-47 mph) maximizes efficiency for most vehicles
- Idling for more than 10-30 seconds uses more fuel than restarting the engine
- Optimal RPM (typically 1500-2500 RPM) can reduce fuel consumption by 20-25%
- Unnecessary stops dramatically increase fuel usage due to the energy required to accelerate from zero

## Contribution Guidelines

We welcome contributions to the Going50 project! If you're interested in helping, please:

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

[MIT License](LICENSE) - feel free to use, modify, and distribute as needed.

## Acknowledgments

- This project builds on research from various environmental and transportation agencies
- Special thanks to all contributors who have helped make eco-driving accessible to everyone

################################################################################
FILE: AppRoadmap.md
################################################################################

# Going50 Eco-Driving App: Step-by-Step Implementation Guide

## Introduction

This document provides a detailed, step-by-step implementation guide for building the Going50 eco-driving application. Each step is designed to be completable within one day of focused development work, starting with core functionality and progressively adding features.

The implementation is organized into logical phases, with each phase building upon previous work. Some components like the OBD library, sensor library, and core models are already implemented and can be leveraged.

## Phase 1: Project Setup & Core Infrastructure (Week 1)

### Day 1: Initial Project Setup & Structure

**Objective:** Set up the Flutter project with the proposed architecture and integrate existing libraries.

**Tasks:**
1. Create a new Flutter project using the latest stable version
2. Set up the folder structure according to the architecture document:
   ```
   lib/
   ├── core/
   ├── services/
   ├── presentation/
   ├── navigation/
   ├── behavior_classifier_lib/ (import existing)
   ├── core_models/ (import existing)
   ├── data_lib/ (import existing)
   ├── obd_lib/ (import existing)
   └── sensor_lib/ (import existing)
   ```
3. Update `pubspec.yaml` with required dependencies:
   - flutter_reactive_ble: ^5.3.1
   - provider: ^6.1.1
   - shared_preferences: ^2.2.2
   - path_provider: ^2.1.2
   - intl: ^0.19.0
   - drift: ^2.16.0
   - uuid: ^4.3.3
   - logging: ^1.2.0
   - permission_handler: ^11.3.0

**Files to Create:**
- `lib/app.dart` - Main app widget with theme setup
- `lib/core/constants/app_constants.dart` - Basic app constants
- `lib/core/theme/app_theme.dart` - Theme definition based on UI guidelines
- `lib/core/theme/app_colors.dart` - Color palette from UI guide

**Definition of Done:**
- Project structure created
- Dependencies added and working
- Basic app widget created with theme
- Existing libraries imported and building successfully

### Day 2: Service Locator & Core Utilities

**Objective:** Implement dependency injection and core utilities.

**Tasks:**
1. Set up service locator using `get_it` or similar
2. Create utilities for common functions:
   - Permission handling
   - Data formatting
   - Driving calculations
   - Device capability detection

**Files to Create:**
- `lib/services/service_locator.dart` - Dependency injection container
- `lib/core/utils/permission_utils.dart` - Permission handling utilities
- `lib/core/utils/formatter_utils.dart` - Formatting functions for dates, numbers, etc.
- `lib/core/utils/driving_utils.dart` - Driving calculation utilities
- `lib/core/utils/device_utils.dart` - Device capability detection

**Files to Modify:**
- `lib/main.dart` - Initialize service locator

**Definition of Done:**
- Service locator implemented and tested
- Core utilities implemented and unit tested
- Main app initializes dependencies correctly

### Day 3: Navigation & Routing Infrastructure

**Objective:** Implement the navigation system and basic screen structure.

**Tasks:**
1. Create route constants
2. Implement tab-based navigation
3. Set up route management for the app
4. Create stub screens for all main tabs

**Files to Create:**
- `lib/core/constants/route_constants.dart` - Route names
- `lib/navigation/app_router.dart` - Main router configuration
- `lib/navigation/tab_navigator.dart` - Tab-based navigation
- `lib/presentation/screens/drive/drive_screen.dart` - Stub Drive tab
- `lib/presentation/screens/insights/insights_screen.dart` - Stub Insights tab
- `lib/presentation/screens/community/community_screen.dart` - Stub Community tab
- `lib/presentation/screens/profile/profile_screen.dart` - Stub Profile tab

**Files to Modify:**
- `lib/app.dart` - Integrate navigation system

**Definition of Done:**
- Navigation system working with tab switching
- All major screens accessible via navigation
- Basic UI structure for tab screens implemented

### Day 4: OBD Connection Service Implementation

**Objective:** Implement the OBD connection service that connects to the existing OBD library.

**Tasks:**
1. Create OBD connection service as a facade to `obd_lib`
2. Implement device scanning and connection handling
3. Add connection state management
4. Set up data retrieval from OBD

**Files to Create:**
- `lib/services/driving/obd_connection_service.dart` - Service to manage OBD connections

**Files to Modify:**
- `lib/services/service_locator.dart` - Register new service

**Definition of Done:**
- OBD connection service implemented
- Service successfully interfaces with existing `obd_lib`
- Bluetooth scanning and device connection working
- OBD data retrieval functions working

### Day 5: Sensor Service Implementation & Integration

**Objective:** Implement the phone sensor service and integrate with existing sensor library.

**Tasks:**
1. Create sensor service as a facade to `sensor_lib`
2. Implement sensor initialization and data collection
3. Set up sensor data streaming
4. Add fallback detection when OBD is unavailable

**Files to Create:**
- `lib/services/driving/sensor_service.dart` - Service to manage phone sensors

**Files to Modify:**
- `lib/services/service_locator.dart` - Register new service
- `lib/services/driving/obd_connection_service.dart` - Add fallback logic

**Definition of Done:**
- Sensor service implemented
- Service successfully interfaces with existing `sensor_lib`
- Sensor data collection and streaming working
- Fallback detection when OBD is unavailable

## Phase 2: Data Collection & Analysis (Week 2)

### Day 6: Data Collection Service Implementation

**Objective:** Create a service to collect and combine data from OBD and sensors.

**Tasks:**
1. Implement data collection service
2. Handle data merging from OBD and sensors
3. Implement background collection capability
4. Add data buffering for continuous operation

**Files to Create:**
- `lib/services/driving/data_collection_service.dart` - Coordinate data collection

**Files to Modify:**
- `lib/services/service_locator.dart` - Register new service

**Definition of Done:**
- Data collection service implemented
- Service successfully collects and combines data from OBD and sensors
- Background collection working
- Data buffering implemented

### Day 7: Behavior Analysis Service Implementation

**Objective:** Implement the service to analyze driving behavior using the classifier library.

**Tasks:**
1. Create analytics service using existing behavior classifier
2. Implement eco-score calculation
3. Add event detection for driving behaviors
4. Set up real-time feedback generation

**Files to Create:**
- `lib/services/driving/analytics_service.dart` - Service for behavior analysis

**Files to Modify:**
- `lib/services/service_locator.dart` - Register new service
- `lib/services/driving/data_collection_service.dart` - Integrate with analytics

**Definition of Done:**
- Analytics service implemented
- Service successfully analyzes driving behavior
- Eco-score calculation working
- Event detection working for key driving behaviors

### Day 8: Trip Management Service Implementation

**Objective:** Create a service to manage trip recording and completion.

**Tasks:**
1. Implement trip service to interface with data storage
2. Add trip start/end functionality
3. Implement trip metrics calculation
4. Add trip data point saving

**Files to Create:**
- `lib/services/driving/trip_service.dart` - Trip management service

**Files to Modify:**
- `lib/services/service_locator.dart` - Register new service
- `lib/services/driving/data_collection_service.dart` - Integrate with trip service

**Definition of Done:**
- Trip service implemented
- Trip start/end functionality working
- Trip metrics calculation implemented
- Trip data points being saved correctly

### Day 9: Main Driving Service Implementation

**Objective:** Create a unified service to coordinate all driving-related functionality.

**Tasks:**
1. Implement driving service as facade to other services
2. Add state management for driving status
3. Implement coordination between services
4. Add driving event notifications

**Files to Create:**
- `lib/services/driving/driving_service.dart` - Main driving service facade

**Files to Modify:**
- `lib/services/service_locator.dart` - Register new service

**Definition of Done:**
- Driving service implemented
- Service successfully coordinates other services
- State management working correctly
- Driving event notifications functioning

### Day 10: State Management & Provider Setup

**Objective:** Set up state management using providers for all major features.

**Tasks:**
1. Create driving provider for real-time driving state
2. Add insights provider for historical data
3. Implement user provider for profile state
4. Create community provider for social features

**Files to Create:**
- `lib/presentation/providers/driving_provider.dart` - Driving-related state
- `lib/presentation/providers/insights_provider.dart` - Insights and history state
- `lib/presentation/providers/user_provider.dart` - User profile state
- `lib/presentation/providers/social_provider.dart` - Social features state

**Files to Modify:**
- `lib/app.dart` - Set up provider system
- `lib/main.dart` - Initialize providers

**Definition of Done:**
- Provider system implemented
- All major providers created
- State management working correctly
- Provider integration with services functioning

## Phase 3: Core UI Implementation (Week 3)

### Day 11: Common UI Components

**Objective:** Implement reusable UI components based on the design system.

**Tasks:**
1. Create button components (primary, secondary)
2. Implement card components
3. Add status indicators and feedback components
4. Create layout helpers

**Files to Create:**
- `lib/presentation/widgets/common/buttons/primary_button.dart`
- `lib/presentation/widgets/common/buttons/secondary_button.dart`
- `lib/presentation/widgets/common/cards/info_card.dart`
- `lib/presentation/widgets/common/cards/stats_card.dart`
- `lib/presentation/widgets/common/indicators/status_indicator.dart`
- `lib/presentation/widgets/common/layout/section_container.dart`

**Definition of Done:**
- All common components implemented
- Components match design guidelines
- Components are reusable across the app
- Basic component tests passing

### Day 12: Onboarding Flow Implementation

**Objective:** Implement the onboarding screens for first-time users.

**Tasks:**
1. Create welcome screen
2. Implement value carousel
3. Add account choice screen
4. Create connection setup screen

**Files to Create:**
- `lib/presentation/screens/onboarding/onboarding_screen.dart` - Main wrapper
- `lib/presentation/screens/onboarding/welcome_screen.dart` - Initial welcome
- `lib/presentation/screens/onboarding/value_carousel_screen.dart` - Value propositions
- `lib/presentation/screens/onboarding/account_choice_screen.dart` - Account options
- `lib/presentation/screens/onboarding/connection_setup_screen.dart` - OBD setup

**Files to Modify:**
- `lib/navigation/app_router.dart` - Add onboarding routes
- `lib/app.dart` - Add logic to show onboarding on first launch

**Definition of Done:**
- Complete onboarding flow implemented
- Screens match design specifications
- Navigation between screens working correctly
- First-time user experience tested

### Day 13: Drive Tab Implementation

**Objective:** Implement the main Drive tab screen with connection status and trip controls.

**Tasks:**
1. Create Drive tab UI according to design
2. Implement connection status display
3. Add trip start/stop functionality
4. Create recent trip summary display

**Files to Create:**
- `lib/presentation/screens/drive/components/connection_status_widget.dart`
- `lib/presentation/screens/drive/components/start_trip_button.dart`
- `lib/presentation/screens/drive/components/recent_trip_card.dart`

**Files to Modify:**
- `lib/presentation/screens/drive/drive_screen.dart` - Implement full UI
- `lib/presentation/providers/driving_provider.dart` - Add methods needed for UI

**Definition of Done:**
- Drive tab UI implemented per design
- Connection status display working
- Trip start/stop functioning correctly
- Recent trip summary displaying actual data

### Day 14: Active Drive Screen Implementation

**Objective:** Create the distraction-minimized active driving screen.

**Tasks:**
1. Implement active drive screen UI
2. Create eco-score display
3. Add current metrics strip
4. Implement event notification system

**Files to Create:**
- `lib/presentation/screens/drive/active_drive_screen.dart` - Full screen
- `lib/presentation/screens/drive/components/eco_score_display.dart`
- `lib/presentation/screens/drive/components/current_metrics_strip.dart`
- `lib/presentation/screens/drive/components/event_notification.dart`

**Files to Modify:**
- `lib/navigation/app_router.dart` - Add active drive route
- `lib/presentation/screens/drive/drive_screen.dart` - Add navigation to active screen

**Definition of Done:**
- Active drive screen implemented per design
- Eco-score display updating in real-time
- Current metrics showing actual data
- Event notifications appearing correctly
- Screen working in split-screen mode

### Day 15: Trip Summary Screen Implementation

**Objective:** Implement the post-trip summary screen.

**Tasks:**
1. Create trip summary screen UI
2. Implement metrics visualizations
3. Add behavior breakdown chart
4. Create improvement suggestions display

**Files to Create:**
- `lib/presentation/screens/drive/trip_summary_screen.dart` - Full screen
- `lib/presentation/screens/drive/components/trip_overview_header.dart`
- `lib/presentation/screens/drive/components/savings_metrics_section.dart`
- `lib/presentation/screens/drive/components/behavior_breakdown_chart.dart`
- `lib/presentation/screens/drive/components/improvement_suggestion_card.dart`

**Files to Modify:**
- `lib/navigation/app_router.dart` - Add trip summary route
- `lib/services/driving/driving_service.dart` - Add methods to retrieve summary data

**Definition of Done:**
- Trip summary screen implemented per design
- Metrics visualizations showing correct data
- Behavior breakdown chart functioning
- Improvement suggestions relevant to actual trip
- Sharing functionality working

## Phase 4: Insights & Analytics (Week 4)

### Day 16: Insights Dashboard Implementation

**Objective:** Implement the main insights dashboard screen.

**Tasks:**
1. Create insights dashboard UI
2. Implement eco-score trend chart
3. Add savings summary cards
4. Create driving behaviors radar chart

**Files to Create:**
- `lib/presentation/screens/insights/components/time_period_selector.dart`
- `lib/presentation/screens/insights/components/eco_score_trend_chart.dart`
- `lib/presentation/screens/insights/components/savings_summary_card.dart`
- `lib/presentation/screens/insights/components/driving_behaviors_chart.dart`

**Files to Modify:**
- `lib/presentation/screens/insights/insights_screen.dart` - Implement full UI
- `lib/presentation/providers/insights_provider.dart` - Add methods for retrieving data

**Definition of Done:**
- Insights dashboard UI implemented per design
- Eco-score trend chart showing actual data
- Savings summaries calculating correctly
- Driving behaviors chart reflecting actual behavior
- Time period selection working

### Day 17: Trip History Screen Implementation

**Objective:** Create the trip history screen with search and filtering.

**Tasks:**
1. Implement trip history list UI
2. Add search and filter functionality
3. Create trip list items
4. Implement sorting controls

**Files to Create:**
- `lib/presentation/screens/insights/trip_history_screen.dart` - Full screen
- `lib/presentation/screens/insights/components/search_filter_bar.dart`
- `lib/presentation/screens/insights/components/trip_list_item.dart`
- `lib/presentation/screens/insights/components/filter_sheet.dart`

**Files to Modify:**
- `lib/navigation/app_router.dart` - Add trip history route
- `lib/presentation/screens/insights/insights_screen.dart` - Add navigation to history

**Definition of Done:**
- Trip history screen implemented per design
- Search functionality working
- Filtering options functioning correctly
- Trip list showing actual trips
- Navigation to trip details working

### Day 18: Trip Detail Screen Implementation

**Objective:** Create the detailed trip analysis screen.

**Tasks:**
1. Implement trip detail screen UI
2. Create map section (if location permitted)
3. Add metrics section with tabs
4. Implement timeline section for events

**Files to Create:**
- `lib/presentation/screens/insights/trip_detail_screen.dart` - Full screen
- `lib/presentation/screens/insights/components/trip_map_section.dart`
- `lib/presentation/screens/insights/components/trip_metrics_section.dart`
- `lib/presentation/screens/insights/components/trip_timeline_section.dart`

**Files to Modify:**
- `lib/navigation/app_router.dart` - Add trip detail route
- `lib/presentation/screens/insights/trip_history_screen.dart` - Add navigation to details

**Definition of Done:**
- Trip detail screen implemented per design
- Map showing actual route (if permitted)
- Metrics tabs showing correct data
- Timeline displaying actual events
- Recommendations based on trip data

### Day 19: Data Visualization Components

**Objective:** Create reusable visualization components for data display.

**Tasks:**
1. Implement eco-score gauge component
2. Create line chart component for trends
3. Add bar chart for comparative metrics
4. Implement radar chart for skills assessment

**Files to Create:**
- `lib/presentation/widgets/common/charts/eco_score_gauge.dart`
- `lib/presentation/widgets/common/charts/line_chart.dart`
- `lib/presentation/widgets/common/charts/bar_chart.dart`
- `lib/presentation/widgets/common/charts/radar_chart.dart`

**Files to Modify:**
- Update various screens to use the new chart components

**Definition of Done:**
- All visualization components implemented
- Components reusable across the app
- Components displaying actual data correctly
- Animation and interaction working as designed

### Day 20: Performance Metrics Service Implementation

**Objective:** Create a service to manage and calculate performance metrics.

**Tasks:**
1. Implement metrics service
2. Add methods for calculating various metrics
3. Create aggregation functions for different time periods
4. Implement projection calculations for savings

**Files to Create:**
- `lib/services/driving/metrics_service.dart` - Performance metrics service

**Files to Modify:**
- `lib/services/service_locator.dart` - Register new service
- `lib/presentation/providers/insights_provider.dart` - Integrate with metrics service

**Definition of Done:**
- Metrics service implemented
- Calculation methods working correctly
- Aggregation across time periods functioning
- Projections calculating reasonably

## Phase 5: User Management & Settings (Week 5)

### Day 21: User Service Implementation

**Objective:** Create a service to manage user profiles and authentication.

**Tasks:**
1. Implement user service
2. Add anonymous user support
3. Create optional account registration
4. Implement profile management

**Files to Create:**
- `lib/services/user/user_service.dart` - User management service

**Files to Modify:**
- `lib/services/service_locator.dart` - Register new service
- `lib/presentation/providers/user_provider.dart` - Integrate with user service

**Definition of Done:**
- User service implemented
- Anonymous users working correctly
- Account registration functioning
- Profile management working

### Day 22: Preferences Service Implementation

**Objective:** Create a service to manage user preferences.

**Tasks:**
1. Implement preferences service
2. Add methods for saving/retrieving preferences
3. Create default preferences
4. Implement preference change notifications

**Files to Create:**
- `lib/services/user/preferences_service.dart` - User preferences service

**Files to Modify:**
- `lib/services/service_locator.dart` - Register new service
- `lib/presentation/providers/user_provider.dart` - Integrate with preferences service

**Definition of Done:**
- Preferences service implemented
- Preference storage working correctly
- Default preferences being applied
- Change notifications functioning

### Day 23: Privacy Service Implementation

**Objective:** Create a service to manage privacy settings and data permissions.

**Tasks:**
1. Implement privacy service
2. Add methods for checking permissions
3. Create privacy setting management
4. Implement data access control

**Files to Create:**
- `lib/services/user/privacy_service.dart` - Privacy settings service

**Files to Modify:**
- `lib/services/service_locator.dart` - Register new service
- `lib/presentation/providers/user_provider.dart` - Integrate with privacy service

**Definition of Done:**
- Privacy service implemented
- Permission checking working correctly
- Privacy settings being saved/retrieved
- Data access control functioning

### Day 24: Profile Screen Implementation

**Objective:** Create the user profile screen with achievements and statistics.

**Tasks:**
1. Implement profile screen UI
2. Create profile header
3. Add achievements section
4. Implement statistics summary

**Files to Create:**
- `lib/presentation/screens/profile/components/profile_header.dart`
- `lib/presentation/screens/profile/components/achievements_grid.dart`
- `lib/presentation/screens/profile/components/statistics_summary.dart`

**Files to Modify:**
- `lib/presentation/screens/profile/profile_screen.dart` - Implement full UI

**Definition of Done:**
- Profile screen UI implemented per design
- Profile header showing user info
- Achievements grid displaying actual badges
- Statistics summary showing correct data
- Navigation to settings working

### Day 25: Settings Screen Implementation

**Objective:** Create the settings screen with all configuration options.

**Tasks:**
1. Implement settings screen UI
2. Create settings sections for different categories
3. Add toggle and selection components
4. Implement settings persistence

**Files to Create:**
- `lib/presentation/screens/profile/settings_screen.dart` - Main settings screen
- `lib/presentation/screens/profile/components/settings_section.dart`
- `lib/presentation/screens/profile/components/settings_item.dart`

**Files to Modify:**
- `lib/navigation/app_router.dart` - Add settings routes
- `lib/presentation/screens/profile/profile_screen.dart` - Add navigation to settings

**Definition of Done:**
- Settings screen UI implemented per design
- All settings sections created
- Toggle and selection components working
- Settings being saved and applied correctly

## Phase 6: Gamification Features (Week 6)

### Day 26: Achievement Service Implementation

**Objective:** Create a service to manage user achievements.

**Tasks:**
1. Implement achievement service
2. Define achievement types and conditions
3. Add methods for checking and awarding achievements
4. Create notification system for new achievements

**Files to Create:**
- `lib/services/gamification/achievement_service.dart` - Achievement service

**Files to Modify:**
- `lib/services/service_locator.dart` - Register new service
- `lib/services/driving/driving_service.dart` - Integrate achievement tracking

**Definition of Done:**
- Achievement service implemented
- Achievement types and conditions defined
- Award checking working correctly
- Notifications appearing for new achievements

### Day 27: Challenge Service Implementation

**Objective:** Create a service to manage challenges.

**Tasks:**
1. Implement challenge service
2. Define challenge types and requirements
3. Add methods for tracking progress
4. Create completion handling

**Files to Create:**
- `lib/services/gamification/challenge_service.dart` - Challenge service

**Files to Modify:**
- `lib/services/service_locator.dart` - Register new service
- `lib/services/driving/driving_service.dart` - Integrate challenge tracking

**Definition of Done:**
- Challenge service implemented
- Challenge types and requirements defined
- Progress tracking working correctly
- Completion handling functioning

### Day 28: Community Hub Screen Implementation

**Objective:** Create the main community screen with tabs for different social features.

**Tasks:**
1. Implement community hub UI with tabs
2. Create leaderboard section
3. Add challenges section
4. Implement friends section

**Files to Create:**
- `lib/presentation/screens/community/components/leaderboard_view.dart`
- `lib/presentation/screens/community/components/challenges_view.dart`
- `lib/presentation/screens/community/components/friends_view.dart`

**Files to Modify:**
- `lib/presentation/screens/community/community_screen.dart` - Implement full UI

**Definition of Done:**
- Community hub UI implemented per design
- Tab navigation working
- Leaderboard showing actual rankings
- Challenges displaying available and active challenges
- Friends section showing connections

### Day 29: Challenge Detail Screen Implementation

**Objective:** Create the challenge detail screen.

**Tasks:**
1. Implement challenge detail UI
2. Create progress visualization
3. Add participant leaderboard
4. Implement join/leave functionality

**Files to Create:**
- `lib/presentation/screens/community/challenge_detail_screen.dart` - Full screen
- `lib/presentation/screens/community/components/challenge_progress_section.dart`
- `lib/presentation/screens/community/components/challenge_leaderboard.dart`

**Files to Modify:**
- `lib/navigation/app_router.dart` - Add challenge detail route
- `lib/presentation/screens/community/components/challenges_view.dart` - Add navigation

**Definition of Done:**
- Challenge detail screen implemented per design
- Progress visualization showing actual progress
- Participant leaderboard displaying actual data
- Join/leave functionality working correctly

### Day 30: Friend Profile Screen Implementation

**Objective:** Create the friend profile viewing screen.

**Tasks:**
1. Implement friend profile UI
2. Create achievement showcase
3. Add statistics summary
4. Implement interaction section

**Files to Create:**
- `lib/presentation/screens/community/friend_profile_screen.dart` - Full screen
- `lib/presentation/screens/community/components/achievement_showcase.dart`
- `lib/presentation/screens/community/components/friend_statistics.dart`

**Files to Modify:**
- `lib/navigation/app_router.dart` - Add friend profile route
- `lib/presentation/screens/community/components/friends_view.dart` - Add navigation

**Definition of Done:**
- Friend profile screen implemented per design
- Achievement showcase displaying actual badges
- Statistics summary respecting privacy settings
- Interaction buttons functioning correctly

## Phase 7: Background Services & Notifications (Week 7)

### Day 31: Background Service Implementation

**Objective:** Create a service for background data collection.

**Tasks:**
1. Implement background service facade
2. Add methods for controlling background operation
3. Implement battery optimization strategies
4. Create service lifecycle management

**Files to Create:**
- `lib/services/background/background_service.dart` - Background service facade

**Files to Modify:**
- `lib/services/service_locator.dart` - Register new service
- `lib/services/driving/driving_service.dart` - Integrate with background service

**Definition of Done:**
- Background service implemented
- Control methods working correctly
- Battery optimization strategies functioning
- Service lifecycle properly managed

### Day 32: Notification Service Implementation

**Objective:** Create a service to manage in-app and system notifications.

**Tasks:**
1. Implement notification service
2. Add methods for different notification types
3. Create notification channels
4. Implement user preference respecting

**Files to Create:**
- `lib/services/background/notification_service.dart` - Notification service

**Files to Modify:**
- `lib/services/service_locator.dart` - Register new service
- `lib/services/background/background_service.dart` - Integrate notifications
- `lib/services/driving/driving_service.dart` - Add notification triggers

**Definition of Done:**
- Notification service implemented
- Notification types working correctly
- Channels created for different purposes
- User preferences being respected

### Day 33: Privacy Settings Screen Implementation

**Objective:** Create the privacy settings screen.

**Tasks:**
1. Implement privacy settings UI
2. Create data collection visualization
3. Add granular toggle controls
4. Implement data management section

**Files to Create:**
- `lib/presentation/screens/profile/privacy_settings_screen.dart` - Full screen
- `lib/presentation/screens/profile/components/data_collection_visualization.dart`
- `lib/presentation/screens/profile/components/privacy_toggles.dart`
- `lib/presentation/screens/profile/components/data_management_section.dart`

**Files to Modify:**
- `lib/navigation/app_router.dart` - Add privacy settings route
- `lib/presentation/screens/profile/settings_screen.dart` - Add navigation

**Definition of Done:**
- Privacy settings screen implemented per design
- Data collection visualization showing actual data usage
- Toggle controls affecting actual settings
- Data management functions working

### Day 34: Social Service Implementation

**Objective:** Create a service to manage social connections and interactions.

**Tasks:**
1. Implement social service
2. Add methods for managing connections
3. Create leaderboard functionality
4. Implement social sharing

**Files to Create:**
- `lib/services/social/social_service.dart` - Social service facade
- `lib/services/social/leaderboard_service.dart` - Leaderboard functionality
- `lib/services/social/sharing_service.dart` - Content sharing

**Files to Modify:**
- `lib/services/service_locator.dart` - Register new services
- `lib/presentation/providers/social_provider.dart` - Integrate with social services

**Definition of Done:**
- Social service implemented
- Connection management working
- Leaderboard functionality functioning
- Sharing capabilities working correctly

### Day 35: Device Connection Screen Implementation

**Objective:** Create the device connection management screen.

**Tasks:**
1. Implement device connection UI
2. Create device scanning functionality
3. Add connection management
4. Implement adapter configuration

**Files to Create:**
- `lib/presentation/screens/profile/device_connection_screen.dart` - Full screen
- `lib/presentation/screens/profile/components/device_scanner.dart`
- `lib/presentation/screens/profile/components/connection_manager.dart`
- `lib/presentation/screens/profile/components/adapter_config.dart`

**Files to Modify:**
- `lib/navigation/app_router.dart` - Add device connection route
- `lib/presentation/screens/profile/settings_screen.dart` - Add navigation

**Definition of Done:**
- Device connection screen implemented per design
- Device scanning working correctly
- Connection management functioning
- Adapter configuration options working

## Phase 8: Polish & Optimization (Week 8)

### Day 36: Animation & Transition Implementation

**Objective:** Implement animations and transitions according to the UI guidelines.

**Tasks:**
1. Add screen transitions
2. Implement component animations
3. Create feedback animations
4. Add celebration effects

**Files to Create:**
- `lib/core/animations/transitions.dart` - Screen transition animations
- `lib/core/animations/component_animations.dart` - Component animations
- `lib/core/animations/feedback_animations.dart` - Feedback animations

**Files to Modify:**
- `lib/navigation/app_router.dart` - Add transitions
- Various component files to add animations

**Definition of Done:**
- Screen transitions implemented per design
- Component animations working correctly
- Feedback animations functioning
- Celebration effects appearing at appropriate times

### Day 37: Responsiveness & Adaptability Implementation

**Objective:** Ensure the app works well on different screen sizes and orientations.

**Tasks:**
1. Implement responsive layouts
2. Add orientation handling
3. Create split-screen support
4. Test on different device sizes

**Files to Create:**
- `lib/core/utils/responsive_utils.dart` - Responsive helpers

**Files to Modify:**
- Various screen files to add responsive layouts

**Definition of Done:**
- App working correctly on different screen sizes
- Orientation changes handled properly
- Split-screen mode functioning
- Tested on at least 3 different device sizes

### Day 38: Accessibility Implementation

**Objective:** Ensure the app is accessible to all users.

**Tasks:**
1. Add semantic labels
2. Implement screen reader support
3. Create high contrast mode
4. Add keyboard navigation support

**Files to Create:**
- `lib/core/utils/accessibility_utils.dart` - Accessibility helpers

**Files to Modify:**
- Various UI component files to add accessibility features

**Definition of Done:**
- Semantic labels added to all important elements
- Screen reader support verified
- High contrast mode working
- Keyboard navigation functioning

### Day 39: Performance Optimization

**Objective:** Optimize the app for smooth performance.

**Tasks:**
1. Profile and optimize rendering
2. Reduce unnecessary rebuilds
3. Optimize background operations
4. Implement efficient data caching

**Files to Modify:**
- Various files based on profiling results

**Definition of Done:**
- App maintaining 60fps during normal use
- No jank during animations
- Battery usage optimized
- Memory usage reasonable

### Day 40: Final Testing & Bug Fixes

**Objective:** Perform comprehensive testing and fix any remaining issues.

**Tasks:**
1. Create test cases for all major features
2. Run thorough testing on different devices
3. Fix identified bugs
4. Verify requirements compliance

**Definition of Done:**
- All major features tested
- Critical bugs fixed
- App meeting performance targets
- Requirements verified

## Conclusion

This implementation guide provides a structured approach to building the Going50 eco-driving application over 8 weeks. Each day's tasks build upon previous work to create a fully-featured app that meets the requirements specified in the architecture, UI/UX, and requirements documents.

The implementation starts with core infrastructure, progresses through data collection and analysis, user interface implementation, and finally polishing and optimization. By following this guide, developers should be able to create a high-quality, feature-complete application that encourages sustainable driving behavior.

Remember that while each task is designed to be completable in a day, some complexity may require adjustments to the timeline. Regular communication among team members and adaptation based on progress is encouraged.

################################################################################
FILE: AppRoadmapStatus.md
################################################################################

# Going50 Eco-Driving App: Step-by-Step Implementation Guide

## Introduction

This document provides a detailed, step-by-step implementation guide for building the Going50 eco-driving application. Each step is designed to be completable within one day of focused development work, starting with core functionality and progressively adding features.

The implementation is organized into logical phases, with each phase building upon previous work. Some components like the OBD library, sensor library, and core models are already implemented and can be leveraged.

## Phase 1: Project Setup & Core Infrastructure (Week 1)

### Day 1: Initial Project Setup & Structure ✅

**Summary**: Set up the project structure according to the architecture document. Added required dependencies in pubspec.yaml. Created the core architecture files: app.dart with theme implementation, main.dart, app_constants.dart with constants, app_colors.dart for color palette, and app_theme.dart with light and dark themes. Fixed integration issues with existing libraries (obd_lib, sensor_lib, data_lib) by adding missing dependencies and generating database code. The app now builds successfully with a basic UI showing the Going50 app name and tagline.



### Day 2: Service Locator & Core Utilities ✅

**Summary**: Implemented dependency injection using the get_it package with the service_locator.dart file to manage all service dependencies. Created core utilities in the utils directory: permission_utils.dart for handling different types of permissions needed for the app (Bluetooth, location, sensors), formatter_utils.dart for formatting various data types (dates, distances, fuel consumption, etc.), driving_utils.dart for eco-driving calculations (fuel consumption, CO2 emissions, aggressive driving detection, etc.), and device_utils.dart for detecting device capabilities (Bluetooth availability, battery status, etc.). All utilities are well-documented with comprehensive error handling and logging.


### Day 3: Navigation & Routing Infrastructure ✅

**Summary**: Implemented the navigation system and basic screen structure. Created route constants in route_constants.dart with well-organized route groups by feature area. Built a TabNavigator component that manages the bottom tab navigation with all four main tabs (Drive, Insights, Community, Profile). Implemented the app_router.dart file to handle named routes across the app, using MaterialPageRoute for consistent transitions. Created stub screen implementations for all main tabs with a clean, functional UI following the design guidelines. Updated the main App component to use the new TabNavigator and router. All screens include placeholders for core functionality and follow material design principles with proper documentation.


### Day 4: OBD Connection Service Implementation ✅

**Summary**: Implemented the OBD Connection Service that interfaces with the existing OBD library. Created the service with robust error handling, device scanning capabilities, and connection management. Implemented data conversion from OBD library format to application data models. Added stale data detection with a timer-based system to monitor connection health. Implemented robust permission handling and Bluetooth capability checking. Updated the service locator to register the new service. The implementation follows the clean architecture approach with clear separation of concerns and comprehensive documentation.

### Day 5: Sensor Service Implementation & Integration ✅

**Summary**: Implemented the SensorService class as a facade to the sensor_lib, providing a clean interface for sensor data collection. Added methods for initialization, data collection, and error handling with appropriate permission checks. Modified the OBD connection service to include fallback functionality for when OBD connection is unavailable, allowing the app to collect driving data using phone sensors. Updated the service locator to properly register and inject dependencies. The implementation supports real-time sensor data streaming and seamless switching between OBD and sensor-only modes.


### Day 6: Data Collection Service Implementation ✅

**Summary**: Implemented the DataCollectionService that coordinates and combines data from both OBD and sensor sources. Created a clean, well-documented service that handles data merging, buffering, and processing. Implemented background collection capability to ensure continuous data flow even when the UI is not active. Added error handling, logging, and proper resource cleanup. Integrated with the EcoDrivingManager to feed combined data for analysis. The service exposes a stream of real-time combined driving data for other parts of the app to consume. Updated the service locator to register the new service, ensuring proper dependency injection. The implementation follows the clean architecture pattern with clear separation of concerns.



### Day 7: Behavior Analysis Service Implementation ✅

**Summary**: Implemented the AnalyticsService that analyzes driving behavior using the behavior classifier library. Created a robust service with real-time analysis capabilities that calculates eco-scores, detects driving behavior events, and generates feedback suggestions. Implemented event detection for key driving behaviors with severity thresholds and confidence levels. Added feedback generation with prioritized improvement suggestions for different behavior categories. Set up real-time notifications through event streams for UI components. Integrated with the DataCollectionService to analyze collected driving data. Updated the service locator to properly connect services. The implementation includes clean error handling, efficient resource management, and comprehensive documentation.


### Day 8: Trip Management Service Implementation ✅

**Summary**: Implemented the TripService that interfaces with the DataStorageManager to manage trip recording and completion. Created functionality for starting and ending trips, calculating trip metrics (distance, speed, fuel consumption, etc.), and saving trip data points. Implemented real-time trip metrics updates through a stream for UI components to consume. Added event counting for different driving behaviors (idling, aggressive acceleration, hard braking, etc.). Integrated with the DataCollectionService to receive and process driving data points. Updated the service locator to register the new service and connect it with the DataCollectionService. The implementation includes robust error handling, comprehensive logging, and follows the clean architecture pattern with proper documentation.


### Day 9: Main Driving Service Implementation ✅

**Summary**: Implemented the DrivingService to act as a facade that coordinates all driving-related services. Improved the overall architecture by centralizing the orchestration of services, removing direct dependencies between subordinate services for better separation of concerns. Implemented proper state management for driving status (notReady, ready, recording, error). Created a unified interface for starting/stopping trips and accessing driving data. Added a driving event notification system that propagates events from all services through a single stream. Added methods for managing OBD device connections, scanning, and data collection. Set up proper error handling and resource disposal. Updated DataCollectionService to focus solely on data collection without dependencies on other services. Fixed issues in the ObdConnectionService to expose needed functionality. The implementation follows clean architecture principles with comprehensive documentation and robust error handling.

### Day 10: State Management & Provider Setup ✅

**Summary**: Implemented state management using providers for all major features. Created the DrivingProvider to expose driving-related functionality to the UI, including methods to start/end trips, scan for OBD devices, and access driving data and events. Implemented InsightsProvider to manage trip history and performance metrics with functionality for filtering, searching, and analyzing trip data. Added UserProvider to handle user profile information and preferences, with placeholder implementation for future user service integration. Implemented SocialProvider with mock data for friends and leaderboard features. Updated the App widget to use MultiProvider for providing all these services to the UI. All providers follow a consistent pattern with proper error handling, loading state management, and clean interfaces. The implementation ensures separation of concerns by keeping UI-related state in providers while delegating actual business logic to the services.


## Phase 3: Core UI Implementation (Week 3)

### Day 11: Common UI Components ✅

**Summary**: Implemented reusable UI components based on the design system. Created button components (PrimaryButton, SecondaryButton) with support for text, icons, and full-width variants. Implemented card components (InfoCard, StatsCard) for displaying information and statistics with consistent styling. Added a StatusIndicator component for showing different status types (success, warning, error, info, inactive) with appropriate styling. Created a SectionContainer layout helper for consistent spacing and organization of content sections with optional titles and dividers. All components follow the design guidelines, are highly reusable across the app, and include comprehensive documentation with usage examples. The implementation ensures consistent UI behavior and appearance throughout the app while maintaining flexibility for different use cases.

### Day 12: Onboarding Flow Implementation ✅

**Summary**: Implemented the complete onboarding flow for first-time users with a series of engaging and informative screens. Created the main OnboardingScreen wrapper that manages navigation between the different onboarding steps. Implemented WelcomeScreen with app introduction and value proposition. Built ValueCarouselScreen with a swipeable carousel showcasing key benefits (save money, reduce emissions, track progress). Created AccountChoiceScreen allowing users to choose between quick start (anonymous) or creating an account with clear benefits and limitations explained. Added ConnectionSetupScreen to guide users through OBD connection options with detailed explanations and visual aids. Updated the app to check for first-time use and show onboarding as needed using SharedPreferences. All screens follow the design guidelines with consistent styling, proper navigation, and comprehensive documentation. The implementation provides a smooth and informative introduction to the app for new users while allowing them to skip or navigate freely through the flow.

### Day 13: Drive Tab Implementation ✅

**Summary**: Implemented the main Drive Tab screen with connection status display and trip controls. Created three reusable components: ConnectionStatusWidget to show the current connection status (OBD/phone sensors), StartTripButton for a large circular button that initiates trip recording, and RecentTripCard to display information about the most recent trip with metrics and eco-score. Restructured the DriveScreen to use a three-section layout with status at the top, action buttons in the middle, and recent trip information at the bottom. Added a first-use experience card with welcoming message for new users. Implemented real-time status updates through providers and added audio feedback toggle functionality. The implementation follows the design specifications with proper component separation, clean architecture, and comprehensive documentation.

### Day 14: Active Drive Screen Implementation ✅

**Summary**: Implemented the distraction-minimized active driving screen for ongoing trips. Created three core components: EcoScoreDisplay showing a large, prominently visible eco-score gauge with color feedback, CurrentMetricsStrip displaying essential real-time metrics (speed, RPM, acceleration) in a compact format at the bottom of the screen, and EventNotification for showing temporary driving behavior feedback notifications. Implemented immersive mode to minimize distractions while driving. Added a status bar with trip duration and end trip button. Modified the StartTripButton to navigate to the ActiveDriveScreen when a trip starts. Integrated with the DrivingProvider to display real-time data and respond to driving events. Updated the AppRouter to properly handle the new screen. The implementation follows a minimalist design approach focused on glanceability and driver safety, with automatic portrait orientation and proper resource cleanup.

### Day 15: Trip Summary Screen Implementation ✅

**Summary**: Implemented the trip summary screen that displays detailed information about a completed trip. Created four component files: TripOverviewHeader showing basic trip information (date, time, duration, eco-score), SavingsMetricsSection showing estimated savings (fuel, CO2, money), BehaviorBreakdownChart displaying a breakdown of driving behaviors with visual score bars, and ImprovementSuggestionCard showing personalized driving improvement suggestions. Updated the app router to navigate to the trip summary screen after a trip is completed. Added necessary methods to the DrivingProvider to retrieve trip data. The implementation follows a clean, modular approach with comprehensive documentation and proper error handling. The trip summary screen provides a complete post-trip analysis with actionable insights for improving eco-driving behavior.


## Phase 4: Insights & Analytics (Week 4)

### Day 16: Insights Dashboard Implementation ✅

**Summary**: Implemented the main insights dashboard screen with comprehensive analytics visualization. Created four key components: TimePeriodSelector for switching between different time frames (day, week, month, year), EcoScoreTrendChart displaying eco-score trends with animated line charts, SavingsSummaryCard showing fuel, money, and CO2 savings, and DrivingBehaviorsChart visualizing performance across seven eco-driving behaviors in a radar chart. Implemented the InsightsProvider with detailed methods for loading and calculating metrics data for different time periods, generating trend data, and providing recommendations based on driving behavior scores. The implementation includes graceful error handling, loading states, and comprehensive documentation. The insights dashboard provides users with a clear visual representation of their eco-driving performance and actionable feedback for improvement.

### Day 17: Trip History Screen Implementation ✅

**Summary**: Implemented the trip history screen with search and filter functionality. Created four components: 1) SearchFilterBar for real-time trip searching, 2) TripListItem to display trip information with date, time, distance, eco-score and event indicators, 3) FilterSheet as a modal bottom sheet with date range picker, eco-score range slider, distance range slider, and event type checkboxes, and 4) the main TripHistoryScreen that coordinates all components and provides sorting controls. Implemented features include: trip grouping by date, infinite scrolling with lazy loading, comprehensive filtering options, real-time search, sorting by date/score/distance, elegant error states and empty states. The screen follows the design guidelines with clean separation of concerns and comprehensive documentation. Updated navigation to connect the insights dashboard to the trip history screen.

### Day 18: Trip Detail Screen Implementation ✅

**Summary**: Implemented the trip detail screen that displays comprehensive information about a specific trip. Created three main component files: TripMapSection for displaying a map visualization of the trip route (with a simulated route for demonstration), TripMetricsSection with tabbed interface showing performance metrics, efficiency data, and behavior analysis, and TripTimelineSection showing a chronological timeline of events during the trip. Added trip header with basic trip information, eco-score display, and key metrics. Implemented tabs for different views of the trip data. Added detailed metrics visualization, driving event summary, and performance analysis. Updated the app router to use the new TripDetailScreen component. Fixed linter issues for clean code. The implementation follows the design guidelines with proper separation of concerns and comprehensive documentation.

### Day 19: Data Visualization Components Implementation ✅

**Summary**: Implemented four reusable data visualization components for the app: 1) EcoScoreGauge displaying a circular gauge with color-coded feedback for eco-scores, 2) LineChart showing trends over time with support for multiple datasets and customization options, 3) BarChart for comparative data visualization with animated bars and value labels, and 4) AppRadarChart displaying multiple metrics in a radial format for skills assessment. Created a demo section in the insights screen to showcase all chart types with sample data and descriptive cards. All components follow the design guidelines with consistent styling, proper animation, and comprehensive documentation. The implementation ensures a consistent visualization approach throughout the app while maintaining flexibility for different use cases. Fixed naming conflicts with external libraries and ensured proper integration with the existing codebase.

### Day 20: Performance Metrics Service Implementation ✅

**Summary**: Implemented the PerformanceMetricsService that calculates and manages various driving performance metrics. Created a robust service that calculates detailed metrics over different time periods (daily, weekly, monthly, yearly), generates trend data for visualizations, and calculates projected savings (fuel, money, CO2). Added comprehensive behavior scoring system with individual metrics for different driving behaviors: calm driving, efficient acceleration, efficient braking, idling management, speed optimization, and steady speed maintenance. Implemented personalized improvement tips generation based on driving behavior analysis. Integrated the service with InsightsProvider to enable rich data visualization in the UI. The implementation follows clean architecture principles with proper separation of concerns, caching for performance, and comprehensive documentation. Fixed all linter issues for code quality.

## Phase 5: User Management & Settings (Week 5)

### Day 21: User Service Implementation ✅

**Summary**: Implemented the UserService to manage user profiles and authentication. Created methods for loading and managing user profiles, supporting anonymous users, optional account registration, and profile updating. Added getUserProfileById and saveUserProfile methods to the DataStorageManager to interface with the database. Implemented a broadcast stream for user profile changes to allow reactive UI updates. Updated the UserProvider to use the UserService, including methods for profile loading and updating. Created functionality to convert anonymous users to registered accounts while preserving their data. Implemented proper state management with loading and error handling. Integrated the UserService with the service locator and updated the app to provide it to the UserProvider. The implementation follows clean architecture principles with proper separation of concerns, comprehensive error handling, and detailed documentation.

### Day 22: Preferences Service Implementation ✅

**Summary**: Implemented the PreferencesService to manage user preferences. Created a robust service with methods for saving, retrieving, and resetting preferences. Implemented a categorized preference structure with default values for various app settings (notifications, privacy, display, driving, feedback, connection). Added a preferences change notification system via a broadcast stream for reactive UI updates. Integrated the service with UserProvider to provide preference access throughout the app. Updated shared preferences for fast app startup access. The implementation follows clean architecture principles with proper separation of concerns, comprehensive error handling, and thorough documentation. The service supports loading preferences from persistent storage, saving preference changes, resetting to defaults, and checking preference existence.


### Day 23: Privacy Service Implementation ✅

**Summary**: Implemented the PrivacyService to manage privacy settings and data access control. Created a robust service with methods for checking permissions, creating and updating privacy settings, and controlling data access. Added functionality to handle different data types (trips, location, driving events, performance metrics) with granular privacy controls for different operations (local storage, cloud sync, sharing, analytics). Implemented a broadcasting stream for privacy setting changes to enable reactive UI updates. Added methods for getting and updating settings, checking if operations are allowed, and resetting to defaults. Integrated the service with the DataStorageManager to persist privacy settings. Added the service to the service locator for dependency injection. 

Created responsive UI components for privacy settings including DataCollectionVisualization for visualizing privacy scores and data usage, PrivacyToggles for controlling privacy settings with granular options, and DataManagementSection for data export and deletion. Implemented real-time UI updates using StreamBuilder pattern to ensure all components reflect the latest privacy settings. The implementation includes comprehensive error handling, proper initialization, and thorough documentation. The service and UI support the privacy-first approach of the app by providing users with granular control over their data.

### Day 24: Profile Screen Implementation ✅

**Summary**: Implemented the user profile screen with detailed user information, achievements, and statistics. Created three reusable components: ProfileHeader displaying user avatar, name, eco-score with progress bar, and impact statistics; AchievementsGrid showing a grid of earned and in-progress badges with proper visualization; and StatisticsSummary displaying detailed driving statistics including trips, distance, fuel savings, and personal records. Integrated these components into the main ProfileScreen with proper styling and layout. Connected the UI to the UserProvider and InsightsProvider to display real data. Added pull-to-refresh functionality and navigation placeholders for settings and help screens. The implementation follows the UI guidelines with a clean, modular approach and comprehensive documentation.

### Day 25: Settings Screen Implementation ✅

**Summary**: Implemented the settings screen with all app configuration options organized by category. Created reusable components: SettingsSection to group related settings under a common header and SettingsItem to display individual settings with title, subtitle, icon and optional interactive elements. Built a comprehensive settings screen with five main sections: Account (profile information, data sync, account deletion), Privacy (privacy settings, social visibility, data management), Device (OBD connection, connection mode, background operation), Preferences (notifications, display, audio feedback, measurement units), and About (app version, terms, privacy policy, feedback). Implemented interactive settings with immediate feedback using the UserProvider and PreferencesService. Added dialog-based settings configuration for connection mode and measurement units. Connected the settings screen to the navigation system and updated the profile screen to navigate to it. The implementation follows design guidelines with consistent styling, proper organization, and comprehensive documentation.

### Day 26: Achievement Service Implementation ✅

**Summary**: Implemented the Achievement Service to manage user achievements and badges. Created a robust service that defines achievement types and conditions, checks for badge qualifications, and awards badges when criteria are met. Implemented 10 badge types with multiple levels including Smooth Driver, Eco Warrior, Fuel Saver, Carbon Reducer, and more. Added stream-based notifications for new achievements with a unified event system. Modified the DrivingService to integrate with the AchievementService, checking for achievements after trips are completed. Enhanced the DataStorageManager with methods to save and retrieve badges from the database. Updated the PerformanceMetricsService to provide user metrics that are used for achievement qualification. Added support for badge levels, allowing users to upgrade existing badges when they reach higher thresholds. The implementation follows clean architecture principles with proper separation of concerns, effective error handling, and comprehensive documentation. 

### Day 27: Challenge Service Implementation ✅

**Summary**: Implemented the Challenge Service to manage user challenges and progress tracking. Created a comprehensive service that defines challenge types (daily, weekly, achievement, etc.) and requirements, tracks progress, and handles completion and reward claiming. Implemented system challenge definitions with a variety of metrics including eco-score, trip count, distance, calm driving, fuel savings, and emissions reduction. Added stream-based notifications for challenge events with a unified event system. Created methods for starting challenges, updating progress, and claiming rewards. Implemented automatic challenge checking after trips are completed to update progress. Added support for challenge reset functionality for periodic challenges (daily, weekly). Enhanced the DrivingService to integrate with the ChallengeService and forward challenge events to the UI. The implementation includes robust error handling, proper caching for performance, and thorough documentation for maintainability. All challenge-related functionality follows clean architecture principles with proper separation of concerns. 

### Day 28: Community Hub Screen Implementation ✅

**Summary**: Implemented the community hub screen with a tab-based interface for three main social features: leaderboards, challenges, and friends. Created three component views: LeaderboardView for displaying user rankings with segmented controls for different leaderboard types and time periods; ChallengesView for showing active, available, and completed challenges with progress indicators and join functionality; and FriendsView for managing connections with search capability and friend requests. Each component follows clean architecture with appropriate separation of concerns. The implementation includes loading states, error handling, and empty state displays. Added interactive elements like time period selectors, search functionality, and buttons for joining challenges and adding friends. Used mock data where necessary while connecting to the SocialProvider for real data access. The UI follows the design guidelines with consistent styling, proper spacing, and intuitive navigation. Fixed linter errors and ensured proper integration with the existing architecture. 

### Day 29: Challenge Detail Screen Implementation ✅

**Summary**: Implemented the challenge detail screen that displays comprehensive information about specific challenges. Created three main components: the ChallengeDetailScreen for the overall screen structure, ChallengeProgressSection for visual progress tracking and target description, and ChallengeLeaderboard for displaying participant rankings. Implemented features include: detailed challenge information display with icon and difficulty level, interactive progress visualization with percentage indicators, participant leaderboard with ranking badges, join/leave functionality for challenges, and reward claiming for completed challenges. Updated mock challenge data in ChallengesView to use real challenge IDs from the ChallengeService. Added proper navigation between the challenges view and detail screen. The implementation follows clean architecture with proper error handling, loading states, and responsive layout. Note: There is a remaining issue with "Challenge not found" errors that will be fixed when mock data is fully replaced with real data from the ChallengeService. 

### Day 30: Friend Profile Screen Implementation ✅

**Summary**: Implemented the friend profile viewing screen with comprehensive user information display. Created a complete FriendProfileScreen that showcases various components: profile header with user avatar and eco-driving level, achievement showcase displaying earned badges with visual indicators for badge levels, statistics summary showing driving performance metrics with optional comparison to the viewer's stats, and an interaction section with challenge and messaging functionality. Added detailed friend activity timeline with relevant achievements and milestones. Implemented interactive features including achievement details dialog, challenge invitation interface with a list of challenge options, and friend management options. Updated the FriendsView to navigate to the new profile screen when a friend's profile is selected. The implementation follows the design guidelines with consistent styling, proper error handling, and privacy-aware data display. Connected the screen to existing services like SocialProvider for data access while using mock data where real data wasn't yet available.

## Phase 7: Background Services & Notifications (Week 7)

### Day 31: Background Service Implementation ✅

**Summary**: Implement BackgroundService with proper dependency management. No errors when running, functionality is not yet verified.

### Day 32: Notification Service Implementation ✅

**Summary**: Implemented the NotificationService to manage in-app and system notifications. Created a robust service with comprehensive notification handling capabilities including: notification channels for different types (driving events, achievements, social, trips, eco-tips), user preference-based filtering, specialized methods for showing different notification types, and proper integration with the DrivingService and BackgroundService. The implementation follows clean architecture with proper separation of concerns, comprehensive error handling, and thorough documentation.

### Day 33: Privacy Settings Screen Implementation ✅

**Summary**: Implemented a comprehensive privacy settings screen with interactive controls and visual feedback. Created three main components: DataCollectionVisualization for showing a visual representation of collected data with privacy score calculation; PrivacyToggles for granular control over different data types (trips, location, driving events, performance metrics) and operations (local storage, cloud sync, sharing, analytics); and DataManagementSection for data export and deletion capabilities. Implemented real-time UI updates using StreamBuilder pattern ensuring all components reflect the latest privacy settings. Added initialization logic to properly load settings when the screen is opened. The implementation provides users with a clear understanding of their data privacy and complete control over how their information is used, aligning with the app's privacy-first approach.

### Day 34: Social Service Implementation ✅

**Summary**: Implemented the social services infrastructure with modules for friendship management, leaderboards, and content sharing. Created SocialService for handling friend connections, requests, and user discovery with privacy-aware implementations. Built LeaderboardService for retrieving and managing user rankings based on eco-driving performance, and SharingService for content sharing within the app and to external platforms. Integrated these services with the SocialProvider to provide a clean interface for the UI components. Added real database tables and methods for friend requests, user blocks, leaderboard entries, and shared content. Implemented proper database operations in place of mock implementations to ensure full functionality. The implementation follows clean architecture principles with proper separation of concerns, effective error handling, and comprehensive documentation.

### Day 35: Device Connection Screen Implementation ✅

**Summary**: Implemented the Device Scan Screen


################################################################################
FILE: AppRequirements.md
################################################################################

# Going50 Eco-Driving App - Comprehensive Implementation Guide

## 1. App Overview

Going50 is an eco-driving application designed to promote sustainable driving behaviors through real-time feedback, gamification, and social features. The app uses OBD2 adapters for precise data collection but can also function with phone sensors alone to ensure low adoption barriers.

### 1.1 Core Value Proposition

- Help drivers reduce fuel consumption and CO₂ emissions
- Provide actionable feedback to improve driving behavior
- Create engaging social motivation through gamification and comparison
- Seamlessly integrate with existing driving routines and apps

### 1.2 Target Personas

1. **Eco-Conscious Emma**: Environmentally motivated, urban professional
2. **Budget-Minded Brian**: Focused on fuel savings, suburban commuter
3. **Competitive Carlos**: Enjoys gamification, tech-savvy
4. **Practical Paula**: Professional driver, interested in skill improvement

## 2. Technical Architecture

### 2.1 Technology Stack

- **Mobile Framework**: Flutter for cross-platform (Android/iOS) development
- **Local Database**: SQLite for offline-first data storage
- **Background Services**: Flutter background execution for data collection
- **OBD2 Communication**: Custom implementation using flutter_reactive_ble library
- **Data Visualization**: Charts and graphs using appropriate Flutter packages

### 2.2 System Components

1. **Data Collection Module**
   - [x] OBD2 adapter connection handler
   - [x] Phone sensor fallback implementation
   - [x] Background service for continuous data collection
   
2. **Analysis Engine**
   - [x] Real-time driving behavior analysis
   - [x] Historical data aggregation and trend detection
   - [x] Eco-score calculation algorithm
   
3. **Feedback System**
   - [x] Visual feedback components
   - [x] Audio coaching system
   - [x] Post-trip analysis generator
   
4. **User Management**
   - [x] Optional account creation and management
   - [x] Profile data handling
   - [x] Privacy controls implementation
   
5. **Social Engine**
   - [x] Leaderboard management
   - [x] Challenge system
   - [x] Social sharing functionality

### 2.3 Data Flow

1. **Collection Phase**
   - [x] Raw data gathered from OBD2 or phone sensors
   - [x] Initial filtering and error correction
   - [x] Secure local storage
   
2. **Processing Phase**
   - [x] Behavior pattern identification
   - [x] Eco-score calculation
   - [x] Feedback generation
   
3. **Presentation Phase**
   - [x] Real-time display (if app in foreground)
   - [x] Notification creation (if app in background)
   - [x] Historical data visualization
   
4. **Social Phase** (optional)
   - [x] Anonymous data aggregation
   - [x] Leaderboard positioning
   - [x] Challenge status updates

## 3. Screen Specifications

### 3.1 Drive Screen

**Purpose**: Starting point for trips, provides quick access to core functionality.

**Components**:
- [x] Large "Start Trip" button
- [x] Connection status indicator (OBD2/Phone sensors)
- [x] Recent trip summary card
- [x] Audio feedback toggle
- [x] Quick access to settings

**Behavior**:
- [x] Main entry point for app
- [x] Displays OBD2 connection status
- [x] Shows simplified recent trip metrics
- [x] Initiates trip recording
- [x] Supports split-screen mode

**Implementation Notes**:
- Must be highly glanceable with large touch targets
- Should work in horizontal orientation for dashboard mounts
- Must adapt to split-screen mode (REQ 4.9)

### 3.2 In-Drive Screen

**Purpose**: Provides real-time feedback during active driving with minimal distraction.

**Components**:
- [x] Large, easy-to-read eco-score
- [x] Simplified driving feedback indicators
- [x] Audio coaching toggle
- [x] End trip button
- [x] Critical events notification area

**Behavior**:
- [x] Updates metrics in real-time
- [x] Provides minimal visual distraction (REQ 1.10)
- [x] Offers audio cues for events (REQ 1.11)
- [x] Continues recording in background if user switches apps

**Implementation Notes**:
- Must follow distracted driving guidelines
- Typography must be readable at a glance
- Color coding should be intuitive (green = good, red = needs improvement)
- Should work in split-screen mode with navigation apps (REQ 4.9)

### 3.3 Post-Trip Summary Screen

**Purpose**: Detailed trip analysis after completion.

**Components**:
- [x] Overall trip eco-score with visual rating
- [x] Key metrics (fuel saved, CO₂ reduced, money saved)
- [x] Behavior breakdown chart (acceleration, braking, idling, speed)
- [x] Map of route with event markers (if location permitted)
- [x] Improvement suggestions
- [x] Share button for achievements

**Behavior**:
- [x] Appears after trip completion
- [x] Provides actionable feedback on specific behaviors (REQ 1.3)
- [x] Calculates and displays financial savings (REQ 1.5)
- [x] Offers one-tap sharing of results (REQ 1.4)

**Implementation Notes**:
- Should convert abstract values to meaningful equivalents (trees saved, etc.)
- Must include specific, actionable improvement suggestions
- Should allow sharing of summary graphics to social media

### 3.4 Insights Screen

**Purpose**: Historical data visualization and trend analysis.

**Components**:
- [x] Eco-score trend chart
- [x] Financial savings metrics with projections
- [x] Environmental impact visualization
- [x] Driving skills breakdown with percentages
- [x] Trip history with individual scores
- [x] Custom date range selector

**Behavior**:
- [x] Aggregates data across multiple trips
- [x] Shows progress over time (REQ 1.9)
- [x] Presents statistics in graph form (REQ 1.15)
- [x] Identifies patterns and improvement areas

**Implementation Notes**:
- All visualizations should include meaningful comparisons
- Financial projections should use local currency
- Should support different time frames (weekly, monthly, yearly)

### 3.5 Community Screen

**Purpose**: Social comparison and community engagement.

**Components**:
- [x] Segmented leaderboard (Friends/Local/Global)
- [x] Active challenges section
- [x] Friend activity feed
- [x] Local community initiatives
- [x] Invite friends feature

**Behavior**:
- [x] Provides social comparison (REQ 1.8)
- [x] Displays normative feedback (REQ 1.1)
- [x] Shows challenge participation
- [x] Enables social interaction around eco-driving

**Implementation Notes**:
- Must include privacy controls for what is shared
- Should provide opt-out options for competitive elements (REQ 3.13)
- Local comparisons should use geographic proximity

### 3.6 Profile Screen

**Purpose**: Personal stats, achievements, and settings access.

**Components**:
- [x] User profile information (optional)
- [x] Achievement badges display
- [x] Overall statistics summary
- [x] Level/progression indicator
- [x] Settings access
- [x] Profile sharing link generator

**Behavior**:
- [x] Displays personal accomplishments
- [x] Shows eco-driving credentials
- [x] Provides access to detailed settings
- [x] Enables profile sharing with ride-sharing platforms (REQ 4.8)

**Implementation Notes**:
- Account creation should be optional (REQ 4.10)
- Profile data should be customizable for privacy
- Should generate shareable profile links for external platforms

### 3.7 Settings Screen

**Purpose**: App configuration and user preferences.

**Components**:
- [x] Account settings section
- [x] Privacy controls section
- [x] Device connection section
- [x] Notification preferences
- [x] Audio feedback settings
- [x] Display preferences
- [x] Data management options

**Behavior**:
- [x] Provides granular privacy controls (REQ 5.4)
- [x] Manages OBD2 device connections
- [x] Configures notification behavior
- [x] Controls data storage and sharing

**Implementation Notes**:
- Privacy settings should be clear and accessible
- Should visualize what data is collected (REQ 5.3)
- Device settings should include adapter configuration options

### 3.8 Onboarding Flow

**Purpose**: Introduction to app value and features.

**Components**:
- [x] Value proposition screens
- [x] Feature highlights carousel
- [x] Skip option for immediate access
- [x] Progressive permission requests
- [x] OBD2 connection guide (optional)
- [x] Onboarding checklist

**Behavior**:
- [x] Introduces key benefits
- [x] Requests permissions contextually (REQ 4.13)
- [x] Allows core functionality without account (REQ 4.10)
- [x] Provides step-by-step exploration guide (REQ 4.11)

**Implementation Notes**:
- Should emphasize financial savings early
- Permissions should only be requested when needed
- Feature explanations should appear on first visit to each screen (REQ 4.12)

## 4. Core Functionalities

### 4.1 Data Collection System

#### 4.1.1 OBD2 Connection
- [x] Bluetooth device discovery
- [x] Connection establishment with different adapter types
- [x] Command sequence handling for various adapters
- [x] Data parsing and error handling
- [x] Connection state management

#### 4.1.2 Phone Sensor Fallback
- [x] Accelerometer data collection
- [x] Gyroscope data analysis
- [x] GPS speed tracking
- [x] Motion activity recognition
- [x] Background collection capability

#### 4.1.3 Background Service
- [x] Foreground service for continuous collection
- [x] Battery optimization strategies
- [x] Data persistence during background operation
- [x] Service lifecycle management
- [x] Resource usage monitoring

### 4.2 Analysis Algorithms

#### 4.2.1 Eco-Driving Detection
- [x] Harsh acceleration detection
- [x] Hard braking identification
- [x] Excessive idling measurement
- [x] Speed efficiency analysis
- [x] Overall driving pattern classification

#### 4.2.2 Scoring System
- [x] Real-time eco-score calculation
- [x] Trip-level scoring algorithm
- [x] Weighted factor analysis
- [x] Vehicle-specific calibration
- [x] Comparative normalization

#### 4.2.3 Feedback Generation
- [x] Context-aware advice creation
- [x] Personalized suggestion system
- [x] Priority-based feedback filtering
- [x] Progressive skill development tracking
- [x] Learning algorithm for recurring issues

### 4.3 Notification System

#### 4.3.1 Drive-Time Notifications
- [x] Critical event alerts
- [x] Milestone achievements
- [x] Safety-conscious timing system
- [x] Audio feedback messages
- [x] Split-screen compatibility

#### 4.3.2 Background Notifications
- [x] Trip recording status indicator
- [x] Summarized feedback delivery
- [x] Re-engagement prompts
- [x] Challenge updates
- [x] Friend activity alerts

#### 4.3.3 Post-Drive Alerts
- [x] Trip completion summary
- [x] Achievement notifications
- [x] Improvement suggestions
- [x] Challenge completion updates
- [x] Comparative performance insights

## 5. Gamification Features

### 5.1 Achievement System

#### 5.1.1 Badges
- [x] Skill mastery badges (smooth driver, eco-expert, etc.)
- [x] Milestone badges (distance, trips, savings)
- [x] Challenge completion badges
- [x] Consistency badges (streaks, improvements)
- [x] Special event badges

#### 5.1.2 Levels and Progression
- [x] Eco-driver level system
- [x] XP accumulation from good driving
- [x] Level-based unlockable features
- [x] Progress visualization
- [x] Skill mastery tracking

#### 5.1.3 Rewards
- [x] Virtual rewards for achievements
- [x] Unlockable app customizations
- [x] Special status indicators
- [x] Profile enhancements
- [x] Feature unlocks (if applicable)

### 5.2 Challenge System

#### 5.2.1 Personal Challenges
- [x] Daily eco-driving goals
- [x] Weekly improvement targets
- [x] Skill-specific challenges
- [x] Streak-based challenges
- [x] Adaptive difficulty system

#### 5.2.2 Community Challenges
- [x] Friend group competitions
- [x] Local area challenges
- [x] Global challenges
- [x] Team-based challenges
- [x] Limited-time events

#### 5.2.3 Challenge Mechanics
- [x] Challenge discovery system
- [x] Opt-in participation
- [x] Progress tracking
- [x] Results calculation
- [x] Reward distribution

### 5.3 Feedback Visualization

#### 5.3.1 Visual Rewards
- [x] Animation celebrations for achievements
- [x] Visual growth metaphors (trees, plants)
- [x] Color-coded progress indicators
- [x] Achievement unlock animations
- [x] Level-up celebrations

#### 5.3.2 Audio Rewards
- [x] Positive reinforcement sounds
- [x] Achievement jingles
- [x] Voice coaching congratulations
- [x] Level-up audio cues
- [x] Challenge completion sounds

## 6. Social Features

### 6.1 Profile System

#### 6.1.1 User Profile
- [x] Optional account creation
- [x] Basic profile information
- [x] Eco-driving statistics display
- [x] Achievement showcase
- [x] Privacy control settings

#### 6.1.2 Driver Reputation
- [x] Eco-driver rating calculation
- [x] Skill mastery indicators
- [x] Consistency metrics
- [x] Comparative positioning
- [x] Public sharing controls

#### 6.1.3 Profile Sharing
- [x] Link generation for external platforms
- [x] Social media sharing templates
- [x] Ride-sharing platform integration
- [x] Embedded profile widgets
- [x] QR code generation

### 6.2 Community Features

#### 6.2.1 Leaderboards
- [x] Friends leaderboard
- [x] Geographic leaderboards (local/regional)
- [x] Global rankings
- [x] Skill-specific leaderboards
- [x] Time-period leaderboards (weekly/monthly)

#### 6.2.2 Social Comparison
- [x] Normative feedback messages
- [x] Peer comparison statistics
- [x] Group averages calculation
- [x] Performance percentiles
- [x] "Better than X% of drivers" metrics

#### 6.2.3 Social Interaction
- [x] Friend invitation system
- [x] Achievement reactions
- [x] Challenge invitations
- [x] Encouragement messages
- [x] Activity feed interaction

### 6.3 External Sharing

#### 6.3.1 Social Media Integration
- [x] Achievement sharing templates
- [x] Trip summary sharing
- [x] Challenge results posting
- [x] Milestone announcements
- [x] Environmental impact statements

#### 6.3.2 Ride-Sharing Integration
- [x] Profile link for rider apps
- [x] Eco-driving credentials API
- [x] Ride-sharing profile badge
- [x] Driver profile enhancement
- [x] Passenger-visible eco-status

## 7. Settings and Configuration

### 7.1 Account Settings

#### 7.1.1 User Information
- [x] Optional profile creation
- [x] Basic information management
- [x] Password/security settings
- [x] Account linking options
- [x] Account deletion function

#### 7.1.2 Preferences
- [x] Motivation type setting
- [x] Feedback style preferences
- [x] Measurement units selection
- [x] Currency selection
- [x] Language settings

### 7.2 Privacy Controls

#### 7.2.1 Data Collection Settings
- [x] Granular sensor permissions
- [x] Location tracking controls
- [x] Analysis opt-out options
- [x] Data retention settings
- [x] Collection visualization

#### 7.2.2 Data Sharing Controls
- [x] Social visibility settings
- [x] Leaderboard participation
- [x] Friend discoverability
- [x] External sharing permissions
- [x] Anonymous contribution options

#### 7.2.3 Data Management
- [x] Local data browser
- [x] Export functionality
- [x] Delete trip data option
- [x] Clear history function
- [x] Backup/restore capability

### 7.3 Device Settings

#### 7.3.1 OBD2 Configuration
- [x] Adapter management
- [x] Connection preferences
- [x] Protocol selection
- [x] Auto-connect settings
- [x] Troubleshooting tools

#### 7.3.2 Sensor Settings
- [x] Sensor calibration tools
- [x] Sensitivity adjustments
- [x] Fallback preferences
- [x] Accuracy indicators
- [x] Phone position guidance

### 7.4 Notification Settings

#### 7.4.1 Drive-Time Notifications
- [x] Audio feedback controls
- [x] Visual alert preferences
- [x] Event notification filters
- [x] Feedback frequency adjustment
- [x] Do not disturb mode

#### 7.4.2 Background Notifications
- [x] Service notification customization
- [x] Post-drive summary settings
- [x] Achievement notification controls
- [x] Re-engagement reminder settings
- [x] Social notification preferences

## 8. Background Services

### 8.1 Data Collection Service

#### 8.1.1 Service Architecture
- [x] Foreground service implementation
- [x] Battery optimization strategies
- [x] Sensor management system
- [x] OBD2 connection maintenance
- [x] Error recovery mechanisms

#### 8.1.2 Collection Triggers
- [x] Automatic trip detection
- [x] Manual recording toggle
- [x] Movement detection algorithm
- [x] Connection-based activation
- [x] Scheduled collection support

#### 8.1.3 Data Management
- [x] Real-time processing pipeline
- [x] Local storage optimization
- [x] Caching strategy
- [x] Buffer management
- [x] Data integrity verification

### 8.2 Analysis Service

#### 8.2.1 Real-Time Analysis
- [x] On-device processing algorithms
- [x] Event detection system
- [x] Scoring calculation
- [x] Feedback generation
- [x] Notification triggering

#### 8.2.2 Post-Trip Analysis
- [x] Comprehensive trip evaluation
- [x] Pattern identification
- [x] Statistical aggregation
- [x] Comparison with historical data
- [x] Personalized insight generation

#### 8.2.3 Long-Term Analysis
- [x] Trend detection algorithm
- [x] Behavioral pattern recognition
- [x] Progress tracking metrics
- [x] Seasonal adjustment factors
- [x] Learning algorithm for personalization

### 8.3 Notification Service

#### 8.3.1 Service Architecture
- [x] Priority-based notification system
- [x] Channel management
- [x] Delivery timing optimization
- [x] User attention modeling
- [x] Background state handling

#### 8.3.2 Notification Generation
- [x] Context-aware content creation
- [x] Personalized message templates
- [x] Multi-level priority system
- [x] Quiet hours respect
- [x] Foreground/background state adaptation

## 9. Technical Implementation Details

### 9.1 OBD2 Implementation

#### 9.1.1 Connection Management
- [x] BLE device discovery
- [x] Connection establishment protocol
- [x] Connection maintenance system
- [x] Error handling and recovery
- [x] Multiple adapter support (strategy pattern)

#### 9.1.2 Command Protocol
- [x] ELM327 command set implementation
- [x] Command queuing system
- [x] Response parsing logic
- [x] Timeout and retry handling
- [x] Protocol negotiation

#### 9.1.3 Data Interpretation
- [x] Parameter ID (PID) support
- [x] Unit conversion utilities
- [x] Missing data interpolation
- [x] Sampling rate management
- [x] Data validation algorithms

### 9.2 Sensor Fallback System

#### 9.2.1 Motion Detection
- [x] Accelerometer data processing
- [x] Gyroscope interpretation
- [x] Movement pattern recognition
- [x] Sensor fusion algorithm
- [x] Calibration system

#### 9.2.2 Location Services
- [x] GPS speed tracking
- [x] Location sampling optimization
- [x] Battery-conscious polling
- [x] Accuracy filtering
- [x] Path reconstruction

#### 9.2.3 Device Position Detection
- [x] Orientation detection
- [x] Mounting position inference
- [x] Stability monitoring
- [x] Recalibration triggers
- [x] Position guidance system

### 9.3 Data Storage Architecture

#### 9.3.1 Local Storage
- [x] SQLite database schema
- [x] Efficient query design
- [x] Indexing strategy
- [x] Data compression approach
- [x] Integrity protection

#### 9.3.2 Sync Architecture
- [x] Optional cloud synchronization
- [x] Incremental sync logic
- [x] Conflict resolution strategy
- [x] Background sync service
- [x] Network-aware operation

### 9.4 UI Implementation

#### 9.4.1 Responsive Design
- [x] Screen size adaptation
- [x] Orientation handling
- [x] Split-screen support
- [x] Widget layouts
- [x] Accessibility compliance

#### 9.4.2 Animation System
- [x] Feedback animations
- [x] Transition effects
- [x] Progress visualizations
- [x] Reward animations
- [x] Performance optimization

## 10. Minimum Viable Product (MVP) Definition

The MVP version of Going50 should include:

### 10.1 Core Functionality (Mandatory)
- [x] OBD2 connection capability
- [x] Phone sensor fallback
- [x] Basic eco-driving detection
- [x] Simple eco-score calculation
- [x] Trip recording and summary
- [x] Local data storage
- [x] Battery-efficient background operation

### 10.2 Essential UI (Mandatory)
- [x] Drive screen with start/stop controls
- [x] In-drive minimal feedback display
- [x] Post-trip summary screen
- [x] Basic insights visualization
- [x] Simple settings menu
- [x] No-account mode for core features

### 10.3 First Enhancement (Recommended)
- [x] Basic gamification elements
- [x] Simple achievements
- [x] Optional account creation
- [x] Basic social features
- [x] Improved data visualizations
- [x] Enhanced feedback specificity

### 10.4 Full Feature Set (Optional)
- [x] Advanced gamification systems
- [x] Comprehensive social features
- [x] External platform integration
- [x] Rich notification system
- [x] Expanded privacy controls
- [x] Advanced analysis algorithms

## 11. Implementation Checklist

### 11.1 Critical Path Items
- [x] OBD2 connection library completion
- [x] Core data collection service
- [x] Basic UI implementation
- [x] Local storage architecture
- [x] Trip recording and analysis
- [x] Eco-score algorithm
- [x] Split-screen compatibility

### 11.2 Technical Risks
- [x] Battery consumption in background mode
- [x] OBD2 adapter compatibility variations
- [x] Background execution limitations
- [x] GPS accuracy in urban environments
- [x] Cross-platform consistency
- [x] Privacy compliance verification

### 11.3 Testing Requirements
- [x] OBD2 adapter compatibility testing
- [x] Background service reliability testing
- [x] Battery consumption benchmarking
- [x] Cross-device UI verification
- [x] Data accuracy verification
- [x] Privacy control validation
- [x] User experience testing

## 12. Adherence to Requirements

This implementation guide incorporates all requirements identified in the thesis:

### 12.1 Eco-Driving Research Requirements
- All requirements REQ 1.1 through REQ 1.16 are addressed in relevant sections

### 12.2 Hype and Social Requirements
- All requirements REQ 2.1 through REQ 2.5 are incorporated in the Social Features section

### 12.3 Gamification Requirements
- All requirements REQ 3.1 through REQ 3.13 are implemented in the Gamification Features section

### 12.4 Seamless Integration Requirements
- All requirements REQ 4.1 through REQ 4.13 are addressed in the Technical Architecture and Core Functionalities sections

### 12.5 Privacy Design Requirements
- All requirements REQ 5.1 through REQ 5.6 are implemented in the Privacy Controls and Data Storage Architecture sections

## 13. Implementation Notes

1. **Development Priority**: Focus on core driving detection and feedback first, as this provides immediate value while requiring minimal user commitment.

2. **Incremental Rollout**: Implement features in order of priority (Mandatory → Recommended → Optional) to enable early testing and feedback.

3. **Technical Debt Avoidance**: Pay particular attention to background service implementation and battery optimization from the beginning, as these are difficult to retrofit later.

4. **Privacy Foundation**: Establish the offline-first architecture early to ensure privacy principles are embedded throughout development.

5. **User Testing Focus**: Prioritize testing of onboarding flow and initial trip experience, as these are critical for user retention.

6. **Accessibility Compliance**: Ensure the app meets accessibility standards from the initial implementation to avoid costly retrofitting.

7. **Performance Monitoring**: Implement analytics to monitor battery usage, crash rates, and feature engagement to guide optimization efforts.

################################################################################
FILE: AppUxUiGuide.md
################################################################################

# Going50: Comprehensive UI/UX Specification

## 1. Introduction & Design Philosophy

Going50 is an eco-driving application designed to promote sustainable driving behaviors through real-time feedback, gamification, and social features. The app is built around a core design philosophy that emphasizes:

- **Minimalist & Intuitive Design**: Clean interfaces with focused content and clear visual hierarchies
- **Progressive Disclosure**: Information presented in layers, starting with core functionality
- **Glanceability**: During driving, information presented in highly scannable formats
- **Visual-First Communication**: Complex data presented through intuitive visualizations
- **Frictionless Adoption**: Core functionality available immediately without barriers
- **Safety-Conscious Interface**: Distraction minimized during active driving
- **Privacy-Centric Experience**: User control over data with transparent policies

### 1.1 Design System Core Principles

1. **Typography**
   - Primary font: SF Pro (iOS) / Roboto (Android) for system consistency
   - Limited to 5 text styles: heading (18pt), subheading (16pt), body (14pt), caption (12pt), small (10pt)
   - Bold weight for emphasis only, avoiding multiple weights
   - Left alignment for all text for consistency and readability

2. **Color Palette**
   - Primary brand color: #00A67E (teal green)
   - Secondary color: #4C9BE8 (blue)
   - Neutral palette: #F7F7F7, #E8E8E8, #C5C5C5, #8E8E8E, #363636
   - Semantic colors:
     - Success: #4CAF50 (green)
     - Warning: #FF9800 (orange)
     - Error: #F44336 (red)
     - Inactive: #9E9E9E (gray)
   - All color combinations must meet WCAG AA accessibility standards (4.5:1 contrast ratio)

3. **Spacing**
   - Base unit: 8dp
   - Spacing scale: 8, 16, 24, 32, 48, 64
   - Content padding: 16dp horizontal, variable vertical
   - Element spacing: minimum 8dp between elements

4. **Interactive Elements**
   - Touch targets: minimum 44×44dp
   - Button states: normal, pressed, disabled
   - Primary buttons: filled with brand color
   - Secondary buttons: outlined or transparent
   - Haptic feedback on all interactive elements

## 2. User Personas

The app is designed with four primary user personas in mind:

### 2.1 Eco-Conscious Emma
- **Demographics**: 28, urban professional, environmentally conscious
- **Goals**: Reduce personal carbon footprint, participate in sustainability initiatives
- **Motivations**: Environmental impact, community building
- **Pain Points**: Balancing environmental concerns with daily needs
- **App Usage Pattern**: Regular, engaged with environmental metrics

### 2.2 Budget-Minded Brian
- **Demographics**: 35, suburban commuter, family-oriented
- **Goals**: Reduce fuel costs, optimize vehicle efficiency
- **Motivations**: Financial savings, practical benefits
- **Pain Points**: Long commute, rising fuel prices
- **App Usage Pattern**: Goal-oriented, focused on savings metrics

### 2.3 Competitive Carlos
- **Demographics**: 24, tech-savvy, enjoys gamification
- **Goals**: Compete with friends, earn achievements, improve skills
- **Motivations**: Social recognition, achievement, mastery
- **Pain Points**: Needs external motivation to maintain interest
- **App Usage Pattern**: Frequent, driven by challenges and social comparison

### 2.4 Practical Paula
- **Demographics**: 45, ride-sharing driver, pragmatic
- **Goals**: Improve driving efficiency, enhance professional profile
- **Motivations**: Professional development, customer satisfaction
- **Pain Points**: Balancing passenger experience with efficient driving
- **App Usage Pattern**: Professional tool, integration with work platforms

## 3. Application Structure

### 3.1 Primary Navigation

The application employs a tab-based primary navigation structure with four main sections:

```
Primary Navigation (Persistent Bottom Tabs)
├── Drive Tab
├── Insights Tab
├── Community Tab
└── Profile Tab
```

#### Navigation Rules:
- Bottom tabs remain visible across the application except during Active Driving mode
- Current tab is indicated with filled icon and label in primary color
- Inactive tabs shown in neutral gray
- No more than 4 primary tabs to ensure clarity and touch target size
- Tab bar height: 56dp with 8dp top/bottom padding

### 3.2 Secondary Navigation

Secondary navigation patterns vary by section:

1. **Drive Tab**: Modal screens for connection setup, trip recording, and post-trip analysis
2. **Insights Tab**: Hierarchical drill-down for historical data and detailed analytics
3. **Community Tab**: Tab-within-tab for different social views (leaderboards, challenges, friends)
4. **Profile Tab**: List-based navigation to settings and user information screens

### 3.3 Modal Layers

The application uses a consistent approach to modal presentations:

1. **Full-Screen Modals**: Trip recording, onboarding, detailed settings
2. **Partial Overlays**: Quick settings, confirmations, connection management
3. **Bottom Sheets**: Contextual actions, filters, selection interfaces
4. **Dialogs**: Confirmations, alerts, permission requests

#### Modal Design Rules:
- Full-screen modals include standard back/close navigation
- Bottom sheets have visible drag handle and dismiss on background tap
- Dialogs center on screen with prominent action buttons
- Maximum two stacked modal layers to prevent confusion

## 4. Core User Flows

### 4.1 First-Time User Flow

1. **App Install → App Launch**
   - System splash screen (1000ms) → Welcome screen

2. **Onboarding Experience**
   - Welcome screen with app value proposition and "Get Started" button
   - Value carousel (3 screens max):
     - Screen 1: Financial benefits (with statistics visualization)
     - Screen 2: Environmental impact (with visual metaphor)
     - Screen 3: Social/gamification elements
   - Skip option available on all screens
   - "Continue without account" or "Create account" choice presented
   - No data collection/permissions requested yet

3. **Connection Setup (Optional)**
   - OBD2 vs. phone-only choice
   - If OBD2 selected:
     - Bluetooth permission request with contextual explanation
     - Device scanning interface
     - Connection setup guide
   - If phone-only selected:
     - Proceed directly to Home screen
     - Notification about limited accuracy with upgrade path

4. **Home Screen Orientation**
   - Guided tooltip highlighting Drive tab features
   - Animated prompt to start first trip
   - Checklist of setup steps (optional account, optional OBD2)

### 4.2 Trip Recording Flow

1. **Pre-Trip Setup**
   - Drive tab → Start Trip button
   - Connection status verification
   - Permission requests if not already granted:
     - Location permission with contextual explanation
     - Motion & fitness activity permission (if needed)
     - Background processing permission
   - Optional pre-drive checklist

2. **Active Driving Mode**
   - Transition to distraction-minimized interface
   - Live eco-score with simple visual indicator
   - Current speed with efficiency indicator
   - Minimal event notifications for significant behaviors
   - Background operation if user switches apps
   - End Trip button prominent at bottom

3. **Post-Trip Analysis**
   - Trip summary screen appears automatically
   - Overall eco-score with visual rating
   - Key metrics animation (fuel saved, CO₂ reduced, money saved)
   - Behavior breakdown with improvement areas
   - Primary "Done" button and secondary "See Details" option
   - Share button for social posting

### 4.3 Insights Exploration Flow

1. **Overview Review**
   - Insights tab → Dashboard view
   - Period selector (week/month/year)
   - Eco-score trend visualization
   - Savings metrics with projection
   - Behavior breakdown chart

2. **Historical Analysis**
   - Trip history list with search/filter options
   - Trip selection → Detailed trip view
   - Map visualization (if location permitted)
   - Timeline of events
   - Comparative metrics against averages

3. **Skill Development**
   - Skill breakdown section
   - Skill selection → Skill detail page
   - Learning tips and techniques
   - Progress tracking over time
   - Suggested challenges to improve

### 4.4 Social Engagement Flow

1. **Community Discovery**
   - Community tab → Leaderboard view
   - View segmentation (Friends/Local/Global)
   - User position highlighted
   - Challenges section with active and available challenges
   - Friend activity feed

2. **Challenge Participation**
   - Challenge selection → Detail view
   - Join button → Confirmation
   - Progress tracking during drives
   - Completion celebration
   - Results sharing

3. **Social Connection**
   - Find Friends feature
   - Friend requests/confirmation flow
   - Privacy-aware profile viewing
   - Activity feed interaction (likes, comments)
   - Achievement sharing

### 4.5 Privacy Management Flow

1. **Privacy Controls Access**
   - Profile tab → Settings → Privacy
   - Data collection visualization
   - Granular permission toggles
   - Data management options

2. **Data Review and Export**
   - Data listing by category
   - Selection interface for export/deletion
   - Confirmation dialogs for destructive actions
   - Export format options
   - Completion confirmation

## 5. Screen-by-Screen Specifications

### 5.1 Onboarding Screens

#### 5.1.1 Welcome Screen

**Purpose**: Initial introduction to the app's value proposition

**UI Components**:
- Full-screen background with subtle eco-driving imagery
- App logo (centered, top 20% of screen)
- Tagline: "Drive smarter, save more" (centered below logo)
- Brief value proposition text (2-3 lines maximum)
- Primary CTA: "Get Started" button (fixed at bottom)
- Secondary CTA: "Already have an account? Log in" (below primary CTA)

**Behaviors**:
- Primary CTA transitions to value carousel
- Secondary CTA transitions to login screen
- No back navigation (first screen)

**States**:
- Default state only

**Accessibility**:
- All text readable with screen readers
- Primary CTA has high contrast for visibility

#### 5.1.2 Value Carousel

**Purpose**: Communicate core app benefits through visual storytelling

**UI Components**:
- Pager with maximum 3 screens
- Visual illustration (top 50% of screen)
- Headline for each benefit (centered below illustration)
- Brief description text (1-2 lines)
- Page indicator (bottom 20% of screen)
- "Skip" button (top right corner)
- "Next" button (bottom right, final screen shows "Get Started")

**Behaviors**:
- Horizontal swipe navigation between pages
- "Next" progresses to next screen
- "Skip" jumps to account choice screen
- Final screen "Get Started" proceeds to account choice

**States**:
- One state per value screen (3 total)

**Accessibility**:
- Swipe gestures supplemented with button controls
- Meaningful descriptions for all illustrations

#### 5.1.3 Account Choice Screen

**Purpose**: Allow users to decide on account creation without blocking usage

**UI Components**:
- App logo (small, top center)
- Question headline: "How would you like to continue?"
- Option card: "Quick Start" with bullet points on limitations
- Option card: "Create Account" with bullet points on benefits
- "Continue" button (fixed at bottom)

**Behaviors**:
- Option selection highlights card with visual indicator
- "Continue" activates based on selection
- "Quick Start" generates anonymous user ID and proceeds to connection choice
- "Create Account" proceeds to account creation flow

**States**:
- Default state (no selection)
- Quick Start selected
- Create Account selected

**Accessibility**:
- Cards must be selectable via screen reader
- Selection state clearly announced

#### 5.1.4 OBD Connection Choice Screen

**Purpose**: Explain connection options and guide setup if desired

**UI Components**:
- Headline: "Choose your setup"
- Option card: "Phone only" with bullet points on capabilities
- Option card: "Connect OBD adapter" with bullet points on enhanced features
- Illustration showing both options
- "Continue" button (fixed at bottom)
- "What's an OBD adapter?" help link

**Behaviors**:
- Option selection highlights card with visual indicator
- "Continue" activates based on selection
- "Phone only" proceeds directly to Drive tab
- "Connect OBD adapter" proceeds to connection setup flow
- Help link opens modal explanation dialog

**States**:
- Default state (no selection)
- Phone only selected
- OBD adapter selected

**Accessibility**:
- Cards must be selectable via screen reader
- Help content accessible without visual dependency

### 5.2 Drive Tab Screens

#### 5.2.1 Drive Home Screen

**Purpose**: Primary entry point for starting trips and accessing core functionality

**UI Components**:
- Status section (top 30%)
  - Connection status pill (OBD/Phone with icon)
  - Latest eco-score with circular visual indicator
  - Quick status message ("Ready to drive" or "Connect device")
  
- Action section (middle 40%)
  - Large "Start Trip" button (circular, 80dp diameter)
  - Device connection shortcut (if not connected)
  - Audio feedback toggle with icon
  
- Quick Stats section (bottom 30%)
  - Recent trip card with:
    - Date/time and distance
    - Eco-score badge
    - Money/CO₂ saved metrics
  - Week's average score pill
  - Subtle "Pull for more" indicator

**Behaviors**:
- "Start Trip" initiates pre-trip verification then trip recording
- Connection status updates in real-time
- Audio toggle persists setting across app
- Recent trip card tappable to view details
- Pull-down gesture reveals weekly summary stats
- First-time user sees onboarding hint card instead of recent trip

**States**:
- Connected (OBD): Full functionality
- Connected (Phone only): Limited functionality indicator
- Not connected: Connection prompt
- First use: Tutorial overlay

**Accessibility**:
- All interactive elements have appropriate labels
- Status information conveyed via screen reader
- Color not sole indicator of connection status

#### 5.2.2 Active Drive Screen

**Purpose**: Provide real-time feedback during driving with minimal distraction

**UI Components**:
- Eco-score section (top 60%)
  - Large eco-score number (128pt)
  - Color-coded background (green/yellow/red)
  - Simple efficiency indicator (arrow up/down or neutral)
  
- Current metrics strip (middle)
  - Current speed with unit
  - Efficiency indicator for current speed
  
- Control bar (bottom)
  - End Trip button (prominent, with confirmation)
  - Audio toggle icon button
  - Minimize button (for split-screen)
  
- Event notification area (overlay)
  - Transient cards for driving events
  - Icon-based with minimal text
  - Color-coded by event type

**Behaviors**:
- Screen remains on during recording
- Brightness adjusts to ambient light
- Event cards appear for 3 seconds then fade
- Background recording continues if user switches apps
- Shake device to report issue or flag false detection
- Double tap to toggle between detailed/simple view

**States**:
- Normal driving state
- Event detection state (with notification)
- Background recording state (minimized view)
- Split-screen state (compact layout)

**Accessibility**:
- Voice feedback option for events
- High contrast mode available
- Large text mode supported

#### 5.2.3 Post-Trip Summary Screen

**Purpose**: Provide immediate feedback after trip completion

**UI Components**:
- Trip overview header
  - Overall eco-score with visual rating (A-F or 0-100)
  - Trip distance and duration
  - Date and time stamps
  
- Savings metrics section
  - Fuel saved (with visual comparison)
  - CO₂ reduced (with tree equivalent)
  - Money saved (in local currency)
  
- Behavior breakdown
  - Circular chart with four segments:
    - Acceleration behavior
    - Braking behavior
    - Speed management
    - Idling time
  - Color-coded segments (red, yellow, green)
  
- Action section
  - Primary improvement suggestion card
  - "Share Results" button with social icons
  - "See More Details" button
  - "Done" button (returns to Drive tab)

**Behaviors**:
- Appears automatically after trip completion
- Metrics animate in sequence (1.5s total)
- Tapping behavior chart segments shows specific feedback
- "Share" creates branded image with key stats
- "See More" navigates to detailed trip view
- "Done" dismisses to Drive tab

**States**:
- Initial load (with animations)
- Fully loaded (static display)
- Sharing active (with platform selection)

**Accessibility**:
- Animation can be disabled in accessibility settings
- All metrics available to screen readers
- Color-coding supplemented with patterns

### 5.3 Insights Tab Screens

#### 5.3.1 Insights Dashboard Screen

**Purpose**: Provide overview of driving performance and trends

**UI Components**:
- Time period selector (top)
  - Segmented control (Week/Month/Year)
  - Optional date range selector
  
- Eco-score trend chart
  - Line chart with color-coded zones
  - Average line indicator
  - Tap points for daily details
  
- Savings summary cards
  - Financial savings card with:
    - Period total with currency
    - Comparison to previous period
    - Projection for coming period
  - Environmental impact card with:
    - CO₂ reduction in kg
    - Equivalent in trees/carbon offset
    - Visual comparison to previous period
  
- Driving behaviors section
  - Radar chart with four metrics:
    - Acceleration
    - Braking
    - Speed
    - Idling
  - Current vs. ideal overlay
  - Improvement direction indicators
  
- Recent trips section
  - Scrollable list of recent trips
  - Each with date, score, distance
  - "View All" button

**Behaviors**:
- Period selection updates all visualizations
- Charts animate on tab selection (once only)
- Tapping chart elements shows detailed tooltips
- Pull-to-refresh updates all data
- Trip items navigate to trip detail

**States**:
- Loading state with skeletons
- Loaded state with data
- Empty state (no trips yet)
- Error state with retry

**Accessibility**:
- Charts include alternative text descriptions
- Numeric data available alongside visualizations
- High contrast mode for all charts

#### 5.3.2 Trip History Screen

**Purpose**: Browse and search past trips

**UI Components**:
- Search and filter bar (top)
  - Search field with icon
  - Filter button opening filter sheet
  
- Sorting controls
  - Sort by dropdown (Date, Score, Distance)
  - Order toggle (Ascending/Descending)
  
- Trip list
  - Date header groups
  - Trip cards with:
    - Start/end locations (if permitted)
    - Time and distance
    - Eco-score badge
    - Key event indicators
  
- Filter sheet (modal)
  - Date range picker
  - Score range slider
  - Distance range slider
  - Event type checkboxes
  - Apply/Reset buttons

**Behaviors**:
- List supports infinite scroll with lazy loading
- Search filters in real-time
- Filter sheet slides up from bottom
- Tapping trip navigates to detail view
- Pull-to-refresh updates list

**States**:
- Default view (chronological)
- Filtered view
- Search results view
- Empty results view

**Accessibility**:
- Filter controls operable via screen reader
- Search results announced
- Sufficient tap targets on all interactive elements

#### 5.3.3 Trip Detail Screen

**Purpose**: Provide comprehensive analysis of an individual trip

**UI Components**:
- Trip header
  - Date and time
  - Start/end locations (if permitted)
  - Distance and duration
  - Overall eco-score
  
- Map section (if location permitted)
  - Route visualization
  - Event markers (color-coded)
  - Start/end pins
  - Heatmap toggle for efficiency
  
- Metrics section
  - Tabbed interface for different metric groups:
    - Efficiency (fuel, cost, emissions)
    - Behavior (acceleration, braking, idling)
    - Context (traffic, weather, terrain)
  - Comparative indicators against personal average
  
- Timeline section
  - Chronological event list
  - Timestamps and event descriptions
  - Severity indicators
  - Tappable for details
  
- Recommendation section
  - Personalized improvement tips
  - Skill focus suggestion
  - Related challenge recommendations

**Behaviors**:
- Map supports pan/zoom
- Timeline scrolls independently
- Tab selection changes metrics display
- Tapping event on map highlights in timeline and vice versa
- Share button creates trip report

**States**:
- Map view (default)
- No location data view (privacy option)
- Loading state
- Error state with fallback

**Accessibility**:
- Alternative to map visualization provided
- Events described textually
- Interactive elements properly labeled

### 5.4 Community Tab Screens

#### 5.4.1 Community Hub Screen

**Purpose**: Central access point for social features

**UI Components**:
- Section tabs (top)
  - Leaderboards
  - Challenges
  - Friends
  
- Leaderboard view
  - Segmented control (Friends/Local/Global)
  - User ranking with position highlight
  - Top performers list with:
    - Position number
    - Avatar and name
    - Score
    - Trend indicator
  - Time period selector (Week/Month/All-time)
  
- Challenges view
  - Active challenges cards with:
    - Challenge title and icon
    - Progress indicator
    - Time remaining
    - Participant count
  - Available challenges section
  - Completed challenges section
  
- Friends view
  - Friend search bar
  - Friend list with:
    - Avatar and name
    - Latest achievement
    - Add friend button for non-connections
  - Activity feed with recent achievements
  - Invitation management section

**Behaviors**:
- Tab selection changes main view
- Leaderboard refreshes automatically when visible
- Challenge cards update progress in real-time
- Pull-to-refresh updates content
- Friend profiles accessible via tap

**States**:
- Each tab view (3 states)
- Empty states for each section
- Loading states with skeletons
- First-use state with tutorial overlay

**Accessibility**:
- Tab selection accessible via screen reader
- Leaderboard positions verbally described
- Friend avatars have alternative text

#### 5.4.2 Challenge Detail Screen

**Purpose**: Display information about specific challenges and track progress

**UI Components**:
- Challenge header
  - Title and icon
  - Description text
  - Duration and participant count
  - Join/Leave button
  
- Progress section
  - Visual progress bar or circular indicator
  - Current status text
  - Target description
  - Countdown timer if time-limited
  
- Leaderboard section
  - Top participants list
  - User's current position
  - Score/progress metrics
  
- Reward section
  - Badge icon preview
  - Reward description
  - Previous winners gallery (if recurring)

**Behaviors**:
- Join/Leave toggles participation status
- Progress updates after qualifying trips
- Completion triggers celebration animation
- Pull-to-refresh updates leaderboard
- Share button for challenge invitation

**States**:
- Not joined state
- Joined/in-progress state
- Completed state
- Expired state

**Accessibility**:
- Progress information clearly conveyed
- Interactive elements properly labeled
- Animations can be disabled

#### 5.4.3 Friend Profile Screen

**Purpose**: View another user's eco-driving profile

**UI Components**:
- Profile header
  - Avatar and name
  - Overall eco-driver level
  - Member since date
  - Connection status button
  
- Achievement showcase
  - Grid of earned badges
  - Special achievement highlights
  - Progress on current challenges
  
- Statistics summary
  - Privacy-respectful metrics
  - Comparison to your stats (where permitted)
  - Recent activity timeline
  
- Interaction section
  - Challenge invitation button
  - Message button (if platform supports)
  - Report button (hidden in overflow menu)

**Behaviors**:
- Content limited by user's privacy settings
- Compare button toggles comparative view
- Challenge button initiates invitation flow
- Back navigation returns to previous screen

**States**:
- Friend state (full access)
- Non-connection state (limited view)
- Blocked state (no access)

**Accessibility**:
- All interactive elements accessible
- Privacy limitations clearly communicated
- Sufficient contrast for all elements

### 5.5 Profile Tab Screens

#### 5.5.1 Profile Screen

**Purpose**: Display personal achievements and provide access to settings

**UI Components**:
- Profile header
  - Avatar and name (or anonymous indicator)
  - Overall eco-driver level with progress bar
  - Total impact statistics (lifetime)
  - Edit button (account users only)
  
- Achievements section
  - Grid of earned badges (3×3 visible)
  - Progress indicators for badges in progress
  - "See All" button for complete view
  
- Statistics summary
  - Key lifetime metrics with icons:
    - Total trips
    - Distance driven
    - Fuel saved
    - Money saved
    - CO₂ reduced
  - Personal records section
  
- Action section
  - Settings button
  - Profile sharing button
  - Account management (or "Create Account")
  - Help & Support button

**Behaviors**:
- Anonymous users see "Create Account" option
- Badges animate briefly on first view
- Settings opens full settings screen
- Profile sharing generates sharable link/image
- Pull-to-refresh updates statistics

**States**:
- Account user state
- Anonymous user state
- First-use state (no achievements)

**Accessibility**:
- Badge grid navigable via screen reader
- Statistics available as text descriptions
- All buttons properly labeled

#### 5.5.2 Settings Screen

**Purpose**: Provide access to all app configuration options

**UI Components**:
- Settings list (grouped sections)
  
  - Account section (if signed in)
    - Profile information item
    - Password/authentication item
    - Linked accounts item
    - Delete account item
  
  - Privacy section
    - Data collection toggles item
    - Social visibility item
    - Data management item
    - Privacy policy item
  
  - Device section
    - OBD connection management item
    - Sensor calibration item
    - Background operation item
  
  - Preferences section
    - Notification settings item
    - Display preferences item
    - Audio feedback item
    - Measurement units item
    - Currency selection item
  
  - About section
    - App version item
    - Terms of service item
    - Open source licenses item
    - Send feedback item

**Behaviors**:
- List items navigate to detailed settings screens
- Toggles change state immediately
- Immediate settings changes show confirmation
- Back navigation returns to Profile tab

**States**:
- Signed in state (all options)
- Anonymous state (limited options)

**Accessibility**:
- All toggles operable via screen reader
- Grouping headers properly labeled
- Navigation hierarchy maintained

#### 5.5.3 Privacy Settings Screen

**Purpose**: Control data collection and sharing preferences

**UI Components**:
- Data collection visualization
  - Visual representation of data types
  - Collection status indicators
  - Privacy score summary
  
- Collection toggles section
  - Trip recording toggle
  - Location tracking toggle
  - Driving behavior toggle
  - App usage analytics toggle
  
- Sharing controls section
  - Leaderboard participation toggle
  - Social visibility toggle
  - Anonymous analytics contribution toggle
  
- Data management section
  - Export data button
  - Delete all data button
  - Retention policy information
  
- Privacy policy link
  - Brief summary of key points
  - Link to full policy

**Behaviors**:
- Toggles update visualization in real-time
- Export initiates data packaging process
- Delete requires confirmation dialog
- Changes saved automatically

**States**:
- Default state
- Privacy-focused state (minimal collection)
- Export in progress state
- Deletion confirmation state

**Accessibility**:
- Toggle state clearly announced
- Visualization has alternative text
- Confirmation dialogs fully accessible

## 6. Component Library

### 6.1 Navigation Components

#### 6.1.1 Tab Bar
- Height: 56dp
- Active tab: Icon (filled) + label in primary color
- Inactive tab: Icon (outlined) + label in neutral gray
- Background: White with subtle top shadow
- Behavior: Tapping switches tabs immediately

#### 6.1.2 App Bar
- Height: 56dp
- Title: Centered for key screens, left-aligned for sub-screens
- Back button: Left side when navigating in hierarchy
- Action buttons: Right side, maximum 2 visible
- Overflow menu: When more than 2 actions
- Background: White or translucent based on context

#### 6.1.3 Navigation Drawer (Optional)
- Width: 80% of screen width, maximum 300dp
- Header: User info or app logo
- Menu items: Icon + label
- Footer: Settings, help, about items
- Behavior: Swipe from left edge or hamburger icon

### 6.2 Input Components

#### 6.2.1 Primary Button
- Height: 48dp
- Horizontal padding: 24dp
- Background: Primary color (#00A67E)
- Text: White, 16sp, medium weight
- Corner radius: 24dp
- States: Normal, Pressed, Disabled
- Behavior: Ripple effect on press

#### 6.2.2 Secondary Button
- Height: 48dp
- Horizontal padding: 24dp
- Background: Transparent
- Border: 1dp primary color
- Text: Primary color, 16sp, medium weight
- Corner radius: 24dp
- States: Normal, Pressed, Disabled
- Behavior: Ripple effect on press

#### 6.2.3 Text Input
- Height: 56dp
- Padding: 16dp horizontal
- Label: Floating or fixed
- Helper text: Below input, 12sp
- Error state: Red border and text
- Validation: Real-time where appropriate
- Behavior: Clear button appears when text entered

#### 6.2.4 Toggle Switch
- Height: 24dp
- Width: 44dp
- Track: Gray when off, primary color when on
- Thumb: White circle with shadow
- Animation: Smooth transition on state change
- Behavior: Tap or slide to toggle

### 6.3 Card Components

#### 6.3.1 Info Card
- Padding: 16dp
- Corner radius: 8dp
- Elevation: 1dp
- Title: 16sp, medium weight
- Content: 14sp, regular weight
- Optional icon or illustration
- Background: White
- Behavior: Can be tappable or static

#### 6.3.2 Stats Card
- Padding: 16dp
- Corner radius: 8dp
- Elevation: 1dp
- Headline figure: 24sp, bold
- Label: 12sp, regular
- Comparison indicator (optional)
- Behavior: Tap for more details

#### 6.3.3 Achievement Card
- Size: 80dp × 80dp
- Corner radius: 8dp
- Badge icon: Centered, 48dp
- Level indicator: Top right corner
- Locked state: Grayscale with overlay
- Behavior: Tap for achievement details

### 6.4 Feedback Components

#### 6.4.1 Snackbar
- Height: 48dp
- Padding: 16dp horizontal
- Background: Dark gray (#363636)
- Text: White, 14sp
- Action button: Text only, accent color
- Duration: 4 seconds or until dismissed
- Position: Bottom of screen, above tab bar

#### 6.4.2 Toast
- Padding: 8dp horizontal, 16dp vertical
- Background: Semi-transparent dark gray
- Text: White, 14sp
- Corner radius: 4dp
- Duration: 2 seconds
- Position: Center of screen

#### 6.4.3 Dialog
- Width: 80% of screen width, maximum 300dp
- Padding: 24dp
- Title: 18sp, medium weight
- Content: 16sp, regular weight
- Buttons: Right-aligned, text only
- Background: White
- Elevation: 8dp
- Behavior: Modal, blocks interaction with underlying UI

### 6.5 Visualization Components

#### 6.5.1 Eco-Score Gauge
- Size: Variable based on context
- Scale: 0-100
- Color gradient: Red (0) → Yellow (50) → Green (100)
- Current value: Large number in center
- Background: Circular track showing full scale
- Behavior: Animates to new value over 1 second

#### 6.5.2 Progress Bar
- Height: 8dp
- Corner radius: 4dp
- Track: Light gray
- Indicator: Primary color
- Label: Optional percentage or value
- Behavior: Animates progress changes

#### 6.5.3 Charts
- Line chart: For trends over time
- Bar chart: For comparative metrics
- Radar chart: For skill assessment
- Pie/Donut chart: For proportion visualization
- All charts include:
  - Axis labels where appropriate
  - Legend for multiple data series
  - Touch interaction for data points
  - Empty state handling

## 7. Transition & Animation Specifications

### 7.1 Screen Transitions

#### 7.1.1 Tab Switching
- Type: Cross-fade
- Duration: 200ms
- Easing: Standard easing
- Element transitions: Staggered by 50ms

#### 7.1.2 Hierarchical Navigation
- Type: Slide from right (forward), slide to right (back)
- Duration: 300ms
- Easing: Decelerate (forward), accelerate (back)
- Elevation change: Subtle shadow adjustment

#### 7.1.3 Modal Presentation
- Type: Slide up from bottom
- Duration: 250ms
- Easing: Decelerate
- Background: Fade overlay to 50% opacity
- Dismissal: Reverse of presentation

### 7.2 Component Animations

#### 7.2.1 Button Feedback
- Press: Scale to 95% with 40ms duration
- Release: Return to 100% with 100ms duration
- Ripple: Radial effect from touch point
- Disabled transition: 150ms fade to disabled state

#### 7.2.2 Toggle Switches
- Duration: 150ms
- Easing: Standard
- Thumb: Slides with slight bounce at end
- Track: Color transition

#### 7.2.3 Loaders
- Spinner: Continuous rotation, 1000ms per cycle
- Progress bar: Linear animation at appropriate speed
- Skeleton screens: Pulse effect (1000ms cycle)

### 7.3 Feedback Animations

#### 7.3.1 Success Feedback
- Icon: Check mark with scale-up (300ms)
- Color: Green flash transition
- Optional confetti effect for major achievements

#### 7.3.2 Error Feedback
- Icon: Alert with subtle shake (300ms)
- Color: Red flash transition
- Input fields: Validation shake if applicable

#### 7.3.3 Driving Event Feedback
- Cards: Fade in (200ms), hold (2800ms), fade out (300ms)
- Position: Slide in from appropriate edge
- Stacking: Maximum 2 visible events, queue others

## 8. Responsiveness & Adaptability

### 8.1 Device Adaptation

#### 8.1.1 Phone Sizes
- Small (< 360dp width):
  - Compact layouts
  - Scrolling for content that doesn't fit
  - Reduced padding (8dp instead of 16dp)
  
- Medium (360-400dp width):
  - Standard layouts
  - Regular padding (16dp)
  
- Large (> 400dp width):
  - Expanded layouts where appropriate
  - Additional content in some views
  - Maintained padding (16dp)

#### 8.1.2 Tablet Support (Optional)
- Multi-column layouts
- Side-by-side panels for master-detail views
- Expanded visualizations
- Maintained touch target sizes

### 8.2 Orientation Handling

#### 8.2.1 Portrait Mode
- Primary orientation for all screens
- Optimized layouts for vertical scrolling
- Full-height modal sheets

#### 8.2.2 Landscape Mode
- Support for Drive screen for dashboard mounting
- Adjusted layouts to minimize vertical scrolling
- Tab bar remains at bottom
- Modal sheets convert to side panels where appropriate

### 8.3 Split-Screen Support

#### 8.3.1 Focus Drive View
- Compressed for side-by-side use with navigation apps
- Large eco-score display maintained
- Controls positioned for easy access
- Background color coding for quick status recognition

#### 8.3.2 Adaptive UI Scaling
- Dynamic text sizing based on available width
- Priority content maintained
- Secondary content collapsed or hidden
- Touch targets maintained at minimum 48×48dp

## 9. Accessibility Guidelines

### 9.1 Visual Accessibility

#### 9.1.1 Text Legibility
- Minimum text size: 12sp
- All text scalable to 200%
- No fixed-size text containers
- Sufficient contrast ratios (4.5:1 minimum)

#### 9.1.2 Color Independence
- No information conveyed by color alone
- Patterns or icons supplement color coding
- Support for high contrast mode
- Color-blind friendly palette

#### 9.1.3 Touch Targets
- Minimum size: 48×48dp
- Minimum spacing: 8dp
- Feedback on all interactive elements
- No floating gesture-only interactions

### 9.2 Screen Reader Support

#### 9.2.1 Semantic Structure
- Proper heading hierarchy
- Meaningful content grouping
- Logical navigation order
- No unlabeled interactive elements

#### 9.2.2 Custom Components
- Accessibility roles assigned appropriately
- State changes announced
- Custom actions properly described
- Complex components with descriptive summaries

#### 9.2.3 Images and Visualizations
- All non-decorative images have descriptions
- Charts include summary of key data points
- Maps have textual route descriptions
- Icons have meaningful labels

### 9.3 Cognitive Accessibility

#### 9.3.1 Simplified Options
- Progressive disclosure of advanced features
- Clear, consistent navigation
- Predictable interface behavior
- Limited cognitive load during driving

#### 9.3.2 Error Prevention
- Confirmation for destructive actions
- Clear error messages with recovery paths
- Undo functionality where appropriate
- Form validation with helpful guidance

#### 9.3.3 Memory Minimization
- No complex gesture memorization required
- Visible navigation and actions
- Consistent patterns throughout app
- Helpful tooltips for less common features

## 10. Implementation Guidelines for Developers

### 10.1 Flutter Implementation

#### 10.1.1 Widget Architecture
- Composition over inheritance
- Stateless widgets for presentation
- Stateful widgets only when necessary
- Provider pattern for state management
- Clean separation of UI and business logic

#### 10.1.2 Responsive Approach
- Use MediaQuery for screen-aware layouts
- Implement LayoutBuilder for adaptive components
- Avoid fixed pixel dimensions
- Use flexible layouts (Expanded, Flexible)
- Test on multiple device sizes

#### 10.1.3 Component Implementation
- Build reusable components based on design system
- Create theme extension for custom styles
- Implement accessibility properties for all widgets
- Add proper documentation for component usage

### 10.2 Performance Considerations

#### 10.2.1 Rendering Optimization
- Minimize widget rebuilds
- Use const constructors where possible
- Implement caching for expensive computations
- Optimize image assets for mobile
- Virtualize long lists with ListView.builder

#### 10.2.2 Animation Performance
- Use implicit animations where possible
- Hardware acceleration for complex animations
- Stagger animations to distribute load
- Reduce animation complexity on low-end devices
- Test animation FPS on target devices

#### 10.2.3 Background Operation
- Minimize battery usage in background
- Throttle sensor reading frequency
- Batch updates to reduce wake cycles
- Adaptive sampling based on activity detection
- Handle app suspension and resumption gracefully

### 10.3 Testing Requirements

#### 10.3.1 UI Testing
- Widget tests for all reusable components
- Golden tests for visual regression
- Integration tests for key user flows
- Accessibility scanner validation
- A11y tests with TalkBack/VoiceOver

#### 10.3.2 Usability Testing
- Test with real users from all personas
- Validate driving mode during actual driving
- Measure cognitive load during interaction
- Verify text legibility in outdoor conditions
- Test with multiple device sizes and orientations

#### 10.3.3 Performance Testing
- Startup time measurement
- Frame rate monitoring during animations
- Memory usage profiling
- Battery consumption in various modes
- Background processing efficiency

## 11. Feature Implementation Roadmap

### 11.1 MVP Launch (Phase 1)
1. Onboarding experience
2. Drive recording with phone sensors
3. Basic trip summary
4. Simple insights visualization
5. Local data storage
6. No-account functionality
7. Battery-efficient background operation

### 11.2 First Enhancement (Phase 2)
1. OBD connection support
2. Enhanced data visualizations
3. Basic achievements system
4. Account creation option
5. Detailed driving feedback
6. Standard notification system
7. Initial social features (leaderboards)

### 11.3 Complete Feature Set (Phase 3)
1. Challenge system
2. Friend connections
3. Advanced gamification
4. External sharing capabilities
5. Rich notification system
6. Advanced analysis algorithms
7. Split-screen optimization

## 12. Success Metrics & KPIs

The UI/UX design should be evaluated against the following key metrics:

### 12.1 Usability Metrics
- **First-Time User Success Rate**: Percentage of users who complete their first trip
- **Task Completion Time**: Average time to complete key tasks
- **Error Rate**: Frequency of user errors during task completion
- **Navigation Efficiency**: Number of taps to reach key functionality

### 12.2 Engagement Metrics
- **Retention Rate**: Percentage of users returning after 1, 7, 30 days
- **Average Session Length**: Time spent in app per session
- **Trip Recording Frequency**: Average trips recorded per active user
- **Feature Discovery**: Percentage of users engaging with each key feature

### 12.3 Satisfaction Metrics
- **App Store Ratings**: Average star rating
- **Net Promoter Score**: Likelihood to recommend to others
- **Feature Satisfaction**: Ratings for specific features
- **Feedback Sentiment**: Analysis of user feedback content

### 12.4 Performance Metrics
- **Crash-Free Users**: Percentage of users experiencing no crashes
- **App Not Responding (ANR) Rate**: Frequency of ANR events
- **Average Load Time**: Time to interactive for key screens
- **Battery Impact**: Battery usage percentage during background operation

## 13. Appendix

### 13.1 User Research References
- Trip recording behavior patterns from field studies
- Pain points from existing eco-driving apps
- Motivational triggers identified in research

### 13.2 Competitive Analysis
- Feature comparison with similar apps
- UX patterns in driving assistance apps
- Gamification strategies in successful apps

### 13.3 Design Changelog
- Version history of major UI decisions
- Rationale for key design changes
- User testing results influencing design


################################################################################
FILE: analysis_options copy.yaml
################################################################################

# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options


################################################################################
FILE: devtools_options.yaml
################################################################################

description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:
  - drift: true

################################################################################
FILE: pubspec copy.yaml
################################################################################

name: going50
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.7.0

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  path_provider: ^2.1.2  # File path utilities
  intl: ^0.19.0  # Date/time formatting
  logging: ^1.2.0  # Logging
  provider: ^6.1.1  # State management
  flutter_reactive_ble: ^5.3.1  # Alternative BLE implementation

  geolocator: ^11.0.0
  sensors_plus: ^6.0.0
  shared_preferences: ^2.2.2
  permission_handler: ^11.3.0
  battery_plus: ^6.0.0

  # Local Database - Updated to latest versions
  drift: ^2.16.0  # Modern SQLite ORM (formerly moor)
  sqlite3_flutter_libs: ^0.5.20  # SQLite native bindings
  path: ^1.8.3  # File path manipulation
  uuid: ^4.3.3  # For generating unique IDs

  # Cloud Storage - Updated to latest Firebase versions
  firebase_core: ^3.6.0
  firebase_auth: ^5.3.1
  cloud_firestore: ^5.4.4
  
  # Data Export
  csv: ^5.1.1  # For CSV exports
  share_plus: ^7.2.2  # For sharing files
  
  # Secure Storage
  flutter_secure_storage: ^9.0.0 


dev_dependencies:
  flutter_test:
    sdk: flutter

  # For generating drift database code - Updated to match drift version
  drift_dev: ^2.16.0
  build_runner: ^2.4.8

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^5.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package


################################################################################
FILE: pubspec.yaml
################################################################################

name: going50
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.7.0

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  
  # Bluetooth communication for OBD-II
  flutter_reactive_ble: ^5.3.1
  
  # State management
  provider: ^6.1.1
  
  # Local storage
  shared_preferences: ^2.2.2
  path_provider: ^2.1.2
  
  # Format handling
  intl: ^0.19.0
  
  # Database
  drift: ^2.16.0
  sqlite3_flutter_libs: ^0.5.20
  sqlite3: ^2.4.0
  path: ^1.9.0
  
  # Utilities
  uuid: ^4.3.3
  logging: ^1.2.0
  package_info_plus: ^8.3.0
  
  # Permissions
  permission_handler: ^11.3.0
  
  # Dependency injection
  get_it: ^7.6.7
  
  # Firebase dependencies (Updated to latest versions with iOS 13+ support)
  firebase_core: ^3.12.1
  firebase_auth: ^5.4.1
  cloud_firestore: ^5.6.3
  firebase_storage: ^12.4.2
  firebase_messaging: ^15.2.2
  firebase_analytics: ^11.4.1
  firebase_crashlytics: ^4.3.2
  
  # Sensor lib dependencies
  geolocator: ^11.0.0
  sensors_plus: ^4.0.2
  battery_plus: ^5.0.3
  fl_chart: 0.66.2

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^5.0.0
  
  # Code generation
  build_runner: ^2.4.8
  drift_dev: ^2.16.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package


################################################################################
FILE: analysis_options.yaml
################################################################################

# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options


################################################################################
FILE: firebase.json
################################################################################

{"flutter":{"platforms":{"android":{"default":{"projectId":"going50","appId":"1:969096771444:android:418d203ce0b0032b0ede21","fileOutput":"android/app/google-services.json"}},"ios":{"default":{"projectId":"going50","appId":"1:969096771444:ios:889b299f2eabc6620ede21","uploadDebugSymbols":true,"fileOutput":"ios/Runner/GoogleService-Info.plist"}},"dart":{"lib/firebase_options.dart":{"projectId":"going50","configurations":{"android":"1:969096771444:android:418d203ce0b0032b0ede21","ios":"1:969096771444:ios:889b299f2eabc6620ede21"}}}}}}

################################################################################
FILE: test/adapter_config_validator_test.dart
################################################################################

import 'package:flutter_test/flutter_test.dart';
import 'package:going50/obd_lib/models/adapter_config.dart';
import 'package:going50/obd_lib/models/adapter_config_factory.dart';
import 'package:going50/obd_lib/models/adapter_config_validator.dart';

void main() {
  group('AdapterConfigValidator', () {
    late AdapterConfigValidator validator;
    
    setUp(() {
      validator = AdapterConfigValidator();
    });
    
    test('validates premium adapter config correctly', () {
      final config = AdapterConfigFactory.createPremiumElm327Config();
      final result = validator.validateConfig(config);
      
      expect(result['isValid'], isTrue);
      expect(result['issues'], isEmpty);
      expect(result['config'], equals(config));
    });
    
    test('validates cheap adapter config correctly', () {
      final config = AdapterConfigFactory.createCheapElm327Config();
      final result = validator.validateConfig(config);
      
      expect(result['isValid'], isTrue);
      expect(result['issues'], isEmpty);
      expect(result['config'], equals(config));
    });
    
    test('corrects invalid response timeout for premium adapter', () {
      final originalConfig = AdapterConfigFactory.createPremiumElm327Config();
      final invalidConfig = originalConfig.copyWith(responseTimeoutMs: 50); // Too low
      
      final result = validator.validateConfig(invalidConfig);
      
      expect(result['isValid'], isTrue);
      expect(result['issues'], isNotEmpty);
      expect((result['config'] as AdapterConfig).responseTimeoutMs, 
          greaterThanOrEqualTo(80)); // Should be adjusted to minimum
    });
    
    test('corrects invalid response timeout for cheap adapter', () {
      final originalConfig = AdapterConfigFactory.createCheapElm327Config();
      final invalidConfig = originalConfig.copyWith(responseTimeoutMs: 400); // Too high
      
      final result = validator.validateConfig(invalidConfig);
      
      expect(result['isValid'], isTrue);
      expect(result['issues'], isNotEmpty);
      expect((result['config'] as AdapterConfig).responseTimeoutMs, 
          lessThanOrEqualTo(350)); // Should be adjusted to maximum
    });
    
    test('identifies invalid Bluetooth parameters', () {
      final originalConfig = AdapterConfigFactory.createPremiumElm327Config();
      final invalidConfig = originalConfig.copyWith(serviceUuid: 'invalid-uuid');
      
      final result = validator.validateConfig(invalidConfig);
      
      expect(result['issues'], isNotEmpty);
      expect(result['issues'], contains(contains('Invalid service UUID')));
    });
    
    test('enforces critical settings for cheap adapters', () {
      final originalConfig = AdapterConfigFactory.createCheapElm327Config();
      final invalidConfig = originalConfig.copyWith(
        useExtendedInitDelays: false,
        useLenientParsing: false,
      );
      
      final result = validator.validateConfig(invalidConfig);
      
      expect(result['issues'], isNotEmpty);
      expect(result['issues'], contains(contains('useExtendedInitDelays must be true')));
      expect(result['issues'], contains(contains('useLenientParsing must be true')));
    });
    
    test('isSafeConfigUpdate prevents modifying critical params for cheap adapter', () {
      final safeUpdates = {'defaultPollingInterval': 1000};
      final unsafeUpdates = {'responseTimeoutMs': 100, 'defaultPollingInterval': 1000};
      
      expect(validator.isSafeConfigUpdate('cheap_elm327', safeUpdates), isTrue);
      expect(validator.isSafeConfigUpdate('cheap_elm327', unsafeUpdates), isFalse);
      
      // Should allow all updates for premium adapter
      expect(validator.isSafeConfigUpdate('premium_elm327', unsafeUpdates), isTrue);
    });
    
    test('records and retrieves runtime metrics', () {
      final config = AdapterConfigFactory.createPremiumElm327Config();
      final deviceId = 'test-device-123';
      final profileId = config.profileId;
      
      // Record some metrics
      validator.recordRuntimeMetrics(deviceId, config, {
        'success': true,
        'responseTime': 75,
        'commandDuration': 500,
      });
      
      validator.recordRuntimeMetrics(deviceId, config, {
        'success': true,
        'responseTime': 85,
        'commandDuration': 600,
      });
      
      validator.recordRuntimeMetrics(deviceId, config, {
        'success': false,
        'timeout': true,
        'responseTime': 150,
        'commandDuration': 1500,
      });
      
      // Get statistics
      final stats = validator.getRuntimeStatistics(deviceId, profileId);
      
      expect(stats, isNotNull);
      expect(stats!['commandCount'], equals(3));
      expect(stats['successRate'], equals(2/3));
      expect(stats['timeoutRate'], equals(1/3));
      
      // Average response time should be around (75 + 85 + 150) / 3 = 103.33
      expect(stats['avgResponseTime'], closeTo(103.33, 1.0));
    });
    
    test('calculateOptimizedConfig returns null with insufficient data', () {
      final config = AdapterConfigFactory.createPremiumElm327Config();
      final deviceId = 'test-device-456';
      final profileId = config.profileId;
      
      // Record just a few metrics, not enough for optimization
      validator.recordRuntimeMetrics(deviceId, config, {
        'success': true,
        'responseTime': 75,
        'commandDuration': 500,
      });
      
      validator.recordRuntimeMetrics(deviceId, config, {
        'success': true,
        'responseTime': 85,
        'commandDuration': 600,
      });
      
      // Should return null since we don't have enough data
      final optimizedConfig = validator.calculateOptimizedConfig(deviceId, profileId);
      expect(optimizedConfig, isNull);
    });
  });
} 

################################################################################
FILE: lib/main.dart
################################################################################

import 'package:flutter/material.dart';
import 'app.dart';
import 'services/service_locator.dart';
import 'services/driving/driving_service.dart';
import 'firebase/firebase_initializer.dart';
import 'package:logging/logging.dart';

/// Main entry point for the Going50 application.
void main() async {
  // Ensure Flutter is initialized
  WidgetsFlutterBinding.ensureInitialized();
  
  // Initialize logging
  final log = Logger('Main');
  
  // Initialize service locator
  await setupServiceLocator();
  
  // Connect the DrivingService to the BackgroundService now that both are registered
  await serviceLocator<DrivingService>().setupBackgroundService();
  
  // Initialize Firebase (non-blocking)
  // This will attempt to initialize Firebase, but the app will still function
  // if Firebase initialization fails or if the user doesn't have an internet connection
  FirebaseInitializer.initializeFirebase().then((initialized) {
    if (initialized) {
      log.info('Firebase initialized successfully');
    } else {
      log.warning('Firebase initialization failed - app will use local storage only');
    }
  }).catchError((e) {
    log.warning('Error during Firebase initialization: $e');
  });
  
  // Run the app
  runApp(const App());
}


################################################################################
FILE: lib/app.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'core/theme/app_theme.dart';
import 'core/constants/app_constants.dart';
import 'navigation/tab_navigator.dart';
import 'navigation/app_router.dart';
import 'services/driving/driving_service.dart';
import 'services/driving/performance_metrics_service.dart';
import 'services/service_locator.dart';
import 'presentation/providers/driving_provider.dart';
import 'presentation/providers/insights_provider.dart';
import 'presentation/providers/user_provider.dart';
import 'presentation/providers/social_provider.dart';
import 'presentation/screens/onboarding/onboarding_screen.dart';
import 'services/user/user_service.dart';
import 'services/user/preferences_service.dart';
import 'services/user/privacy_service.dart';
import 'services/social/social_service.dart';
import 'services/social/leaderboard_service.dart';
import 'services/social/sharing_service.dart';

/// The main application widget for Going50.
///
/// This widget sets up the application theme and navigation.
class App extends StatefulWidget {
  const App({super.key});

  @override
  State<App> createState() => _AppState();
}

class _AppState extends State<App> {
  /// Whether the user has completed onboarding
  bool _onboardingComplete = false;
  
  /// Loading state
  bool _loading = true;

  @override
  void initState() {
    super.initState();
    _checkOnboardingStatus();
    
    // Initialize the PrivacyService
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      // Initialize privacy service after frame is rendered
      await serviceLocator<PrivacyService>().initialize();
      
      // Log the privacy settings to debug
      final privacyService = serviceLocator<PrivacyService>();
      debugPrint('Privacy settings after initialization: ${privacyService.privacySettings}');
    });
  }

  /// Check if the user has completed onboarding
  Future<void> _checkOnboardingStatus() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _onboardingComplete = prefs.getBool('onboarding_complete') ?? false;
      _loading = false;
    });
  }
  
  /// Mark onboarding as complete
  Future<void> _completeOnboarding() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool('onboarding_complete', true);
    setState(() {
      _onboardingComplete = true;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        // Set up providers
        ChangeNotifierProvider(
          create: (_) => DrivingProvider(serviceLocator<DrivingService>())),
        ChangeNotifierProvider(
          create: (_) => InsightsProvider(
            serviceLocator<DrivingService>(),
            serviceLocator<PerformanceMetricsService>(),
          )),
        ChangeNotifierProvider<UserProvider>(
          create: (_) => UserProvider(
            serviceLocator<UserService>(),
            serviceLocator<PreferencesService>(),
          )
        ),
        ChangeNotifierProvider(
          create: (_) => SocialProvider(
            serviceLocator<SocialService>(),
            serviceLocator<LeaderboardService>(),
            serviceLocator<SharingService>(),
          )),
        // Add Privacy Service Provider
        Provider<PrivacyService>(
          create: (_) => serviceLocator<PrivacyService>(),
        ),
      ],
      child: MaterialApp(
        title: AppInfo.appName,
        theme: AppTheme.getLightTheme(),
        darkTheme: AppTheme.getDarkTheme(),
        themeMode: ThemeMode.system, // Respect system theme settings
        
        // Show loading indicator, onboarding, or main app depending on state
        home: _loading 
            ? const _LoadingScreen() 
            : _onboardingComplete 
                ? const TabNavigator()
                : OnboardingScreen(
                    onComplete: _completeOnboarding,
                  ),
        
        // Set up the router for handling named routes
        onGenerateRoute: AppRouter.generateRoute,
        
        // Customize app bar theme
        builder: (context, child) {
          return child!;
        },
        
        // Remove the debug banner
        debugShowCheckedModeBanner: false,
      ),
    );
  }
}

/// A simple loading screen shown while checking onboarding status
class _LoadingScreen extends StatelessWidget {
  const _LoadingScreen();

  @override
  Widget build(BuildContext context) {
    return const Scaffold(
      body: Center(
        child: CircularProgressIndicator(),
      ),
    );
  }
} 

################################################################################
FILE: lib/core/constants/app_constants.dart
################################################################################

/// Application-wide constants for the Going50 app.
/// This file contains various constants used throughout the application.
library;

/// App information constants
class AppInfo {
  /// The name of the application
  static const String appName = 'Going50';
  
  /// The tagline/slogan of the application
  static const String appTagline = 'Drive Smart, Live Green';
  
  /// The current version of the application
  static const String appVersion = '1.0.0';
  
  /// The build number of the application
  static const String appBuildNumber = '1';
  
  // Prevent instantiation
  AppInfo._();
}

/// Default values used throughout the application
class DefaultValues {
  /// Default refresh interval in milliseconds
  static const int defaultRefreshIntervalMs = 500;
  
  /// Default eco-score value
  static const double defaultEcoScore = 50.0;
  
  /// Maximum number of recent trips to show in list
  static const int maxRecentTrips = 5;
  
  // Prevent instantiation
  DefaultValues._();
}

/// Feature flags for enabling/disabling features during development
class FeatureFlags {
  /// Whether OBD functionality is enabled
  static const bool enableObd = true;
  
  /// Whether social features are enabled
  static const bool enableSocialFeatures = true;
  
  /// Whether gamification features are enabled
  static const bool enableGamification = true;
  
  /// Whether background data collection is enabled
  static const bool enableBackgroundCollection = true;
  
  // Prevent instantiation
  FeatureFlags._();
}

/// Timing constants for various operations
class TimingConstants {
  /// Timeout for OBD connection in milliseconds
  static const int obdConnectionTimeoutMs = 10000;
  
  /// Timeout for sensor initialization in milliseconds
  static const int sensorInitTimeoutMs = 5000;
  
  /// Minimum duration of a trip to be recorded, in milliseconds
  static const int minTripDurationMs = 60000; // 1 minute
  
  // Prevent instantiation
  TimingConstants._();
}

/// Common error messages used in the application
class ErrorMessages {
  /// Error message for OBD connection failure
  static const String obdConnectionFailed = 'Could not connect to OBD device';
  
  /// Error message for sensor initialization failure
  static const String sensorInitFailed = 'Failed to initialize sensors';
  
  /// Error message for when location permission is denied
  static const String locationPermissionDenied = 'Location permission required for trip tracking';
  
  // Prevent instantiation
  ErrorMessages._();
} 

################################################################################
FILE: lib/core/constants/route_constants.dart
################################################################################

/// Route constants for the Going50 app.
/// This file contains named routes used throughout the application.
library;

/// Main tab routes
class TabRoutes {
  /// Route for the Drive tab
  static const String driveTab = '/drive';
  
  /// Route for the Insights tab
  static const String insightsTab = '/insights';
  
  /// Route for the Community tab
  static const String communityTab = '/community';
  
  /// Route for the Profile tab
  static const String profileTab = '/profile';
  
  // Prevent instantiation
  TabRoutes._();
}

/// Drive section routes
class DriveRoutes {
  /// Route for the active driving screen
  static const String activeDrive = '/drive/active';
  
  /// Route for the trip summary screen
  static const String tripSummary = '/drive/trip-summary';
  
  // Prevent instantiation
  DriveRoutes._();
}

/// Insights section routes
class InsightsRoutes {
  /// Route for the trip history screen
  static const String tripHistory = '/insights/history';
  
  /// Route for the trip detail screen
  static const String tripDetail = '/insights/trip-detail';
  
  // Prevent instantiation
  InsightsRoutes._();
}

/// Community section routes
class CommunityRoutes {
  /// Route for the leaderboard screen
  static const String leaderboard = '/community/leaderboard';
  
  /// Route for the challenges screen
  static const String challenges = '/community/challenges';
  
  /// Route for the friend profile screen
  static const String friendProfile = '/community/friend-profile';
  
  /// Route for the challenge detail screen
  static const String challengeDetail = '/community/challenge-detail';
  
  // Prevent instantiation
  CommunityRoutes._();
}

/// Profile section routes
class ProfileRoutes {
  /// Route for the settings screen
  static const String settings = '/profile/settings';
  
  /// Route for the privacy settings screen
  static const String privacySettings = '/profile/privacy';
  
  /// Route for the device connection screen
  static const String deviceConnection = '/profile/device-connection';
  
  /// Route for the data management screen
  static const String dataManagement = '/profile/data-management';
  
  // Prevent instantiation
  ProfileRoutes._();
}

/// Onboarding routes
class OnboardingRoutes {
  /// Route for the welcome screen
  static const String welcome = '/onboarding/welcome';
  
  /// Route for the value carousel screen
  static const String valueCarousel = '/onboarding/value-carousel';
  
  /// Route for the account choice screen
  static const String accountChoice = '/onboarding/account-choice';
  
  /// Route for the connection setup screen
  static const String connectionSetup = '/onboarding/connection-setup';
  
  // Prevent instantiation
  OnboardingRoutes._();
} 

################################################################################
FILE: lib/core/utils/device_utils.dart
################################################################################

import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:flutter_reactive_ble/flutter_reactive_ble.dart' hide Logger;
import 'package:permission_handler/permission_handler.dart';
import 'package:battery_plus/battery_plus.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:logging/logging.dart';

/// A utility class for detecting device capabilities and features
class DeviceUtils {
  static final Logger _logger = Logger('DeviceUtils');
  static final FlutterReactiveBle _ble = FlutterReactiveBle();
  static final Battery _battery = Battery();
  
  /// Check if the device supports Bluetooth
  static Future<bool> hasBluetoothSupport() async {
    try {
      if (!Platform.isAndroid && !Platform.isIOS) {
        return false; // Only Android and iOS support Bluetooth
      }
      
      final status = await _ble.statusStream.first;
      return status != BleStatus.unsupported;
    } catch (e) {
      _logger.warning('Error checking Bluetooth support: $e');
      return false;
    }
  }
  
  /// Check if Bluetooth is currently enabled
  static Future<bool> isBluetoothEnabled() async {
    try {
      final status = await _ble.statusStream.first;
      return status == BleStatus.ready;
    } catch (e) {
      _logger.warning('Error checking if Bluetooth is enabled: $e');
      return false;
    }
  }
  
  /// Check if the device has a gyroscope
  static Future<bool> hasGyroscope() async {
    try {
      final hasPermission = await Permission.sensors.isGranted;
      if (!hasPermission) {
        return false;
      }
      
      // This is a simplified check - in a real implementation, you would actually try to read from the sensor
      return Platform.isAndroid || Platform.isIOS; // Most modern devices have gyroscopes
    } catch (e) {
      _logger.warning('Error checking gyroscope availability: $e');
      return false;
    }
  }
  
  /// Check if the device has location services available
  static Future<bool> hasLocationServices() async {
    try {
      if (Platform.isAndroid || Platform.isIOS) {
        return await Permission.locationWhenInUse.serviceStatus.isEnabled;
      }
      return false;
    } catch (e) {
      _logger.warning('Error checking location services: $e');
      return false;
    }
  }
  
  /// Get the current battery level as a percentage
  static Future<int> getBatteryLevel() async {
    try {
      return await _battery.batteryLevel;
    } catch (e) {
      _logger.warning('Error getting battery level: $e');
      return -1;
    }
  }
  
  /// Check if the device is currently charging
  static Future<bool> isCharging() async {
    try {
      final batteryState = await _battery.batteryState;
      return batteryState == BatteryState.charging || 
             batteryState == BatteryState.full;
    } catch (e) {
      _logger.warning('Error checking charging status: $e');
      return false;
    }
  }
  
  /// Check if the device is in low power mode
  static Future<bool> isLowPowerMode() async {
    try {
      if (Platform.isIOS) {
        return await _battery.isInBatterySaveMode;
      } else {
        // No direct API for Android, return false as fallback
        return false;
      }
    } catch (e) {
      _logger.warning('Error checking low power mode: $e');
      return false;
    }
  }
  
  /// Get the app version
  static Future<String> getAppVersion() async {
    try {
      final packageInfo = await PackageInfo.fromPlatform();
      return packageInfo.version;
    } catch (e) {
      _logger.warning('Error getting app version: $e');
      return 'Unknown';
    }
  }
  
  /// Get the device model
  static String getDeviceModel() {
    try {
      if (Platform.isAndroid) {
        return '${Platform.operatingSystem} ${Platform.operatingSystemVersion}';
      } else if (Platform.isIOS) {
        return 'iOS ${Platform.operatingSystemVersion}';
      } else {
        return Platform.operatingSystem;
      }
    } catch (e) {
      _logger.warning('Error getting device model: $e');
      return 'Unknown';
    }
  }
  
  /// Check if the device has background execution capabilities
  static bool canExecuteInBackground() {
    return !kIsWeb && (Platform.isAndroid || Platform.isIOS);
  }
  
  /// Check if the device is using a lot of battery (would benefit from optimizations)
  static Future<bool> needsBatteryOptimization() async {
    try {
      // Consider below 20% as low battery
      final int batteryLevel = await getBatteryLevel();
      return batteryLevel > 0 && batteryLevel < 20 && !(await isCharging());
    } catch (e) {
      _logger.warning('Error checking battery optimization need: $e');
      return false;
    }
  }
  
  /// Check if the device has all required sensors for collecting driving data
  static Future<bool> hasSensorCapabilities() async {
    try {
      // In debug mode, always return true to allow testing
      if (kDebugMode) {
        _logger.info('Debug mode: Bypassing sensor capability check');
        return true;
      }
      
      // Check for accelerometer and location services
      final hasAccelerometer = await hasGyroscope(); // Using gyroscope check as a proxy for sensors
      final hasLocation = await hasLocationServices();
      
      // Log the results
      _logger.info('Sensor capabilities: accelerometer=$hasAccelerometer, location=$hasLocation');
      
      // Both are required for basic functionality
      return hasAccelerometer && hasLocation;
    } catch (e) {
      _logger.warning('Error checking sensor capabilities: $e');
      return false;
    }
  }
} 

################################################################################
FILE: lib/core/utils/formatter_utils.dart
################################################################################

import 'package:intl/intl.dart';
import 'dart:math' as math;

/// A utility class for formatting various data types for display
class FormatterUtils {
  /// Format a date to a readable string
  static String formatDate(DateTime date, {String format = 'MMM d, yyyy'}) {
    return DateFormat(format).format(date);
  }
  
  /// Format a date and time to a readable string
  static String formatDateTime(DateTime dateTime, {String format = 'MMM d, yyyy - HH:mm'}) {
    return DateFormat(format).format(dateTime);
  }
  
  /// Format a time to a readable string
  static String formatTime(DateTime time, {String format = 'HH:mm'}) {
    return DateFormat(format).format(time);
  }
  
  /// Format a duration to a readable string (e.g., "1h 30m")
  static String formatDuration(Duration duration) {
    String twoDigits(int n) => n.toString().padLeft(2, '0');
    
    String result = '';
    
    // Add hours if greater than 0
    if (duration.inHours > 0) {
      result += '${duration.inHours}h ';
    }
    
    // Add minutes
    result += '${twoDigits(duration.inMinutes.remainder(60))}m';
    
    return result;
  }
  
  /// Format a duration in seconds to a readable string (e.g., "1:30")
  static String formatDurationInSeconds(int seconds) {
    final duration = Duration(seconds: seconds);
    final minutes = duration.inMinutes;
    final remainingSeconds = duration.inSeconds.remainder(60);
    return '$minutes:${remainingSeconds.toString().padLeft(2, '0')}';
  }
  
  /// Format a distance in kilometers with 1 decimal place
  static String formatDistance(double? kilometers, {bool includeUnit = true}) {
    if (kilometers == null) return '--';
    
    final formatter = NumberFormat('0.0');
    return includeUnit ? '${formatter.format(kilometers)} km' : formatter.format(kilometers);
  }
  
  /// Format a speed in km/h with 0 decimal places
  static String formatSpeed(double? kmPerHour, {bool includeUnit = true}) {
    if (kmPerHour == null) return '--';
    
    final formatter = NumberFormat('0');
    return includeUnit ? '${formatter.format(kmPerHour)} km/h' : formatter.format(kmPerHour);
  }
  
  /// Format fuel in liters with 2 decimal places
  static String formatFuel(double? liters, {bool includeUnit = true}) {
    if (liters == null) return '--';
    
    final formatter = NumberFormat('0.00');
    return includeUnit ? '${formatter.format(liters)} L' : formatter.format(liters);
  }
  
  /// Format fuel consumption in L/100km with 1 decimal place
  static String formatFuelConsumption(double? litersPer100Km, {bool includeUnit = true}) {
    if (litersPer100Km == null) return '--';
    
    final formatter = NumberFormat('0.0');
    return includeUnit ? '${formatter.format(litersPer100Km)} L/100km' : formatter.format(litersPer100Km);
  }
  
  /// Format a percentage value with 0 decimal places
  static String formatPercentage(double? percentage) {
    if (percentage == null) return '--';
    
    final formatter = NumberFormat('0');
    return '${formatter.format(percentage)}%';
  }
  
  /// Format an eco-score (0-100) with appropriate styling guidance
  static String formatEcoScore(int? score) {
    if (score == null) return '--';
    
    return score.toString();
  }
  
  /// Get color for eco-score
  /// Returns a string representation of a color based on the score
  /// Can be used with Color.fromARGB or similar
  static String getEcoScoreColorString(int score) {
    if (score >= 80) {
      return '#4CAF50'; // Green for excellent
    } else if (score >= 60) {
      return '#8BC34A'; // Light green for good
    } else if (score >= 40) {
      return '#FFC107'; // Amber for average
    } else if (score >= 20) {
      return '#FF9800'; // Orange for below average
    } else {
      return '#F44336'; // Red for poor
    }
  }
  
  /// Format a currency amount
  static String formatCurrency(double? amount, {String currencySymbol = '\$'}) {
    if (amount == null) return '--';
    
    final formatter = NumberFormat('#,##0.00');
    return '$currencySymbol${formatter.format(amount)}';
  }
  
  /// Format a file size in bytes to human-readable format
  static String formatFileSize(int bytes) {
    if (bytes <= 0) return '0 B';
    
    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    final i = (math.log(bytes) / math.log(1024)).floor();
    
    return '${(bytes / math.pow(1024, i)).toStringAsFixed(1)} ${units[i]}';
  }
} 

################################################################################
FILE: lib/core/utils/permission_utils.dart
################################################################################

import 'package:permission_handler/permission_handler.dart';
import 'package:logging/logging.dart';

/// A utility class for handling app permissions
class PermissionUtils {
  static final Logger _logger = Logger('PermissionUtils');
  
  /// Permissions required for driving features with OBD
  static const List<Permission> drivingPermissions = [
    Permission.location,
    Permission.locationWhenInUse,
    Permission.bluetooth,
    Permission.bluetoothScan,
    Permission.bluetoothConnect,
  ];
  
  /// Permissions required for driving features with phone sensors only
  static const List<Permission> sensorOnlyPermissions = [
    Permission.location,
    Permission.locationWhenInUse,
    Permission.sensors,
  ];
  
  /// Permissions required for background tracking
  static const List<Permission> backgroundTrackingPermissions = [
    Permission.location,
    Permission.locationAlways,
    Permission.bluetooth,
    Permission.bluetoothScan,
    Permission.bluetoothConnect,
    Permission.ignoreBatteryOptimizations,
  ];
  
  /// Check if a permission is granted
  static Future<bool> isPermissionGranted(Permission permission) async {
    final status = await permission.status;
    return status.isGranted;
  }
  
  /// Request a specific permission
  static Future<bool> requestPermission(Permission permission) async {
    _logger.info('Requesting permission: ${permission.toString()}');
    
    try {
      final status = await permission.request();
      _logger.info('Permission ${permission.toString()} status: ${status.toString()}');
      return status.isGranted;
    } catch (e) {
      _logger.severe('Error requesting permission ${permission.toString()}: $e');
      return false;
    }
  }
  
  /// Request multiple permissions
  static Future<Map<Permission, bool>> requestPermissions(List<Permission> permissions) async {
    _logger.info('Requesting multiple permissions: ${permissions.map((p) => p.toString()).join(', ')}');
    
    Map<Permission, bool> results = {};
    
    for (final permission in permissions) {
      results[permission] = await requestPermission(permission);
    }
    
    return results;
  }
  
  /// Check if all required permissions for driving with OBD are granted
  static Future<bool> checkDrivingPermissions() async {
    for (final permission in drivingPermissions) {
      if (!await isPermissionGranted(permission)) {
        return false;
      }
    }
    return true;
  }
  
  /// Check if all required permissions for driving with sensors only are granted
  static Future<bool> checkSensorOnlyPermissions() async {
    for (final permission in sensorOnlyPermissions) {
      if (!await isPermissionGranted(permission)) {
        return false;
      }
    }
    return true;
  }
  
  /// Check if all required permissions for background tracking are granted
  static Future<bool> checkBackgroundTrackingPermissions() async {
    for (final permission in backgroundTrackingPermissions) {
      if (!await isPermissionGranted(permission)) {
        return false;
      }
    }
    return true;
  }
  
  /// Request all permissions needed for driving with OBD
  static Future<bool> requestDrivingPermissions() async {
    final results = await requestPermissions(drivingPermissions);
    return !results.values.contains(false);
  }
  
  /// Request all permissions needed for driving with sensors only
  static Future<bool> requestSensorOnlyPermissions() async {
    final results = await requestPermissions(sensorOnlyPermissions);
    return !results.values.contains(false);
  }
  
  /// Request all permissions needed for background tracking
  static Future<bool> requestBackgroundTrackingPermissions() async {
    final results = await requestPermissions(backgroundTrackingPermissions);
    return !results.values.contains(false);
  }
  
  /// Open app settings when permissions are permanently denied
  static Future<bool> openSettings() async {
    _logger.info('Opening app settings');
    return await openAppSettings();
  }
  
  /// Check if all required permissions for sensor use are granted
  static Future<bool> checkSensorPermissions() async {
    return checkSensorOnlyPermissions();
  }
  
  /// Request all permissions needed for sensor use
  static Future<bool> requestSensorPermissions() async {
    return requestSensorOnlyPermissions();
  }
} 

################################################################################
FILE: lib/core/utils/driving_utils.dart
################################################################################

import 'dart:math' as math;

/// A utility class for driving-related calculations
class DrivingUtils {
  /// Calculate the eco-efficiency score of a speed in km/h
  /// Returns a score between 0 and 100 based on how close the speed is to the optimal range
  static double calculateSpeedEfficiencyScore(double speedKmh) {
    // Most vehicles are most efficient between 50-80 km/h (31-50 mph)
    const double optimumLower = 50.0;
    const double optimumUpper = 80.0;
    
    // Score is 100 if within optimal range
    if (speedKmh >= optimumLower && speedKmh <= optimumUpper) {
      return 100.0;
    }
    
    // Score decreases as speed moves away from optimal range
    // Using a logarithmic falloff for more realistic scoring
    if (speedKmh < optimumLower) {
      // For speeds below optimal range
      return 100.0 * (1.0 - math.log(optimumLower / math.max(speedKmh, 5.0)) * 0.2);
    } else {
      // For speeds above optimal range
      return 100.0 * (1.0 - math.log(speedKmh / optimumUpper) * 0.1);
    }
  }
  
  /// Calculate the estimated fuel consumption (L/100km) based on speed and other factors
  /// This is a simplified model and should be calibrated with real-world data
  static double estimateFuelConsumption(double speedKmh, double accelerationMps2, double engineRpm) {
    // Base consumption for a typical mid-size vehicle at steady speed
    double baseFuelConsumption = 0.0;
    
    // Adjust for speed (U-shaped curve with minimum around 70-90 km/h)
    if (speedKmh < 40) {
      // Higher consumption at low speeds
      baseFuelConsumption = 8.0 + (40 - speedKmh) * 0.1;
    } else if (speedKmh <= 80) {
      // Optimal range 
      baseFuelConsumption = 5.0 + (speedKmh - 60).abs() * 0.05;
    } else {
      // Increases with speed above optimal range
      baseFuelConsumption = 6.0 + (speedKmh - 80) * 0.06;
    }
    
    // Adjust for acceleration (higher acceleration = higher consumption)
    double accelerationFactor = 1.0 + math.max(0.0, accelerationMps2) * 0.5;
    
    // Adjust for RPM (higher RPM = higher consumption)
    double rpmFactor = 1.0;
    if (engineRpm > 0) {  // Only if we have RPM data
      rpmFactor = 1.0 + math.max(0.0, (engineRpm - 1500) / 1000) * 0.2;
    }
    
    return baseFuelConsumption * accelerationFactor * rpmFactor;
  }
  
  /// Calculate the estimated CO2 emissions (g/km) based on fuel consumption
  /// Using an average conversion factor for gasoline
  static double estimateCO2Emissions(double fuelConsumptionL100km) {
    // Average conversion factor: ~2.3 kg CO2 per liter of gasoline
    const double co2PerLiterGasoline = 2300.0; // g/L
    
    // Convert L/100km to g/km
    return (fuelConsumptionL100km * co2PerLiterGasoline) / 100.0;
  }
  
  /// Calculate acceleration from two speed measurements
  static double calculateAcceleration(double speedKmh1, double speedKmh2, double timeIntervalSeconds) {
    if (timeIntervalSeconds <= 0) {
      return 0.0;
    }
    
    // Convert km/h to m/s
    double speedMps1 = speedKmh1 * (1000.0 / 3600.0);
    double speedMps2 = speedKmh2 * (1000.0 / 3600.0);
    
    // Calculate acceleration in m/s²
    return (speedMps2 - speedMps1) / timeIntervalSeconds;
  }
  
  /// Detect if an acceleration event is aggressive
  static bool isAggressiveAcceleration(double accelerationMps2) {
    // Threshold for aggressive acceleration (typical threshold is 2.5-3.0 m/s²)
    const double aggressiveAccelerationThreshold = 2.5;
    
    return accelerationMps2 > aggressiveAccelerationThreshold;
  }
  
  /// Detect if a braking event is aggressive
  static bool isAggressiveBraking(double accelerationMps2) {
    // Threshold for aggressive braking (typical threshold is -3.0 to -3.5 m/s²)
    const double aggressiveBrakingThreshold = -3.0;
    
    return accelerationMps2 < aggressiveBrakingThreshold;
  }
  
  /// Calculate the optimal following distance in meters based on speed
  static double calculateOptimalFollowingDistance(double speedKmh) {
    // Using the 3-second rule: distance = speed × time
    const double followingTimeSeconds = 3.0;
    
    // Convert km/h to m/s for distance calculation
    double speedMps = speedKmh * (1000.0 / 3600.0);
    
    return speedMps * followingTimeSeconds;
  }
  
  /// Calculate distance between two coordinate points using the Haversine formula
  static double calculateDistanceBetweenCoordinates(
    double lat1, double lon1, double lat2, double lon2
  ) {
    const double earthRadiusKm = 6371.0;
    
    // Convert degrees to radians
    double toRadians(double degrees) => degrees * math.pi / 180.0;
    
    final double dLat = toRadians(lat2 - lat1);
    final double dLon = toRadians(lon2 - lon1);
    
    final double a = 
        math.sin(dLat / 2) * math.sin(dLat / 2) +
        math.cos(toRadians(lat1)) * math.cos(toRadians(lat2)) * 
        math.sin(dLon / 2) * math.sin(dLon / 2);
    
    final double c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a));
    return earthRadiusKm * c;
  }
  
  /// Determine if a trip is considered "short distance" (potentially inefficient)
  static bool isShortDistanceTrip(double distanceKm) {
    // Trips under 3 km are generally considered short
    const double shortTripThresholdKm = 3.0;
    
    return distanceKm < shortTripThresholdKm;
  }
  
  /// Calculate the eco-savings from improved driving (in liters of fuel)
  static double calculateFuelSavings(double distanceKm, double actualConsumptionL100km, double targetConsumptionL100km) {
    // Calculate difference in consumption
    double consumptionDifferenceL100km = actualConsumptionL100km - targetConsumptionL100km;
    
    // Convert to actual fuel saved
    return (consumptionDifferenceL100km * distanceKm) / 100.0;
  }
  
  /// Calculate the cost savings from improved fuel efficiency
  static double calculateCostSavings(double fuelSavedL, double fuelPricePerLiter) {
    return fuelSavedL * fuelPricePerLiter;
  }
  
  /// Calculate the CO2 savings from improved driving (in kg)
  static double calculateCO2Savings(double fuelSavedL) {
    // Average conversion factor: ~2.3 kg CO2 per liter of gasoline
    const double co2PerLiterGasoline = 2.3; // kg/L
    
    return fuelSavedL * co2PerLiterGasoline;
  }
} 

################################################################################
FILE: lib/core/theme/app_theme.dart
################################################################################

import 'package:flutter/material.dart';
import 'app_colors.dart';

/// Theme definitions for the Going50 app.
///
/// This class provides light and dark themes and text styles.
class AppTheme {
  /// Creates the light theme for the app.
  static ThemeData getLightTheme() {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      primaryColor: AppColors.primary,
      colorScheme: ColorScheme(
        brightness: Brightness.light,
        primary: AppColors.primary,
        onPrimary: AppColors.textOnPrimary,
        secondary: AppColors.secondary,
        onSecondary: AppColors.textOnSecondary,
        error: AppColors.error,
        onError: AppColors.textOnPrimary,
        surface: AppColors.background,
        onSurface: AppColors.textPrimary,
        surfaceTint: AppColors.primary.withAlpha(26),
      ),
      scaffoldBackgroundColor: AppColors.background,
      appBarTheme: const AppBarTheme(
        backgroundColor: AppColors.primary,
        foregroundColor: AppColors.textOnPrimary,
        elevation: 0,
      ),
      cardTheme: const CardTheme(
        color: AppColors.surfaceLight,
        elevation: 2,
        margin: EdgeInsets.all(8),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.all(Radius.circular(12)),
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: AppColors.primary,
          foregroundColor: AppColors.textOnPrimary,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(24),
          ),
          padding: const EdgeInsets.symmetric(
            horizontal: 24,
            vertical: 12,
          ),
          textStyle: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: AppColors.primary,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(24),
          ),
          padding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 8,
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: AppColors.primary,
          side: const BorderSide(color: AppColors.primary, width: 2),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(24),
          ),
          padding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 8,
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),
      textTheme: const TextTheme(
        displayLarge: TextStyle(
          fontSize: 32,
          fontWeight: FontWeight.bold,
          color: AppColors.textPrimary,
        ),
        displayMedium: TextStyle(
          fontSize: 28,
          fontWeight: FontWeight.bold,
          color: AppColors.textPrimary,
        ),
        displaySmall: TextStyle(
          fontSize: 24,
          fontWeight: FontWeight.bold,
          color: AppColors.textPrimary,
        ),
        headlineMedium: TextStyle(
          fontSize: 20,
          fontWeight: FontWeight.w600,
          color: AppColors.textPrimary,
        ),
        titleLarge: TextStyle(
          fontSize: 18,
          fontWeight: FontWeight.w600,
          color: AppColors.textPrimary,
        ),
        bodyLarge: TextStyle(
          fontSize: 16,
          color: AppColors.textPrimary,
        ),
        bodyMedium: TextStyle(
          fontSize: 14,
          color: AppColors.textPrimary,
        ),
        labelLarge: TextStyle(
          fontSize: 16,
          fontWeight: FontWeight.w500,
          color: AppColors.textPrimary,
        ),
      ),
      dividerTheme: const DividerThemeData(
        color: AppColors.textDisabled,
        thickness: 1,
        space: 24,
      ),
    );
  }

  /// Creates the dark theme for the app.
  static ThemeData getDarkTheme() {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      primaryColor: AppColors.primary,
      colorScheme: ColorScheme(
        brightness: Brightness.dark,
        primary: AppColors.primary,
        onPrimary: AppColors.textOnPrimary,
        secondary: AppColors.secondary,
        onSecondary: AppColors.textOnSecondary,
        error: AppColors.error,
        onError: AppColors.textOnPrimary,
        surface: AppColors.darkBackground,
        onSurface: AppColors.darkTextPrimary,
        surfaceTint: AppColors.primary.withAlpha(26),
      ),
      scaffoldBackgroundColor: AppColors.darkBackground,
      appBarTheme: const AppBarTheme(
        backgroundColor: AppColors.darkSurface,
        foregroundColor: AppColors.darkTextPrimary,
        elevation: 0,
      ),
      cardTheme: const CardTheme(
        color: AppColors.darkSurface,
        elevation: 2,
        margin: EdgeInsets.all(8),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.all(Radius.circular(12)),
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: AppColors.primary,
          foregroundColor: AppColors.textOnPrimary,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(24),
          ),
          padding: const EdgeInsets.symmetric(
            horizontal: 24,
            vertical: 12,
          ),
          textStyle: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: AppColors.primary,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(24),
          ),
          padding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 8,
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: AppColors.primary,
          side: const BorderSide(color: AppColors.primary, width: 2),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(24),
          ),
          padding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 8,
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),
      textTheme: const TextTheme(
        displayLarge: TextStyle(
          fontSize: 32,
          fontWeight: FontWeight.bold,
          color: AppColors.darkTextPrimary,
        ),
        displayMedium: TextStyle(
          fontSize: 28,
          fontWeight: FontWeight.bold,
          color: AppColors.darkTextPrimary,
        ),
        displaySmall: TextStyle(
          fontSize: 24,
          fontWeight: FontWeight.bold,
          color: AppColors.darkTextPrimary,
        ),
        headlineMedium: TextStyle(
          fontSize: 20,
          fontWeight: FontWeight.w600,
          color: AppColors.darkTextPrimary,
        ),
        titleLarge: TextStyle(
          fontSize: 18,
          fontWeight: FontWeight.w600,
          color: AppColors.darkTextPrimary,
        ),
        bodyLarge: TextStyle(
          fontSize: 16,
          color: AppColors.darkTextPrimary,
        ),
        bodyMedium: TextStyle(
          fontSize: 14,
          color: AppColors.darkTextPrimary,
        ),
        labelLarge: TextStyle(
          fontSize: 16,
          fontWeight: FontWeight.w500,
          color: AppColors.darkTextPrimary,
        ),
      ),
      dividerTheme: const DividerThemeData(
        color: AppColors.darkTextSecondary,
        thickness: 1,
        space: 24,
      ),
    );
  }
} 

################################################################################
FILE: lib/core/theme/app_colors.dart
################################################################################

import 'package:flutter/material.dart';

/// App color palette for Going50.
///
/// This class defines all the colors used in the application.
class AppColors {
  // Primary brand colors
  static const Color primary = Color(0xFF4CAF50); // Green
  static const Color primaryLight = Color(0xFF80E27E);
  static const Color primaryDark = Color(0xFF087F23);
  
  // Secondary accent colors
  static const Color secondary = Color(0xFF03A9F4); // Blue
  static const Color secondaryLight = Color(0xFF67DAFF);
  static const Color secondaryDark = Color(0xFF007AC1);
  
  // Background colors
  static const Color background = Color(0xFFFAFAFA);
  static const Color surfaceLight = Color(0xFFFFFFFF);
  static const Color surfaceDark = Color(0xFFF5F5F5);
  
  // Text colors
  static const Color textPrimary = Color(0xFF212121);
  static const Color textSecondary = Color(0xFF757575);
  static const Color textDisabled = Color(0xFFBDBDBD);
  static const Color textOnPrimary = Color(0xFFFFFFFF);
  static const Color textOnSecondary = Color(0xFFFFFFFF);
  
  // Feedback colors
  static const Color success = Color(0xFF4CAF50);
  static const Color warning = Color(0xFFFF9800);
  static const Color error = Color(0xFFE53935);
  static const Color info = Color(0xFF2196F3);
  
  // Neutral colors
  static const Color neutralGray = Color(0xFF9E9E9E);
  
  // Eco-score gradient colors
  static const Color ecoScoreLow = Color(0xFFE53935); // Red
  static const Color ecoScoreMedium = Color(0xFFFFB300); // Amber
  static const Color ecoScoreHigh = Color(0xFF43A047); // Green
  
  // Dark theme adjustments
  static const Color darkBackground = Color(0xFF121212);
  static const Color darkSurface = Color(0xFF1E1E1E);
  static const Color darkTextPrimary = Color(0xFFEEEEEE);
  static const Color darkTextSecondary = Color(0xFFB0B0B0);
  
  // Prevent instantiation
  AppColors._();
  
  /// Returns a color based on the eco-score value.
  ///
  /// [score] should be between 0 and 100.
  static Color getEcoScoreColor(double score) {
    if (score < 40) {
      return ecoScoreLow;
    } else if (score < 70) {
      return ecoScoreMedium;
    } else {
      return ecoScoreHigh;
    }
  }
} 

################################################################################
FILE: lib/sensor_lib/README.md
################################################################################

# Sensor Library

This library provides a simplified interface for collecting phone sensor data in Flutter applications. It handles sensor registration, permissions, and data processing.

## Features

- Accelerometer, gyroscope, and magnetometer data collection
- GPS location tracking with configurable accuracy
- Flexible configuration options for data collection frequency
- Streams for real-time data updates
- Battery-efficient operation modes
- Clean modular architecture

## Usage

```dart
import 'package:going50/sensor_lib/sensor_lib.dart';

// Create a sensor service
final sensorService = SensorService(
  config: SensorConfig.ecoDrivingConfig,
  isDebugMode: true,
);

// Initialize the service
await sensorService.initialize();

// Start collecting data
await sensorService.startCollection(collectionIntervalMs: 200);

// Get real-time updates
sensorService.dataStream.listen((data) {
  print('New sensor data: ${data.timestamp}');
  print('Location: ${data.latitude}, ${data.longitude}');
  print('Acceleration: ${data.accelerationX}, ${data.accelerationY}, ${data.accelerationZ}');
});

// Get the latest data on demand
final latestData = await sensorService.getLatestSensorData();

// Stop collection when done
sensorService.stopCollection();

// Clean up resources
sensorService.dispose();
```

## Architecture

The library is built with a modular architecture:

- **sensor_service.dart**: Main facade that coordinates sensors and provides the API
- **interfaces/**: Abstract interfaces for each component
- **implementations/**: Concrete implementations of the interfaces
- **models/**: Data models and configuration options
- **sensor_factory.dart**: Factory for creating components with dependency injection

## Advanced Usage

For more advanced usage, you can create and provide custom implementations:

```dart
import 'package:going50/sensor_lib/sensor_lib.dart';

// Create custom components
final customConfig = SensorConfig(
  accelerometerFrequency: 30,
  gyroscopeFrequency: 15,
  locationUpdateIntervalMs: 2000,
);

final components = SensorFactory.createComponents(
  config: customConfig,
);

// Create service with custom components
final sensorService = SensorService(
  config: customConfig,
  sensorManager: components.sensors,
  locationManager: components.location,
);
```

## Testing

The architecture supports easy mocking for testing:

```dart
class MockSensorManager implements SensorManager {
  // Implement with test values
}

final testService = SensorService(
  sensorManager: MockSensorManager(),
  locationManager: MockLocationManager(),
);
```


################################################################################
FILE: lib/sensor_lib/sensor_lib.dart
################################################################################

// Sensor Library for Flutter
//
// This library provides a simplified interface for collecting and managing phone sensor data
// in Flutter applications. It handles permissions, sensor registration, and data processing.

// Export the main service class
export 'sensor_service.dart';
export 'sensor_factory.dart';

// Export interfaces
export 'interfaces/sensor_manager.dart';
export 'interfaces/location_manager.dart';

// Export models
export 'models/sensor_config.dart';

// Export implementations for advanced usage
export 'implementations/sensor_manager_impl.dart';
export 'implementations/location_manager_impl.dart';

// Re-export core models for convenience
export '../core_models/phone_sensor_data.dart'; 

################################################################################
FILE: lib/sensor_lib/sensor_service.dart
################################################################################

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:logging/logging.dart';
import 'package:geolocator/geolocator.dart';

import '../core_models/phone_sensor_data.dart';
import 'interfaces/sensor_manager.dart';
import 'interfaces/location_manager.dart';
import 'implementations/sensor_manager_impl.dart';
import 'implementations/location_manager_impl.dart';
import 'models/sensor_config.dart';

/// Main service for collecting phone sensor data
///
/// This class provides a facade for the sensor library, handling sensor initialization,
/// data collection, and processing.
class SensorService extends ChangeNotifier {
  final Logger _logger = Logger('SensorService');
  final bool isDebugMode;
  
  // Managers
  late final SensorManager _sensorManager;
  late final LocationManager _locationManager;
  
  // Config
  final SensorConfig config;
  
  // Collection state
  bool _isCollecting = false;
  Timer? _dataCollectionTimer;
  final List<PhoneSensorData> _dataBuffer = [];
  
  // Data controllers
  final StreamController<PhoneSensorData> _dataStreamController = 
      StreamController<PhoneSensorData>.broadcast();
  
  /// Creates a new SensorService instance with the specified configuration
  SensorService({
    this.config = const SensorConfig(),
    this.isDebugMode = false,
    SensorManager? sensorManager,
    LocationManager? locationManager,
    bool initLogging = true,
  }) {
    if (isDebugMode && initLogging) {
      Logger.root.level = Level.ALL;
      Logger.root.onRecord.listen((record) {
        // ignore: avoid_print
        print('${record.level.name}: ${record.time}: ${record.message}');
      });
    }
    
    // Initialize managers
    _sensorManager = sensorManager ?? SensorManagerImpl(config: config);
    _locationManager = locationManager ?? LocationManagerImpl(config: config);
    
    _logger.info('SensorService created with config: ${config.toString()}');
  }
  
  /// Whether the service is currently collecting data
  bool get isCollecting => _isCollecting;
  
  /// Stream of sensor data updates
  Stream<PhoneSensorData> get dataStream => _dataStreamController.stream;
  
  /// The buffer of collected data
  List<PhoneSensorData> get dataBuffer => List.unmodifiable(_dataBuffer);
  
  /// Initialize the sensor service
  Future<void> initialize() async {
    _logger.info('Initializing sensor service');
    
    try {
      // Initialize sensors
      await _sensorManager.initialize();
      
      // Initialize location
      await _locationManager.initialize();
      
      _logger.info('Sensor service initialized successfully');
    } catch (e) {
      _logger.severe('Error initializing sensor service: $e');
    }
    
    notifyListeners();
  }
  
  /// Start collecting sensor data
  Future<void> startCollection({int collectionIntervalMs = 100}) async {
    if (_isCollecting) return;
    
    _logger.info('Starting sensor data collection');
    _isCollecting = true;
    
    // Start individual managers if they aren't already running
    _sensorManager.startCollection();
    _locationManager.startCollection();
    
    // Set up timer for periodic data collection
    _dataCollectionTimer = Timer.periodic(
      Duration(milliseconds: collectionIntervalMs), 
      _collectData
    );
    
    notifyListeners();
  }
  
  /// Stop collecting sensor data
  void stopCollection() {
    if (!_isCollecting) return;
    
    _logger.info('Stopping sensor data collection');
    _isCollecting = false;
    
    // Stop collection timer
    _dataCollectionTimer?.cancel();
    _dataCollectionTimer = null;
    
    notifyListeners();
  }
  
  /// Clear the data buffer
  void clearDataBuffer() {
    _dataBuffer.clear();
    notifyListeners();
  }
  
  /// Get the latest sensor data
  Future<PhoneSensorData> getLatestSensorData() async {
    return _collectSensorData();
  }
  
  /// Periodic collection callback
  void _collectData(Timer timer) async {
    try {
      final data = await _collectSensorData();
      
      // Add to buffer
      _dataBuffer.add(data);
      
      // Limit buffer size to prevent memory issues
      if (_dataBuffer.length > 1000) {
        _dataBuffer.removeAt(0);
      }
      
      // Send to stream
      _dataStreamController.add(data);
    } catch (e) {
      _logger.warning('Error collecting sensor data: $e');
    }
  }
  
  /// Collect and combine all sensor data
  Future<PhoneSensorData> _collectSensorData() async {
    final timestamp = DateTime.now();
    
    // Get the latest sensor readings
    final accel = _sensorManager.latestAccelerometer;
    final gyro = _sensorManager.latestGyroscope;
    final magnet = _sensorManager.latestMagnetometer;
    
    // Get location data
    Position? position = _locationManager.lastPosition;
    
    // If we don't have a recent position, try to get the current one
    try {
      position ??= await _locationManager.getCurrentPosition();
    } catch (e) {
      _logger.warning('Failed to get position: $e');
      // Position will remain null, the rest of the method handles this case
    }
    
    // Calculate total acceleration if components are available
    double? totalAcceleration;
    if (accel != null) {
      totalAcceleration = PhoneSensorData.calculateTotalAcceleration(
        accel.x, accel.y, accel.z);
    }
    
    // Construct and return the data model
    return PhoneSensorData(
      timestamp: timestamp,
      latitude: position?.latitude,
      longitude: position?.longitude,
      altitude: position?.altitude,
      gpsSpeed: position?.speed,
      gpsAccuracy: position?.accuracy,
      gpsHeading: position?.heading,
      accelerationX: accel?.x,
      accelerationY: accel?.y,
      accelerationZ: accel?.z,
      gyroX: gyro?.x,
      gyroY: gyro?.y,
      gyroZ: gyro?.z,
      magneticX: magnet?.x,
      magneticY: magnet?.y,
      magneticZ: magnet?.z,
      totalAcceleration: totalAcceleration,
    );
  }
  
  /// Clean up resources
  @override
  void dispose() {
    _logger.info('Disposing sensor service');
    
    stopCollection();
    
    _sensorManager.dispose();
    _locationManager.dispose();
    _dataStreamController.close();
    
    super.dispose();
  }
} 

################################################################################
FILE: lib/sensor_lib/sensor_factory.dart
################################################################################

import 'interfaces/sensor_manager.dart';
import 'interfaces/location_manager.dart';
import 'implementations/sensor_manager_impl.dart';
import 'implementations/location_manager_impl.dart';
import 'models/sensor_config.dart';

/// Factory for creating sensor components
///
/// This factory allows for easy creation of sensor components with different
/// configurations or replacements with mocks for testing.
class SensorFactory {
  /// Create a sensor manager
  static SensorManager createSensorManager({
    SensorConfig? config,
    bool useMock = false,
  }) {
    if (useMock) {
      // Return a mock implementation for testing
      throw UnimplementedError('Mock sensor manager not implemented');
    }
    
    // Return the standard implementation
    return SensorManagerImpl(config: config ?? const SensorConfig());
  }
  
  /// Create a location manager
  static LocationManager createLocationManager({
    SensorConfig? config,
    bool useMock = false,
  }) {
    if (useMock) {
      // Return a mock implementation for testing
      throw UnimplementedError('Mock location manager not implemented');
    }
    
    // Return the standard implementation
    return LocationManagerImpl(config: config ?? const SensorConfig());
  }
  
  /// Create sensor components with shared configuration
  static ({SensorManager sensors, LocationManager location}) createComponents({
    SensorConfig? config,
    bool useMock = false,
  }) {
    final effectiveConfig = config ?? const SensorConfig();
    
    return (
      sensors: createSensorManager(config: effectiveConfig, useMock: useMock),
      location: createLocationManager(config: effectiveConfig, useMock: useMock),
    );
  }
} 

################################################################################
FILE: lib/sensor_lib/models/sensor_config.dart
################################################################################

import 'package:geolocator/geolocator.dart';

/// Configuration options for sensor collection
class SensorConfig {
  /// Frequency of accelerometer readings in Hz
  final int accelerometerFrequency;
  
  /// Frequency of gyroscope readings in Hz
  final int gyroscopeFrequency;
  
  /// Frequency of magnetometer readings in Hz
  final int magnetometerFrequency;
  
  /// Frequency of location updates in seconds
  final int locationUpdateIntervalMs;
  
  /// Accuracy level for location data
  final LocationAccuracy locationAccuracy;
  
  /// Minimum distance (in meters) between location updates
  final int locationDistanceFilter;
  
  /// Whether to collect accelerometer data
  final bool collectAccelerometer;
  
  /// Whether to collect gyroscope data
  final bool collectGyroscope;
  
  /// Whether to collect magnetometer data
  final bool collectMagnetometer;
  
  /// Whether to collect location data
  final bool collectLocation;
  
  /// Constructor
  const SensorConfig({
    this.accelerometerFrequency = 10,
    this.gyroscopeFrequency = 10,
    this.magnetometerFrequency = 10,
    this.locationUpdateIntervalMs = 1000, // Every second
    this.locationAccuracy = LocationAccuracy.high,
    this.locationDistanceFilter = 5,
    this.collectAccelerometer = true,
    this.collectGyroscope = true,
    this.collectMagnetometer = true,
    this.collectLocation = true,
  });
  
  /// Default configuration suitable for eco-driving analysis
  static const SensorConfig ecoDrivingConfig = SensorConfig(
    accelerometerFrequency: 20, // Higher frequency for sudden movements
    gyroscopeFrequency: 10,
    magnetometerFrequency: 5,
    locationUpdateIntervalMs: 1000,
    locationAccuracy: LocationAccuracy.high,
    locationDistanceFilter: 5,
  );
  
  /// Configuration for low power usage
  static const SensorConfig lowPowerConfig = SensorConfig(
    accelerometerFrequency: 5,
    gyroscopeFrequency: 5,
    magnetometerFrequency: 2,
    locationUpdateIntervalMs: 5000, // Every 5 seconds
    locationAccuracy: LocationAccuracy.medium,
    locationDistanceFilter: 20,
  );
  
  /// Create a new SensorConfig with modified parameters
  SensorConfig copyWith({
    int? accelerometerFrequency,
    int? gyroscopeFrequency,
    int? magnetometerFrequency,
    int? locationUpdateIntervalMs,
    LocationAccuracy? locationAccuracy,
    int? locationDistanceFilter,
    bool? collectAccelerometer,
    bool? collectGyroscope,
    bool? collectMagnetometer,
    bool? collectLocation,
  }) {
    return SensorConfig(
      accelerometerFrequency: accelerometerFrequency ?? this.accelerometerFrequency,
      gyroscopeFrequency: gyroscopeFrequency ?? this.gyroscopeFrequency,
      magnetometerFrequency: magnetometerFrequency ?? this.magnetometerFrequency,
      locationUpdateIntervalMs: locationUpdateIntervalMs ?? this.locationUpdateIntervalMs,
      locationAccuracy: locationAccuracy ?? this.locationAccuracy,
      locationDistanceFilter: locationDistanceFilter ?? this.locationDistanceFilter,
      collectAccelerometer: collectAccelerometer ?? this.collectAccelerometer,
      collectGyroscope: collectGyroscope ?? this.collectGyroscope,
      collectMagnetometer: collectMagnetometer ?? this.collectMagnetometer,
      collectLocation: collectLocation ?? this.collectLocation,
    );
  }
} 

################################################################################
FILE: lib/sensor_lib/implementations/location_manager_impl.dart
################################################################################

import 'dart:async';

import 'package:geolocator/geolocator.dart';
import 'package:logging/logging.dart';

import '../interfaces/location_manager.dart';
import '../models/sensor_config.dart';

/// Implementation of the LocationManager interface
class LocationManagerImpl implements LocationManager {
  final Logger _logger = Logger('LocationManager');
  final SensorConfig config;
  
  // Location data
  Position? _lastPosition;
  StreamSubscription<Position>? _positionSubscription;
  final StreamController<Position> _positionController = StreamController<Position>.broadcast();
  
  bool _isCollecting = false;
  
  /// Create a new LocationManagerImpl with the given configuration
  LocationManagerImpl({this.config = const SensorConfig()});
  
  @override
  Future<void> initialize() async {
    _logger.info('Initializing location manager');
    
    if (!config.collectLocation) {
      _logger.info('Location collection disabled by configuration');
      return;
    }
    
    try {
      // Check if location services are enabled
      final enabled = await isLocationServiceEnabled;
      if (!enabled) {
        _logger.warning('Location services are disabled');
        return;
      }
      
      // Request permission
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          _logger.warning('Location permissions denied');
          return;
        }
      }
      
      if (permission == LocationPermission.deniedForever) {
        _logger.warning('Location permissions permanently denied');
        return;
      }
      
      // Start collection
      startCollection();
    } catch (e) {
      _logger.severe('Error initializing location manager: $e');
    }
  }
  
  @override
  Future<bool> get isLocationServiceEnabled => Geolocator.isLocationServiceEnabled();
  
  @override
  Position? get lastPosition => _lastPosition;
  
  @override
  Stream<Position> get positionStream => _positionController.stream;
  
  @override
  Future<Position?> getCurrentPosition() async {
    try {
      if (_lastPosition != null) {
        return _lastPosition;
      }
      
      final position = await Geolocator.getCurrentPosition(
        desiredAccuracy: config.locationAccuracy,
        timeLimit: const Duration(seconds: 5) // Increase timeout to 5 seconds
      ).timeout(
        const Duration(seconds: 5), // Increase timeout to 5 seconds
        onTimeout: () {
          _logger.warning('Timeout while getting position, using last known position');
          // Return default position to avoid null
          return _lastPosition ?? Position(
            longitude: 0, 
            latitude: 0, 
            timestamp: DateTime.now(),
            accuracy: 0,
            altitude: 0, 
            heading: 0,
            speed: 0,
            speedAccuracy: 0,
            altitudeAccuracy: 0,
            headingAccuracy: 0
          );
        }
      );
      
      _lastPosition = position;
      return position;
    } catch (e) {
      _logger.warning('Error getting current position: $e');
      // Return the last position or a default position instead of null
      return _lastPosition ?? Position(
        longitude: 0, 
        latitude: 0, 
        timestamp: DateTime.now(),
        accuracy: 0,
        altitude: 0, 
        heading: 0,
        speed: 0,
        speedAccuracy: 0,
        altitudeAccuracy: 0,
        headingAccuracy: 0
      );
    }
  }
  
  @override
  void startCollection({
    LocationAccuracy? accuracy,
    int? distanceFilter,
    int? timeInterval,
  }) {
    if (_isCollecting) return;
    
    _logger.info('Starting location data collection');
    _isCollecting = true;
    
    try {
      // Use provided parameters or fall back to config values
      final locationSettings = LocationSettings(
        accuracy: accuracy ?? config.locationAccuracy,
        distanceFilter: distanceFilter ?? config.locationDistanceFilter,
        timeLimit: Duration(milliseconds: timeInterval ?? config.locationUpdateIntervalMs * 5), // Increase timeout 5x
      );
      
      _positionSubscription = Geolocator.getPositionStream(
        locationSettings: locationSettings,
      ).listen((Position position) {
        _lastPosition = position;
        _positionController.add(position);
      }, onError: (error) {
        // Handle errors from the position stream
        _logger.warning('Error in position stream: $error');
        // Don't propagate errors to prevent app crashes
      });
    } catch (e) {
      _logger.severe('Error starting location collection: $e');
      _isCollecting = false;
    }
  }
  
  @override
  void stopCollection() {
    if (!_isCollecting) return;
    
    _logger.info('Stopping location data collection');
    _isCollecting = false;
    
    _positionSubscription?.cancel();
    _positionSubscription = null;
  }
  
  @override
  void dispose() {
    _logger.info('Disposing location manager');
    
    stopCollection();
    _positionController.close();
  }
} 

################################################################################
FILE: lib/sensor_lib/implementations/sensor_manager_impl.dart
################################################################################

import 'dart:async';

import 'package:sensors_plus/sensors_plus.dart';
import 'package:logging/logging.dart';

import '../interfaces/sensor_manager.dart';
import '../models/sensor_config.dart';

/// Implementation of the SensorManager interface
class SensorManagerImpl implements SensorManager {
  final Logger _logger = Logger('SensorManager');
  final SensorConfig config;
  
  // Store the latest sensor readings
  AccelerometerEvent? _latestAccelerometer;
  GyroscopeEvent? _latestGyroscope;
  MagnetometerEvent? _latestMagnetometer;
  UserAccelerometerEvent? _latestUserAccelerometer;
  
  // Stream subscriptions
  StreamSubscription<AccelerometerEvent>? _accelerometerSubscription;
  StreamSubscription<GyroscopeEvent>? _gyroscopeSubscription;
  StreamSubscription<MagnetometerEvent>? _magnetometerSubscription;
  StreamSubscription<UserAccelerometerEvent>? _userAccelerometerSubscription;
  
  // Stream controllers for custom event frequencies
  final StreamController<AccelerometerEvent> _accelerometerController = 
      StreamController<AccelerometerEvent>.broadcast();
  final StreamController<GyroscopeEvent> _gyroscopeController = 
      StreamController<GyroscopeEvent>.broadcast();
  final StreamController<MagnetometerEvent> _magnetometerController = 
      StreamController<MagnetometerEvent>.broadcast();
  final StreamController<UserAccelerometerEvent> _userAccelerometerController = 
      StreamController<UserAccelerometerEvent>.broadcast();
  
  bool _isCollecting = false;
  
  /// Create a new SensorManagerImpl with the given configuration
  SensorManagerImpl({this.config = const SensorConfig()});
  
  @override
  Future<void> initialize() async {
    _logger.info('Initializing sensor manager');
    
    // Start collection if config says so
    if (config.collectAccelerometer || 
        config.collectGyroscope || 
        config.collectMagnetometer) {
      startCollection();
    }
  }

  @override
  AccelerometerEvent? get latestAccelerometer => _latestAccelerometer;

  @override
  GyroscopeEvent? get latestGyroscope => _latestGyroscope;

  @override
  MagnetometerEvent? get latestMagnetometer => _latestMagnetometer;

  @override
  UserAccelerometerEvent? get latestUserAccelerometer => _latestUserAccelerometer;

  @override
  Stream<AccelerometerEvent> get accelerometerStream => _accelerometerController.stream;

  @override
  Stream<GyroscopeEvent> get gyroscopeStream => _gyroscopeController.stream;

  @override
  Stream<MagnetometerEvent> get magnetometerStream => _magnetometerController.stream;

  @override
  Stream<UserAccelerometerEvent> get userAccelerometerStream => _userAccelerometerController.stream;
  
  @override
  void startCollection() {
    if (_isCollecting) return;
    
    _logger.info('Starting sensor data collection');
    _isCollecting = true;
    
    // Subscribe to accelerometer events
    if (config.collectAccelerometer) {
      _accelerometerSubscription = accelerometerEventStream().listen((event) {
        _latestAccelerometer = event;
        _accelerometerController.add(event);
      });
      
      _userAccelerometerSubscription = userAccelerometerEventStream().listen((event) {
        _latestUserAccelerometer = event;
        _userAccelerometerController.add(event);
      });
    }
    
    // Subscribe to gyroscope events
    if (config.collectGyroscope) {
      _gyroscopeSubscription = gyroscopeEventStream().listen((event) {
        _latestGyroscope = event;
        _gyroscopeController.add(event);
      });
    }
    
    // Subscribe to magnetometer events
    if (config.collectMagnetometer) {
      _magnetometerSubscription = magnetometerEventStream().listen((event) {
        _latestMagnetometer = event;
        _magnetometerController.add(event);
      });
    }
  }
  
  @override
  void stopCollection() {
    if (!_isCollecting) return;
    
    _logger.info('Stopping sensor data collection');
    _isCollecting = false;
    
    _accelerometerSubscription?.cancel();
    _accelerometerSubscription = null;
    
    _gyroscopeSubscription?.cancel();
    _gyroscopeSubscription = null;
    
    _magnetometerSubscription?.cancel();
    _magnetometerSubscription = null;
    
    _userAccelerometerSubscription?.cancel();
    _userAccelerometerSubscription = null;
  }
  
  @override
  void dispose() {
    _logger.info('Disposing sensor manager');
    
    stopCollection();
    
    _accelerometerController.close();
    _gyroscopeController.close();
    _magnetometerController.close();
    _userAccelerometerController.close();
  }
} 

################################################################################
FILE: lib/sensor_lib/interfaces/location_manager.dart
################################################################################

import 'package:geolocator/geolocator.dart';

/// Interface for location management
abstract class LocationManager {
  /// Initialize the location manager and request permissions
  Future<void> initialize();

  /// Check if location services are enabled
  Future<bool> get isLocationServiceEnabled;

  /// Get the current position
  Future<Position?> getCurrentPosition();

  /// Get a stream of position updates
  Stream<Position> get positionStream;

  /// Get the last known position
  Position? get lastPosition;

  /// Start collecting location data
  void startCollection({
    LocationAccuracy accuracy = LocationAccuracy.high,
    int distanceFilter = 5, // meters
    int timeInterval = 1000, // milliseconds
  });

  /// Stop collecting location data
  void stopCollection();

  /// Clean up resources
  void dispose();
} 

################################################################################
FILE: lib/sensor_lib/interfaces/sensor_manager.dart
################################################################################

import 'package:sensors_plus/sensors_plus.dart';

/// Interface for sensor management
abstract class SensorManager {
  /// Initialize the sensor manager and start collecting data
  Future<void> initialize();

  /// Latest accelerometer reading
  AccelerometerEvent? get latestAccelerometer;

  /// Latest gyroscope reading
  GyroscopeEvent? get latestGyroscope;

  /// Latest magnetometer reading (if available)
  MagnetometerEvent? get latestMagnetometer;

  /// Latest user accelerometer reading (gravity removed)
  UserAccelerometerEvent? get latestUserAccelerometer;

  /// Get a stream of accelerometer events
  Stream<AccelerometerEvent> get accelerometerStream;

  /// Get a stream of gyroscope events
  Stream<GyroscopeEvent> get gyroscopeStream;

  /// Get a stream of magnetometer events
  Stream<MagnetometerEvent> get magnetometerStream;

  /// Get a stream of user accelerometer events
  Stream<UserAccelerometerEvent> get userAccelerometerStream;

  /// Start collecting sensor data
  void startCollection();

  /// Stop collecting sensor data
  void stopCollection();

  /// Clean up resources
  void dispose();
} 

################################################################################
FILE: lib/navigation/tab_navigator.dart
################################################################################

import 'package:flutter/material.dart';
import '../core/constants/route_constants.dart';
import '../core/theme/app_colors.dart';
import '../presentation/screens/drive/drive_screen.dart';
import '../presentation/screens/insights/insights_screen.dart';
import '../presentation/screens/community/community_screen.dart';
import '../presentation/screens/profile/profile_screen.dart';

/// TabNavigator handles tab-based navigation for the application.
/// 
/// This class manages the bottom navigation bar and tab switching.
class TabNavigator extends StatefulWidget {
  /// Optional initial route to determine which tab to show first
  final String? initialRoute;

  /// Creates a tab navigator widget
  const TabNavigator({
    super.key,
    this.initialRoute,
  });

  @override
  State<TabNavigator> createState() => _TabNavigatorState();
}

class _TabNavigatorState extends State<TabNavigator> {
  int _currentIndex = 0;
  
  // The list of tab screens
  final List<Widget> _screens = [
    const DriveScreen(),
    const InsightsScreen(),
    const CommunityScreen(),
    const ProfileScreen(),
  ];
  
  // The tab configuration data
  final List<_TabItem> _tabs = [
    _TabItem(
      index: 0,
      label: 'Drive',
      route: TabRoutes.driveTab,
      icon: Icons.directions_car_outlined,
      activeIcon: Icons.directions_car,
    ),
    _TabItem(
      index: 1,
      label: 'Insights',
      route: TabRoutes.insightsTab,
      icon: Icons.insights_outlined,
      activeIcon: Icons.insights,
    ),
    _TabItem(
      index: 2,
      label: 'Community',
      route: TabRoutes.communityTab,
      icon: Icons.people_outline,
      activeIcon: Icons.people,
    ),
    _TabItem(
      index: 3,
      label: 'Profile',
      route: TabRoutes.profileTab,
      icon: Icons.person_outline,
      activeIcon: Icons.person,
    ),
  ];

  @override
  void initState() {
    super.initState();
    
    // Set the initial tab based on the initial route if provided
    if (widget.initialRoute != null) {
      _setInitialTab(widget.initialRoute!);
    }
  }
  
  /// Sets the initial tab based on the provided route
  void _setInitialTab(String route) {
    for (int i = 0; i < _tabs.length; i++) {
      if (_tabs[i].route == route) {
        setState(() {
          _currentIndex = i;
        });
        return;
      }
    }
  }

  void _onTabTapped(int index) {
    setState(() {
      _currentIndex = index;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _screens[_currentIndex],
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _currentIndex,
        onTap: _onTabTapped,
        type: BottomNavigationBarType.fixed,
        selectedItemColor: AppColors.primary,
        unselectedItemColor: AppColors.neutralGray,
        items: _tabs.map((tab) => BottomNavigationBarItem(
          icon: Icon(tab.icon),
          activeIcon: Icon(tab.activeIcon),
          label: tab.label,
        )).toList(),
      ),
    );
  }
}

/// Helper class to store tab item data
class _TabItem {
  final int index;
  final String label;
  final String route;
  final IconData icon;
  final IconData activeIcon;
  
  const _TabItem({
    required this.index,
    required this.label,
    required this.route,
    required this.icon,
    required this.activeIcon,
  });
} 

################################################################################
FILE: lib/navigation/app_router.dart
################################################################################

import 'package:flutter/material.dart';
import '../core/constants/route_constants.dart';
import '../presentation/screens/onboarding/welcome_screen.dart';
import '../presentation/screens/onboarding/value_carousel_screen.dart';
import '../presentation/screens/onboarding/account_choice_screen.dart';
import '../presentation/screens/onboarding/connection_setup_screen.dart';
import '../presentation/screens/drive/active_drive_screen.dart';
import '../presentation/screens/drive/trip_summary_screen.dart';
import '../presentation/screens/insights/trip_history_screen.dart';
import '../presentation/screens/insights/trip_detail_screen.dart';
import '../presentation/screens/profile/settings_screen.dart';
import '../presentation/screens/profile/privacy_settings_screen.dart';
import '../presentation/screens/profile/device_connection_screen.dart';
import '../presentation/screens/profile/data_management_screen.dart';
import '../presentation/screens/community/challenge_detail_screen.dart';
import '../presentation/screens/community/friend_profile_screen.dart';
import '../navigation/tab_navigator.dart';

/// AppRouter handles route management for the application.
/// 
/// This class provides methods to generate routes and navigate between screens.
class AppRouter {
  /// Generate routes for the application
  static Route<dynamic> generateRoute(RouteSettings settings) {
    switch (settings.name) {
      // Tab routes are handled by the TabNavigator, so we don't need cases for them
      // Add tab routes to handle direct navigation to tabs
      case TabRoutes.driveTab:
      case TabRoutes.insightsTab:
      case TabRoutes.communityTab:
      case TabRoutes.profileTab:
        // For all tab routes, return the TabNavigator (it will handle showing the correct tab)
        return MaterialPageRoute(
          builder: (_) => TabNavigator(initialRoute: settings.name),
        );
      
      // Drive routes
      case DriveRoutes.activeDrive:
        return MaterialPageRoute(
          builder: (_) => const ActiveDriveScreen(),
        );
        
      case DriveRoutes.tripSummary:
        final tripId = settings.arguments as String?;
        return MaterialPageRoute(
          builder: (_) => TripSummaryScreen(tripId: tripId),
        );
        
      // Insights routes
      case InsightsRoutes.tripHistory:
        return MaterialPageRoute(
          builder: (_) => const TripHistoryScreen(),
        );
        
      case InsightsRoutes.tripDetail:
        final tripId = settings.arguments as String;
        return MaterialPageRoute(
          builder: (_) => TripDetailScreen(tripId: tripId),
        );
        
      // Community routes
      case CommunityRoutes.leaderboard:
        return MaterialPageRoute(
          builder: (_) => const Scaffold(
            body: Center(child: Text('Leaderboard Screen - To be implemented')),
          ),
        );
        
      case CommunityRoutes.challenges:
        return MaterialPageRoute(
          builder: (_) => const Scaffold(
            body: Center(child: Text('Challenges Screen - To be implemented')),
          ),
        );
        
      case CommunityRoutes.challengeDetail:
        final challengeId = settings.arguments as String;
        return MaterialPageRoute(
          builder: (_) => ChallengeDetailScreen(challengeId: challengeId),
        );
        
      case CommunityRoutes.friendProfile:
        final friendId = settings.arguments as String;
        return MaterialPageRoute(
          builder: (_) => FriendProfileScreen(friendId: friendId),
        );
        
      // Profile routes
      case ProfileRoutes.settings:
        return MaterialPageRoute(
          builder: (_) => const SettingsScreen(),
        );
        
      case ProfileRoutes.privacySettings:
        return MaterialPageRoute(
          builder: (_) => const PrivacySettingsScreen(),
        );
        
      case ProfileRoutes.deviceConnection:
        return MaterialPageRoute(
          builder: (_) => const DeviceConnectionScreen(),
        );
        
      case ProfileRoutes.dataManagement:
        // Extract the arguments if present
        final Map<String, dynamic> args = settings.arguments as Map<String, dynamic>? ?? {};
        final bool scrollToReset = args['scrollToReset'] as bool? ?? false;
        
        return MaterialPageRoute(
          builder: (_) => DataManagementScreen(scrollToReset: scrollToReset),
        );
        
      // Onboarding routes
      case OnboardingRoutes.welcome:
        return MaterialPageRoute(
          builder: (context) => WelcomeScreen(
            onGetStarted: () => Navigator.of(context).pushNamed(OnboardingRoutes.valueCarousel),
          ),
        );
        
      case OnboardingRoutes.valueCarousel:
        return MaterialPageRoute(
          builder: (context) => ValueCarouselScreen(
            onNext: () => Navigator.of(context).pushNamed(OnboardingRoutes.accountChoice),
            onSkip: () => Navigator.of(context).pushNamed(OnboardingRoutes.accountChoice),
          ),
        );
        
      case OnboardingRoutes.accountChoice:
        return MaterialPageRoute(
          builder: (context) => AccountChoiceScreen(
            onContinue: () => Navigator.of(context).pushNamed(OnboardingRoutes.connectionSetup),
          ),
        );
        
      case OnboardingRoutes.connectionSetup:
        final VoidCallback? onComplete = settings.arguments as VoidCallback?;
        return MaterialPageRoute(
          builder: (context) => ConnectionSetupScreen(
            onContinue: onComplete ?? () => Navigator.of(context).pushReplacementNamed(TabRoutes.driveTab),
          ),
        );
        
      // Default case for unknown routes
      default:
        return MaterialPageRoute(
          builder: (_) => Scaffold(
            body: Center(
              child: Text('No route defined for ${settings.name}'),
            ),
          ),
        );
    }
  }
} 

################################################################################
FILE: lib/navigation/route_names.dart
################################################################################

/// Export route constants for easy importing
library;
export '../core/constants/route_constants.dart'; 

################################################################################
FILE: lib/core_models/data_model.md
################################################################################

## Core Models Structure

The data model is organized into several key areas:

1. **Trip Tracking**: Records individual journeys with detailed metrics
2. **Driving Data**: Captures OBD-II and phone sensor data during trips
3. **User Management**: Handles user profiles and preferences
4. **Performance Analysis**: Analyzes driving patterns and provides feedback
5. **Gamification**: Implements challenges, badges, and streaks to encourage engagement
6. **Social Features**: Enables social connections and content sharing
7. **Privacy Controls**: Manages user data privacy preferences

## Model Relationships

![Data Model Relationships](https://mermaid.ink/img/pako:eNqFVE1v2zAM_SuETj2sPrRpgGGnDTm0QzegQC7GLAe2RcdCZcmQ5LRB0f8-ynaSuEE3X0z-PJGPpE7KWQ9Kqo5S9H47vXMm5wQ9vMbI-PbA2HEKLjE3thfgwwdmsadX_AYWe91fHx6Z3znN3c33N3Y0hsTdrHlHWr8FOMiYuYWxQw8eIvuPKZDZpoBkPn54vLm-aS5QmcgWmINhM2LZpR9o6D0m1skzJBzCaHSCCXpvfWUyvf-qDKV9Yjx46E3S0NXmXBvcWdOPHScXxjRZYRrNOV-OXtCFZL1GzYnZ7TDIHcRjYEfX3x1XuHOz1FPRCLvzaV5JdGu8nS00sUuRpzlDRGfynNu15xO6Rss_JUEw09ZZXyTGdASHHdoVfXaGc-3-D8bsECOHYx2XLnLqDbtI3rLjMGQKFgXZY0wctHPejkOKWNXBJ4Xx8BoiCVWjWpwgmhxrPfHKaDbOrSYPu4jZWYOZXdBQ63O5lKGQw2a1Uo3dLlRnxZVb9BCMw_6Sjp44LAvxOsjdXvnVwkJXwJUtFB0GF2aSP7QqS12V6gPV2_Fv0j0KXIUe8wI_XKqgdMfPchldmFnOQ0NvLSUYvs2sNfiYhSmQh0_vVUJFqiKqoYrXoTKqLWZ-WrwQspUFxVZVQXpPT2O_oGNV8LMuTF6JdF63jcuzcpFVZSkOtfS-WOWJ7Xpx-G2oDt-P7ZGjXOoKZXXIZ0QlpymXopuSajjJSmVcveFXJNKZyuKrKE6TH3-8RPE4_ewYK-YDFWWpDrgvCZUumvtj1KQYLKmRq5TnedwGFzZFDyW_OgYVuSDnNe989mKO6_JkJd9_QfIf)

## Detailed Model Descriptions

### 1. Trip Related Models

#### Trip
- **Description**: Represents a single journey taken by a user
- **Key Attributes**:
  - `id`: Unique identifier
  - `startTime`: When the trip began
  - `endTime`: When the trip ended
  - `distanceKm`: Total distance traveled
  - `averageSpeedKmh`: Average speed
  - `maxSpeedKmh`: Maximum speed reached
  - `fuelUsedL`: Estimated fuel consumption
  - Various event counters (idling, aggressive acceleration, etc.)
  - `isCompleted`: Whether the trip has ended
  - `ecoScore`: Overall eco-efficiency score
  - `routeDataJson`: Geographical route data
  - `userId`: Reference to the user who took the trip

#### TripDataPoint
- **Description**: Time-series data recorded during a trip
- **Key Attributes**:
  - `tripId`: Reference to the trip
  - `timestamp`: When the data point was recorded
  - `latitude` & `longitude`: Location coordinates
  - `speed`: Vehicle speed in km/h
  - `acceleration`: Vehicle acceleration in m/s²
  - `rpm`: Engine RPM
  - `throttlePosition`: Accelerator position in percentage
  - `engineLoad`: Engine load in percentage
  - `fuelRate`: Fuel consumption rate in L/h
  - `rawDataJson`: Additional data in JSON format

#### DrivingEvent
- **Description**: Significant events detected during driving
- **Key Attributes**:
  - `tripId`: Reference to the trip
  - `timestamp`: When the event occurred
  - `eventType`: Type of event (e.g., hard braking, aggressive acceleration)
  - `severity`: How severe the event was (0.0 to 1.0)
  - `latitude` & `longitude`: Location where the event occurred
  - `detailsJson`: Additional event details in JSON format

### 2. User Management Models

#### UserProfile
- **Description**: Represents a user of the application
- **Key Attributes**:
  - `id`: Unique identifier
  - `name`: User's name
  - `createdAt`: Account creation date
  - `lastUpdatedAt`: Last profile update date
  - `isPublic`: Whether the profile is publicly visible
  - `allowDataUpload`: Whether the user allows data to be uploaded
  - `preferencesJson`: User preferences in JSON format

#### DataPrivacySettings
- **Description**: User's privacy preferences for different data types
- **Key Attributes**:
  - `userId`: Reference to the user
  - `dataType`: Type of data (trips, location, driving events, etc.)
  - `allowLocalStorage`: Whether data can be stored locally
  - `allowCloudSync`: Whether data can be synced to the cloud
  - `allowSharing`: Whether data can be shared with others
  - `allowAnonymizedAnalytics`: Whether anonymized data can be used for analytics

#### UserPreferences
- **Description**: Detailed user preferences for various app features
- **Key Attributes**:
  - `userId`: Reference to the user
  - `preferenceCategory`: Category of preference (feedback, gamification, UI, etc.)
  - `preferenceName`: Name of the specific preference
  - `preferenceValue`: Value of the preference in JSON format
  - `updatedAt`: When the preference was last updated

### 3. Performance Analysis Models

#### PerformanceMetrics
- **Description**: Aggregated driving performance data over a period
- **Key Attributes**:
  - `userId`: Reference to the user
  - `generatedAt`: When the metrics were calculated
  - `periodStart` & `periodEnd`: Time range for the metrics
  - `totalTrips`: Number of trips in the period
  - `totalDistanceKm`: Total distance driven
  - `totalDrivingTimeMinutes`: Total time spent driving
  - Various score metrics (calm driving, speed optimization, etc.)
  - `overallScore`: Overall eco-driving score
  - `improvementTipsJson`: Personalized tips for improvement

#### FeedbackEffectiveness
- **Description**: Tracks how effective different types of feedback are for a user
- **Key Attributes**:
  - `userId`: Reference to the user
  - `feedbackType`: Type of feedback (gentle reminder, direct instruction, etc.)
  - `drivingBehaviorType`: Behavior targeted by the feedback
  - `timesDelivered`: How many times the feedback was given
  - `timesBehaviorImproved`: How many times the behavior improved after feedback
  - `effectivenessRatio`: Ratio of improvement to delivery
  - `lastUpdated`: When the record was last updated

### 4. Gamification Models

#### Challenge
- **Description**: Represents a challenge that users can undertake
- **Key Attributes**:
  - `title`: Name of the challenge
  - `description`: What the challenge involves
  - `type`: Type of challenge (daily, weekly, achievement)
  - `targetValue`: Target to achieve for completion
  - `metricType`: What metric is being measured
  - `isSystem`: Whether it's a system challenge or user-created
  - `creatorId`: Reference to the creator if user-created
  - `difficultyLevel`: How difficult the challenge is (1-5)
  - `rewardType` & `rewardValue`: What the user gets for completing it

#### UserChallenge
- **Description**: Tracks a user's progress on a specific challenge
- **Key Attributes**:
  - `userId`: Reference to the user
  - `challengeId`: Reference to the challenge
  - `startedAt`: When the user started the challenge
  - `completedAt`: When the user completed the challenge
  - `progress`: Current progress toward completion
  - `isCompleted`: Whether the challenge is complete
  - `rewardClaimed`: Whether the reward has been claimed

#### Badge
- **Description**: Represents achievements earned by users
- **Key Attributes**:
  - `userId`: Reference to the user
  - `badgeType`: Type of badge (eco master, smooth driver, etc.)
  - `earnedDate`: When the badge was earned
  - `level`: Level of the badge (1+)
  - `metadataJson`: Additional badge information

#### Streak
- **Description**: Tracks consecutive activity completion
- **Key Attributes**:
  - `userId`: Reference to the user
  - `streakType`: Type of streak (daily drive, eco score, etc.)
  - `currentCount`: Current streak count
  - `bestCount`: Best streak ever achieved
  - `lastRecorded`: When the streak was last updated
  - `nextDue`: When the next activity is due to maintain the streak
  - `isActive`: Whether the streak is currently active

#### LeaderboardEntry
- **Description**: Represents a user's position on a leaderboard
- **Key Attributes**:
  - `leaderboardType`: Type of leaderboard (global, regional, friends)
  - `timeframe`: Time period (daily, weekly, monthly, all-time)
  - `userId`: Reference to the user
  - `regionCode`: Optional region for regional leaderboards
  - `rank`: User's position on the leaderboard
  - `score`: User's score
  - `recordedAt`: When the entry was recorded
  - `daysRetained`: How many days the rank has been maintained

### 5. Social Feature Models

#### SocialConnection
- **Description**: Represents a connection between users
- **Key Attributes**:
  - `userId`: Reference to the user
  - `connectedUserId`: Reference to the connected user
  - `connectionType`: Type of connection (friend, following)
  - `connectedSince`: When the connection was established
  - `isMutual`: Whether the connection is mutual

#### SocialInteraction
- **Description**: Represents interactions with content
- **Key Attributes**:
  - `userId`: Reference to the user
  - `contentType`: Type of content (trip, achievement, milestone)
  - `contentId`: Reference to the content
  - `interactionType`: Type of interaction (like, comment, share)
  - `content`: Text content for comments
  - `timestamp`: When the interaction occurred

#### SharedContent
- **Description**: Represents content shared by a user
- **Key Attributes**:
  - `userId`: Reference to the user
  - `contentType`: Type of content (trip, achievement, eco score)
  - `contentId`: Reference to the content
  - `shareType`: How it was shared (public, friends, external)
  - `externalPlatform`: If shared externally, where it was shared
  - `shareUrl`: Public URL if generated
  - `sharedAt`: When it was shared
  - `isActive`: Whether the share is still active

### 6. External Integration Models

#### ExternalIntegration
- **Description**: Represents a connection to an external platform
- **Key Attributes**:
  - `userId`: Reference to the user
  - `platformType`: Type of platform (Uber, Lyft, Apple CarPlay, etc.)
  - `externalId`: User ID on the external platform
  - `integrationStatus`: Status of the integration (active, pending, revoked)
  - `connectedAt`: When the integration was established
  - `lastSyncAt`: When data was last synced
  - `accessToken` & `refreshToken`: Authentication tokens
  - `integrationDataJson`: Platform-specific settings

#### SyncStatus
- **Description**: Tracks synchronization status for entities
- **Key Attributes**:
  - `userId`: Reference to the user
  - `entityType`: Type of entity (trip, badge, challenge, etc.)
  - `entityId`: Reference to the entity
  - `targetPlatform`: Platform being synced to
  - `syncStatus`: Status of the sync (pending, synced, failed)
  - `lastAttemptAt`: When sync was last attempted
  - `retryCount`: Number of retry attempts
  - `errorMessage`: Error message if sync failed

## Database Schema

The database is implemented using the drift package (formerly moor), which provides type-safe database access for Flutter applications. The database schema includes tables for all the models described above, with appropriate relationships between them.

################################################################################
FILE: lib/core_models/combined_driving_data.dart
################################################################################

import 'package:going50/core_models/obd_II_data.dart';
import 'package:going50/core_models/phone_sensor_data.dart';
import 'package:going50/core_models/optional_context_data.dart';

// Combined Data Model (for algorithms)
class CombinedDrivingData {
  final DateTime timestamp;
  final OBDIIData? obdData;
  final PhoneSensorData? sensorData;
  final OptionalContextData? contextData;
  
  // Derived real-time metrics (calculated from raw data)
  final double? calculatedAcceleration; // km/h/s
  final bool? isIdling;
  final bool? isAggressive;
  final bool? isOptimalSpeed;
  final bool? isHighRPM;
  final double? estimatedFollowDistance; // seconds
  
  CombinedDrivingData({
    required this.timestamp,
    this.obdData,
    this.sensorData,
    this.contextData,
    this.calculatedAcceleration,
    this.isIdling,
    this.isAggressive,
    this.isOptimalSpeed,
    this.isHighRPM,
    this.estimatedFollowDistance,
  });
  
  // Factory constructor to combine data sources
  factory CombinedDrivingData.combine({
    required DateTime timestamp,
    OBDIIData? obdData,
    PhoneSensorData? sensorData,
    OptionalContextData? contextData,
  }) {
    // Get speed from best available source
    double? speed = obdData?.vehicleSpeed ?? sensorData?.gpsSpeed;
    
    // Calculate acceleration (simplified - should use previous data points)
    double? calculatedAcceleration;
    
    // Determine if idling
    bool? isIdling;
    if (obdData?.engineRunning == true && (speed == null || speed < 1.0)) {
      isIdling = true;
    } else if (obdData?.engineRunning == true && speed != null && speed >= 1.0) {
      isIdling = false;
    }
    
    // Determine if speed is in optimal range (50-75 km/h)
    bool? isOptimalSpeed;
    if (speed != null) {
      isOptimalSpeed = (speed >= 50.0 && speed <= 75.0);
    }
    
    // Determine if RPM is higher than optimal
    bool? isHighRPM;
    if (obdData?.rpm != null && obdData?.vehicleSpeed != null) {
      // Simplified logic - actual implementation would need gear ratios
      double rpmPerSpeed = obdData!.rpm! / obdData.vehicleSpeed!;
      isHighRPM = rpmPerSpeed > 70; // Arbitrary threshold, needs calibration
    }
    
    return CombinedDrivingData(
      timestamp: timestamp,
      obdData: obdData,
      sensorData: sensorData,
      contextData: contextData,
      calculatedAcceleration: calculatedAcceleration,
      isIdling: isIdling,
      isAggressive: null, // Requires calculation using previous data points
      isOptimalSpeed: isOptimalSpeed,
      isHighRPM: isHighRPM,
      estimatedFollowDistance: null, // Requires sensor data not directly available
    );
  }
  
  Map<String, dynamic> toJson() {
    return {
      'timestamp': timestamp.toIso8601String(),
      'obdData': obdData?.toJson(),
      'sensorData': sensorData?.toJson(),
      'contextData': contextData?.toJson(),
      'calculatedAcceleration': calculatedAcceleration,
      'isIdling': isIdling,
      'isAggressive': isAggressive,
      'isOptimalSpeed': isOptimalSpeed,
      'isHighRPM': isHighRPM,
      'estimatedFollowDistance': estimatedFollowDistance,
    };
  }
}


################################################################################
FILE: lib/core_models/optional_context_data.dart
################################################################################


// Model for Optional External Data
class OptionalContextData {
  final DateTime timestamp;
  
  // Road & Traffic Data
  final int? speedLimit; // km/h
  final String? roadType; // highway, urban, rural
  final double? slope; // % grade
  final int? trafficDensity; // scale 1-10
  final bool? isTrafficJam;
  
  // Weather Data
  final double? temperature; // Celsius
  final double? precipitation; // mm/h
  final double? windSpeed; // km/h
  final String? weatherCondition; // clear, rain, snow, etc.
  
  // User Input
  final bool? userConfirmedDriving;
  final String? transmissionType; // manual/automatic
  
  OptionalContextData({
    required this.timestamp,
    this.speedLimit,
    this.roadType,
    this.slope,
    this.trafficDensity,
    this.isTrafficJam,
    this.temperature,
    this.precipitation,
    this.windSpeed,
    this.weatherCondition,
    this.userConfirmedDriving,
    this.transmissionType,
  });

  factory OptionalContextData.fromJson(Map<String, dynamic> json) {
    return OptionalContextData(
      timestamp: DateTime.parse(json['timestamp']),
      speedLimit: json['speedLimit'],
      roadType: json['roadType'],
      slope: json['slope'],
      trafficDensity: json['trafficDensity'],
      isTrafficJam: json['isTrafficJam'],
      temperature: json['temperature'],
      precipitation: json['precipitation'],
      windSpeed: json['windSpeed'],
      weatherCondition: json['weatherCondition'],
      userConfirmedDriving: json['userConfirmedDriving'],
      transmissionType: json['transmissionType'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'timestamp': timestamp.toIso8601String(),
      'speedLimit': speedLimit,
      'roadType': roadType,
      'slope': slope,
      'trafficDensity': trafficDensity,
      'isTrafficJam': isTrafficJam,
      'temperature': temperature,
      'precipitation': precipitation,
      'windSpeed': windSpeed,
      'weatherCondition': weatherCondition,
      'userConfirmedDriving': userConfirmedDriving,
      'transmissionType': transmissionType,
    };
  }
}


################################################################################
FILE: lib/core_models/driving_event.dart
################################################################################

// Event model to track specific eco-driving events
class DrivingEvent {
  final String id;
  final String tripId;
  final DateTime timestamp;
  final String eventType; // 'idling', 'aggressive_acceleration', 'hard_braking', 'excessive_speed', etc.
  final double severity; // 0.0 to 1.0 representing event severity
  final double? magnitude; // Severity of the event (e.g., acceleration rate)
  final double? latitude;
  final double? longitude;
  final Map<String, dynamic>? additionalData;
  
  DrivingEvent({
    required this.id,
    required this.tripId,
    required this.timestamp,
    required this.eventType,
    required this.severity,
    this.magnitude,
    this.latitude,
    this.longitude,
    this.additionalData,
  });

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'tripId': tripId,
      'timestamp': timestamp.toIso8601String(),
      'eventType': eventType,
      'severity': severity,
      'magnitude': magnitude,
      'latitude': latitude,
      'longitude': longitude,
      'additionalData': additionalData,
    };
  }
  
  factory DrivingEvent.fromJson(Map<String, dynamic> json) {
    return DrivingEvent(
      id: json['id'],
      tripId: json['tripId'],
      timestamp: DateTime.parse(json['timestamp']),
      eventType: json['eventType'],
      severity: json['severity'],
      magnitude: json['magnitude'],
      latitude: json['latitude'],
      longitude: json['longitude'],
      additionalData: json['additionalData'],
    );
  }
}


################################################################################
FILE: lib/core_models/driver_performance_metrics.dart
################################################################################

import 'package:intl/intl.dart';

/// Represents a collection of performance metrics for a driver over a period of time
/// Used for tracking progress and providing feedback on eco-driving behaviors
class DriverPerformanceMetrics {
  /// When these metrics were generated
  final DateTime generatedAt;
  
  /// Start of the period these metrics cover
  final DateTime periodStart;
  
  /// End of the period these metrics cover
  final DateTime periodEnd;
  
  /// Total number of trips in this period
  final int totalTrips;
  
  /// Total distance driven in kilometers
  final double totalDistanceKm;
  
  /// Total time spent driving in minutes
  final double totalDrivingTimeMinutes;
  
  /// Average speed in km/h across all trips
  final double averageSpeedKmh;
  
  /// Estimated fuel savings in liters (if available)
  final double? estimatedFuelSavingsL;
  
  /// Estimated CO2 reduction in kg (if available)
  final double? estimatedCO2ReductionKg;
  
  // Behavior-specific scores (0-100)
  
  /// Score for smooth acceleration/braking (0-100)
  final int calmDrivingScore;
  
  /// Score for maintaining optimal speed (0-100)
  final int speedOptimizationScore;
  
  /// Score for minimizing idle time (0-100)
  final int idlingScore;
  
  /// Score for avoiding unnecessary short trips (0-100)
  final int shortDistanceScore;
  
  /// Score for optimal RPM management (0-100)
  final int rpmManagementScore;
  
  /// Score for efficient stop management (0-100)
  final int stopManagementScore;
  
  /// Score for maintaining safe following distance (0-100)
  final int followDistanceScore;
  
  /// Overall eco-driving score (0-100)
  final int overallEcoScore;
  
  /// List of recommended improvements
  final List<String> improvementRecommendations;

  DriverPerformanceMetrics({
    required this.generatedAt,
    required this.periodStart,
    required this.periodEnd,
    required this.totalTrips,
    required this.totalDistanceKm,
    required this.totalDrivingTimeMinutes,
    required this.averageSpeedKmh,
    this.estimatedFuelSavingsL,
    this.estimatedCO2ReductionKg,
    required this.calmDrivingScore,
    required this.speedOptimizationScore,
    required this.idlingScore,
    required this.shortDistanceScore,
    required this.rpmManagementScore,
    required this.stopManagementScore,
    required this.followDistanceScore,
    required this.overallEcoScore,
    required this.improvementRecommendations,
  });

  /// Convert to JSON representation
  Map<String, dynamic> toJson() {
    final dateFormat = DateFormat('yyyy-MM-dd HH:mm:ss');
    
    return {
      'generatedAt': dateFormat.format(generatedAt),
      'periodStart': dateFormat.format(periodStart),
      'periodEnd': dateFormat.format(periodEnd),
      'totalTrips': totalTrips,
      'totalDistanceKm': totalDistanceKm,
      'totalDrivingTimeMinutes': totalDrivingTimeMinutes,
      'averageSpeedKmh': averageSpeedKmh,
      'estimatedFuelSavingsL': estimatedFuelSavingsL,
      'estimatedCO2ReductionKg': estimatedCO2ReductionKg,
      'calmDrivingScore': calmDrivingScore,
      'speedOptimizationScore': speedOptimizationScore,
      'idlingScore': idlingScore,
      'shortDistanceScore': shortDistanceScore,
      'rpmManagementScore': rpmManagementScore,
      'stopManagementScore': stopManagementScore,
      'followDistanceScore': followDistanceScore,
      'overallEcoScore': overallEcoScore,
      'improvementRecommendations': improvementRecommendations,
    };
  }

  /// Create from JSON data
  factory DriverPerformanceMetrics.fromJson(Map<String, dynamic> json) {
    final dateFormat = DateFormat('yyyy-MM-dd HH:mm:ss');
    
    return DriverPerformanceMetrics(
      generatedAt: dateFormat.parse(json['generatedAt']),
      periodStart: dateFormat.parse(json['periodStart']),
      periodEnd: dateFormat.parse(json['periodEnd']),
      totalTrips: json['totalTrips'],
      totalDistanceKm: json['totalDistanceKm'].toDouble(),
      totalDrivingTimeMinutes: json['totalDrivingTimeMinutes'].toDouble(),
      averageSpeedKmh: json['averageSpeedKmh'].toDouble(),
      estimatedFuelSavingsL: json['estimatedFuelSavingsL']?.toDouble(),
      estimatedCO2ReductionKg: json['estimatedCO2ReductionKg']?.toDouble(),
      calmDrivingScore: json['calmDrivingScore'],
      speedOptimizationScore: json['speedOptimizationScore'],
      idlingScore: json['idlingScore'],
      shortDistanceScore: json['shortDistanceScore'],
      rpmManagementScore: json['rpmManagementScore'],
      stopManagementScore: json['stopManagementScore'],
      followDistanceScore: json['followDistanceScore'],
      overallEcoScore: json['overallEcoScore'],
      improvementRecommendations: List<String>.from(json['improvementRecommendations']),
    );
  }
}


################################################################################
FILE: lib/core_models/gamification_models.dart
################################################################################


/// Challenge represents a specific goal or task for users.
/// 
/// Challenges can be system-generated or user-created, supporting
/// the gamification requirements in the application.
class Challenge {
  final String id;
  final String title;
  final String description;
  final String type; // 'daily', 'weekly', 'achievement'
  final int targetValue;
  final String metricType; // 'calmDriving', 'idling', etc.
  final bool isSystem;
  final String? creatorId; // If user-created
  final bool isActive;
  final int difficultyLevel; // 1-5
  final String? iconName;
  final String? rewardType; // Points, badge, etc.
  final int rewardValue;
  
  Challenge({
    required this.id,
    required this.title,
    required this.description,
    required this.type,
    required this.targetValue,
    required this.metricType,
    this.isSystem = true,
    this.creatorId,
    this.isActive = true,
    this.difficultyLevel = 1,
    this.iconName,
    this.rewardType,
    this.rewardValue = 0,
  });
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'type': type,
    'targetValue': targetValue,
    'metricType': metricType,
    'isSystem': isSystem,
    'creatorId': creatorId,
    'isActive': isActive,
    'difficultyLevel': difficultyLevel,
    'iconName': iconName,
    'rewardType': rewardType,
    'rewardValue': rewardValue,
  };
  
  factory Challenge.fromJson(Map<String, dynamic> json) => 
    Challenge(
      id: json['id'],
      title: json['title'],
      description: json['description'],
      type: json['type'],
      targetValue: json['targetValue'],
      metricType: json['metricType'],
      isSystem: json['isSystem'] ?? true,
      creatorId: json['creatorId'],
      isActive: json['isActive'] ?? true,
      difficultyLevel: json['difficultyLevel'] ?? 1,
      iconName: json['iconName'],
      rewardType: json['rewardType'],
      rewardValue: json['rewardValue'] ?? 0,
    );
    
  /// Create a copy of this object with the specified fields updated
  Challenge copyWith({
    String? id,
    String? title,
    String? description,
    String? type,
    int? targetValue,
    String? metricType,
    bool? isSystem,
    String? creatorId,
    bool? isActive,
    int? difficultyLevel,
    String? iconName,
    String? rewardType,
    int? rewardValue,
  }) {
    return Challenge(
      id: id ?? this.id,
      title: title ?? this.title,
      description: description ?? this.description,
      type: type ?? this.type,
      targetValue: targetValue ?? this.targetValue,
      metricType: metricType ?? this.metricType,
      isSystem: isSystem ?? this.isSystem,
      creatorId: creatorId ?? this.creatorId,
      isActive: isActive ?? this.isActive,
      difficultyLevel: difficultyLevel ?? this.difficultyLevel,
      iconName: iconName ?? this.iconName,
      rewardType: rewardType ?? this.rewardType,
      rewardValue: rewardValue ?? this.rewardValue,
    );
  }
}

/// UserChallenge tracks a user's progress on a particular challenge.
/// 
/// This links users to challenges and tracks their completion status.
class UserChallenge {
  final String id;
  final String userId;
  final String challengeId;
  final DateTime startedAt;
  final DateTime? completedAt;
  final int progress;
  final bool isCompleted;
  final bool rewardClaimed;
  
  UserChallenge({
    required this.id,
    required this.userId,
    required this.challengeId,
    required this.startedAt,
    this.completedAt,
    this.progress = 0,
    this.isCompleted = false,
    this.rewardClaimed = false,
  });
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'challengeId': challengeId,
    'startedAt': startedAt.toIso8601String(),
    'completedAt': completedAt?.toIso8601String(),
    'progress': progress,
    'isCompleted': isCompleted,
    'rewardClaimed': rewardClaimed,
  };
  
  factory UserChallenge.fromJson(Map<String, dynamic> json) => 
    UserChallenge(
      id: json['id'],
      userId: json['userId'],
      challengeId: json['challengeId'],
      startedAt: DateTime.parse(json['startedAt']),
      completedAt: json['completedAt'] != null ? DateTime.parse(json['completedAt']) : null,
      progress: json['progress'] ?? 0,
      isCompleted: json['isCompleted'] ?? false,
      rewardClaimed: json['rewardClaimed'] ?? false,
    );
    
  /// Update progress and check if challenge is now completed
  UserChallenge copyWithProgress(int newProgress, int targetValue) {
    final bool nowComplete = newProgress >= targetValue;
    return UserChallenge(
      id: id,
      userId: userId,
      challengeId: challengeId,
      startedAt: startedAt,
      completedAt: nowComplete && !isCompleted ? DateTime.now() : completedAt,
      progress: newProgress,
      isCompleted: nowComplete,
      rewardClaimed: rewardClaimed,
    );
  }
  
  /// Mark the reward as claimed
  UserChallenge copyWithRewardClaimed() {
    return UserChallenge(
      id: id,
      userId: userId,
      challengeId: challengeId,
      startedAt: startedAt,
      completedAt: completedAt,
      progress: progress, 
      isCompleted: isCompleted,
      rewardClaimed: true,
    );
  }
  
  /// Create a copy of this object with the specified fields updated
  UserChallenge copyWith({
    String? id,
    String? userId,
    String? challengeId,
    DateTime? startedAt,
    DateTime? completedAt,
    int? progress,
    bool? isCompleted,
    bool? rewardClaimed,
  }) {
    return UserChallenge(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      challengeId: challengeId ?? this.challengeId,
      startedAt: startedAt ?? this.startedAt,
      completedAt: completedAt ?? this.completedAt,
      progress: progress ?? this.progress,
      isCompleted: isCompleted ?? this.isCompleted,
      rewardClaimed: rewardClaimed ?? this.rewardClaimed,
    );
  }
}

/// Streak tracks consecutive activity completion.
/// 
/// This supports maintaining user engagement through streaks of daily/weekly activities.
class Streak {
  final String id;
  final String userId;
  final String streakType; // 'daily_drive', 'eco_score', etc.
  final int currentCount;
  final int bestCount;
  final DateTime lastRecorded;
  final DateTime nextDue;
  final bool isActive;
  
  Streak({
    required this.id,
    required this.userId,
    required this.streakType,
    this.currentCount = 0,
    this.bestCount = 0,
    required this.lastRecorded,
    required this.nextDue,
    this.isActive = true,
  });
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'streakType': streakType,
    'currentCount': currentCount,
    'bestCount': bestCount,
    'lastRecorded': lastRecorded.toIso8601String(),
    'nextDue': nextDue.toIso8601String(),
    'isActive': isActive,
  };
  
  factory Streak.fromJson(Map<String, dynamic> json) => 
    Streak(
      id: json['id'],
      userId: json['userId'],
      streakType: json['streakType'],
      currentCount: json['currentCount'] ?? 0,
      bestCount: json['bestCount'] ?? 0,
      lastRecorded: DateTime.parse(json['lastRecorded']),
      nextDue: DateTime.parse(json['nextDue']),
      isActive: json['isActive'] ?? true,
    );
    
  /// Increment the streak when a user completes an activity
  Streak incrementStreak() {
    final now = DateTime.now();
    final newCount = currentCount + 1;
    return Streak(
      id: id,
      userId: userId,
      streakType: streakType,
      currentCount: newCount,
      bestCount: newCount > bestCount ? newCount : bestCount,
      lastRecorded: now,
      nextDue: _calculateNextDue(now, streakType),
      isActive: true,
    );
  }
  
  /// Reset the streak when a user misses an activity
  Streak breakStreak() {
    final now = DateTime.now();
    return Streak(
      id: id,
      userId: userId,
      streakType: streakType,
      currentCount: 0,
      bestCount: bestCount,
      lastRecorded: now,
      nextDue: _calculateNextDue(now, streakType),
      isActive: true,
    );
  }
  
  /// Calculate the next due date based on streak type
  DateTime _calculateNextDue(DateTime current, String type) {
    if (type == 'daily_drive') {
      return DateTime(current.year, current.month, current.day + 1);
    } else if (type == 'weekly_summary') {
      return DateTime(current.year, current.month, current.day + 7);
    }
    // Default to next day
    return DateTime(current.year, current.month, current.day + 1);
  }
  
  /// Create a copy of this object with the specified fields updated
  Streak copyWith({
    String? id,
    String? userId,
    String? streakType,
    int? currentCount,
    int? bestCount,
    DateTime? lastRecorded,
    DateTime? nextDue,
    bool? isActive,
  }) {
    return Streak(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      streakType: streakType ?? this.streakType,
      currentCount: currentCount ?? this.currentCount,
      bestCount: bestCount ?? this.bestCount,
      lastRecorded: lastRecorded ?? this.lastRecorded,
      nextDue: nextDue ?? this.nextDue,
      isActive: isActive ?? this.isActive,
    );
  }
}

/// LeaderboardEntry represents a user's position on a leaderboard.
/// 
/// This supports the social and competitive aspects of the application.
class LeaderboardEntry {
  final String id;
  final String leaderboardType; // 'global', 'regional', 'friends'
  final String timeframe; // 'daily', 'weekly', 'monthly', 'alltime'
  final String userId;
  final String? regionCode; // Optional region
  final int rank;
  final int score;
  final DateTime recordedAt;
  final int daysRetained;
  
  LeaderboardEntry({
    required this.id,
    required this.leaderboardType,
    required this.timeframe,
    required this.userId,
    this.regionCode,
    required this.rank,
    required this.score,
    required this.recordedAt,
    this.daysRetained = 0,
  });
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'leaderboardType': leaderboardType,
    'timeframe': timeframe,
    'userId': userId,
    'regionCode': regionCode,
    'rank': rank,
    'score': score,
    'recordedAt': recordedAt.toIso8601String(),
    'daysRetained': daysRetained,
  };
  
  factory LeaderboardEntry.fromJson(Map<String, dynamic> json) => 
    LeaderboardEntry(
      id: json['id'],
      leaderboardType: json['leaderboardType'],
      timeframe: json['timeframe'],
      userId: json['userId'],
      regionCode: json['regionCode'],
      rank: json['rank'],
      score: json['score'],
      recordedAt: DateTime.parse(json['recordedAt']),
      daysRetained: json['daysRetained'] ?? 0,
    );
    
  /// Create a copy of this object with the specified fields updated
  LeaderboardEntry copyWith({
    String? id,
    String? leaderboardType,
    String? timeframe,
    String? userId,
    String? regionCode,
    int? rank,
    int? score,
    DateTime? recordedAt,
    int? daysRetained,
  }) {
    return LeaderboardEntry(
      id: id ?? this.id,
      leaderboardType: leaderboardType ?? this.leaderboardType,
      timeframe: timeframe ?? this.timeframe,
      userId: userId ?? this.userId,
      regionCode: regionCode ?? this.regionCode,
      rank: rank ?? this.rank,
      score: score ?? this.score,
      recordedAt: recordedAt ?? this.recordedAt,
      daysRetained: daysRetained ?? this.daysRetained,
    );
  }
} 

################################################################################
FILE: lib/core_models/social_models.dart
################################################################################


/// Represents a connection between users in the social features system.
/// 
/// This supports REQ-1.4 and REQ-1.8 for social integration and connection tracking.
class SocialConnection {
  final String id;
  final String userId;
  final String connectedUserId;
  final String connectionType; // 'friend', 'following'
  final DateTime connectedSince;
  final bool isMutual;
  
  SocialConnection({
    required this.id,
    required this.userId,
    required this.connectedUserId,
    required this.connectionType,
    required this.connectedSince,
    this.isMutual = false,
  });
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'connectedUserId': connectedUserId,
    'connectionType': connectionType,
    'connectedSince': connectedSince.toIso8601String(),
    'isMutual': isMutual,
  };
  
  factory SocialConnection.fromJson(Map<String, dynamic> json) => 
    SocialConnection(
      id: json['id'],
      userId: json['userId'],
      connectedUserId: json['connectedUserId'],
      connectionType: json['connectionType'],
      connectedSince: DateTime.parse(json['connectedSince']),
      isMutual: json['isMutual'] ?? false,
    );
    
  /// Create a copy of this object with the specified fields updated
  SocialConnection copyWith({
    String? id,
    String? userId,
    String? connectedUserId,
    String? connectionType,
    DateTime? connectedSince,
    bool? isMutual,
  }) {
    return SocialConnection(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      connectedUserId: connectedUserId ?? this.connectedUserId,
      connectionType: connectionType ?? this.connectionType,
      connectedSince: connectedSince ?? this.connectedSince,
      isMutual: isMutual ?? this.isMutual,
    );
  }
}

/// Represents user interactions with content in the social features system.
/// 
/// This supports tracking likes, comments, and other engagement metrics
/// for social content sharing.
class SocialInteraction {
  final String id;
  final String userId;
  final String contentType; // 'trip', 'achievement', 'milestone'
  final String contentId;
  final String interactionType; // 'like', 'comment', 'share'
  final String? content; // For comments, etc.
  final DateTime timestamp;
  
  SocialInteraction({
    required this.id,
    required this.userId,
    required this.contentType,
    required this.contentId,
    required this.interactionType,
    this.content,
    required this.timestamp,
  });
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'contentType': contentType,
    'contentId': contentId,
    'interactionType': interactionType,
    'content': content,
    'timestamp': timestamp.toIso8601String(),
  };
  
  factory SocialInteraction.fromJson(Map<String, dynamic> json) => 
    SocialInteraction(
      id: json['id'],
      userId: json['userId'],
      contentType: json['contentType'],
      contentId: json['contentId'],
      interactionType: json['interactionType'],
      content: json['content'],
      timestamp: DateTime.parse(json['timestamp']),
    );
    
  /// Create a copy of this object with the specified fields updated
  SocialInteraction copyWith({
    String? id,
    String? userId,
    String? contentType,
    String? contentId,
    String? interactionType,
    String? content,
    DateTime? timestamp,
  }) {
    return SocialInteraction(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      contentType: contentType ?? this.contentType,
      contentId: contentId ?? this.contentId,
      interactionType: interactionType ?? this.interactionType,
      content: content ?? this.content,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

/// Represents content that has been shared by a user through the social system.
/// 
/// This supports REQ-1.4 and REQ-1.8 for content sharing and social features.
class SharedContent {
  final String id;
  final String userId;
  final String contentType; // 'trip', 'achievement', 'ecoScore'
  final String contentId;
  final String shareType; // 'public', 'friends', 'external'
  final String? externalPlatform; // If external, where it was shared
  final String? shareUrl; // Public URL if generated
  final DateTime sharedAt;
  final bool isActive;
  
  SharedContent({
    required this.id,
    required this.userId,
    required this.contentType,
    required this.contentId,
    required this.shareType,
    this.externalPlatform,
    this.shareUrl,
    required this.sharedAt,
    this.isActive = true,
  });
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'contentType': contentType,
    'contentId': contentId,
    'shareType': shareType,
    'externalPlatform': externalPlatform,
    'shareUrl': shareUrl,
    'sharedAt': sharedAt.toIso8601String(),
    'isActive': isActive,
  };
  
  factory SharedContent.fromJson(Map<String, dynamic> json) => 
    SharedContent(
      id: json['id'],
      userId: json['userId'],
      contentType: json['contentType'],
      contentId: json['contentId'],
      shareType: json['shareType'],
      externalPlatform: json['externalPlatform'],
      shareUrl: json['shareUrl'],
      sharedAt: DateTime.parse(json['sharedAt']),
      isActive: json['isActive'] ?? true,
    );
    
  /// Create a copy of this object with the specified fields updated
  SharedContent copyWith({
    String? id,
    String? userId,
    String? contentType,
    String? contentId,
    String? shareType,
    String? externalPlatform,
    String? shareUrl,
    DateTime? sharedAt,
    bool? isActive,
  }) {
    return SharedContent(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      contentType: contentType ?? this.contentType,
      contentId: contentId ?? this.contentId,
      shareType: shareType ?? this.shareType,
      externalPlatform: externalPlatform ?? this.externalPlatform,
      shareUrl: shareUrl ?? this.shareUrl,
      sharedAt: sharedAt ?? this.sharedAt,
      isActive: isActive ?? this.isActive,
    );
  }
} 

################################################################################
FILE: lib/core_models/phone_sensor_data.dart
################################################################################

import 'dart:math' show sqrt;

// Model for Phone Sensor data
class PhoneSensorData {
  final DateTime timestamp;
  
  // GPS Data
  final double? latitude;
  final double? longitude;
  final double? altitude; // meters
  final double? gpsSpeed; // km/h
  final double? gpsAccuracy; // meters
  final double? gpsHeading; // degrees
  
  // Accelerometer Data
  final double? accelerationX; // m/s²
  final double? accelerationY; // m/s²
  final double? accelerationZ; // m/s²
  
  // Gyroscope Data
  final double? gyroX; // rad/s
  final double? gyroY; // rad/s
  final double? gyroZ; // rad/s
  
  // Magnetometer Data
  final double? magneticX; // µT
  final double? magneticY; // µT
  final double? magneticZ; // µT
  
  // Derived calculations
  final double? totalAcceleration; // magnitude of acceleration vector
  
  PhoneSensorData({
    required this.timestamp,
    this.latitude,
    this.longitude,
    this.altitude,
    this.gpsSpeed,
    this.gpsAccuracy,
    this.gpsHeading,
    this.accelerationX,
    this.accelerationY,
    this.accelerationZ,
    this.gyroX,
    this.gyroY,
    this.gyroZ,
    this.magneticX,
    this.magneticY,
    this.magneticZ,
    this.totalAcceleration,
  });

  factory PhoneSensorData.fromJson(Map<String, dynamic> json) {
    return PhoneSensorData(
      timestamp: DateTime.parse(json['timestamp']),
      latitude: json['latitude'],
      longitude: json['longitude'],
      altitude: json['altitude'],
      gpsSpeed: json['gpsSpeed'],
      gpsAccuracy: json['gpsAccuracy'],
      gpsHeading: json['gpsHeading'],
      accelerationX: json['accelerationX'],
      accelerationY: json['accelerationY'],
      accelerationZ: json['accelerationZ'],
      gyroX: json['gyroX'],
      gyroY: json['gyroY'],
      gyroZ: json['gyroZ'],
      magneticX: json['magneticX'],
      magneticY: json['magneticY'],
      magneticZ: json['magneticZ'],
      totalAcceleration: json['totalAcceleration'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'timestamp': timestamp.toIso8601String(),
      'latitude': latitude,
      'longitude': longitude,
      'altitude': altitude,
      'gpsSpeed': gpsSpeed,
      'gpsAccuracy': gpsAccuracy,
      'gpsHeading': gpsHeading,
      'accelerationX': accelerationX,
      'accelerationY': accelerationY,
      'accelerationZ': accelerationZ,
      'gyroX': gyroX,
      'gyroY': gyroY,
      'gyroZ': gyroZ,
      'magneticX': magneticX,
      'magneticY': magneticY,
      'magneticZ': magneticZ,
      'totalAcceleration': totalAcceleration,
    };
  }
  
  // Calculate acceleration magnitude if x,y,z components are available
  static double? calculateTotalAcceleration(double? x, double? y, double? z) {
    if (x != null && y != null && z != null) {
      return sqrt(x * x + y * y + z * z);
    }
    return null;
  }
}


################################################################################
FILE: lib/core_models/data_privacy_settings.dart
################################################################################


/// DataPrivacySettings defines user preferences for privacy controls on various data types.
///
/// This model enables granular control over how different types of data are stored,
/// shared, and analyzed, supporting REQ-5.4 for privacy controls.
class DataPrivacySettings {
  final String id;
  final String userId;
  final String dataType; // 'trips', 'location', 'driving_events', etc.
  final bool allowLocalStorage;
  final bool allowCloudSync;
  final bool allowSharing;
  final bool allowAnonymizedAnalytics;
  
  DataPrivacySettings({
    required this.id,
    required this.userId,
    required this.dataType,
    this.allowLocalStorage = true,
    this.allowCloudSync = false,
    this.allowSharing = false,
    this.allowAnonymizedAnalytics = true,
  });
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'dataType': dataType,
    'allowLocalStorage': allowLocalStorage,
    'allowCloudSync': allowCloudSync,
    'allowSharing': allowSharing,
    'allowAnonymizedAnalytics': allowAnonymizedAnalytics,
  };
  
  factory DataPrivacySettings.fromJson(Map<String, dynamic> json) => 
    DataPrivacySettings(
      id: json['id'],
      userId: json['userId'],
      dataType: json['dataType'],
      allowLocalStorage: json['allowLocalStorage'] ?? true,
      allowCloudSync: json['allowCloudSync'] ?? false,
      allowSharing: json['allowSharing'] ?? false,
      allowAnonymizedAnalytics: json['allowAnonymizedAnalytics'] ?? true,
    );
    
  /// Create a copy of this object with the specified fields updated
  DataPrivacySettings copyWith({
    String? id,
    String? userId,
    String? dataType,
    bool? allowLocalStorage,
    bool? allowCloudSync,
    bool? allowSharing,
    bool? allowAnonymizedAnalytics,
  }) {
    return DataPrivacySettings(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      dataType: dataType ?? this.dataType,
      allowLocalStorage: allowLocalStorage ?? this.allowLocalStorage,
      allowCloudSync: allowCloudSync ?? this.allowCloudSync,
      allowSharing: allowSharing ?? this.allowSharing,
      allowAnonymizedAnalytics: allowAnonymizedAnalytics ?? this.allowAnonymizedAnalytics,
    );
  }
} 

################################################################################
FILE: lib/core_models/user_profile.dart
################################################################################

import 'dart:convert';

/// UserProfile represents a user of the application
/// 
/// This model stores basic information about the user
/// and their privacy preferences.
class UserProfile {
  final String id;
  final String name;
  final DateTime createdAt;
  final DateTime lastUpdatedAt;
  final bool isPublic;
  final bool allowDataUpload;
  final Map<String, dynamic>? preferences;
  
  // Firebase-related fields
  final String? firebaseId;  // Firebase User UID
  final String? email;       // User email address
  
  /// Constructor
  UserProfile({
    required this.id,
    required this.name,
    required this.createdAt,
    DateTime? lastUpdatedAt,
    required this.isPublic,
    required this.allowDataUpload,
    this.preferences,
    this.firebaseId,
    this.email,
  }) : lastUpdatedAt = lastUpdatedAt ?? createdAt;
  
  /// Convert to JSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'createdAt': createdAt.toIso8601String(),
      'lastUpdatedAt': lastUpdatedAt.toIso8601String(),
      'isPublic': isPublic,
      'allowDataUpload': allowDataUpload,
      'preferencesJson': preferences != null ? jsonEncode(preferences) : null,
      'firebaseId': firebaseId,
      'email': email,
    };
  }
  
  /// Create from JSON
  factory UserProfile.fromJson(Map<String, dynamic> json) {
    // Parse preferences JSON if it exists
    Map<String, dynamic>? prefsMap;
    if (json['preferencesJson'] != null) {
      try {
        prefsMap = jsonDecode(json['preferencesJson']) as Map<String, dynamic>;
      } catch (e) {
        // Ignore parsing errors, just use null
      }
    }
    
    return UserProfile(
      id: json['id'],
      name: json['name'] ?? 'Anonymous',
      createdAt: json['createdAt'] != null ? 
          DateTime.parse(json['createdAt']) : 
          DateTime.now(),
      lastUpdatedAt: json['lastUpdatedAt'] != null ? 
          DateTime.parse(json['lastUpdatedAt']) : 
          null,
      isPublic: json['isPublic'] ?? false,
      allowDataUpload: json['allowDataUpload'] ?? false,
      preferences: prefsMap,
      firebaseId: json['firebaseId'],
      email: json['email'],
    );
  }
  
  /// Create a copy with updated fields
  UserProfile copyWith({
    String? id,
    String? name,
    DateTime? createdAt,
    DateTime? lastUpdatedAt,
    bool? isPublic,
    bool? allowDataUpload,
    Map<String, dynamic>? preferences,
    String? firebaseId,
    String? email,
  }) {
    return UserProfile(
      id: id ?? this.id,
      name: name ?? this.name,
      createdAt: createdAt ?? this.createdAt,
      lastUpdatedAt: lastUpdatedAt ?? this.lastUpdatedAt,
      isPublic: isPublic ?? this.isPublic,
      allowDataUpload: allowDataUpload ?? this.allowDataUpload,
      preferences: preferences ?? this.preferences,
      firebaseId: firebaseId ?? this.firebaseId,
      email: email ?? this.email,
    );
  }
} 

################################################################################
FILE: lib/core_models/user_preferences.dart
################################################################################

import 'dart:convert';

/// UserPreference represents a single user preference setting.
/// 
/// Preferences are stored as key-value pairs organized by category
/// to support REQ-1.2 for personalization and adaptive feedback.
class UserPreference {
  final String id;
  final String userId;
  final String preferenceCategory; // 'feedback', 'gamification', 'ui', etc.
  final String preferenceName;
  final dynamic preferenceValue;
  final DateTime updatedAt;
  
  UserPreference({
    required this.id,
    required this.userId,
    required this.preferenceCategory,
    required this.preferenceName,
    required this.preferenceValue,
    required this.updatedAt,
  });
  
  Map<String, dynamic> toJson() {
    var valueToStore = preferenceValue;
    
    // Ensure complex objects are properly JSON encoded
    if (preferenceValue != null && 
        preferenceValue is! String && 
        preferenceValue is! num && 
        preferenceValue is! bool) {
      valueToStore = jsonEncode(preferenceValue);
    }
    
    return {
      'id': id,
      'userId': userId,
      'preferenceCategory': preferenceCategory,
      'preferenceName': preferenceName,
      'preferenceValue': valueToStore,
      'updatedAt': updatedAt.toIso8601String(),
    };
  }
  
  factory UserPreference.fromJson(Map<String, dynamic> json) {
    var value = json['preferenceValue'];
    
    // Try to decode JSON string values
    if (value is String) {
      try {
        value = jsonDecode(value);
      } catch (_) {
        // Not a JSON string, use as is
      }
    }
    
    return UserPreference(
      id: json['id'],
      userId: json['userId'],
      preferenceCategory: json['preferenceCategory'],
      preferenceName: json['preferenceName'],
      preferenceValue: value,
      updatedAt: DateTime.parse(json['updatedAt']),
    );
  }
  
  /// Create a copy of this object with the specified fields updated
  UserPreference copyWith({
    String? id,
    String? userId,
    String? preferenceCategory,
    String? preferenceName,
    dynamic preferenceValue,
    DateTime? updatedAt,
  }) {
    return UserPreference(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      preferenceCategory: preferenceCategory ?? this.preferenceCategory,
      preferenceName: preferenceName ?? this.preferenceName,
      preferenceValue: preferenceValue ?? this.preferenceValue,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

/// FeedbackEffectiveness tracks how different feedback types affect user behavior.
/// 
/// This supports REQ-1.2 for adaptive personalization by measuring which
/// feedback approaches work best for each user and driving behavior.
class FeedbackEffectiveness {
  final String id;
  final String userId;
  final String feedbackType; // 'gentle_reminder', 'direct_instruction', 'positive_reinforcement'
  final String drivingBehaviorType; // 'acceleration', 'speed', 'idling', etc.
  final int timesDelivered;
  final int timesBehaviorImproved;
  final double effectivenessRatio;
  final DateTime lastUpdated;
  
  FeedbackEffectiveness({
    required this.id,
    required this.userId,
    required this.feedbackType,
    required this.drivingBehaviorType,
    this.timesDelivered = 0,
    this.timesBehaviorImproved = 0,
    this.effectivenessRatio = 0.0,
    required this.lastUpdated,
  });
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'feedbackType': feedbackType,
    'drivingBehaviorType': drivingBehaviorType,
    'timesDelivered': timesDelivered,
    'timesBehaviorImproved': timesBehaviorImproved,
    'effectivenessRatio': effectivenessRatio,
    'lastUpdated': lastUpdated.toIso8601String(),
  };
  
  factory FeedbackEffectiveness.fromJson(Map<String, dynamic> json) => 
    FeedbackEffectiveness(
      id: json['id'],
      userId: json['userId'],
      feedbackType: json['feedbackType'],
      drivingBehaviorType: json['drivingBehaviorType'],
      timesDelivered: json['timesDelivered'] ?? 0,
      timesBehaviorImproved: json['timesBehaviorImproved'] ?? 0,
      effectivenessRatio: json['effectivenessRatio'] ?? 0.0,
      lastUpdated: DateTime.parse(json['lastUpdated']),
    );
    
  /// Create a copy when feedback was given and behavior improved
  FeedbackEffectiveness copyWithImprovement() {
    final newTimesDelivered = timesDelivered + 1;
    final newTimesBehaviorImproved = timesBehaviorImproved + 1;
    
    return FeedbackEffectiveness(
      id: id,
      userId: userId,
      feedbackType: feedbackType,
      drivingBehaviorType: drivingBehaviorType,
      timesDelivered: newTimesDelivered,
      timesBehaviorImproved: newTimesBehaviorImproved,
      effectivenessRatio: newTimesBehaviorImproved / newTimesDelivered,
      lastUpdated: DateTime.now(),
    );
  }
  
  /// Create a copy when feedback was given but behavior did not improve
  FeedbackEffectiveness copyWithNoImprovement() {
    final newTimesDelivered = timesDelivered + 1;
    
    return FeedbackEffectiveness(
      id: id,
      userId: userId,
      feedbackType: feedbackType,
      drivingBehaviorType: drivingBehaviorType,
      timesDelivered: newTimesDelivered,
      timesBehaviorImproved: timesBehaviorImproved,
      effectivenessRatio: timesBehaviorImproved / newTimesDelivered,
      lastUpdated: DateTime.now(),
    );
  }
  
  /// Create a copy of this object with the specified fields updated
  FeedbackEffectiveness copyWith({
    String? id,
    String? userId,
    String? feedbackType,
    String? drivingBehaviorType,
    int? timesDelivered,
    int? timesBehaviorImproved,
    double? effectivenessRatio,
    DateTime? lastUpdated,
  }) {
    return FeedbackEffectiveness(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      feedbackType: feedbackType ?? this.feedbackType,
      drivingBehaviorType: drivingBehaviorType ?? this.drivingBehaviorType,
      timesDelivered: timesDelivered ?? this.timesDelivered,
      timesBehaviorImproved: timesBehaviorImproved ?? this.timesBehaviorImproved,
      effectivenessRatio: effectivenessRatio ?? this.effectivenessRatio,
      lastUpdated: lastUpdated ?? this.lastUpdated,
    );
  }
} 

################################################################################
FILE: lib/core_models/external_integration.dart
################################################################################

import 'dart:convert';

/// ExternalIntegration represents a connection to an external platform.
/// 
/// This supports REQ-4.8 for integration with ride-sharing platforms
/// and other external services.
class ExternalIntegration {
  final String id;
  final String userId;
  final String platformType; // 'uber', 'lyft', 'applecarplay', etc.
  final String? externalId;
  final String integrationStatus; // 'active', 'pending', 'revoked'
  final DateTime connectedAt;
  final DateTime? lastSyncAt;
  final String? accessToken;
  final String? refreshToken;
  final Map<String, dynamic>? integrationData;
  
  ExternalIntegration({
    required this.id,
    required this.userId,
    required this.platformType,
    this.externalId,
    required this.integrationStatus,
    required this.connectedAt,
    this.lastSyncAt,
    this.accessToken,
    this.refreshToken,
    this.integrationData,
  });
  
  Map<String, dynamic> toJson() {
    final Map<String, dynamic> json = {
      'id': id,
      'userId': userId,
      'platformType': platformType,
      'externalId': externalId,
      'integrationStatus': integrationStatus,
      'connectedAt': connectedAt.toIso8601String(),
      'lastSyncAt': lastSyncAt?.toIso8601String(),
    };
    
    // Only include tokens in the JSON if they're present
    // In a real app, these would be securely stored or encrypted
    if (accessToken != null) {
      json['accessToken'] = accessToken;
    }
    
    if (refreshToken != null) {
      json['refreshToken'] = refreshToken;
    }
    
    // Encode the integration data as a JSON string if present
    if (integrationData != null) {
      json['integrationData'] = jsonEncode(integrationData);
    }
    
    return json;
  }
  
  factory ExternalIntegration.fromJson(Map<String, dynamic> json) {
    // Parse integration data if present
    Map<String, dynamic>? integrationData;
    if (json['integrationData'] != null) {
      try {
        integrationData = jsonDecode(json['integrationData']);
      } catch (_) {
        integrationData = null;
      }
    }
    
    return ExternalIntegration(
      id: json['id'],
      userId: json['userId'],
      platformType: json['platformType'],
      externalId: json['externalId'],
      integrationStatus: json['integrationStatus'],
      connectedAt: DateTime.parse(json['connectedAt']),
      lastSyncAt: json['lastSyncAt'] != null ? DateTime.parse(json['lastSyncAt']) : null,
      accessToken: json['accessToken'],
      refreshToken: json['refreshToken'],
      integrationData: integrationData,
    );
  }
  
  /// Create a copy with tokens updated (e.g., after token refresh)
  ExternalIntegration copyWithUpdatedTokens({
    required String accessToken,
    String? refreshToken,
  }) {
    return ExternalIntegration(
      id: id,
      userId: userId,
      platformType: platformType,
      externalId: externalId,
      integrationStatus: integrationStatus,
      connectedAt: connectedAt,
      lastSyncAt: DateTime.now(),
      accessToken: accessToken,
      refreshToken: refreshToken ?? this.refreshToken,
      integrationData: integrationData,
    );
  }
  
  /// Create a copy with status updated
  ExternalIntegration copyWithStatus(String newStatus) {
    return ExternalIntegration(
      id: id,
      userId: userId,
      platformType: platformType,
      externalId: externalId,
      integrationStatus: newStatus,
      connectedAt: connectedAt,
      lastSyncAt: DateTime.now(),
      accessToken: accessToken,
      refreshToken: refreshToken,
      integrationData: integrationData,
    );
  }
  
  /// Create a copy of this object with the specified fields updated
  ExternalIntegration copyWith({
    String? id,
    String? userId,
    String? platformType,
    String? externalId,
    String? integrationStatus,
    DateTime? connectedAt,
    DateTime? lastSyncAt,
    String? accessToken,
    String? refreshToken,
    Map<String, dynamic>? integrationData,
  }) {
    return ExternalIntegration(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      platformType: platformType ?? this.platformType,
      externalId: externalId ?? this.externalId,
      integrationStatus: integrationStatus ?? this.integrationStatus,
      connectedAt: connectedAt ?? this.connectedAt,
      lastSyncAt: lastSyncAt ?? this.lastSyncAt,
      accessToken: accessToken ?? this.accessToken,
      refreshToken: refreshToken ?? this.refreshToken,
      integrationData: integrationData ?? this.integrationData,
    );
  }
}

/// SyncStatus tracks the synchronization status of entities with external systems.
/// 
/// This supports REQ-4.8 by providing a way to track which data has been
/// synchronized with external platforms and the status of those syncs.
class SyncStatus {
  final String id;
  final String userId;
  final String entityType; // 'trip', 'badge', 'challenge', etc.
  final String entityId;
  final String? targetPlatform; // If syncing to specific external platform
  final String syncStatus; // 'pending', 'synced', 'failed'
  final DateTime? lastAttemptAt;
  final int retryCount;
  final String? errorMessage;
  
  SyncStatus({
    required this.id,
    required this.userId,
    required this.entityType,
    required this.entityId,
    this.targetPlatform,
    required this.syncStatus,
    this.lastAttemptAt,
    this.retryCount = 0,
    this.errorMessage,
  });
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'entityType': entityType,
    'entityId': entityId,
    'targetPlatform': targetPlatform,
    'syncStatus': syncStatus,
    'lastAttemptAt': lastAttemptAt?.toIso8601String(),
    'retryCount': retryCount,
    'errorMessage': errorMessage,
  };
  
  factory SyncStatus.fromJson(Map<String, dynamic> json) => 
    SyncStatus(
      id: json['id'],
      userId: json['userId'],
      entityType: json['entityType'],
      entityId: json['entityId'],
      targetPlatform: json['targetPlatform'],
      syncStatus: json['syncStatus'],
      lastAttemptAt: json['lastAttemptAt'] != null ? DateTime.parse(json['lastAttemptAt']) : null,
      retryCount: json['retryCount'] ?? 0,
      errorMessage: json['errorMessage'],
    );
  
  /// Mark as pending sync
  SyncStatus markAsPending() {
    return SyncStatus(
      id: id,
      userId: userId,
      entityType: entityType,
      entityId: entityId,
      targetPlatform: targetPlatform,
      syncStatus: 'pending',
      lastAttemptAt: DateTime.now(),
      retryCount: retryCount,
      errorMessage: null,
    );
  }
  
  /// Mark as successfully synced
  SyncStatus markAsSynced() {
    return SyncStatus(
      id: id,
      userId: userId,
      entityType: entityType,
      entityId: entityId,
      targetPlatform: targetPlatform,
      syncStatus: 'synced',
      lastAttemptAt: DateTime.now(),
      retryCount: retryCount,
      errorMessage: null,
    );
  }
  
  /// Mark as failed with error message
  SyncStatus markAsFailed(String error) {
    return SyncStatus(
      id: id,
      userId: userId,
      entityType: entityType,
      entityId: entityId,
      targetPlatform: targetPlatform,
      syncStatus: 'failed',
      lastAttemptAt: DateTime.now(),
      retryCount: retryCount + 1,
      errorMessage: error,
    );
  }
  
  /// Create a copy of this object with the specified fields updated
  SyncStatus copyWith({
    String? id,
    String? userId,
    String? entityType,
    String? entityId,
    String? targetPlatform,
    String? syncStatus,
    DateTime? lastAttemptAt,
    int? retryCount,
    String? errorMessage,
  }) {
    return SyncStatus(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      entityType: entityType ?? this.entityType,
      entityId: entityId ?? this.entityId,
      targetPlatform: targetPlatform ?? this.targetPlatform,
      syncStatus: syncStatus ?? this.syncStatus,
      lastAttemptAt: lastAttemptAt ?? this.lastAttemptAt,
      retryCount: retryCount ?? this.retryCount,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }
} 

################################################################################
FILE: lib/core_models/obd_II_data.dart
################################################################################


// Model for OBD-II data collection
class OBDIIData {
  final DateTime timestamp;
  final double? vehicleSpeed; // km/h
  final int? rpm; // engine RPM
  final double? throttlePosition; // %
  final bool? engineRunning; // true if engine is on
  final double? engineTemp; // Celsius
  final double? fuelRate; // L/h if available
  final double? engineLoad; // %a
  final double? mafRate; // Mass Air Flow rate g/s
  final double? relativePedalPosition; // %
  final int? gearPosition; // if available (usually only in newer cars)
  final double? distanceTraveledWithMIL; // km traveled with malfunction indicator lamp on
  final double? instantFuelEconomy; // if available (km/L)
  final double? acceleratorPedalPosition; // %
  
  OBDIIData({
    required this.timestamp,
    this.vehicleSpeed,
    this.rpm,
    this.throttlePosition,
    this.engineRunning,
    this.engineTemp,
    this.fuelRate,
    this.engineLoad,
    this.mafRate,
    this.relativePedalPosition,
    this.gearPosition,
    this.distanceTraveledWithMIL,
    this.instantFuelEconomy,
    this.acceleratorPedalPosition,
  });

  factory OBDIIData.fromJson(Map<String, dynamic> json) {
    return OBDIIData(
      timestamp: DateTime.parse(json['timestamp']),
      vehicleSpeed: json['vehicleSpeed'],
      rpm: json['rpm'],
      throttlePosition: json['throttlePosition'],
      engineRunning: json['engineRunning'],
      engineTemp: json['engineTemp'],
      fuelRate: json['fuelRate'],
      engineLoad: json['engineLoad'],
      mafRate: json['mafRate'],
      relativePedalPosition: json['relativePedalPosition'],
      gearPosition: json['gearPosition'],
      distanceTraveledWithMIL: json['distanceTraveledWithMIL'],
      instantFuelEconomy: json['instantFuelEconomy'],
      acceleratorPedalPosition: json['acceleratorPedalPosition'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'timestamp': timestamp.toIso8601String(),
      'vehicleSpeed': vehicleSpeed,
      'rpm': rpm,
      'throttlePosition': throttlePosition,
      'engineRunning': engineRunning,
      'engineTemp': engineTemp,
      'fuelRate': fuelRate,
      'engineLoad': engineLoad,
      'mafRate': mafRate,
      'relativePedalPosition': relativePedalPosition,
      'gearPosition': gearPosition,
      'distanceTraveledWithMIL': distanceTraveledWithMIL,
      'instantFuelEconomy': instantFuelEconomy,
      'acceleratorPedalPosition': acceleratorPedalPosition,
    };
  }
}


################################################################################
FILE: lib/core_models/trip.dart
################################################################################

// Trip model to track a single journey
class Trip {
  final String id;
  final DateTime startTime;
  final DateTime? endTime;
  final double? distanceKm;
  final double? averageSpeedKmh;
  final double? maxSpeedKmh;
  final double? fuelUsedL; // Calculated or actual if available
  final int? idlingEvents;
  final int? aggressiveAccelerationEvents;
  final int? hardBrakingEvents;
  final int? excessiveSpeedEvents;
  final int? stopEvents;
  final double? averageRPM;
  final bool isCompleted;
  final String? userId; // Add userId to track which user the trip belongs to
  
  Trip({
    required this.id,
    required this.startTime,
    this.endTime,
    this.distanceKm,
    this.averageSpeedKmh,
    this.maxSpeedKmh,
    this.fuelUsedL,
    this.idlingEvents,
    this.aggressiveAccelerationEvents,
    this.hardBrakingEvents,
    this.excessiveSpeedEvents,
    this.stopEvents,
    this.averageRPM,
    this.isCompleted = false,
    this.userId, // Include in constructor
  });

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'startTime': startTime.toIso8601String(),
      'endTime': endTime?.toIso8601String(),
      'distanceKm': distanceKm,
      'averageSpeedKmh': averageSpeedKmh,
      'maxSpeedKmh': maxSpeedKmh,
      'fuelUsedL': fuelUsedL,
      'idlingEvents': idlingEvents,
      'aggressiveAccelerationEvents': aggressiveAccelerationEvents,
      'hardBrakingEvents': hardBrakingEvents,
      'excessiveSpeedEvents': excessiveSpeedEvents,
      'stopEvents': stopEvents,
      'averageRPM': averageRPM,
      'isCompleted': isCompleted,
      'userId': userId, // Include in JSON
    };
  }
  
  factory Trip.fromJson(Map<String, dynamic> json) {
    return Trip(
      id: json['id'],
      startTime: DateTime.parse(json['startTime']),
      endTime: json['endTime'] != null ? DateTime.parse(json['endTime']) : null,
      distanceKm: json['distanceKm'],
      averageSpeedKmh: json['averageSpeedKmh'],
      maxSpeedKmh: json['maxSpeedKmh'],
      fuelUsedL: json['fuelUsedL'],
      idlingEvents: json['idlingEvents'],
      aggressiveAccelerationEvents: json['aggressiveAccelerationEvents'],
      hardBrakingEvents: json['hardBrakingEvents'],
      excessiveSpeedEvents: json['excessiveSpeedEvents'],
      stopEvents: json['stopEvents'],
      averageRPM: json['averageRPM'],
      isCompleted: json['isCompleted'] ?? false,
      userId: json['userId'], // Parse from JSON
    );
  }
  
  // Create a new Trip object with updated fields
  Trip copyWith({
    String? id,
    DateTime? startTime,
    DateTime? endTime,
    double? distanceKm,
    double? averageSpeedKmh,
    double? maxSpeedKmh,
    double? fuelUsedL,
    int? idlingEvents,
    int? aggressiveAccelerationEvents,
    int? hardBrakingEvents,
    int? excessiveSpeedEvents,
    int? stopEvents,
    double? averageRPM,
    bool? isCompleted,
    String? userId, // Include in copyWith
  }) {
    return Trip(
      id: id ?? this.id,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      distanceKm: distanceKm ?? this.distanceKm,
      averageSpeedKmh: averageSpeedKmh ?? this.averageSpeedKmh,
      maxSpeedKmh: maxSpeedKmh ?? this.maxSpeedKmh,
      fuelUsedL: fuelUsedL ?? this.fuelUsedL,
      idlingEvents: idlingEvents ?? this.idlingEvents,
      aggressiveAccelerationEvents: aggressiveAccelerationEvents ?? this.aggressiveAccelerationEvents,
      hardBrakingEvents: hardBrakingEvents ?? this.hardBrakingEvents,
      excessiveSpeedEvents: excessiveSpeedEvents ?? this.excessiveSpeedEvents,
      stopEvents: stopEvents ?? this.stopEvents,
      averageRPM: averageRPM ?? this.averageRPM,
      isCompleted: isCompleted ?? this.isCompleted,
      userId: userId ?? this.userId, // Include in return
    );
  }
}


################################################################################
FILE: lib/obd_lib/README.md
################################################################################

# OBD Library (obd_lib)

A comprehensive library for interacting with OBD-II adapters over Bluetooth for vehicle data collection, designed specifically for eco-driving applications.

## Overview

The OBD Library provides a high-level, robust interface for communicating with ELM327-based OBD-II adapters via Bluetooth. It handles the complexities of Bluetooth connectivity, protocol negotiation, command formatting, and data parsing, presenting a clean and simple API to consumer services.

This library is a core component of the eco-driving application, providing real-time vehicle data such as RPM, speed, throttle position, and more.

## Architecture

The library follows a layered architecture with clear separation of concerns:

```
┌───────────────────────────────────────────────┐
│               ObdService (Facade)             │
├───────────────────────────────────────────────┤
│    ObdProtocol    │         ObdFactory        │
│  (Elm327Protocol) │                           │
├─────────────┬─────┴───────────────────────────┤
│ ObdConnection (BluetoothConnection)           │
├───────────────────────────────────────────────┤
│          Profiles & Configuration             │
└───────────────────────────────────────────────┘
```

### Key Components

1. **ObdService** - Main facade class that consumer services interact with
2. **ObdProtocol** - Protocol implementation (currently ELM327)
3. **ObdConnection** - Connection implementation (Bluetooth)
4. **AdapterProfile** - Configuration profiles for different OBD adapters
5. **Models** - Data structures for OBD commands, responses, device info, etc.

### Data Flow

1. Consumer services interact with the `ObdService` facade
2. `ObdService` manages the protocol instance and handles data polling
3. `ObdProtocol` sends commands and processes responses from the adapter
4. `ObdConnection` handles the low-level Bluetooth communication
5. Parsed data flows back up to the consumer as `ObdData` objects

## Key Features

- **Adapter Profile System**: Automatic detection and configuration for different ELM327 adapters
- **Robust Connection Handling**: Automatic recovery from connection loss and stalled connections
- **Prioritized Polling**: Smart, dynamic polling system that prioritizes critical PIDs
- **Engine State Detection**: Accurate engine running state detection with multiple indicators
- **Throttle Position Optimization**: Enhanced responsiveness during acceleration
- **Error Handling**: Comprehensive error handling and retry mechanisms
- **Configurable Behavior**: Extensive configuration options for different adapters

## Usage

### Basic Usage

```dart
// 1. Import the library
import 'package:going50/lib/obd_lib/obd_lib.dart';

// 2. Create an instance of ObdService
final obdService = ObdService(isDebugMode: true);

// 3. Scan for Bluetooth devices
Stream<BluetoothDevice> deviceStream = obdService.scanForDevices();
await for (final device in deviceStream) {
  print('Found device: ${device.name} (${device.id})');
}

// 4. Connect to a device
bool connected = await obdService.connect(deviceId);

// 5. Start continuous queries
await obdService.startContinuousQueries();

// 6. Listen for data updates
obdService.addListener(() {
  final rpm = obdService.latestData[ObdConstants.pidEngineRpm];
  final speed = obdService.latestData[ObdConstants.pidVehicleSpeed];
  final throttle = obdService.latestData[ObdConstants.pidThrottlePosition];
  
  // Do something with the data...
});

// 7. Request specific PIDs on demand
ObdData? coolantTemp = await obdService.requestPid(ObdConstants.pidCoolantTemp);

// 8. Disconnect when done
await obdService.disconnect();
```

### Advanced Usage

#### Using Adapter Profiles

```dart
// Get available profiles
List<Map<String, String>> profiles = obdService.getAvailableProfiles();

// Set specific profile for known adapter
obdService.setAdapterProfile('premium_elm327');

// Or enable automatic profile detection
obdService.enableAutomaticProfileDetection();
```

#### Customizing Monitored PIDs

```dart
// Add PIDs to monitor
obdService.addMonitoredPid(ObdConstants.pidFuelLevel);
obdService.addMonitoredPid(ObdConstants.pidIntakeAirTemp);

// Remove PIDs from monitoring
obdService.removeMonitoredPid(ObdConstants.pidCoolantTemp);
```

#### Sending Custom Commands

```dart
// Send a raw command to the adapter
String response = await obdService.sendCustomCommand('010C');
```

## Error Handling

The library implements several error handling and recovery mechanisms:

1. **Command Retries**: Failed commands are automatically retried
2. **Connection Recovery**: Stalled or dropped connections are automatically recovered
3. **PID Failure Tracking**: PIDs that consistently fail are polled less frequently
4. **RPM Validation**: Stale or stuck RPM values are validated with additional checks

## Integration with Driving Service

The OBD library is designed to work seamlessly with the DrivingService, which coordinates data collection from multiple sources (OBD, phone sensors, etc.).

DrivingService should:
1. Create an instance of `ObdService`
2. Connect to an OBD adapter when starting a drive
3. Call `startContinuousQueries()` to begin data collection
4. Register as a listener for data updates
5. Process the OBD data along with other sensor data
6. Call `stopQueries()` and `disconnect()` when the drive ends

## Known Limitations

1. **Adapter Compatibility**: While the library supports multiple adapter profiles, it primarily targets ELM327-based adapters over Bluetooth.
2. **Polling Delay**: There is an inherent delay in the polling system, usually 500-1000ms at best.
3. **Vehicle Compatibility**: Not all vehicles support all PIDs, and some may require specialized configurations.

## Implementation Issues and Recommendations

### Current Issues

1. **Bluetooth Connection Reliability**: The current implementation sometimes struggles with connection reliability, especially during long drives or when encountering Bluetooth interference.

2. **Error Handling Inconsistencies**: Some lower-level errors in the Bluetooth layer are not properly propagated to the ObdService facade.

3. **No Centralized Error Repository**: Error messages are scattered throughout the codebase without a centralized repository, making it difficult to maintain consistent error messages.

4. **Resource Leaks**: In some exceptional cases, resources like StreamSubscriptions might not be properly cleaned up.

5. **Limited Protocol Support**: Currently, only ELM327 protocol is supported, which might limit compatibility with some vehicles.

6. **Connection Recovery Mechanism**: The connection recovery logic could be more aggressive, especially when dealing with cheap Bluetooth adapters that frequently drop connections.

### Important Implementation Notes

1. **Critical Connection Requirements**: The specific ELM327 adapter used in this project requires a strict connection sequence that must be preserved:
   - Always establish Bluetooth connection before protocol initialization
   - Include a 2000ms wait after starting Bluetooth connection
   - Follow the exact initialization command sequence
   - Maintain specific delays between commands (1000ms after reset, 300ms between others)

2. **Adapter-Specific Settings**:
   - Protocol must use ISO 14230-4 KWP (5 baud init) via command `ATSP4`
   - Baud rate must be 10.4 kbaud via command `ATBRD10`
   - Timeout must be 200ms via command `ATST20`

3. **Bluetooth Implementation**:
   - Service UUID must be `FFF0`
   - Notify (read) characteristic UUID must be `FFF1`
   - Write characteristic UUID must be `FFF2`

## Testing

### Manual Testing

1. **Connection Testing**:
   - Test connection to different adapter types
   - Test connection recovery after Bluetooth disconnect
   - Test behavior when out of range

2. **Data Polling Testing**:
   - Verify that critical PIDs (RPM, speed) are updated frequently
   - Test during different driving conditions (idle, acceleration, cruising)
   - Verify that engine state detection works correctly

3. **Error Recovery Testing**:
   - Intentionally disrupt the Bluetooth connection
   - Test with adapter power off/on during a session
   - Test with different vehicles to verify compatibility

### Automated Testing

The library should be tested with automated tests for core functionality:

1. **Unit Tests**:
   - Test protocol command formatting
   - Test response parsing
   - Test profile selection logic

2. **Integration Tests**:
   - Test with mock adapter responses
   - Test error handling and recovery
   - Test different adapter profiles

3. **Performance Tests**:
   - Measure command-response latency
   - Test polling frequency under various conditions
   - Test memory and CPU usage during extended sessions

### Test Fixtures

To facilitate testing, consider implementing:

1. **Mock OBD Connection**: A mock implementation of `ObdConnection` that returns predefined responses for testing.

2. **Mock OBD Protocol**: A mock implementation of `ObdProtocol` that simulates different adapter behaviors.

3. **Virtual OBD Device**: A virtual OBD device that can be used for integration testing without an actual physical adapter.

4. **Scenario-based Test Cases**: Predefined scenarios (e.g., engine start, highway driving, city traffic) with expected data patterns.

## Recommendations for Improvement

1. **Enhanced Diagnostics**: Add comprehensive logging and diagnostics for troubleshooting connection issues.
2. **Protocol Expansion**: Support additional OBD protocols beyond ELM327.
3. **Performance Optimization**: Further optimize the polling system for faster data updates.
4. **Cached PID Support**: Implement a cache for PIDs that change infrequently.
5. **Adapter Detection**: Improve automatic adapter profile detection accuracy.
6. **Testing Infrastructure**: Develop a comprehensive testing suite with mock adapters.
7. **Bluetooth Connection Robustness**: Implement more aggressive connection recovery mechanisms.
8. **Documentation**: Add more inline documentation and examples.
9. **Error Handling Framework**: Develop a centralized error handling and reporting system.
10. **Resource Management**: Implement a more robust resource cleanup mechanism, especially for StreamSubscriptions.

## Conclusion

The OBD Library provides a robust, high-level interface for interacting with OBD-II adapters, abstracting away the complexities of Bluetooth communication and protocol handling. It is designed to be used by the DrivingService as part of the eco-driving application to collect real-time vehicle data. 

################################################################################
FILE: lib/obd_lib/example_adapter_config.dart
################################################################################

import 'models/adapter_config_factory.dart';
import 'profiles/cheap_elm327_profile.dart';
import 'profiles/premium_elm327_profile.dart';
import 'package:logging/logging.dart';

/// Example demonstrating how to use the adapter configuration framework
void adapterConfigExample() {
  // Configure logging
  Logger.root.level = Level.INFO;
  Logger.root.onRecord.listen((record) {
    print('${record.level.name}: ${record.time}: ${record.message}');
  });
  
  final Logger logger = Logger('AdapterConfigExample');

  logger.info('Creating different adapter configurations');
  
  // Create configurations using factory
  final cheapConfig = AdapterConfigFactory.createCheapElm327Config();
  final premiumConfig = AdapterConfigFactory.createPremiumElm327Config();
  final dynamicConfig = AdapterConfigFactory.createDynamicConfig();
  
  logger.info('Cheap adapter config: ${cheapConfig.profileId}');
  logger.info(' - Uses extended init delays: ${cheapConfig.useExtendedInitDelays}');
  logger.info(' - Uses lenient parsing: ${cheapConfig.useLenientParsing}');
  logger.info(' - Default polling interval: ${cheapConfig.defaultPollingInterval}ms');
  
  logger.info('Premium adapter config: ${premiumConfig.profileId}');
  logger.info(' - Uses extended init delays: ${premiumConfig.useExtendedInitDelays}');
  logger.info(' - Uses lenient parsing: ${premiumConfig.useLenientParsing}');
  logger.info(' - Default polling interval: ${premiumConfig.defaultPollingInterval}ms');
  
  logger.info('Dynamic adapter config: ${dynamicConfig.profileId}');
  logger.info(' - Uses extended init delays: ${dynamicConfig.useExtendedInitDelays}');
  logger.info(' - Uses lenient parsing: ${dynamicConfig.useLenientParsing}');
  logger.info(' - Default polling interval: ${dynamicConfig.defaultPollingInterval}ms');
  
  // Create custom configuration
  final customConfig = cheapConfig.copyWith(
    profileId: 'custom_elm327',
    name: 'Custom ELM327 Adapter', 
    defaultPollingInterval: 1500,
    maxRetries: 3,
  );
  
  logger.info('Custom adapter config: ${customConfig.profileId}');
  logger.info(' - Uses extended init delays: ${customConfig.useExtendedInitDelays}');
  logger.info(' - Uses lenient parsing: ${customConfig.useLenientParsing}');
  logger.info(' - Default polling interval: ${customConfig.defaultPollingInterval}ms');
  logger.info(' - Max retries: ${customConfig.maxRetries}');
  
  // Example of creating profiles with configurations
  final cheapProfile = CheapElm327Profile();
  final premiumProfile = PremiumElm327Profile();
  final customCheapProfile = CheapElm327Profile.withConfig(customConfig);
  
  logger.info('Cheap profile ID: ${cheapProfile.profileId}');
  logger.info('Premium profile ID: ${premiumProfile.profileId}');
  logger.info('Custom cheap profile ID: ${customCheapProfile.profileId}');
}

/// Run this to test adapter configuration
void main() {
  adapterConfigExample();
} 

################################################################################
FILE: lib/obd_lib/obd_factory.dart
################################################################################

import 'package:logging/logging.dart';
import 'interfaces/obd_connection.dart';
import 'protocol/obd_protocol.dart';
import 'protocol/elm327_protocol.dart';
import 'bluetooth/bluetooth_connection.dart';
import 'profiles/profile_manager.dart';

/// Factory for creating OBD-II connections and protocols
class ObdFactory {
  static final Logger _logger = Logger('ObdFactory');
  
  // Private constructor to prevent instantiation
  ObdFactory._();
  
  // Profile manager singleton instance
  static final ProfileManager _profileManager = ProfileManager();
  
  /// Get the profile manager instance
  static ProfileManager get profileManager => _profileManager;
  
  /// Create a Bluetooth connection to an OBD-II adapter
  static ObdConnection createBluetoothConnection(String deviceId, {bool isDebugMode = false}) {
    _logger.info('Creating Bluetooth connection to device: $deviceId');
    return BluetoothConnection(deviceId, isDebugMode: isDebugMode);
  }
  
  /// Create an ELM327 protocol handler using the specified connection
  static ObdProtocol createElm327Protocol(ObdConnection connection, {bool isDebugMode = false}) {
    _logger.info('Creating ELM327 protocol handler');
    return Elm327Protocol(connection, isDebugMode: isDebugMode);
  }
  
  /// Create a protocol handler for a device using the best matching profile
  /// 
  /// This automatically detects and selects the best adapter profile
  static Future<ObdProtocol> createProtocolForDevice(String deviceId, {bool isDebugMode = false}) async {
    _logger.info('Creating protocol for device: $deviceId');
    return await _profileManager.createProtocolForDevice(deviceId, isDebugMode: isDebugMode);
  }
  
  /// Convenience method to create a complete OBD-II connection and protocol
  /// for communicating with an ELM327 adapter over Bluetooth
  /// 
  /// This method is kept for backward compatibility
  static ObdProtocol createBluetoothElm327({
    required String deviceId,
    bool isDebugMode = false,
  }) {
    final connection = createBluetoothConnection(deviceId, isDebugMode: isDebugMode);
    return createElm327Protocol(connection, isDebugMode: isDebugMode);
  }
  
  /// Set a specific adapter profile to be used
  ///
  /// This will override automatic profile detection
  static void setAdapterProfile(String profileId) {
    _profileManager.setManualProfile(profileId);
  }
  
  /// Clear manual profile selection
  ///
  /// This will re-enable automatic profile detection
  static void enableAutomaticProfileDetection() {
    _profileManager.clearManualProfile();
  }
  
  /// Get a list of available adapter profiles
  static List<Map<String, String>> getAvailableProfiles() {
    return _profileManager.profilesList;
  }
} 

################################################################################
FILE: lib/obd_lib/obd_lib.dart
################################################################################

// OBD Library for Flutter
//
// This library provides a simplified interface for working with OBD-II adapters
// in Flutter applications. It handles Bluetooth connectivity, protocol
// communication, and data parsing.

library;

// Main service class
export 'obd_service.dart';

// Factory for creating connections and protocols
export 'obd_factory.dart';

// Protocols
export 'protocol/obd_protocol.dart';
export 'protocol/elm327_protocol.dart';

// Bluetooth
export 'bluetooth/bluetooth_scanner.dart';
export 'bluetooth/bluetooth_connection.dart';
export 'models/bluetooth_device.dart';

// Data models
export 'models/obd_data.dart';
export 'models/obd_command.dart';
export 'models/obd_pid_config.dart';
export 'models/adapter_config.dart';
export 'models/adapter_config_factory.dart';
export 'models/adapter_config_validator.dart';

// Constants
export 'protocol/obd_constants.dart';

// Response processors
export 'protocol/response_processor/obd_response_processor.dart';
export 'protocol/response_processor/base_response_processor.dart';
export 'protocol/response_processor/cheap_elm327_processor.dart';
export 'protocol/response_processor/premium_elm327_processor.dart';
export 'protocol/response_processor/processor_factory.dart';

// Profiles
export 'profiles/adapter_profile.dart';
export 'profiles/cheap_elm327_profile.dart';
export 'profiles/premium_elm327_profile.dart';
export 'profiles/profile_manager.dart'; 

################################################################################
FILE: lib/obd_lib/obd_service.dart
################################################################################

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:logging/logging.dart';

import 'bluetooth/bluetooth_scanner.dart';
import 'models/bluetooth_device.dart';
import 'models/obd_data.dart';
import 'obd_factory.dart';
import 'protocol/obd_protocol.dart';
import 'protocol/obd_constants.dart';

/// Main service class for OBD-II communication
///
/// This class provides a facade for the OBD-II library, handling device discovery,
/// connection management, and data retrieval.
class ObdService extends ChangeNotifier {
  final Logger _logger = Logger('ObdService');
  final bool isDebugMode;
  
  // Bluetooth
  final BluetoothScanner _scanner = BluetoothScanner();
  bool _isScanning = false;
  
  // Protocol
  ObdProtocol? _protocol;
  
  // Adapter profile
  String? _selectedProfileId;
  
  // State
  bool _isConnecting = false;
  String? _errorMessage;
  final Map<String, ObdData> _latestData = {};
  final List<String> _monitoredPids = [];
  Timer? _pollingTimer;
  int _currentPollingInterval = ObdConstants.defaultPollingInterval;
  
  // Engine state tracking
  bool _engineRunning = false;
  int _engineCheckCounter = 0;

  // PID tracking
  final Map<String, int> _pidFailureCount = {};
  final int _maxFailureCount = 3;  // Maximum consecutive failures before reducing polling frequency
  final Map<String, DateTime> _lastPidRequestTime = {};
  
  // Polling cycle tracking
  int _pollingCycleCounter = 0;
  
  // Add tracking for RPM staleness detection
  DateTime? _lastRpmChangeTime;
  int? _lastRpmValue;
  // Reduce the threshold to detect staleness sooner - was 30 seconds
  static const _rpmStalenessThresholdMs = 15000; // 15 seconds without RPM change (was 30s)
  // Add counter for consecutive identical RPM readings to detect stuck values
  int _sameRpmCounter = 0;
  // Maximum identical RPM readings before forced verification
  static const _maxIdenticalRpmReadings = 5;
  
  // Add tracking for connection health
  int _consecutivePollingFailures = 0;
  static const _maxPollingFailures = 3;
  DateTime _lastSuccessfulPoll = DateTime.now();
  
  // Add a field to track the last connected device ID
  String? _lastConnectedDeviceId;
  
  /// Creates a new ObdService instance
  ///
  /// Set [isDebugMode] to true to enable debug logging
  /// Set [initLogging] to false to prevent setting up a logging listener
  ObdService({this.isDebugMode = false, bool initLogging = true}) {
    if (isDebugMode && initLogging) {
      Logger.root.level = Level.ALL;
      // No need to add a listener here, it's already set in main.dart
    }
    
    // Add default PIDs to monitor
    _monitoredPids.addAll([
      ObdConstants.pidEngineRpm,
      ObdConstants.pidVehicleSpeed,
      ObdConstants.pidCoolantTemp,
      ObdConstants.pidControlModuleVoltage,
    ]);
  }
  
  /// Whether the service is currently connected to an OBD adapter
  bool get isConnected => _protocol?.isConnected ?? false;
  
  /// Whether the service is currently connecting to an OBD adapter
  bool get isConnecting => _isConnecting;
  
  /// The latest error message, if any occurred
  String? get errorMessage => _errorMessage;
  
  /// The latest data received from the OBD adapter
  Map<String, ObdData> get latestData => Map.unmodifiable(_latestData);
  
  /// The list of PIDs currently being monitored
  List<String> get monitoredPids => List.unmodifiable(_monitoredPids);
  
  /// Whether the engine is currently running, based on RPM readings
  bool get isEngineRunning => _engineRunning;
  
  /// The ID of the currently selected adapter profile, if any
  String? get selectedProfileId => _selectedProfileId;

  /// Set a specific adapter profile to be used
  ///
  /// This will override automatic profile detection
  void setAdapterProfile(String profileId) {
    _logger.info('Setting adapter profile: $profileId');
    _selectedProfileId = profileId;
    ObdFactory.setAdapterProfile(profileId);
  }
  
  /// Clear manual profile selection
  ///
  /// This will re-enable automatic profile detection
  void enableAutomaticProfileDetection() {
    _logger.info('Enabling automatic profile detection');
    _selectedProfileId = null;
    ObdFactory.enableAutomaticProfileDetection();
  }
  
  /// Get a list of available adapter profiles
  List<Map<String, String>> getAvailableProfiles() {
    return ObdFactory.getAvailableProfiles();
  }
  
  /// Scan for available Bluetooth devices
  ///
  /// Returns a stream of discovered devices
  Stream<BluetoothDevice> scanForDevices({Duration timeout = const Duration(seconds: 30)}) async* {
    if (_isScanning) {
      _logger.warning('Scan already in progress');
      return;
    }
    
    _isScanning = true;
    _errorMessage = null;
    notifyListeners();
    
    try {
      _logger.info('Starting device scan with ${timeout.inSeconds}s timeout');
      
      // Create a controller to convert list-based device updates to individual device emissions
      final controller = StreamController<BluetoothDevice>();
      
      // Start the actual scan with timeout
      _scanner.startScan(timeout: timeout);
      
      // Subscribe to devices stream to emit individual devices
      final subscription = _scanner.devices.listen((devices) {
        for (final device in devices) {
          // Only emit if the controller is still active
          if (!controller.isClosed) {
            controller.add(device);
          }
        }
      });
      
      // Set up a cleanup function
      final cleanup = () {
        _logger.info('Cleaning up scan resources');
        subscription.cancel();
        _scanner.stopScan();
        controller.close();
        _isScanning = false;
        notifyListeners();
      };
      
      // Make sure we clean up when the consumer cancels the subscription
      controller.onCancel = cleanup;
      
      // Also ensure we clean up after the timeout
      Future.delayed(timeout, () {
        if (!controller.isClosed) {
          _logger.info('Scan timeout reached after ${timeout.inSeconds}s');
          cleanup();
        }
      });
      
      // Yield all devices from the controller's stream
      await for (final device in controller.stream) {
        yield device;
      }
    } catch (e) {
      _errorMessage = 'Error scanning for devices: $e';
      _logger.severe(_errorMessage);
    } finally {
      // Ensure scan is stopped and state is updated even if there's an error
      if (_isScanning) {
        _scanner.stopScan();
        _isScanning = false;
        notifyListeners();
      }
    }
  }
  
  /// Connect to an OBD adapter
  ///
  /// Returns true if the connection was successful
  Future<bool> connect(String deviceId) async {
    // Store the device ID for recovery purposes
    _lastConnectedDeviceId = deviceId;
    
    if (isConnected) {
      _logger.info('Already connected, disconnecting first');
      disconnect();
    }
    
    _isConnecting = true;
    _errorMessage = null;
    notifyListeners();
    
    try {
      _logger.info('Connecting to device: $deviceId');
      
      // Use the profile-based protocol creation if a profile is selected
      // or if no profile is selected, use automatic detection
      if (_selectedProfileId != null) {
        _logger.info('Using selected profile: $_selectedProfileId');
        ObdFactory.setAdapterProfile(_selectedProfileId!);
      } else {
        _logger.info('Using automatic profile detection');
        ObdFactory.enableAutomaticProfileDetection();
      }
      
      // Create protocol with the best matching profile
      _protocol = await ObdFactory.createProtocolForDevice(deviceId, isDebugMode: isDebugMode);
      
      if (_protocol == null) {
        _errorMessage = 'Failed to create protocol handler';
        _logger.warning(_errorMessage!);
        _isConnecting = false;
        notifyListeners();
        return false;
      }
      
      // Initialize protocol
      _logger.info('Initializing OBD protocol');
      final initialized = await _protocol!.initialize();
      if (!initialized) {
        _errorMessage = 'Failed to initialize OBD protocol';
        _logger.warning(_errorMessage!);
        _protocol!.dispose();
        _protocol = null;
        _isConnecting = false;
        notifyListeners();
        return false;
      }
      
      // Start data stream
      _protocol!.obdDataStream.listen(_handleObdData);
      
      // Make sure essential PIDs are monitored
      ensureEssentialPidsAreMonitored();
      
      // Start polling
      _startPolling();
      
      _logger.info('Connected successfully');
      _isConnecting = false;
      notifyListeners();
      return true;
    } catch (e) {
      _errorMessage = 'Connection error: $e';
      _logger.severe(_errorMessage);
      _protocol?.dispose();
      _protocol = null;
      _isConnecting = false;
      notifyListeners();
      return false;
    }
  }
  
  /// Stop scanning for devices
  void stopScan() {
    if (!_isScanning) return;
    
    _logger.info('Stopping device scan');
    _scanner.stopScan();
    _isScanning = false;
    notifyListeners();
  }
  
  /// Disconnect from the OBD adapter
  void disconnect() {
    _logger.info('Disconnecting');
    _stopPolling();
    _protocol?.dispose();
    _protocol = null;
    _latestData.clear();
    notifyListeners();
  }
  
  /// Add a PID to the list of monitored PIDs
  void addMonitoredPid(String pid) {
    if (!_monitoredPids.contains(pid)) {
      _logger.info('Adding monitored PID: $pid');
      _monitoredPids.add(pid);
      notifyListeners();
    }
  }
  
  /// Remove a PID from the list of monitored PIDs
  void removeMonitoredPid(String pid) {
    if (_monitoredPids.contains(pid)) {
      _logger.info('Removing monitored PID: $pid');
      _monitoredPids.remove(pid);
      _latestData.remove(pid);
      notifyListeners();
    }
  }
  
  /// Request data for a specific PID
  ///
  /// Returns the parsed OBD data
  Future<ObdData?> requestPid(String pid) async {
    if (!isConnected) {
      _logger.warning('Cannot request PID, not connected');
      return null;
    }
    
    try {
      _logger.fine('Requesting PID: $pid');
      final data = await _protocol!.requestPid(pid);
      if (data != null) {
        _latestData[pid] = data;
        notifyListeners();
      }
      return data;
    } catch (e) {
      _logger.warning('Error requesting PID $pid: $e');
      return null;
    }
  }
  
  /// Send a custom command to the OBD adapter
  ///
  /// This method allows sending any arbitrary command to the OBD adapter.
  /// Returns the raw response string from the adapter.
  Future<String> sendCustomCommand(String command) async {
    if (!isConnected) {
      _logger.warning('Cannot send command, not connected');
      return 'Not connected';
    }
    
    try {
      _logger.info('Sending custom command: $command');
      final response = await _protocol!.sendCommand(command);
      return response;
    } catch (e) {
      _logger.warning('Error sending custom command: $e');
      return 'Error: $e';
    }
  }
  
  /// Get a list of PIDs to request based on current engine state
  List<String> _getPidsForCurrentState() {
    // Define critical PIDs (requested in every cycle)
    final criticalPids = [
      ObdConstants.pidEngineRpm,
      ObdConstants.pidVehicleSpeed, // Promote speed to critical tier
    ];
    
    // Define high priority PIDs (requested in most cycles)
    final highPriorityPids = [
      ObdConstants.pidThrottlePosition, // Keep this as high priority
    ];
    
    final mediumPriorityPids = [
      ObdConstants.pidCoolantTemp,
      ObdConstants.pidControlModuleVoltage,
      ObdConstants.pidFuelLevel
    ];
    
    // Initialize with empty list
    final pidsToRequest = <String>[];
    
    // Track which polling cycle we're in using a cycle counter
    _pollingCycleCounter = (_pollingCycleCounter + 1) % 10;
    
    // Always request critical PIDs first
    for (final pid in criticalPids) {
      if (_monitoredPids.contains(pid)) {
        pidsToRequest.add(pid);
      }
    }
    
    // Request throttle position more frequently during acceleration
    // If we have RPM data and it's increasing, we're likely accelerating
    bool isAccelerating = false;
    if (_lastRpmValue != null && _lastRpmChangeTime != null) {
      final timeSinceRpmChange = DateTime.now().difference(_lastRpmChangeTime!).inMilliseconds;
      
      // If RPM changed recently (last 2 seconds) and is above idle RPM
      if (timeSinceRpmChange < 2000 && _lastRpmValue! > 1000) {
        isAccelerating = true;
      }
    }
    
    // During acceleration, always include throttle position
    if (isAccelerating && _monitoredPids.contains(ObdConstants.pidThrottlePosition)) {
      if (!pidsToRequest.contains(ObdConstants.pidThrottlePosition)) {
        _logger.fine('Adding throttle position due to acceleration');
        pidsToRequest.add(ObdConstants.pidThrottlePosition);
      }
    } 
    // Otherwise follow normal schedule for high priority PIDs
    else if (_pollingCycleCounter % 2 == 0) {
      for (final pid in _monitoredPids) {
        if (highPriorityPids.contains(pid) && !pidsToRequest.contains(pid)) {
          pidsToRequest.add(pid);
        }
      }
      
      // Add medium priority PIDs less frequently
      if (_pollingCycleCounter % 3 == 0) {
        for (final pid in _monitoredPids) {
          if (mediumPriorityPids.contains(pid) && !pidsToRequest.contains(pid)) {
            pidsToRequest.add(pid);
          }
        }
      }
    }
    
    // Engine state specific logic
    if (!_engineRunning) {
      // When engine is off, only add basic PIDs that work with ignition on
      for (final pid in _monitoredPids) {
        if (pid == ObdConstants.pidSupportedPids || 
            pid == ObdConstants.pidFuelLevel) {
          if (!pidsToRequest.contains(pid)) {
            pidsToRequest.add(pid);
          }
        }
      }
    } else {
      // For engine running state, add remaining low priority PIDs every 5 cycles
      if (_pollingCycleCounter % 5 == 0) {
        final currentTime = DateTime.now();
        
        for (final pid in _monitoredPids) {
          // Skip if already added as priority
          if (pidsToRequest.contains(pid)) continue;
          // Skip high/medium priority PIDs if this isn't their cycle
          if (highPriorityPids.contains(pid) && _pollingCycleCounter % 2 != 0) continue;
          if (mediumPriorityPids.contains(pid) && _pollingCycleCounter % 3 != 0) continue;
          
          final failureCount = _pidFailureCount[pid] ?? 0;
          final lastRequestTime = _lastPidRequestTime[pid];
          
          // If PID has failed too many times, reduce polling frequency
          if (failureCount >= _maxFailureCount && lastRequestTime != null) {
            // More aggressive backoff for problematic PIDs (4 seconds per failure)
            final backoffSeconds = (failureCount - _maxFailureCount + 1) * 4;
            final nextRequestTime = lastRequestTime.add(Duration(seconds: backoffSeconds));
            
            // Skip this PID if we need to wait longer
            if (currentTime.isBefore(nextRequestTime)) {
              continue;
            }
          }
          
          // Limit the number of PIDs per cycle to prevent overwhelming the adapter
          // Only allow 3 PIDs max if RPM is one of them for better responsiveness
          final maxPidsPerCycle = pidsToRequest.contains(ObdConstants.pidEngineRpm) ? 3 : 5;
          if (pidsToRequest.length < maxPidsPerCycle) {
            pidsToRequest.add(pid);
          }
        }
      }
    }
    
    // Log the PIDs being requested
    _logger.fine('Requesting PIDs: ${pidsToRequest.join(', ')} (cycle: $_pollingCycleCounter)');
    
    return pidsToRequest;
  }
  
  /// Poll for data from the OBD adapter
  Future<void> _pollData() async {
    if (!isConnected || _monitoredPids.isEmpty) return;
    
    try {
      _logger.fine('Polling data for ${_monitoredPids.length} PIDs');
      
      // Always check RPM first for engine state tracking
      if (!_engineRunning || _engineCheckCounter % 2 == 0) {
        await _checkEngineState();
      }
      _engineCheckCounter++;
      
      // Determine which PIDs to request this cycle based on engine state and priority
      List<String> pidsToRequest = _getPidsForCurrentState();
      
      if (pidsToRequest.isNotEmpty) {
        // Track which PIDs were processed separately to avoid duplicate requests
        final processedPids = <String>{};
        bool anySeparateRequestSucceeded = false;
        
        // Check if we're likely accelerating (for throttle position priority)
        bool isAccelerating = false;
        if (_lastRpmValue != null && _lastRpmChangeTime != null) {
          final timeSinceRpmChange = DateTime.now().difference(_lastRpmChangeTime!).inMilliseconds;
          // If RPM changed recently and is above idle
          if (timeSinceRpmChange < 2000 && _lastRpmValue! > 1000) {
            isAccelerating = true;
          }
        }
        
        // Handle RPM separately for faster response time if needed
        if (pidsToRequest.contains(ObdConstants.pidEngineRpm) && pidsToRequest.length > 1) {
          if (_engineRunning) {
            pidsToRequest.remove(ObdConstants.pidEngineRpm);
            
            final rpmFailureCount = _pidFailureCount[ObdConstants.pidEngineRpm] ?? 0;
            if (rpmFailureCount < 2) {
              final rpmData = await _protocol!.requestPid(ObdConstants.pidEngineRpm);
              if (rpmData != null) {
                _latestData[ObdConstants.pidEngineRpm] = rpmData;
                _pidFailureCount[ObdConstants.pidEngineRpm] = 0;
                _lastPidRequestTime[ObdConstants.pidEngineRpm] = DateTime.now();
                processedPids.add(ObdConstants.pidEngineRpm);
                anySeparateRequestSucceeded = true;
              } else {
                _pidFailureCount[ObdConstants.pidEngineRpm] = 
                    (_pidFailureCount[ObdConstants.pidEngineRpm] ?? 0) + 1;
                // Add back to batch request
                pidsToRequest.add(ObdConstants.pidEngineRpm);
              }
            } else {
              // Too many failures, add back to batch
              pidsToRequest.add(ObdConstants.pidEngineRpm);
            }
          } else {
            // Keep in batch for non-running engines
            // No change needed here
          }
        }
        
        // Also handle speed separately for improved responsiveness
        if (pidsToRequest.contains(ObdConstants.pidVehicleSpeed) && _engineRunning) {
          pidsToRequest.remove(ObdConstants.pidVehicleSpeed);
          
          final speedFailureCount = _pidFailureCount[ObdConstants.pidVehicleSpeed] ?? 0;
          if (speedFailureCount < 2) {
            final speedData = await _protocol!.requestPid(ObdConstants.pidVehicleSpeed);
            if (speedData != null) {
              _latestData[ObdConstants.pidVehicleSpeed] = speedData;
              _pidFailureCount[ObdConstants.pidVehicleSpeed] = 0;
              _lastPidRequestTime[ObdConstants.pidVehicleSpeed] = DateTime.now();
              processedPids.add(ObdConstants.pidVehicleSpeed);
              anySeparateRequestSucceeded = true;
            } else {
              _pidFailureCount[ObdConstants.pidVehicleSpeed] = 
                  (_pidFailureCount[ObdConstants.pidVehicleSpeed] ?? 0) + 1;
              // Add back to batch request
              pidsToRequest.add(ObdConstants.pidVehicleSpeed);
            }
          } else {
            // Too many failures, add back to batch
            pidsToRequest.add(ObdConstants.pidVehicleSpeed);
          }
        }
        
        // Handle throttle position separately during acceleration
        if (isAccelerating && pidsToRequest.contains(ObdConstants.pidThrottlePosition)) {
          pidsToRequest.remove(ObdConstants.pidThrottlePosition);
          
          final throttleFailureCount = _pidFailureCount[ObdConstants.pidThrottlePosition] ?? 0;
          if (throttleFailureCount < 2) {
            _logger.fine('Requesting throttle position separately during acceleration');
            final throttleData = await _protocol!.requestPid(ObdConstants.pidThrottlePosition);
            if (throttleData != null) {
              _latestData[ObdConstants.pidThrottlePosition] = throttleData;
              _pidFailureCount[ObdConstants.pidThrottlePosition] = 0;
              _lastPidRequestTime[ObdConstants.pidThrottlePosition] = DateTime.now();
              processedPids.add(ObdConstants.pidThrottlePosition);
              anySeparateRequestSucceeded = true;
            } else {
              _pidFailureCount[ObdConstants.pidThrottlePosition] = 
                  (_pidFailureCount[ObdConstants.pidThrottlePosition] ?? 0) + 1;
              // Add back to batch request
              pidsToRequest.add(ObdConstants.pidThrottlePosition);
            }
          } else {
            // Too many failures, add back to batch
            pidsToRequest.add(ObdConstants.pidThrottlePosition);
          }
        }
        
        // Process all remaining PIDs as a batch
        if (pidsToRequest.isNotEmpty) {
          final data = await _protocol!.requestPids(pidsToRequest);
          
          // Update successful PIDs and their last request times
          data.forEach((pid, value) {
            _pidFailureCount[pid] = 0;  // Reset failure count on success
            _lastPidRequestTime[pid] = DateTime.now();
          });
          
          // Check for failures (PIDs that were requested but not returned)
          for (var pid in pidsToRequest) {
            if (!data.containsKey(pid)) {
              _pidFailureCount[pid] = (_pidFailureCount[pid] ?? 0) + 1;
              _logger.fine('PID $pid failed, failure count: ${_pidFailureCount[pid]}');
            }
          }
          
          // Track successful poll
          if (data.isNotEmpty) {
            _consecutivePollingFailures = 0;
            _lastSuccessfulPoll = DateTime.now();
          } else {
            _consecutivePollingFailures++;
            _logger.warning('Empty poll response, consecutive failures: $_consecutivePollingFailures');
          }
          
          _latestData.addAll(data);
          notifyListeners();
        } else if (anySeparateRequestSucceeded) {
          // If we only processed PIDs separately but nothing in batch, still consider this a successful poll
          _consecutivePollingFailures = 0;
          _lastSuccessfulPoll = DateTime.now();
          notifyListeners();
        }
      }
    } catch (e) {
      _logger.warning('Error polling data: $e');
      _consecutivePollingFailures++;
      
      // Check if we need to recover the connection
      final timeSinceLastSuccess = DateTime.now().difference(_lastSuccessfulPoll).inSeconds;
      if (_consecutivePollingFailures >= _maxPollingFailures || timeSinceLastSuccess > 30) {
        _logger.warning('Too many polling failures ($_consecutivePollingFailures) or too long without data (${timeSinceLastSuccess}s). Attempting recovery...');
        _attemptConnectionRecovery();
      }
    }
  }
  
  /// Attempt to recover a stalled connection
  Future<void> _attemptConnectionRecovery() async {
    _logger.info('Attempting connection recovery');
    try {
      // Stop polling during recovery
      _stopPolling();
      
      // Disconnect and reconnect to the same device
      final currentDeviceId = _getCurrentDeviceId();
      if (currentDeviceId != null) {
        _logger.info('Disconnecting from device: $currentDeviceId');
        disconnect(); // No need to await, this method is void
        
        // Wait a moment before reconnecting
        await Future.delayed(const Duration(milliseconds: 1000));
        
        _logger.info('Reconnecting to device: $currentDeviceId');
        final reconnected = await connect(currentDeviceId);
        if (reconnected) {
          _logger.info('Successfully recovered connection');
          _consecutivePollingFailures = 0;
          _lastSuccessfulPoll = DateTime.now();
          _startPolling();
        } else {
          _logger.severe('Failed to recover connection');
        }
      }
    } catch (e) {
      _logger.severe('Error during connection recovery: $e');
    }
  }
  
  /// Get the current device ID from the protocol
  String? _getCurrentDeviceId() {
    // Simply return the last connected device ID that we stored
    // when connect() was called
    return _lastConnectedDeviceId;
  }
  
  /// Checks if the engine is running by requesting RPM
  Future<void> _checkEngineState() async {
    try {
      final currentTime = DateTime.now();
      
      // Request the RPM PID specifically
      final rpmData = await _protocol?.requestPid(ObdConstants.pidEngineRpm);
      
      // Update engine running state based on RPM
      bool newEngineState = false;
      bool rpmResponseValid = false;
      int rpm = 0;
      
      if (rpmData != null && rpmData.value != null) {
        // RPM > 0 means engine is running
        if (rpmData.value is int) {
          rpm = rpmData.value as int;
          rpmResponseValid = true;
        } else if (rpmData.value is double) {
          rpm = (rpmData.value as double).toInt();
          rpmResponseValid = true;
        } else if (rpmData.value is String) {
          try {
            rpm = int.parse(rpmData.value.toString());
            rpmResponseValid = true;
          } catch (_) {
            // Failed to parse as int, leave rpm as 0
            _logger.warning('Failed to parse RPM value: ${rpmData.value}');
          }
        }
        
        // Check if RPM has changed since last time
        if (rpmResponseValid) {
          if (_lastRpmValue != rpm) {
            _lastRpmChangeTime = currentTime;
            _lastRpmValue = rpm;
            _sameRpmCounter = 0; // Reset counter when RPM changes
            _logger.fine('RPM changed to: $rpm');
          } else {
            // Same RPM value as before
            _sameRpmCounter++;
            _logger.fine('Same RPM value ($rpm) for $_sameRpmCounter consecutive readings');
            
            // Check if we need to verify due to too many identical readings
            bool needsVerification = false;
            
            if (_sameRpmCounter >= _maxIdenticalRpmReadings) {
              _logger.info('RPM value ($rpm) unchanged for $_sameRpmCounter consecutive readings, verifying');
              needsVerification = true;
              _sameRpmCounter = 0; // Reset counter after verification
            } else if (_lastRpmChangeTime != null && rpm > 0) {
              // Check for RPM staleness (no change for a while) - only if RPM > 0
              final staleDuration = currentTime.difference(_lastRpmChangeTime!).inMilliseconds;
              if (staleDuration > _rpmStalenessThresholdMs) {
                _logger.info('RPM value ($rpm) has not changed for ${staleDuration}ms, verifying engine state');
                needsVerification = true;
              }
            }
            
            // Perform verification if needed
            if (needsVerification) {
              // Less aggressive verification - don't rely only on other indicators
              // For a cheap adapter, constant RPM value might be valid for a long time at idle
              
              // Check vehicle speed - if speed > 0, engine must be running
              final speedData = _latestData[ObdConstants.pidVehicleSpeed];
              if (speedData != null && speedData.value != null) {
                final speed = _asInt(speedData.value) ?? 0;
                if (speed > 0) {
                  // Vehicle is moving, definitely engine running, no need for verification
                  _logger.fine('Vehicle is moving (${speed}km/h), engine must be on despite stale RPM');
                  newEngineState = true;
                  // Skip further verification
                  _lastRpmChangeTime = currentTime; // Reset staleness timer
                } else {
                  // Only do a single verification request for very stale RPM at idle
                  _logger.info('Requesting RPM again to verify idle engine state');
                  final verifyRpmData = await _protocol?.requestPid(ObdConstants.pidEngineRpm);
                  
                  // Trust any valid response
                  if (verifyRpmData != null && verifyRpmData.value != null) {
                    final verifyRpm = _asInt(verifyRpmData.value) ?? 0;
                    rpm = verifyRpm; // Use the newest value
                    _lastRpmValue = rpm;
                    _lastRpmChangeTime = currentTime; // Reset staleness timer
                    _logger.info('RPM verified: $rpm');
                  }
                }
              }
            }
          }
        }
        
        // If we got any valid RPM value > 0, trust it
        newEngineState = rpm > 0;
        _logger.fine('Current RPM: $rpm, engine state: ${newEngineState ? "running" : "off"}');
      } else {
        // No RPM data received - could indicate engine is off or adapter issue
        _logger.info('No valid RPM data received, checking alternative indicators');
        
        // If we had a previous RPM value but now getting no data, likely engine off
        // But be more conservative about declaring engine off based on a single failed reading
        if (_lastRpmValue != null && _lastRpmValue! > 0) {
          // Check other indicators before concluding engine is off
          
          // Check vehicle speed
          final speedData = _latestData[ObdConstants.pidVehicleSpeed];
          if (speedData != null && speedData.value != null) {
            final speed = _asInt(speedData.value) ?? 0;
            if (speed > 0) {
              // If vehicle is moving, engine must be running despite RPM issue
              newEngineState = true;
              _logger.info('Engine still running based on speed: $speed km/h despite no RPM data');
            } else {
              // Try one more RPM request to be sure before declaring engine off
              _logger.info('No speed, trying RPM again before concluding engine off');
              final retryRpmData = await _protocol?.requestPid(ObdConstants.pidEngineRpm);
              if (retryRpmData != null && retryRpmData.value != null) {
                final retryRpm = _asInt(retryRpmData.value) ?? 0;
                if (retryRpm > 0) {
                  newEngineState = true;
                  rpm = retryRpm;
                  _lastRpmValue = rpm;
                  _lastRpmChangeTime = currentTime;
                  _logger.info('Engine confirmed running on retry: RPM $rpm');
                } else {
                  // Now we're more confident the engine is off
                  _logger.info('Engine confirmed off: RPM 0 on verification');
                  _lastRpmValue = 0;
                }
              } else {
                // Two failed RPM requests in a row, likely engine off
                _logger.info('Two failed RPM requests, engine likely off');
                _lastRpmValue = 0;
              }
            }
          } else {
            // No speed data and no RPM data - check other indicators
            // But be more conservative about declaring engine off
            
            // Check throttle position
            final throttleData = _latestData[ObdConstants.pidThrottlePosition];
            if (throttleData != null && throttleData.value != null) {
              final throttle = _asInt(throttleData.value) ?? 0;
              if (throttle > 0) {
                newEngineState = true;
                _logger.info('Engine likely running based on throttle position: $throttle%');
              }
            }
            
            // Check engine load as last resort
            if (!newEngineState) {
              final loadData = _latestData[ObdConstants.pidEngineLoad];
              if (loadData != null && loadData.value != null) {
                final load = _asInt(loadData.value) ?? 0;
                if (load > 0) {
                  newEngineState = true;
                  _logger.info('Engine likely running based on engine load: $load%');
                } else {
                  // Multiple indicators suggest engine off
                  _logger.info('Multiple indicators suggest engine off');
                  _lastRpmValue = 0;
                }
              }
            }
          }
        }
      }
      
      // Only notify if state changed
      if (_engineRunning != newEngineState) {
        _logger.info('Engine state changed from ${_engineRunning ? "running" : "off"} to ${newEngineState ? "running" : "off"}');
        _engineRunning = newEngineState;
        notifyListeners();
      }
    } catch (e) {
      _logger.warning('Error checking engine state: $e');
    }
  }
  
  /// Handle data received from the OBD adapter
  void _handleObdData(ObdData data) {
    _logger.fine('Received OBD data: $data');
    
    // Store previous value to check for changes
    dynamic previousValue = _latestData[data.pid]?.value;
    
    // Update latest data
    _latestData[data.pid] = data;
    
    // Special handling for RPM data for engine state tracking
    if (data.pid == ObdConstants.pidEngineRpm && data.value != null) {
      int rpm = 0;
      
      if (data.value is int) {
        rpm = data.value as int;
      } else if (data.value is double) {
        rpm = (data.value as double).toInt();
      } else if (data.value is String) {
        try {
          rpm = int.parse(data.value.toString());
        } catch (_) {
          // Failed to parse as int
          _logger.warning('Failed to parse RPM in _handleObdData: ${data.value}');
        }
      }
      
      // Track RPM changes for staleness detection
      if (_lastRpmValue != rpm) {
        _lastRpmValue = rpm;
        _lastRpmChangeTime = DateTime.now();
      }
      
      bool newEngineState = rpm > 0;
      
      // Always update and notify if RPM data received, regardless of previous state
      if (_engineRunning != newEngineState) {
        _logger.info('Engine state changed to: ${newEngineState ? "running" : "off"} (RPM: $rpm)');
        _engineRunning = newEngineState;
        notifyListeners();
      }
    }
    
    // Special handling for speed data for eco-driving
    if (data.pid == ObdConstants.pidVehicleSpeed && data.value != null) {
      int speed = 0;
      
      if (data.value is int) {
        speed = data.value as int;
      } else if (data.value is double) {
        speed = (data.value as double).toInt();
      } else if (data.value is String) {
        try {
          speed = int.parse(data.value.toString());
        } catch (_) {
          // Failed to parse as int
          _logger.warning('Failed to parse speed: ${data.value}');
        }
      }
      
      // Log when speed changes to help with debugging
      if (previousValue != data.value) {
        _logger.info('Speed changed from $previousValue to $speed km/h');
      }
    }
    
    // Special handling for throttle position
    if (data.pid == ObdConstants.pidThrottlePosition && data.value != null) {
      double throttle = 0;
      
      if (data.value is int) {
        throttle = (data.value as int).toDouble();
      } else if (data.value is double) {
        throttle = data.value as double;
      } else if (data.value is String) {
        try {
          throttle = double.parse(data.value.toString());
        } catch (_) {
          // Failed to parse as double
          _logger.warning('Failed to parse throttle position: ${data.value}');
        }
      }
      
      // Log throttle position changes for debugging
      if (previousValue != data.value) {
        _logger.info('Throttle position changed from $previousValue to $throttle%');
      }
    }
    
    notifyListeners();
  }
  
  /// Helper method to safely convert a value to double 
  double? _asDouble(dynamic value) {
    if (value == null) return null;
    if (value is double) return value;
    if (value is int) return value.toDouble();
    if (value is String) return double.tryParse(value);
    return null;
  }
  
  /// Helper method to safely convert a value to int
  int? _asInt(dynamic value) {
    if (value == null) return null;
    if (value is int) return value;
    if (value is double) return value.toInt();
    if (value is String) return int.tryParse(value);
    return null;
  }
  
  /// Start polling for data
  void _startPolling() {
    _stopPolling();
    _logger.info('Starting polling');
    
    // Start with safer, slightly longer polling interval for cheap adapters
    _currentPollingInterval = ObdConstants.slowPollingInterval;
    _pollingTimer = Timer.periodic(
      Duration(milliseconds: _currentPollingInterval),
      (_) {
        _pollData();
        _updatePollingInterval();
      },
    );
  }
  
  /// Stop polling for data
  void _stopPolling() {
    if (_pollingTimer != null) {
      _logger.info('Stopping polling');
      _pollingTimer!.cancel();
      _pollingTimer = null;
    }
  }
  
  /// Update polling interval based on engine state and adapter performance
  void _updatePollingInterval() {
    if (_pollingTimer == null) return;
    
    // Track the number of consecutive timeouts to dynamically adjust polling
    int timeoutCount = 0;
    _pidFailureCount.forEach((pid, count) {
      if (count >= _maxFailureCount) timeoutCount++;
    });
    
    // Determine appropriate polling interval
    int desiredInterval;
    
    // Base polling interval selection on engine state first
    if (!_engineRunning) {
      // Engine off - use longer polling interval to conserve resources
      desiredInterval = ObdConstants.engineOffPollingInterval;
    } else {
      // Start with the base polling interval for running engine
      // Higher timeout counts mean the adapter is struggling
      if (timeoutCount > 3) {
        // Multiple timeouts - increase interval to give adapter more time
        // But don't go as high as before - increment by smaller amounts now
        desiredInterval = ObdConstants.slowPollingInterval + 300; 
        _logger.info('Increasing polling interval due to multiple timeouts');
      } else if (timeoutCount > 1) {
        // Some timeouts - use the standard slow polling interval
        desiredInterval = ObdConstants.slowPollingInterval;
      } else {
        // No or few timeouts - can use default polling, which is already optimized
        desiredInterval = ObdConstants.defaultPollingInterval;
        
        // If we have recent RPM changes (active driving), try to be even more responsive
        if (_lastRpmChangeTime != null) {
          final timeSinceRpmChange = 
              DateTime.now().difference(_lastRpmChangeTime!).inMilliseconds;
              
          // If RPM changed recently (last 5 seconds), try to use faster polling
          // But only if we have no timeouts at all
          if (timeSinceRpmChange < 5000 && timeoutCount == 0) {
            desiredInterval = ObdConstants.fastPollingInterval;
            _logger.fine('Using fast polling due to recent RPM changes');
          }
        }
      }
      
      // Safety check to ensure we don't go too fast
      if (desiredInterval < 500) { // Don't go below 500ms minimum for any adapter
        desiredInterval = 500;
      }
    }
    
    // Update polling timer if interval needs to change
    if (_currentPollingInterval != desiredInterval) {
      _logger.info('Changing polling interval from $_currentPollingInterval ms to $desiredInterval ms');
      _stopPolling();
      _currentPollingInterval = desiredInterval;
      _pollingTimer = Timer.periodic(
        Duration(milliseconds: _currentPollingInterval),
        (_) {
          _pollData();
          _updatePollingInterval();
        },
      );
    }
  }
  
  /// Start continuous queries for monitored PIDs
  /// This is used by the DrivingService to begin data collection
  Future<void> startContinuousQueries() async {
    _logger.info('Starting continuous queries for ${_monitoredPids.length} PIDs');
    ensureEssentialPidsAreMonitored();
    _startPolling();
    return Future.value();
  }
  
  /// Stop all queries
  /// This is used by the DrivingService to end data collection
  Future<void> stopQueries() async {
    _logger.info('Stopping all queries');
    _stopPolling();
    return Future.value();
  }
  
  @override
  void dispose() {
    _logger.info('Disposing ObdService');
    _stopPolling();
    _protocol?.dispose();
    _scanner.dispose();
    super.dispose();
  }

  /// Make sure throttle position is monitored
  void ensureEssentialPidsAreMonitored() {
    // Essential PIDs for eco-driving that should always be monitored
    final essentialPids = [
      ObdConstants.pidEngineRpm,
      ObdConstants.pidVehicleSpeed,
      ObdConstants.pidThrottlePosition,
    ];
    
    // Add any missing essential PIDs
    for (final pid in essentialPids) {
      if (!_monitoredPids.contains(pid)) {
        _logger.info('Adding missing essential PID: $pid');
        _monitoredPids.add(pid);
      }
    }
  }
} 

/// Extension methods for testing
extension ObdServiceTestExtensions on ObdService {
  /// Injects a protocol instance for testing purposes
  void injectProtocolForTesting(ObdProtocol protocol) {
    _protocol = protocol;
  }
  
  /// Runs the engine state check directly for testing
  Future<void> checkEngineStateForTesting() async {
    await _checkEngineState();
  }
  
  /// Simulates consecutive polling failures for testing
  void simulatePollingFailureForTesting(int failureCount) {
    _consecutivePollingFailures = failureCount;
    _updatePollingInterval();
  }
  
  /// Get the current polling interval for testing
  int get currentPollingIntervalForTesting => _currentPollingInterval;
  
  /// Directly trigger a polling cycle for testing
  Future<void> triggerPollingCycleForTesting() async {
    await _pollData();
  }
  
  /// Get the current protocol for testing
  ObdProtocol? get protocolForTesting => _protocol;
}

################################################################################
FILE: lib/obd_lib/mocks/mock_elm327_protocol.dart
################################################################################

import 'dart:async';
import 'dart:convert';
import 'dart:math';
import 'package:logging/logging.dart';

import '../interfaces/obd_connection.dart';
import '../protocol/obd_protocol.dart';
import '../protocol/obd_constants.dart';
import '../models/obd_command.dart';
import '../models/obd_data.dart';
import '../models/adapter_config.dart';
import '../models/adapter_config_factory.dart';
import 'mock_test_data.dart';

/// A mock implementation of the ELM327 protocol for testing
///
/// This class simulates the behavior of an ELM327 protocol handler,
/// providing synthetic responses based on pre-defined or recorded data.
class MockElm327Protocol implements ObdProtocol {
  static final Logger _logger = Logger('MockElm327Protocol');
  
  /// The connection being used (likely a MockConnection)
  final ObdConnection connection;
  
  /// Debug mode flag
  final bool _isDebugMode;
  
  /// Test data configuration
  final String? scenarioName;
  final Map<String, List<dynamic>>? testData;
  final bool simulateConnectionIssues;
  final double connectionReliability;
  
  /// Adapter configuration
  final AdapterConfig config;
  
  /// Protocol state
  bool _isInitialized = false;
  bool _isConnecting = false;
  String? _errorMessage;
  
  /// Data stream controller
  final _dataStreamController = StreamController<ObdData>.broadcast();
  
  /// Stream subscription for connection data
  StreamSubscription? _connectionSubscription;
  
  /// Test data provider
  late MockTestData _testDataProvider;
  
  /// Current simulation timer
  Timer? _simulationTimer;
  
  /// Creates a new MockElm327Protocol
  MockElm327Protocol(
    this.connection, {
    this.scenarioName,
    this.testData,
    this.simulateConnectionIssues = false,
    this.connectionReliability = 1.0,
    bool isDebugMode = false,
    AdapterConfig? adapterConfig,
  }) : _isDebugMode = isDebugMode,
       config = adapterConfig ?? AdapterConfigFactory.createCheapElm327Config() {
    // Initialize with appropriate test data
    _testDataProvider = MockTestData(
      scenarioName: scenarioName,
      customData: testData,
    );
    
    // Log configuration
    _logger.info('Created MockElm327Protocol with '
        'scenario: $scenarioName, '
        'simulateConnectionIssues: $simulateConnectionIssues, '
        'reliability: $connectionReliability, '
        'config: ${config.profileId}');
  }
  
  @override
  bool get isInitialized => _isInitialized;
  
  @override
  bool get isConnected => connection.isConnected && _isInitialized;
  
  @override
  bool get isConnecting => _isConnecting;
  
  @override
  String? get errorMessage => _errorMessage;
  
  @override
  Stream<String> get dataStream => connection.dataStream;
  
  @override
  Stream<ObdData> get obdDataStream => _dataStreamController.stream;
  
  @override
  Future<bool> initialize() async {
    _logger.info('Initializing mock protocol');
    _isConnecting = true;
    _errorMessage = null;
    
    try {
      // Simulate connection process
      if (!connection.isConnected) {
        final connected = await connection.connect();
        if (!connected) {
          _errorMessage = 'Failed to connect';
          _isConnecting = false;
          return false;
        }
      }
      
      // Simulate initialization delay
      await Future.delayed(Duration(milliseconds: 200));
      
      // Simulate a connection issue if configured
      if (simulateConnectionIssues && Random().nextDouble() > connectionReliability) {
        _errorMessage = 'Simulated connection issue during initialization';
        _isConnecting = false;
        return false;
      }
      
      // Set up listeners
      _setupDataListener();
      
      // Set up simulation timer for continuous data
      _startSimulation();
      
      _isInitialized = true;
      _isConnecting = false;
      return true;
    } catch (e) {
      _errorMessage = 'Error during initialization: $e';
      _logger.severe(_errorMessage);
      _isConnecting = false;
      return false;
    }
  }
  
  @override
  Future<void> dispose() async {
    _logger.info('Disposing mock protocol');
    
    // Stop simulation
    _stopSimulation();
    
    // Cancel subscriptions
    await _connectionSubscription?.cancel();
    _connectionSubscription = null;
    
    // Close streams
    await _dataStreamController.close();
    
    // Disconnect
    if (connection.isConnected) {
      await connection.disconnect();
    }
    
    _isInitialized = false;
  }
  
  @override
  Future<ObdData?> requestPid(String pid) async {
    if (!isConnected) {
      _logger.warning('Cannot request data: not connected');
      return null;
    }
    
    // Simulate command processing delay
    await Future.delayed(Duration(milliseconds: 20 + Random().nextInt(30)));
    
    // Simulate connection issues if configured
    if (simulateConnectionIssues && Random().nextDouble() > connectionReliability) {
      _logger.warning('Simulated connection issue during command: $pid');
      return null;
    }
    
    // Get data from test data provider
    final data = _testDataProvider.getDataForPid(pid);
    if (data != null) {
      final obdData = ObdData(
        pid: pid,
        value: data,
        timestamp: DateTime.now(),
        mode: '01',  // Standard mode for current data
        name: _getPidName(pid),
        unit: _getPidUnit(pid),
        rawData: utf8.encode(data.toString()),  // Convert to bytes
      );
      _dataStreamController.add(obdData);
      return obdData;
    }
    
    _logger.warning('No test data available for PID: $pid');
    return null;
  }
  
  @override
  Future<Map<String, ObdData>> requestPids(List<String> pids) async {
    if (!isConnected) {
      _logger.warning('Cannot request multiple data: not connected');
      return {};
    }
    
    final results = <String, ObdData>{};
    
    // Process each PID with a small delay between them
    for (final pid in pids) {
      final data = await requestPid(pid);
      if (data != null) {
        results[pid] = data;
      }
      
      // Small delay between commands
      await Future.delayed(Duration(milliseconds: 10));
    }
    
    return results;
  }
  
  @override
  Future<String> sendCommand(String command) async {
    if (!isConnected) {
      _logger.warning('Cannot send command: not connected');
      return 'ERROR';
    }
    
    // Simulate command processing
    await Future.delayed(Duration(milliseconds: 50));
    
    // Simulate success or failure
    if (simulateConnectionIssues && Random().nextDouble() > connectionReliability) {
      return 'ERROR';
    }
    
    // For standard commands, return OK
    return 'OK';
  }
  
  @override
  Future<String> sendObdCommand(ObdCommand command) async {
    if (!isConnected) {
      _logger.warning('Cannot send OBD command: not connected');
      return 'ERROR';
    }
    
    // Simulate command processing
    await Future.delayed(Duration(milliseconds: 50));
    
    // Simulate success or failure
    if (simulateConnectionIssues && Random().nextDouble() > connectionReliability) {
      return 'ERROR';
    }
    
    // Return a simulated response based on command
    return '41 ${command.pid} 00 00';
  }
  
  /// Set up the data listener
  void _setupDataListener() {
    // Subscribe to the connection's data stream
    _connectionSubscription = connection.dataStream.listen((data) {
      if (_isDebugMode) {
        _logger.fine('Received data from connection: $data');
      }
      
      // In a real implementation, this would parse the data
      // For the mock, we'll ignore it since we're generating data directly
    });
  }
  
  /// Start the simulation timer for continuous data updates
  void _startSimulation() {
    _logger.info('Starting data simulation');
    
    // Cancel any existing timer
    _stopSimulation();
    
    // Create a new timer that generates data periodically
    // Increased from 100ms to 1000ms to make values more stable and readable
    _simulationTimer = Timer.periodic(Duration(milliseconds: 1000), (_) {
      if (isConnected) {
        _simulateDataUpdate();
      }
    });
  }
  
  /// Stop the simulation timer
  void _stopSimulation() {
    _simulationTimer?.cancel();
    _simulationTimer = null;
  }
  
  /// Simulate a data update by generating values for common PIDs
  void _simulateDataUpdate() {
    final now = DateTime.now();
    
    // Generate data for common PIDs
    final commonPids = [
      ObdConstants.pidEngineRpm,
      ObdConstants.pidVehicleSpeed,
      ObdConstants.pidThrottlePosition,
      ObdConstants.pidCoolantTemp,
      ObdConstants.pidControlModuleVoltage,
    ];
    
    for (final pid in commonPids) {
      final value = _testDataProvider.getDataForPid(pid);
      if (value != null) {
        final obdData = ObdData(
          pid: pid,
          value: value,
          timestamp: now,
          mode: '01',  // Standard mode for current data
          name: _getPidName(pid),
          unit: _getPidUnit(pid),
          rawData: utf8.encode(value.toString()),  // Convert to bytes
        );
        _dataStreamController.add(obdData);
      }
    }
  }
  
  /// Get a human-readable name for a PID
  String _getPidName(String pid) {
    switch (pid) {
      case ObdConstants.pidEngineRpm:
        return 'Engine RPM';
      case ObdConstants.pidVehicleSpeed:
        return 'Vehicle Speed';
      case ObdConstants.pidThrottlePosition:
        return 'Throttle Position';
      case ObdConstants.pidCoolantTemp:
        return 'Coolant Temperature';
      case ObdConstants.pidControlModuleVoltage:
        return 'Module Voltage';
      case ObdConstants.pidFuelLevel:
        return 'Fuel Level';
      default:
        return 'Unknown';
    }
  }
  
  /// Get the unit for a PID
  String _getPidUnit(String pid) {
    switch (pid) {
      case ObdConstants.pidEngineRpm:
        return 'rpm';
      case ObdConstants.pidVehicleSpeed:
        return 'km/h';
      case ObdConstants.pidThrottlePosition:
        return '%';
      case ObdConstants.pidCoolantTemp:
        return '°C';
      case ObdConstants.pidControlModuleVoltage:
        return 'V';
      case ObdConstants.pidFuelLevel:
        return '%';
      default:
        return '';
    }
  }
} 

################################################################################
FILE: lib/obd_lib/mocks/mock_example.dart
################################################################################

import 'package:flutter/material.dart';
import '../obd_factory.dart';
import '../obd_service.dart';
import 'mock_test_data.dart';

/// Example of using the mock OBD implementation
///
/// This example demonstrates how to use the mock OBD implementation
/// for testing without requiring actual hardware.
class MockObdExample extends StatefulWidget {
  const MockObdExample({super.key});

  @override
  State<MockObdExample> createState() => _MockObdExampleState();
}

class _MockObdExampleState extends State<MockObdExample> {
  final ObdService _obdService = ObdService(isDebugMode: true);
  String _status = 'Disconnected';
  final Map<String, String> _data = {};
  String _selectedScenario = 'city_driving';

  @override
  void initState() {
    super.initState();
    _setupService();
  }

  @override
  void dispose() {
    _obdService.disconnect();
    super.dispose();
  }

  /// Set up the OBD service with the mock profile
  Future<void> _setupService() async {
    // Set the mock adapter profile
    _obdService.setAdapterProfile('mock_elm327');
    
    // Listen for data updates
    _obdService.addListener(() {
      if (mounted) {
        setState(() {
          _status = _obdService.isConnected ? 'Connected' : 'Disconnected';
          
          // Update data display
          _data.clear();
          _obdService.latestData.forEach((pid, data) {
            _data[data.name] = '${data.value} ${data.unit}';
          });
        });
      }
    });
  }

  /// Connect to the mock OBD adapter
  Future<void> _connect() async {
    setState(() {
      _status = 'Connecting...';
    });
    
    // Connect to the mock device
    final connected = await _obdService.connect('MOCK_DEVICE');
    
    setState(() {
      _status = connected ? 'Connected' : 'Connection failed';
    });
  }

  /// Disconnect from the mock OBD adapter
  Future<void> _disconnect() async {
    _obdService.disconnect();
    
    setState(() {
      _status = 'Disconnected';
      _data.clear();
    });
  }

  /// Change the test scenario
  void _changeScenario(String scenario) {
    setState(() {
      _selectedScenario = scenario;
    });
    
    // Disconnect first if connected
    if (_obdService.isConnected) {
      _obdService.disconnect();
    }
    
    // Set the mock adapter profile with the selected scenario
    ObdFactory.profileManager.setManualProfile('mock_elm327');
    
    // Reconnect with the new scenario
    _connect();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Mock OBD Example'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Status
            Text('Status: $_status', 
              style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 16),
            
            // Connection controls
            Row(
              children: [
                ElevatedButton(
                  onPressed: _obdService.isConnected ? null : _connect,
                  child: const Text('Connect'),
                ),
                const SizedBox(width: 16),
                ElevatedButton(
                  onPressed: _obdService.isConnected ? _disconnect : null,
                  child: const Text('Disconnect'),
                ),
              ],
            ),
            const SizedBox(height: 24),
            
            // Scenario selection
            Text('Test Scenario:', 
              style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            DropdownButton<String>(
              value: _selectedScenario,
              onChanged: (value) {
                if (value != null) {
                  _changeScenario(value);
                }
              },
              items: MockTestData.availableScenarios
                  .map((scenario) => DropdownMenuItem(
                        value: scenario,
                        child: Text(scenario.replaceAll('_', ' ')),
                      ))
                  .toList(),
            ),
            const SizedBox(height: 24),
            
            // Data display
            Text('OBD Data:', 
              style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            Expanded(
              child: _data.isEmpty
                  ? const Center(child: Text('No data available'))
                  : ListView.builder(
                      itemCount: _data.length,
                      itemBuilder: (context, index) {
                        final name = _data.keys.elementAt(index);
                        final value = _data[name];
                        return ListTile(
                          title: Text(name),
                          trailing: Text(value ?? 'N/A'),
                        );
                      },
                    ),
            ),
          ],
        ),
      ),
    );
  }
} 

################################################################################
FILE: lib/obd_lib/mocks/mock_connection.dart
################################################################################

import 'dart:async';
import 'dart:math';
import 'package:logging/logging.dart';

import '../interfaces/obd_connection.dart';

/// Mock OBD connection for testing
///
/// This class simulates an OBD-II connection for testing purposes
/// without requiring actual hardware.
class MockConnection implements ObdConnection {
  final Logger _logger = Logger('MockConnection');
  
  /// Stream controller for incoming data
  final _dataStreamController = StreamController<String>.broadcast();
  
  /// Whether the connection is established
  bool _isConnected = false;
  
  /// Simulated connection reliability
  final double connectionReliability;
  
  /// Simulate connection issues
  final bool simulateConnectionIssues;
  
  /// Mock responses for commands
  final Map<String, dynamic>? mockResponses;
  
  /// Index for selecting mock responses
  final Map<String, int> _responseIndex = {};
  
  /// Creates a new MockConnection
  MockConnection({
    this.connectionReliability = 1.0,
    this.simulateConnectionIssues = false,
    this.mockResponses,
  }) {
    _logger.info('Created MockConnection with reliability: $connectionReliability');
  }
  
  @override
  Stream<String> get dataStream => _dataStreamController.stream;
  
  @override
  bool get isConnected => _isConnected;
  
  @override
  Future<bool> connect() async {
    _logger.info('Connecting mock connection');
    
    // Simulate connection delay
    await Future.delayed(Duration(milliseconds: 200));
    
    // Simulate connection reliability
    if (Random().nextDouble() > connectionReliability) {
      _logger.warning('Mock connection failed (simulated failure)');
      return false;
    }
    
    _isConnected = true;
    _dataStreamController.add('CONNECTED');
    _logger.info('Mock connection successful');
    return true;
  }
  
  @override
  Future<bool> disconnect() async {
    _logger.info('Disconnecting mock connection');
    
    // Simulate disconnection delay
    await Future.delayed(Duration(milliseconds: 100));
    
    _isConnected = false;
    _dataStreamController.add('DISCONNECTED');
    _logger.info('Mock disconnection successful');
    return true;
  }
  
  @override
  Future<bool> sendCommand(String command) async {
    _logger.info('Sending mock command: $command');
    
    if (!isConnected) {
      _logger.warning('Cannot send command: mock connection not established');
      return false;
    }
    
    // Simulate connection issues if enabled
    if (simulateConnectionIssues && Random().nextDouble() > connectionReliability) {
      _logger.warning('Simulated connection issue for command: $command');
      // Don't send any response
      return false;
    }

    // Simulate command processing delay
    await Future.delayed(Duration(milliseconds: Random().nextInt(100) + 50));
    
    // Generate appropriate mock response based on the command
    String response = '';
    
    // Handle initialization commands
    if (command == 'ATZ') {
      response = 'ELM327 v1.5\r\r>';
    } else if (command == 'ATE0') {
      response = 'OK\r\r>';
    } else if (command == 'ATH0') {
      response = 'OK\r\r>';
    } else if (command == 'ATL0') {
      response = 'OK\r\r>';
    } else if (command == 'ATSP4') {
      response = 'OK\r\r>';
    } else if (command == 'ATBRD10') {
      response = 'OK\r\r>';
    } else if (command == 'ATST20') {
      response = 'OK\r\r>';
    } else if (command == 'AT@1') {
      response = 'ELM327 v1.5\r\r>';
    }
    // Handle OBD PID commands
    else if (command == '0100') {
      response = '41 00 BE 3E B8 10\r\r>';
    } else if (command == '010C') {
      response = '41 0C 0F A0\r\r>'; // ~1000 RPM
    } else if (command == '010D') {
      response = '41 0D 45\r\r>'; // ~70 km/h
    } else if (command == '0105') {
      response = '41 05 50\r\r>'; // ~40°C
    } else if (command == '0142') {
      response = '41 42 30 14\r\r>'; // ~12.3V
    } else {
      // Default response
      response = 'NO DATA\r\r>';
    }
    
    // Check if there's a mock response defined for this command
    if (mockResponses != null && mockResponses!.containsKey(command)) {
      final mockResponse = mockResponses![command];
      if (mockResponse != null) {
        // If it's a string, use it directly
        if (mockResponse is String) {
          response = mockResponse;
        }
        // If it's a list, get the next response from the list
        else if (mockResponse is List<String>) {
          if (_responseIndex.containsKey(command)) {
            final index = _responseIndex[command]!;
            if (index < mockResponse.length) {
              response = mockResponse[index];
              _responseIndex[command] = index + 1;
            }
          } else {
            if (mockResponse.isNotEmpty) {
              response = mockResponse[0];
              _responseIndex[command] = 1;
            }
          }
        }
      }
    }
    
    // Send the response
    if (response.isNotEmpty) {
      _sendResponse(response);
    }
    
    return true;
  }

  /// Send a response through the data stream
  void _sendResponse(String response) {
    if (_isConnected) {
      _dataStreamController.add(response);
    }
  }
  
  @override
  Future<void> dispose() async {
    _logger.info('Disposing mock connection');
    await disconnect();
    await _dataStreamController.close();
  }
} 

################################################################################
FILE: lib/obd_lib/mocks/mock_test_data.dart
################################################################################

import 'dart:math';
import '../protocol/obd_constants.dart';

/// Class for providing test data to mock OBD implementations
class MockTestData {
  /// The name of the pre-defined scenario to use
  final String? scenarioName;
  
  /// Custom data mapping PIDs to values
  final Map<String, List<dynamic>>? customData;
  
  /// Random number generator for simulating data
  final Random _random = Random();
  
  /// Index tracking for each PID in the test data
  final Map<String, int> _dataIndices = {};
  
  /// Last timestamp for data progression
  DateTime _lastUpdateTime = DateTime.now();
  
  /// Last values for each PID to ensure smooth transitions
  final Map<String, dynamic> _lastValues = {};
  
  /// Pre-defined scenarios
  static final Map<String, Map<String, List<dynamic>>> _scenarios = {
    'city_driving': _cityDrivingScenario(),
    'highway_driving': _highwayDrivingScenario(),
    'aggressive_driving': _aggressiveDrivingScenario(),
    'eco_driving': _ecoDrivingScenario(),
    'idle': _idleScenario(),
  };
  
  /// Creates a new MockTestData instance
  MockTestData({this.scenarioName, this.customData});
  
  /// Gets the next data value for the specified PID
  dynamic getDataForPid(String pid) {
    // First, try to get from custom data if provided
    if (customData != null && customData!.containsKey(pid)) {
      return _getNextDataPoint(pid, customData!);
    }
    
    // Next, try to get from the scenario if specified
    if (scenarioName != null && _scenarios.containsKey(scenarioName)) {
      final scenarioData = _scenarios[scenarioName]!;
      if (scenarioData.containsKey(pid)) {
        return _getNextDataPoint(pid, scenarioData);
      }
    }
    
    // Finally, fall back to generating random data
    return _generateRandomDataForPid(pid);
  }
  
  /// Gets the next data point from a sequence, handling cycling through the data
  dynamic _getNextDataPoint(String pid, Map<String, List<dynamic>> dataSource) {
    if (!dataSource.containsKey(pid) || dataSource[pid]!.isEmpty) {
      return null;
    }
    
    final dataList = dataSource[pid]!;
    
    // Initialize index if not present
    _dataIndices[pid] ??= 0;
    
    // Get data at current index
    final data = dataList[_dataIndices[pid]!];
    
    // Progress through the data naturally based on time
    final now = DateTime.now();
    if (now.difference(_lastUpdateTime).inMilliseconds >= 1000) {
      _dataIndices[pid] = (_dataIndices[pid]! + 1) % dataList.length;
      _lastUpdateTime = now;
    }
    
    return data;
  }
  
  /// Generates realistic random data for the specified PID
  dynamic _generateRandomDataForPid(String pid) {
    // Initialize with defaults if not present
    _lastValues[pid] ??= _getDefaultValue(pid);
    
    // Get the last value
    final lastValue = _lastValues[pid];
    
    // Generate a new value that's not too far from the last one
    dynamic newValue;
    
    switch (pid) {
      case ObdConstants.pidEngineRpm:
        // Limit RPM changes to +/- 200 RPM
        newValue = lastValue + (_random.nextInt(400) - 200);
        // Keep within realistic bounds
        newValue = newValue.clamp(800, 5500);
        break;
        
      case ObdConstants.pidVehicleSpeed:
        // Limit speed changes to +/- 5 km/h
        newValue = lastValue + (_random.nextInt(10) - 5);
        // Keep within realistic bounds
        newValue = newValue.clamp(0, 180);
        break;
        
      case ObdConstants.pidThrottlePosition:
        // Limit throttle changes to +/- 5%
        newValue = lastValue + (_random.nextInt(10) - 5);
        // Keep within realistic bounds
        newValue = newValue.clamp(0, 100);
        break;
        
      case ObdConstants.pidControlModuleVoltage:
        // Limit voltage changes to +/- 0.1V
        newValue = lastValue + ((_random.nextDouble() - 0.5) * 0.2);
        // Keep within realistic bounds
        newValue = newValue.clamp(11.5, 14.5);
        break;
        
      case ObdConstants.pidCoolantTemp:
        // Limit temp changes to +/- 1°C
        newValue = lastValue + (_random.nextInt(3) - 1);
        // Keep within realistic bounds
        newValue = newValue.clamp(80, 120);
        break;
        
      case ObdConstants.pidFuelLevel:
        // Fuel level decreases very gradually
        newValue = lastValue - (_random.nextDouble() * 0.5);
        // Keep within realistic bounds
        newValue = newValue.clamp(0, 100);
        break;
        
      default:
        return null;
    }
    
    // Store the new value
    _lastValues[pid] = newValue;
    return newValue;
  }
  
  /// Get default starting value for a PID
  dynamic _getDefaultValue(String pid) {
    switch (pid) {
      case ObdConstants.pidEngineRpm:
        return 1200;
      case ObdConstants.pidVehicleSpeed:
        return 0;
      case ObdConstants.pidThrottlePosition:
        return 15;
      case ObdConstants.pidControlModuleVoltage:
        return 13.8;
      case ObdConstants.pidCoolantTemp:
        return 90;
      case ObdConstants.pidFuelLevel:
        return 75;
      default:
        return 0;
    }
  }
  
  /// Creates a city driving scenario with realistic data patterns
  static Map<String, List<dynamic>> _cityDrivingScenario() {
    return {
      ObdConstants.pidEngineRpm: [
        800, 1200, 1800, 2200, 2500, 2000, 1500, 800, 900, 1500, 2000, 2300, 1800, 1200, 800
      ],
      ObdConstants.pidVehicleSpeed: [
        0, 15, 30, 45, 50, 35, 20, 0, 0, 20, 35, 40, 25, 15, 0
      ],
      ObdConstants.pidThrottlePosition: [
        0, 20, 35, 45, 40, 25, 15, 0, 0, 25, 35, 40, 25, 15, 0
      ],
      ObdConstants.pidCoolantTemp: [
        85, 85, 86, 87, 88, 89, 89, 89, 89, 89, 90, 90, 90, 90, 90
      ],
      ObdConstants.pidControlModuleVoltage: [
        14.2, 14.1, 14.0, 13.9, 14.0, 14.1, 14.2, 14.3, 14.3, 14.2, 14.1, 14.0, 14.1, 14.2, 14.3
      ],
    };
  }
  
  /// Creates a highway driving scenario with realistic data patterns
  static Map<String, List<dynamic>> _highwayDrivingScenario() {
    return {
      ObdConstants.pidEngineRpm: [
        2000, 2200, 2300, 2400, 2500, 2300, 2400, 2500, 2400, 2300, 2400, 2500
      ],
      ObdConstants.pidVehicleSpeed: [
        80, 85, 90, 95, 100, 95, 100, 105, 100, 95, 100, 105
      ],
      ObdConstants.pidThrottlePosition: [
        30, 32, 35, 37, 40, 35, 37, 40, 37, 35, 37, 40
      ],
      ObdConstants.pidCoolantTemp: [
        90, 90, 91, 91, 92, 92, 93, 93, 93, 92, 92, 92
      ],
      ObdConstants.pidControlModuleVoltage: [
        14.1, 14.1, 14.0, 14.0, 14.0, 14.1, 14.1, 14.0, 14.0, 14.1, 14.1, 14.0
      ],
    };
  }
  
  /// Creates an aggressive driving scenario with realistic data patterns
  static Map<String, List<dynamic>> _aggressiveDrivingScenario() {
    return {
      ObdConstants.pidEngineRpm: [
        1000, 2500, 3500, 4500, 5000, 4000, 4500, 5500, 3500, 2500, 3500, 4500
      ],
      ObdConstants.pidVehicleSpeed: [
        0, 30, 60, 90, 110, 90, 100, 120, 80, 60, 80, 100
      ],
      ObdConstants.pidThrottlePosition: [
        0, 50, 70, 90, 95, 70, 85, 95, 60, 40, 70, 90
      ],
      ObdConstants.pidCoolantTemp: [
        85, 87, 90, 93, 95, 97, 98, 99, 99, 99, 99, 99
      ],
      ObdConstants.pidControlModuleVoltage: [
        14.3, 14.1, 13.9, 13.7, 13.6, 13.8, 13.7, 13.6, 13.8, 14.0, 13.8, 13.7
      ],
    };
  }
  
  /// Creates an eco-friendly driving scenario with realistic data patterns
  static Map<String, List<dynamic>> _ecoDrivingScenario() {
    return {
      ObdConstants.pidEngineRpm: [
        800, 1200, 1500, 1800, 2000, 1800, 1700, 1600, 1500, 1400, 1500, 1600
      ],
      ObdConstants.pidVehicleSpeed: [
        0, 20, 40, 60, 70, 65, 60, 55, 50, 45, 50, 55
      ],
      ObdConstants.pidThrottlePosition: [
        0, 15, 25, 30, 35, 30, 25, 20, 15, 10, 15, 20
      ],
      ObdConstants.pidCoolantTemp: [
        85, 86, 87, 88, 89, 89, 89, 89, 89, 89, 89, 89
      ],
      ObdConstants.pidControlModuleVoltage: [
        14.3, 14.2, 14.1, 14.0, 14.0, 14.1, 14.1, 14.2, 14.2, 14.3, 14.2, 14.2
      ],
    };
  }
  
  /// Creates an idle scenario with realistic data patterns
  static Map<String, List<dynamic>> _idleScenario() {
    return {
      ObdConstants.pidEngineRpm: [
        750, 760, 770, 780, 790, 800, 790, 780, 770, 760, 750, 760
      ],
      ObdConstants.pidVehicleSpeed: [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
      ],
      ObdConstants.pidThrottlePosition: [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
      ],
      ObdConstants.pidCoolantTemp: [
        90, 90, 90, 91, 91, 91, 91, 91, 91, 90, 90, 90
      ],
      ObdConstants.pidControlModuleVoltage: [
        14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0
      ],
    };
  }
  
  /// Allows registration of custom scenarios
  static void registerScenario(String name, Map<String, List<dynamic>> data) {
    _scenarios[name] = data;
  }
  
  /// Lists available scenario names
  static List<String> get availableScenarios => _scenarios.keys.toList();
} 

################################################################################
FILE: lib/obd_lib/test/obd_service_test.dart
################################################################################

import 'package:flutter_test/flutter_test.dart';
import 'package:flutter/services.dart';

import '../models/obd_data.dart';
import '../protocol/obd_constants.dart';
import 'mock_bluetooth_connection.dart';
import 'mock_obd_protocol.dart';

/// Simplified tests for the OBD library, focusing on protocol and connection testing
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();
  
  // Mock method channels to avoid platform channel issues
  const MethodChannel bleChannel = MethodChannel('com.signify.hue.flutter/reactiveBle');
  TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger.setMockMethodCallHandler(
    bleChannel,
    (MethodCall methodCall) async {
      return null;
    },
  );

  group('MockObdProtocol Tests', () {
    late MockBluetoothConnection mockConnection;
    late MockObdProtocol mockProtocol;

    setUp(() {
      mockConnection = MockBluetoothConnection();
      mockProtocol = MockObdProtocol(connection: mockConnection);
      
      // Pre-initialize protocol state
      mockProtocol.setInitialized(true);
      mockProtocol.setConnected(true);
    });

    tearDown(() async {
      await mockProtocol.dispose();
      await mockConnection.dispose();
    });

    test('Protocol returns stored PID response', () async {
      // Set up a mock response for RPM
      final rpmData = ObdData(
        pid: ObdConstants.pidEngineRpm,
        mode: '01',
        value: 1500,
        unit: 'rpm',
        timestamp: DateTime.now(),
        rawData: [0x41, 0x0C, 0x12, 0x00],
        name: 'Engine RPM'
      );
      
      // Add the response to the protocol
      mockProtocol.addPidResponse(ObdConstants.pidEngineRpm, rpmData);
      
      // Request the PID
      final response = await mockProtocol.requestPid(ObdConstants.pidEngineRpm);
      
      // Verify the response matches
      expect(response, isNotNull);
      expect(response!.pid, ObdConstants.pidEngineRpm);
      expect(response.value, 1500);
      expect(response.unit, 'rpm');
    });

    test('Protocol streams data correctly', () async {
      // Create test data
      final testData = ObdData(
        pid: ObdConstants.pidVehicleSpeed,
        mode: '01',
        value: 50,
        unit: 'km/h',
        timestamp: DateTime.now(),
        rawData: [0x41, 0x0D, 0x32],
        name: 'Vehicle Speed'
      );
      
      // Set up a listener to detect the data
      bool dataReceived = false;
      ObdData? receivedData;
      
      final subscription = mockProtocol.obdDataStream.listen((data) {
        dataReceived = true;
        receivedData = data;
      });
      
      // Simulate receiving data
      mockProtocol.simulateDataResponse(testData);
      
      // Allow time for the event to propagate
      await Future.delayed(const Duration(milliseconds: 50));
      
      // Verify data was received
      expect(dataReceived, isTrue);
      expect(receivedData, isNotNull);
      expect(receivedData!.pid, testData.pid);
      expect(receivedData!.value, testData.value);
      
      // Clean up
      await subscription.cancel();
    });

    test('Protocol handles commands via connection', () async {
      // Set up a command response
      mockConnection.addCommandResponse('ATZ', 'ELM327 v1.5\r\n>');
      await mockConnection.connect();
      
      // We need to give time for the connection to be established and response
      // to be emitted before trying to send a command
      await Future.delayed(const Duration(milliseconds: 50));
      
      // Create a direct subscription to monitor responses
      final responses = <String>[];
      final subscription = mockConnection.dataStream.listen((data) {
        responses.add(data);
      });
      
      // Send the command
      await mockConnection.sendCommand('ATZ');
      
      // Allow time for the response to be processed
      await Future.delayed(const Duration(milliseconds: 50));
      
      // Verify response - now we check the collected responses
      expect(responses.any((r) => r.contains('ELM327')), isTrue);
      
      // Clean up
      await subscription.cancel();
    });

    test('Protocol handles multiple PID requests', () async {
      // Set up responses for multiple PIDs
      mockProtocol.addPidResponse(
        ObdConstants.pidEngineRpm,
        ObdData(
          pid: ObdConstants.pidEngineRpm,
          mode: '01',
          value: 1500,
          unit: 'rpm',
          timestamp: DateTime.now(),
          rawData: [0x41, 0x0C, 0x12, 0x00],
          name: 'Engine RPM'
        )
      );
      
      mockProtocol.addPidResponse(
        ObdConstants.pidVehicleSpeed,
        ObdData(
          pid: ObdConstants.pidVehicleSpeed,
          mode: '01',
          value: 50,
          unit: 'km/h',
          timestamp: DateTime.now(),
          rawData: [0x41, 0x0D, 0x32],
          name: 'Vehicle Speed'
        )
      );
      
      // Request multiple PIDs
      final results = await mockProtocol.requestPids([
        ObdConstants.pidEngineRpm,
        ObdConstants.pidVehicleSpeed
      ]);
      
      // Verify responses
      expect(results.length, 2);
      expect(results.containsKey(ObdConstants.pidEngineRpm), isTrue);
      expect(results.containsKey(ObdConstants.pidVehicleSpeed), isTrue);
      expect(results[ObdConstants.pidEngineRpm]?.value, 1500);
      expect(results[ObdConstants.pidVehicleSpeed]?.value, 50);
    });
  });

  group('MockBluetoothConnection Tests', () {
    late MockBluetoothConnection mockConnection;

    setUp(() {
      mockConnection = MockBluetoothConnection();
    });

    tearDown(() async {
      await mockConnection.dispose();
    });

    test('Connection sends and receives data', () async {
      // Set up a listener for the data stream first
      final dataReceived = <String>[];
      final subscription = mockConnection.dataStream.listen((data) {
        dataReceived.add(data);
      });
      
      // Add a small delay to ensure subscription is active
      await Future.delayed(const Duration(milliseconds: 10));
      
      // Connect
      final connected = await mockConnection.connect();
      expect(connected, isTrue);
      expect(mockConnection.isConnected, isTrue);
      
      // Wait to ensure connection message has been processed
      await Future.delayed(const Duration(milliseconds: 50));
      
      // Send a command that will generate a response
      await mockConnection.sendCommand('ATZ');
      
      // Allow time for the response
      await Future.delayed(const Duration(milliseconds: 50));
      
      // Verify we received responses (the exact order depends on implementation)
      expect(dataReceived, isNotEmpty);
      
      // Check that we have the expected messages
      expect(dataReceived.where((data) => data == 'CONNECTED').isNotEmpty, isTrue,
          reason: 'Expected to find CONNECTED message');
      expect(dataReceived.where((data) => data.contains('ELM327')).isNotEmpty, isTrue,
          reason: 'Expected to find ELM327 response');
      
      // Clean up
      await subscription.cancel();
    });

    test('Connection handles predefined responses', () async {
      // Connect
      await mockConnection.connect();
      
      // Add a custom command response
      mockConnection.addCommandResponse('CUSTOM', 'CUSTOM_RESPONSE');
      
      // Set up a listener
      String? customResponse;
      final subscription = mockConnection.dataStream.listen((data) {
        if (data == 'CUSTOM_RESPONSE') {
          customResponse = data;
        }
      });
      
      // Send the custom command
      await mockConnection.sendCommand('CUSTOM');
      
      // Allow time for the response
      await Future.delayed(const Duration(milliseconds: 100));
      
      // Verify the custom response was received
      expect(customResponse, 'CUSTOM_RESPONSE');
      
      // Clean up
      await subscription.cancel();
    });

    test('Connection sends disconnect notification', () async {
      // Connect
      await mockConnection.connect();
      
      // Set up a listener
      bool disconnectReceived = false;
      final subscription = mockConnection.dataStream.listen((data) {
        if (data == 'DISCONNECTED') {
          disconnectReceived = true;
        }
      });
      
      // Disconnect
      await mockConnection.disconnect();
      
      // Allow time for the notification
      await Future.delayed(const Duration(milliseconds: 50));
      
      // Verify disconnect notification was received
      expect(disconnectReceived, isTrue);
      expect(mockConnection.isConnected, isFalse);
      
      // Clean up
      await subscription.cancel();
    });
  });
  
  group('OBD PID Parsing Tests', () {
    test('Parse engine RPM data', () {
      // Test data for engine RPM (1500 RPM)
      final rpmData = ObdData(
        pid: ObdConstants.pidEngineRpm,
        mode: '01',
        value: 1500,
        unit: 'rpm',
        timestamp: DateTime.now(),
        rawData: [0x41, 0x0C, 0x12, 0x00],  // 41 0C 12 00 -> (0x1200 / 4) = 1152 RPM
        name: 'Engine RPM'
      );
      
      // Verify the parsed value
      expect(rpmData, isNotNull);
      expect(rpmData.pid, ObdConstants.pidEngineRpm);
      expect(rpmData.value, 1500);
      expect(rpmData.unit, 'rpm');
    });
    
    test('Parse vehicle speed data', () {
      // Test data for vehicle speed (50 km/h)
      final speedData = ObdData(
        pid: ObdConstants.pidVehicleSpeed,
        mode: '01',
        value: 50,
        unit: 'km/h',
        timestamp: DateTime.now(),
        rawData: [0x41, 0x0D, 0x32],  // 41 0D 32 -> 0x32 = 50 km/h
        name: 'Vehicle Speed'
      );
      
      // Verify the parsed value
      expect(speedData, isNotNull);
      expect(speedData.pid, ObdConstants.pidVehicleSpeed);
      expect(speedData.value, 50);
      expect(speedData.unit, 'km/h');
    });
    
    test('Parse engine coolant temperature data', () {
      // Test data for coolant temperature (90 °C)
      final coolantData = ObdData(
        pid: ObdConstants.pidCoolantTemp,
        mode: '01',
        value: 90,
        unit: '°C',
        timestamp: DateTime.now(),
        rawData: [0x41, 0x05, 0x5A],  // 41 05 5A -> 0x5A = 90 °C
        name: 'Engine Coolant Temperature'
      );
      
      // Verify the parsed value
      expect(coolantData, isNotNull);
      expect(coolantData.pid, ObdConstants.pidCoolantTemp);
      expect(coolantData.value, 90);
      expect(coolantData.unit, '°C');
    });
    
    test('Parse throttle position data', () {
      // Test data for throttle position (25%)
      final throttleData = ObdData(
        pid: ObdConstants.pidThrottlePosition,
        mode: '01',
        value: 25.0,
        unit: '%',
        timestamp: DateTime.now(),
        rawData: [0x41, 0x11, 0x40],  // 41 11 40 -> (0x40 * 100) / 255 = ~25%
        name: 'Throttle Position'
      );
      
      // Verify the parsed value
      expect(throttleData, isNotNull);
      expect(throttleData.pid, ObdConstants.pidThrottlePosition);
      expect(throttleData.value, 25.0);
      expect(throttleData.unit, '%');
    });
  });
} 

################################################################################
FILE: lib/obd_lib/test/mock_obd_protocol.dart
################################################################################

import 'dart:async';

import '../interfaces/obd_connection.dart';
import '../protocol/obd_protocol.dart';
import '../models/obd_command.dart';
import '../models/obd_data.dart';

/// A mock implementation of ObdProtocol for testing
class MockObdProtocol implements ObdProtocol {
  /// The connection used by this protocol
  final ObdConnection? connection;
  
  /// Whether the protocol has been initialized
  bool _isInitialized = false;
  
  /// Whether the protocol is connected
  bool _isConnected = false;
  
  /// Whether the protocol is connecting
  bool _isConnecting = false;
  
  /// Error message if initialization fails
  String? _errorMessage;
  
  /// Stream controller for OBD data
  final _dataStreamController = StreamController<ObdData>.broadcast();
  
  /// Map of predefined responses by PID
  final Map<String, ObdData> _pidResponses = {};
  
  /// Map of predefined raw responses
  final Map<String, String> _commandResponses = {};
  
  /// Subscription to connection data stream
  StreamSubscription? _connectionSubscription;
  
  /// Last received response from the connection
  String _lastResponse = '';
  
  /// Completer for the current command
  Completer<String>? _currentCommandCompleter;
  
  /// Create a new mock protocol instance
  MockObdProtocol({
    this.connection,
    Map<String, ObdData>? pidResponses,
    Map<String, String>? commandResponses,
  }) {
    // Add any predefined PID responses
    if (pidResponses != null) {
      _pidResponses.addAll(pidResponses);
    }
    
    // Add any predefined command responses
    if (commandResponses != null) {
      _commandResponses.addAll(commandResponses);
    }
    
    // Subscribe to connection data if available
    if (connection != null) {
      _connectionSubscription = connection!.dataStream.listen(_handleConnectionData);
    }
  }
  
  /// Handle incoming data from the connection
  void _handleConnectionData(String data) {
    _lastResponse = data;
    
    // If there's a pending command, complete it with the response
    if (_currentCommandCompleter != null && !_currentCommandCompleter!.isCompleted) {
      _currentCommandCompleter!.complete(data);
    }
  }
  
  @override
  Stream<ObdData> get obdDataStream => _dataStreamController.stream;
  
  @override
  Stream<String> get dataStream => connection?.dataStream ?? 
      Stream<String>.empty();
  
  @override
  bool get isConnected => _isConnected;
  
  @override
  bool get isConnecting => _isConnecting;
  
  @override
  bool get isInitialized => _isInitialized;
  
  @override
  String? get errorMessage => _errorMessage;
  
  @override
  Future<bool> initialize() async {
    _isConnecting = true;
    // Simulate initialization delay
    await Future.delayed(const Duration(milliseconds: 500));
    _isInitialized = true;
    _isConnected = true;
    _isConnecting = false;
    return true;
  }
  
  @override
  Future<String> sendCommand(String command) async {
    if (!_isConnected) {
      return 'ERROR: Not connected';
    }
    
    // Return predefined response if available
    if (_commandResponses.containsKey(command)) {
      return _commandResponses[command]!;
    }
    
    // Use the connection if available
    if (connection != null) {
      try {
        // Create a completer for this command
        _currentCommandCompleter = Completer<String>();
        
        // Send the command (which will return void)
        await connection!.sendCommand(command);
        
        // Wait for a response with timeout
        final response = await _currentCommandCompleter!.future
            .timeout(const Duration(seconds: 2), 
              onTimeout: () => 'ERROR: Timeout waiting for response');
        
        return response;
      } catch (e) {
        return 'ERROR: $e';
      }
    }
    
    // Default response
    if (command.startsWith('AT')) {
      return 'OK\r\n>';
    } else {
      return 'NO DATA\r\n>';
    }
  }
  
  @override
  Future<String> sendObdCommand(ObdCommand command) async {
    final response = await sendCommand(command.command);
    return response;
  }
  
  @override
  Future<ObdData?> requestPid(String pid) async {
    if (!_isConnected) {
      return null;
    }
    
    // Return predefined response if available
    if (_pidResponses.containsKey(pid)) {
      final data = _pidResponses[pid]!;
      _dataStreamController.add(data);
      return data;
    }
    
    // Generate a basic response for common PIDs
    final defaultData = _generateDefaultPidResponse(pid);
    if (defaultData != null) {
      _dataStreamController.add(defaultData);
    }
    
    return defaultData;
  }
  
  @override
  Future<Map<String, ObdData>> requestPids(List<String> pids) async {
    if (!_isConnected) {
      return {};
    }
    
    final results = <String, ObdData>{};
    
    for (final pid in pids) {
      final data = await requestPid(pid);
      if (data != null) {
        results[pid] = data;
      }
    }
    
    return results;
  }
  
  @override
  Future<void> dispose() async {
    _isConnected = false;
    await _connectionSubscription?.cancel();
    await _dataStreamController.close();
    
    // Don't dispose the connection, it's managed externally
  }
  
  /// Add a PID response for testing
  void addPidResponse(String pid, ObdData data) {
    _pidResponses[pid] = data;
  }
  
  /// Add a command response for testing
  void addCommandResponse(String command, String response) {
    _commandResponses[command] = response;
  }
  
  /// Simulate a data response coming from the adapter
  void simulateDataResponse(ObdData data) {
    if (_isConnected) {
      _dataStreamController.add(data);
    }
  }
  
  /// Set the initialized state for testing
  void setInitialized(bool initialized) {
    _isInitialized = initialized;
  }
  
  /// Set the connected state for testing
  void setConnected(bool connected) {
    _isConnected = connected;
  }
  
  /// Convert a hexadecimal string to a list of integers
  List<int> _hexStringToBytes(String hexString) {
    final cleanHex = hexString.replaceAll(' ', '');
    final bytes = <int>[];
    for (var i = 0; i < cleanHex.length; i += 2) {
      if (i + 2 <= cleanHex.length) {
        bytes.add(int.parse(cleanHex.substring(i, i + 2), radix: 16));
      }
    }
    return bytes;
  }
  
  /// Generate a default response for common PIDs
  ObdData? _generateDefaultPidResponse(String pid) {
    final timestamp = DateTime.now();
    
    // Handle common PIDs
    switch (pid) {
      case '0100': // Supported PIDs 01-20
        return ObdData(
          pid: pid,
          mode: '01',
          value: 'BE1FA813', // Example supported PIDs bitstring
          unit: '',
          timestamp: timestamp,
          rawData: _hexStringToBytes('4100BE1FA813'),
          name: 'Supported PIDs 01-20'
        );
        
      case '010C': // Engine RPM
        return ObdData(
          pid: pid,
          mode: '01',
          value: 1500, // 1500 RPM
          unit: 'rpm',
          timestamp: timestamp,
          rawData: _hexStringToBytes('410C12C0'),
          name: 'Engine RPM'
        );
        
      case '010D': // Vehicle speed
        return ObdData(
          pid: pid,
          mode: '01',
          value: 50, // 50 km/h
          unit: 'km/h',
          timestamp: timestamp,
          rawData: _hexStringToBytes('410D32'),
          name: 'Vehicle Speed'
        );
        
      case '0105': // Coolant temperature
        return ObdData(
          pid: pid,
          mode: '01',
          value: 90, // 90°C
          unit: '°C',
          timestamp: timestamp,
          rawData: _hexStringToBytes('41055A'),
          name: 'Engine Coolant Temperature'
        );
        
      case '0111': // Throttle position
        return ObdData(
          pid: pid,
          mode: '01',
          value: 25.0, // 25%
          unit: '%',
          timestamp: timestamp,
          rawData: _hexStringToBytes('411140'),
          name: 'Throttle Position'
        );
        
      case '0142': // Control module voltage
        return ObdData(
          pid: pid,
          mode: '01',
          value: 14.2, // 14.2V
          unit: 'V',
          timestamp: timestamp,
          rawData: _hexStringToBytes('41428E'),
          name: 'Control Module Voltage'
        );
        
      default:
        return null;
    }
  }
} 

################################################################################
FILE: lib/obd_lib/test/obd_field_test.dart
################################################################################

import 'dart:async';
import 'dart:io';
import 'dart:convert';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:battery_plus/battery_plus.dart';
import 'package:path_provider/path_provider.dart';
import '../obd_service.dart';
import '../protocol/obd_constants.dart';

/// A utility for real-world testing of OBD adapters
/// 
/// This class provides a comprehensive set of tests for validating
/// OBD adapter performance and reliability in real-world conditions.
class ObdFieldTest {
  final ObdService obdService;
  final Battery battery = Battery();
  final String deviceId;
  
  // Test configuration
  bool _isRunningTest = false;
  final _testResults = <Map<String, dynamic>>[];
  final _eventLog = <Map<String, dynamic>>[];
  
  // Test metrics
  int _connectionAttempts = 0;
  int _successfulConnections = 0;
  int _connectionDrops = 0;
  int _autoReconnects = 0;
  
  // Performance metrics
  final Map<String, List<int>> _pidResponseTimes = {};
  final Map<int, double> _pollingIntervalSuccessRates = {};
  
  // Status reporting
  final StreamController<String> _statusStreamController = StreamController<String>.broadcast();
  Stream<String> get statusStream => _statusStreamController.stream;
  
  /// Create a new instance for testing a specific adapter
  ObdFieldTest({
    required this.obdService,
    required this.deviceId,
  });
  
  /// Whether a test is currently running
  bool get isRunningTest => _isRunningTest;
  
  /// Returns the test results
  List<Map<String, dynamic>> get testResults => List.unmodifiable(_testResults);
  
  /// Logs an event during testing
  void _logEvent(String type, String description, [Map<String, dynamic>? details]) {
    final event = {
      'timestamp': DateTime.now().toIso8601String(),
      'type': type,
      'description': description,
      'details': details ?? {},
    };
    
    _eventLog.add(event);
    _statusStreamController.add(description);
    debugPrint('[$type] $description');
  }
  
  /// Run a basic connectivity test
  /// 
  /// Attempts to connect to the adapter multiple times and
  /// records success rate and connection time statistics.
  Future<void> runConnectivityTest({
    int attempts = 10,
    int delayBetweenAttemptsMs = 2000,
  }) async {
    if (_isRunningTest) {
      throw Exception('A test is already running');
    }
    
    _isRunningTest = true;
    _connectionAttempts = 0;
    _successfulConnections = 0;
    final connectionTimes = <int>[];
    
    _logEvent('test', 'Starting connectivity test with $attempts attempts');
    
    for (int i = 0; i < attempts; i++) {
      _connectionAttempts++;
      
      try {
        _logEvent('connection', 'Attempting connection #$i');
        
        final startTime = DateTime.now();
        final connected = await obdService.connect(deviceId);
        final duration = DateTime.now().difference(startTime).inMilliseconds;
        
        if (connected) {
          _successfulConnections++;
          connectionTimes.add(duration);
          _logEvent('connection', 'Connection successful (${duration}ms)');
          
          // Verify we can get some basic data
          try {
            final rpmData = await obdService.requestPid(ObdConstants.pidEngineRpm);
            final voltageData = await obdService.requestPid(ObdConstants.pidControlModuleVoltage);
            
            _logEvent('data', 'Basic data check', {
              'rpm': rpmData?.value,
              'voltage': voltageData?.value,
            });
          } catch (e) {
            _logEvent('error', 'Failed to get basic data: $e');
          }
        } else {
          _logEvent('connection', 'Connection failed');
        }
      } catch (e) {
        _logEvent('error', 'Connection error: $e');
      } finally {
        if (obdService.isConnected) {
          obdService.disconnect();
        }
        await Future.delayed(Duration(milliseconds: delayBetweenAttemptsMs));
      }
    }
    
    // Calculate results
    final successRate = _successfulConnections / _connectionAttempts;
    final avgConnectionTime = connectionTimes.isEmpty 
        ? 0 
        : connectionTimes.reduce((a, b) => a + b) / connectionTimes.length;
    
    final results = {
      'test_type': 'connectivity',
      'timestamp': DateTime.now().toIso8601String(),
      'attempts': attempts,
      'successful_connections': _successfulConnections,
      'success_rate': successRate,
      'average_connection_time_ms': avgConnectionTime,
      'connection_times': connectionTimes,
    };
    
    _testResults.add(results);
    _isRunningTest = false;
    
    _logEvent('test', 'Connectivity test completed. Success rate: ${(successRate * 100).toStringAsFixed(1)}%, Avg time: ${avgConnectionTime.toStringAsFixed(0)}ms');
  }
  
  /// Run a performance test with different polling rates
  /// 
  /// Tests how the adapter performs with different polling intervals
  /// and numbers of PIDs requested.
  Future<void> runPerformanceTest({
    List<int> pollingIntervals = const [500, 1000, 2000],
    List<int> pidCounts = const [1, 3, 5, 10],
    int testDurationSeconds = 30,
  }) async {
    if (_isRunningTest) {
      throw Exception('A test is already running');
    }
    
    _isRunningTest = true;
    _pidResponseTimes.clear();
    _pollingIntervalSuccessRates.clear();
    
    _logEvent('test', 'Starting performance test');
    
    // First connect to the adapter
    final connected = await obdService.connect(deviceId);
    if (!connected) {
      _isRunningTest = false;
      throw Exception('Failed to connect to adapter');
    }
    
    final performanceData = <Map<String, dynamic>>[];
    final startBattery = await battery.batteryLevel;
    
    try {
      // Test each polling interval
      for (final intervalMs in pollingIntervals) {
        // Test each PID count
        for (final pidCount in pidCounts) {
          // Select PIDs to test
          final pids = _selectTestPids(pidCount);
          
          _logEvent('test', 'Testing with interval=${intervalMs}ms, PIDs=$pidCount');
          
          final testResults = await _runPollingIntervalTest(
            pids: pids,
            pollingIntervalMs: intervalMs,
            durationSeconds: testDurationSeconds,
          );
          
          performanceData.add({
            'polling_interval_ms': intervalMs,
            'pid_count': pidCount,
            'success_rate': testResults['success_rate'],
            'avg_response_time_ms': testResults['avg_response_time_ms'],
            'data_points_received': testResults['data_points_received'],
            'response_times_by_pid': testResults['response_times_by_pid'],
          });
          
          // Update overall metrics
          _pollingIntervalSuccessRates[intervalMs] = testResults['success_rate'];
        }
      }
    } finally {
      obdService.disconnect();
    }
    
    final endBattery = await battery.batteryLevel;
    final batteryDrain = startBattery - endBattery;
    
    // Calculate optimal settings
    final optimalInterval = _findOptimalPollingInterval();
    final optimalPidCount = _findOptimalPidCount();
    
    final results = {
      'test_type': 'performance',
      'timestamp': DateTime.now().toIso8601String(),
      'test_duration_seconds': testDurationSeconds * pollingIntervals.length * pidCounts.length,
      'performance_data': performanceData,
      'battery_drain_percent': batteryDrain,
      'recommendations': {
        'optimal_polling_interval_ms': optimalInterval,
        'optimal_pid_count': optimalPidCount,
      }
    };
    
    _testResults.add(results);
    _isRunningTest = false;
    
    _logEvent('test', 'Performance test completed. Optimal settings: interval=${optimalInterval}ms, PIDs=$optimalPidCount');
  }
  
  /// Run a stability test for a longer duration
  /// 
  /// Tests the adapter's stability over an extended period,
  /// including how it handles reconnections.
  Future<void> runStabilityTest({
    int durationMinutes = 30,
    int pollingIntervalMs = 1000,
    int pidCount = 5,
    bool simulateDisconnects = true,
    int disconnectIntervalMinutes = 5,
  }) async {
    if (_isRunningTest) {
      throw Exception('A test is already running');
    }
    
    _isRunningTest = true;
    _connectionDrops = 0;
    _autoReconnects = 0;
    
    _logEvent('test', 'Starting stability test for $durationMinutes minutes');
    
    // Connect to the adapter
    final connected = await obdService.connect(deviceId);
    if (!connected) {
      _isRunningTest = false;
      throw Exception('Failed to connect to adapter');
    }
    
    final pids = _selectTestPids(pidCount);
    final startTime = DateTime.now();
    final dataPoints = <DateTime, Map<String, dynamic>>{};
    final startBattery = await battery.batteryLevel;
    
    // Setup memory tracking
    final memorySnapshots = <DateTime, int>{}; 
    
    // Create a timer for simulating disconnects if enabled
    Timer? disconnectTimer;
    if (simulateDisconnects) {
      disconnectTimer = Timer.periodic(
        Duration(minutes: disconnectIntervalMinutes),
        (_) async {
          if (_isRunningTest) {
            _logEvent('test', 'Simulating disconnect');
            _connectionDrops++;
            obdService.disconnect();
            
            // Wait a few seconds before reconnecting
            await Future.delayed(const Duration(seconds: 3));
            
            // Try to reconnect
            final reconnected = await obdService.connect(deviceId);
            if (reconnected) {
              _autoReconnects++;
              _logEvent('connection', 'Successfully reconnected');
            } else {
              _logEvent('error', 'Failed to reconnect');
            }
          }
        },
      );
    }
    
    // Track whether we're still running the test
    bool isTestRunning = true;
    final testCompleteTimer = Timer(Duration(minutes: durationMinutes), () {
      isTestRunning = false;
    });
    
    // Create a polling mechanism
    int successfulPolls = 0;
    int failedPolls = 0;
    
    try {
      while (isTestRunning) {
        if (obdService.isConnected) {
          // Collect data for all PIDs
          final pollStartTime = DateTime.now();
          final dataMap = <String, dynamic>{};
          bool pollSucceeded = false;
          
          try {
            // Request each PID
            for (final pid in pids) {
              final responseStartTime = DateTime.now();
              final data = await obdService.requestPid(pid);
              
              if (data != null) {
                final responseTime = DateTime.now().difference(responseStartTime).inMilliseconds;
                dataMap[pid] = {
                  'value': data.value,
                  'unit': data.unit,
                  'response_time_ms': responseTime,
                };
                
                // Add to response times tracking
                _pidResponseTimes.putIfAbsent(pid, () => []).add(responseTime);
              }
            }
            
            // If we got any data, consider the poll successful
            if (dataMap.isNotEmpty) {
              pollSucceeded = true;
              successfulPolls++;
            } else {
              failedPolls++;
            }
          } catch (e) {
            _logEvent('error', 'Error polling data: $e');
            failedPolls++;
          }
          
          final pollDuration = DateTime.now().difference(pollStartTime).inMilliseconds;
          
          // Record data point
          dataPoints[DateTime.now()] = {
            'poll_duration_ms': pollDuration,
            'data': dataMap,
            'successful': pollSucceeded,
          };
          
          // Take a memory snapshot every 5 minutes
          final sinceStart = DateTime.now().difference(startTime).inMinutes;
          if (sinceStart % 5 == 0 && !memorySnapshots.containsKey(DateTime.now())) {
            // In a real implementation, you'd use a platform channel to get actual memory usage
            // Here we're just simulating it
            memorySnapshots[DateTime.now()] = 0;
          }
          
          // Log progress periodically
          if (successfulPolls % 10 == 0) {
            final elapsedMinutes = DateTime.now().difference(startTime).inMinutes;
            final remainingMinutes = durationMinutes - elapsedMinutes;
            final testProgress = 'Test running: $elapsedMinutes/${durationMinutes}min, $successfulPolls polls completed, $remainingMinutes min remaining';
            _logEvent('progress', testProgress);
          }
        } else {
          _logEvent('connection', 'Not connected, waiting...');
        }
        
        // Wait for the polling interval
        await Future.delayed(Duration(milliseconds: pollingIntervalMs));
      }
    } finally {
      disconnectTimer?.cancel();
      testCompleteTimer.cancel();
      obdService.disconnect();
    }
    
    final endBattery = await battery.batteryLevel;
    final batteryDrain = startBattery - endBattery;
    final totalRuntime = DateTime.now().difference(startTime).inMinutes;
    final successRate = successfulPolls / (successfulPolls + failedPolls);
    
    final results = {
      'test_type': 'stability',
      'timestamp': DateTime.now().toIso8601String(),
      'planned_duration_minutes': durationMinutes,
      'actual_duration_minutes': totalRuntime,
      'polling_interval_ms': pollingIntervalMs,
      'pid_count': pidCount,
      'data_points_count': dataPoints.length,
      'successful_polls': successfulPolls,
      'failed_polls': failedPolls,
      'success_rate': successRate,
      'connection_drops': _connectionDrops,
      'successful_reconnects': _autoReconnects,
      'battery_drain_percent': batteryDrain,
    };
    
    _testResults.add(results);
    _isRunningTest = false;
    
    _logEvent('test', 'Stability test completed. Success rate: ${(successRate * 100).toStringAsFixed(1)}%, Battery drain: $batteryDrain%');
  }
  
  /// Save test results to a file
  Future<String> saveTestResults() async {
    final directory = await getApplicationDocumentsDirectory();
    final timestamp = DateTime.now().toIso8601String().replaceAll(':', '-');
    final fileName = 'obd_test_results_$timestamp.json';
    final file = File('${directory.path}/$fileName');
    
    final results = {
      'device_id': deviceId,
      'timestamp': DateTime.now().toIso8601String(),
      'test_results': _testResults,
      'event_log': _eventLog,
    };
    
    await file.writeAsString(jsonEncode(results));
    return file.path;
  }
  
  /// Run a test with a specific polling interval
  Future<Map<String, dynamic>> _runPollingIntervalTest({
    required List<String> pids,
    required int pollingIntervalMs,
    required int durationSeconds,
  }) async {
    final startTime = DateTime.now();
    final endTime = startTime.add(Duration(seconds: durationSeconds));
    
    int dataPointsReceived = 0;
    int successfulRequests = 0;
    int failedRequests = 0;
    final pidResponses = <String, List<int>>{};
    
    while (DateTime.now().isBefore(endTime)) {
      // Request each PID
      for (final pid in pids) {
        try {
          final requestStartTime = DateTime.now();
          final data = await obdService.requestPid(pid);
          
          if (data != null) {
            final responseTime = DateTime.now().difference(requestStartTime).inMilliseconds;
            pidResponses.putIfAbsent(pid, () => []).add(responseTime);
            successfulRequests++;
            dataPointsReceived++;
          } else {
            failedRequests++;
          }
        } catch (e) {
          _logEvent('error', 'Error requesting PID $pid: $e');
          failedRequests++;
        }
      }
      
      // Wait for the polling interval
      await Future.delayed(Duration(milliseconds: pollingIntervalMs));
    }
    
    // Calculate average response times by PID
    final avgResponseTimesByPid = <String, double>{};
    double totalAvgResponseTime = 0;
    int pidCount = 0;
    
    pidResponses.forEach((pid, times) {
      if (times.isNotEmpty) {
        final avg = times.reduce((a, b) => a + b) / times.length;
        avgResponseTimesByPid[pid] = avg;
        totalAvgResponseTime += avg;
        pidCount++;
      }
    });
    
    final overallAvgResponseTime = pidCount > 0 ? totalAvgResponseTime / pidCount : 0;
    final successRate = successfulRequests / (successfulRequests + failedRequests);
    
    return {
      'polling_interval_ms': pollingIntervalMs,
      'pid_count': pids.length,
      'duration_seconds': durationSeconds,
      'data_points_received': dataPointsReceived,
      'successful_requests': successfulRequests,
      'failed_requests': failedRequests,
      'success_rate': successRate,
      'avg_response_time_ms': overallAvgResponseTime,
      'response_times_by_pid': avgResponseTimesByPid,
    };
  }
  
  /// Select a set of test PIDs based on count
  List<String> _selectTestPids(int count) {
    // Define available PIDs to test with
    final availablePids = [
      ObdConstants.pidEngineRpm,
      ObdConstants.pidVehicleSpeed,
      ObdConstants.pidThrottlePosition,
      ObdConstants.pidCoolantTemp,
      ObdConstants.pidControlModuleVoltage,
      ObdConstants.pidFuelLevel,
      ObdConstants.pidEngineLoad,
      // Remove undefined PIDs (intake temp and timing spark)
      ObdConstants.pidSupportedPids,
    ];
    
    // Always include RPM and speed in the selected PIDs
    final criticalPids = [
      ObdConstants.pidEngineRpm,
      ObdConstants.pidVehicleSpeed,
    ];
    
    // If count is less than or equal to critical PIDs, just return those
    if (count <= criticalPids.length) {
      return criticalPids.sublist(0, count);
    }
    
    // Start with critical PIDs
    final result = List<String>.from(criticalPids);
    
    // Add remaining PIDs until we reach the desired count
    final remainingPids = availablePids
        .where((pid) => !criticalPids.contains(pid))
        .toList();
    
    final additionalCount = min(count - criticalPids.length, remainingPids.length);
    result.addAll(remainingPids.sublist(0, additionalCount));
    
    return result;
  }
  
  /// Find the optimal polling interval based on test results
  int _findOptimalPollingInterval() {
    if (_pollingIntervalSuccessRates.isEmpty) {
      return 1000; // Default
    }
    
    // Find the fastest interval with at least 90% success rate
    int optimalInterval = 1000;
    double bestScore = 0;
    
    _pollingIntervalSuccessRates.forEach((interval, successRate) {
      // Calculate a score that favors faster intervals with good success rates
      // This biases toward faster intervals but only if they're reliable
      final reliabilityFactor = successRate >= 0.9 ? 1.0 : successRate / 0.9;
      final speedFactor = 1000 / interval; // Faster intervals get higher scores
      final score = reliabilityFactor * speedFactor;
      
      if (score > bestScore) {
        bestScore = score;
        optimalInterval = interval;
      }
    });
    
    return optimalInterval;
  }
  
  /// Find the optimal PID count based on test results
  int _findOptimalPidCount() {
    if (_pidResponseTimes.isEmpty) {
      return 5; // Default
    }
    
    // Analyze response time vs. PID count from test data
    // This is a simplified approximation - in a real implementation,
    // you would do more sophisticated analysis of the test results
    
    return 5; // Simplified implementation
  }
  
  /// Dispose resources used by this test utility
  void dispose() {
    _statusStreamController.close();
  }
}

/// A widget for displaying and running OBD field tests
class ObdFieldTestScreen extends StatefulWidget {
  final ObdService obdService;
  final String deviceId;
  
  const ObdFieldTestScreen({
    super.key,
    required this.obdService,
    required this.deviceId,
  });
  
  @override
  State<ObdFieldTestScreen> createState() => _ObdFieldTestScreenState();
}

class _ObdFieldTestScreenState extends State<ObdFieldTestScreen> {
  late ObdFieldTest _fieldTest;
  final List<String> _statusMessages = [];
  Map<String, dynamic>? _lastTestResult;
  bool _isTesting = false;
  String _selectedTest = 'connectivity';
  
  @override
  void initState() {
    super.initState();
    _fieldTest = ObdFieldTest(
      obdService: widget.obdService,
      deviceId: widget.deviceId,
    );
    
    _fieldTest.statusStream.listen((message) {
      setState(() {
        _statusMessages.add(message);
        // Keep the status list at a reasonable size
        if (_statusMessages.length > 100) {
          _statusMessages.removeAt(0);
        }
      });
    });
  }
  
  @override
  void dispose() {
    _fieldTest.dispose();
    super.dispose();
  }
  
  Future<void> _runSelectedTest() async {
    if (_isTesting) return;
    
    setState(() {
      _isTesting = true;
      _statusMessages.clear();
    });
    
    try {
      switch (_selectedTest) {
        case 'connectivity':
          await _fieldTest.runConnectivityTest();
          _lastTestResult = _fieldTest.testResults.last;
          break;
        case 'performance':
          await _fieldTest.runPerformanceTest();
          _lastTestResult = _fieldTest.testResults.last;
          break;
        case 'stability':
          await _fieldTest.runStabilityTest(
            durationMinutes: 5, // Short duration for demo purposes
          );
          _lastTestResult = _fieldTest.testResults.last;
          break;
        default:
          // Add default case to handle other cases
          break;
      }
      
      // Save results to file
      if (_lastTestResult != null) {
        final filePath = await _fieldTest.saveTestResults();
        setState(() {
          _statusMessages.add('Test results saved to: $filePath');
        });
      }
    } catch (e) {
      setState(() {
        _statusMessages.add('Error: $e');
      });
    } finally {
      setState(() {
        _isTesting = false;
      });
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('OBD Field Test'),
        actions: [
          IconButton(
            icon: const Icon(Icons.save),
            onPressed: _isTesting ? null : () async {
              try {
                if (_fieldTest.testResults.isNotEmpty) {
                  final path = await _fieldTest.saveTestResults();
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Results saved to: $path')),
                  );
                } else {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('No test results to save')),
                  );
                }
              } catch (e) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text('Error saving results: $e')),
                );
              }
            },
          ),
        ],
      ),
      body: Column(
        children: [
          // Test selection and controls
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Row(
              children: [
                Expanded(
                  child: DropdownButton<String>(
                    value: _selectedTest,
                    isExpanded: true,
                    items: const [
                      DropdownMenuItem(value: 'connectivity', child: Text('Connectivity Test')),
                      DropdownMenuItem(value: 'performance', child: Text('Performance Test')),
                      DropdownMenuItem(value: 'stability', child: Text('Stability Test')),
                    ],
                    onChanged: _isTesting ? null : (value) {
                      if (value != null) {
                        setState(() {
                          _selectedTest = value;
                        });
                      }
                    },
                  ),
                ),
                const SizedBox(width: 16),
                ElevatedButton(
                  onPressed: _isTesting ? null : _runSelectedTest,
                  child: _isTesting
                      ? const SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : const Text('Run Test'),
                ),
              ],
            ),
          ),
          
          // Test status and logs
          Expanded(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(
                    'Test Status',
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                  const SizedBox(height: 8),
                  Expanded(
                    child: Container(
                      decoration: BoxDecoration(
                        border: Border.all(color: Colors.grey),
                        borderRadius: BorderRadius.circular(4),
                      ),
                      padding: const EdgeInsets.all(8),
                      child: ListView.builder(
                        itemCount: _statusMessages.length,
                        itemBuilder: (context, index) {
                          return Text(
                            _statusMessages[index],
                            style: const TextStyle(fontSize: 12),
                          );
                        },
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
          
          // Results preview (simplified)
          if (_lastTestResult != null)
            Container(
              padding: const EdgeInsets.all(16),
              color: Colors.grey[200],
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Test Results',
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Type: ${_lastTestResult!['test_type']}',
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                  if (_lastTestResult!['test_type'] == 'connectivity')
                    Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('Success rate: ${(_lastTestResult!['success_rate'] * 100).toStringAsFixed(1)}%'),
                        Text('Avg connection time: ${_lastTestResult!['average_connection_time_ms'].toStringAsFixed(0)}ms'),
                      ],
                    )
                  else if (_lastTestResult!['test_type'] == 'performance')
                    Text('Optimal polling: ${_lastTestResult!['recommendations']['optimal_polling_interval_ms']}ms'),
                ],
              ),
            ),
        ],
      ),
    );
  }
} 

################################################################################
FILE: lib/obd_lib/test/mock_bluetooth_connection.dart
################################################################################

import 'dart:async';
import '../interfaces/obd_connection.dart';

/// A mock implementation of ObdConnection for testing
class MockBluetoothConnection implements ObdConnection {
  /// Internal controller for the data stream
  final StreamController<String> _dataStreamController;
  
  /// Connection status
  bool _isConnected = false;
  
  /// List of predefined responses for testing
  final Map<String, String> _commandResponses = {};
  
  /// Delay to simulate realistic response timing
  final Duration _responseDelay;
  
  /// Create a mock Bluetooth connection
  MockBluetoothConnection({
    Duration? responseDelay,
    Map<String, String>? commandResponses,
    bool createFreshController = true,
  }) : 
    _responseDelay = responseDelay ?? const Duration(milliseconds: 50),
    _dataStreamController = StreamController<String>.broadcast() {
    
    // Add any predefined responses
    if (commandResponses != null) {
      _commandResponses.addAll(commandResponses);
    }
    
    // Add default responses for common commands if not provided
    _commandResponses.putIfAbsent('ATZ', () => 'ELM327 v1.5\r\n>');
  }
  
  @override
  Stream<String> get dataStream => _dataStreamController.stream;
  
  @override
  bool get isConnected => _isConnected;
  
  @override
  Future<bool> connect() async {
    if (_dataStreamController.isClosed) {
      return false;
    }
    
    // Simulate connection delay
    await Future.delayed(const Duration(milliseconds: 20));
    _isConnected = true;
    
    // Add the CONNECTED message
    try {
      if (!_dataStreamController.isClosed) {
        _dataStreamController.add('CONNECTED');
        
        // Give a small delay to ensure the CONNECTED message is processed
        await Future.delayed(const Duration(milliseconds: 10));
      }
    } catch (e) {
      // Ignore if stream is closed
      print('Warning: Could not add to stream: $e');
      return false;
    }
    
    return true;
  }
  
  @override
  Future<void> disconnect() async {
    _isConnected = false;
    if (!_dataStreamController.isClosed) {
      try {
        _dataStreamController.add('DISCONNECTED');
      } catch (e) {
        print('Warning: Could not add DISCONNECTED to stream: $e');
      }
    }
  }
  
  @override
  Future<void> sendCommand(String command) async {
    if (!_isConnected || _dataStreamController.isClosed) {
      return;
    }
    
    // Simulate command processing delay
    await Future.delayed(_responseDelay);
    
    try {
      // Return predefined response if available
      if (_commandResponses.containsKey(command)) {
        final response = _commandResponses[command]!;
        _dataStreamController.add(response);
        return;
      }
      
      // Generate a default response based on the command
      String response = _generateDefaultResponse(command);
      _dataStreamController.add(response);
    } catch (e) {
      print('Warning: Could not send command response: $e');
    }
  }
  
  @override
  Future<void> dispose() async {
    _isConnected = false;
    // Only close the stream if it's not already closed
    if (!_dataStreamController.isClosed) {
      await _dataStreamController.close();
    }
  }
  
  /// Add a command response mapping
  void addCommandResponse(String command, String response) {
    _commandResponses[command] = response;
  }
  
  /// Simulate sending a response directly to the stream
  void simulateResponse(String response) {
    if (!_dataStreamController.isClosed) {
      try {
        _dataStreamController.add(response);
      } catch (e) {
        print('Warning: Could not simulate response: $e');
      }
    }
  }
  
  /// Generate a default response for a command if no predefined response exists
  String _generateDefaultResponse(String command) {
    // Handle standard ELM327 commands
    if (command == 'ATZ') {
      return 'ELM327 v1.5\r\n>';
    } else if (command == 'ATE0') {
      return 'OK\r\n>';
    } else if (command == 'ATL0') {
      return 'OK\r\n>';
    } else if (command == 'ATH0') {
      return 'OK\r\n>';
    } else if (command == 'ATSP0') {
      return 'OK\r\n>';
    } else if (command == 'ATAT1') {
      return 'OK\r\n>';
    } else if (command == 'ATST64') {
      return 'OK\r\n>';
    } else if (command.startsWith('01')) {
      // Generate OBD-II mode 01 responses
      if (command == '0100') {
        // Supported PIDs
        return '41 00 98 3F 80 10\r\n>';
      } else if (command == '010C') {
        // Engine RPM (1500 RPM)
        return '41 0C 12 00\r\n>'; 
      } else if (command == '010D') {
        // Vehicle speed (50 km/h)
        return '41 0D 32\r\n>';
      } else if (command == '0105') {
        // Coolant temperature (90°C)
        return '41 05 5A\r\n>';
      } else if (command == '0111') {
        // Throttle position (25%)
        return '41 11 40\r\n>';
      } else {
        // Unknown PID
        return 'NO DATA\r\n>';
      }
    } else {
      // Unknown command
      return '?\r\n>';
    }
  }
} 

################################################################################
FILE: lib/obd_lib/models/obd_command.dart
################################################################################

/// Represents an OBD-II command
class ObdCommand {
  /// The command mode (e.g., '01' for current data)
  final String mode;
  
  /// The Parameter ID (PID) for the command
  final String pid;
  
  /// Optional additional parameters
  final List<String> parameters;
  
  /// Human-readable name of the command
  final String name;
  
  /// Description of what this command retrieves
  final String description;
  
  /// Creates a new OBD-II command
  const ObdCommand({
    required this.mode,
    required this.pid,
    this.parameters = const [],
    required this.name,
    required this.description,
  });
  
  /// The full command string to send to the OBD-II adapter
  String get command {
    final buffer = StringBuffer();
    buffer.write(mode);
    buffer.write(pid);
    
    for (final param in parameters) {
      buffer.write(' ');
      buffer.write(param);
    }
    
    return buffer.toString();
  }
  
  /// Creates a standard mode 01 command for current data
  factory ObdCommand.mode01(
    String pid, {
    required String name,
    required String description,
    List<String> parameters = const [],
  }) {
    return ObdCommand(
      mode: '01',
      pid: pid,
      name: name,
      description: description,
      parameters: parameters,
    );
  }
  
  /// Creates a standard mode 09 command for vehicle information
  factory ObdCommand.mode09(
    String pid, {
    required String name,
    required String description,
    List<String> parameters = const [],
  }) {
    return ObdCommand(
      mode: '09',
      pid: pid,
      name: name,
      description: description,
      parameters: parameters,
    );
  }
  
  @override
  String toString() => '$name ($mode$pid)';
} 

################################################################################
FILE: lib/obd_lib/models/bluetooth_device.dart
################################################################################

/// Represents a Bluetooth device that can be used for OBD-II communication
class BluetoothDevice {
  /// Unique identifier of the device
  final String id;
  
  /// Human-readable name of the device
  final String name;
  
  /// Signal strength indicator (RSSI)
  final int? rssi;
  
  /// Whether the device is connectable
  final bool isConnectable;
  
  /// Creates a new Bluetooth device
  const BluetoothDevice({
    required this.id,
    required this.name,
    this.rssi,
    this.isConnectable = true,
  });
  
  @override
  String toString() => '$name ($id)';
  
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BluetoothDevice && runtimeType == other.runtimeType && id == other.id;
  
  @override
  int get hashCode => id.hashCode;
} 

################################################################################
FILE: lib/obd_lib/models/adapter_config.dart
################################################################################

import 'package:logging/logging.dart';

/// Configuration for OBD-II adapters
///
/// This class encapsulates adapter-specific settings and replaces
/// hard-coded constants with configurable parameters. It allows
/// for dynamic configuration of adapters based on their capabilities.
class AdapterConfig {
  static final Logger _logger = Logger('AdapterConfig');
  
  /// Unique identifier for the configuration profile
  final String profileId;
  
  /// Human-readable name for the configuration
  final String name;
  
  /// Description of this configuration profile
  final String description;
  
  // Bluetooth-related settings
  /// Service UUID for BLE communication
  final String serviceUuid;
  
  /// Characteristic UUID for notifications (data from adapter)
  final String notifyCharacteristicUuid;
  
  /// Characteristic UUID for writing commands to adapter
  final String writeCharacteristicUuid;
  
  // Timing-related settings
  /// Response timeout for single commands (ms)
  final int responseTimeoutMs;
  
  /// Connection establishment timeout (ms)
  final int connectionTimeoutMs;
  
  /// Command execution timeout (ms)
  final int commandTimeoutMs;
  
  /// Delay between initialization commands (ms)
  final int initCommandDelayMs;
  
  /// Delay after reset command (ms)
  final int resetDelayMs;
  
  // Polling-related settings
  /// Default polling interval for normal operation (ms)
  final int defaultPollingInterval;
  
  /// Slower polling for less reliable adapters (ms)
  final int slowPollingInterval;
  
  /// Polling interval when engine is off (ms)
  final int engineOffPollingInterval;
  
  // Error handling settings
  /// Maximum number of command retries
  final int maxRetries;
  
  /// Whether to use extended initialization delays
  final bool useExtendedInitDelays;
  
  /// Whether to use strict or lenient response parsing
  final bool useLenientParsing;
  
  // Protocol settings
  /// OBD protocol to use (e.g., "AUTO", "ISO 14230-4")
  final String obdProtocol;
  
  /// Baud rate for communication
  final int baudRate;
  
  /// Create a new adapter configuration
  AdapterConfig({
    required this.profileId,
    required this.name,
    required this.description,
    required this.serviceUuid,
    required this.notifyCharacteristicUuid,
    required this.writeCharacteristicUuid,
    required this.responseTimeoutMs,
    required this.connectionTimeoutMs,
    required this.commandTimeoutMs,
    required this.initCommandDelayMs,
    required this.resetDelayMs,
    required this.defaultPollingInterval,
    required this.slowPollingInterval,
    required this.engineOffPollingInterval,
    required this.maxRetries,
    required this.useExtendedInitDelays,
    required this.useLenientParsing,
    required this.obdProtocol,
    required this.baudRate,
  }) {
    _logger.info('Created adapter configuration: $profileId');
  }
  
  /// Create a deep copy of this configuration with optional overrides
  AdapterConfig copyWith({
    String? profileId,
    String? name,
    String? description,
    String? serviceUuid,
    String? notifyCharacteristicUuid,
    String? writeCharacteristicUuid,
    int? responseTimeoutMs,
    int? connectionTimeoutMs,
    int? commandTimeoutMs,
    int? initCommandDelayMs,
    int? resetDelayMs,
    int? defaultPollingInterval,
    int? slowPollingInterval,
    int? engineOffPollingInterval,
    int? maxRetries,
    bool? useExtendedInitDelays,
    bool? useLenientParsing,
    String? obdProtocol,
    int? baudRate,
  }) {
    return AdapterConfig(
      profileId: profileId ?? this.profileId,
      name: name ?? this.name,
      description: description ?? this.description,
      serviceUuid: serviceUuid ?? this.serviceUuid,
      notifyCharacteristicUuid: notifyCharacteristicUuid ?? this.notifyCharacteristicUuid,
      writeCharacteristicUuid: writeCharacteristicUuid ?? this.writeCharacteristicUuid,
      responseTimeoutMs: responseTimeoutMs ?? this.responseTimeoutMs,
      connectionTimeoutMs: connectionTimeoutMs ?? this.connectionTimeoutMs,
      commandTimeoutMs: commandTimeoutMs ?? this.commandTimeoutMs,
      initCommandDelayMs: initCommandDelayMs ?? this.initCommandDelayMs,
      resetDelayMs: resetDelayMs ?? this.resetDelayMs,
      defaultPollingInterval: defaultPollingInterval ?? this.defaultPollingInterval,
      slowPollingInterval: slowPollingInterval ?? this.slowPollingInterval,
      engineOffPollingInterval: engineOffPollingInterval ?? this.engineOffPollingInterval,
      maxRetries: maxRetries ?? this.maxRetries,
      useExtendedInitDelays: useExtendedInitDelays ?? this.useExtendedInitDelays,
      useLenientParsing: useLenientParsing ?? this.useLenientParsing,
      obdProtocol: obdProtocol ?? this.obdProtocol,
      baudRate: baudRate ?? this.baudRate,
    );
  }
  
  @override
  String toString() {
    return 'AdapterConfig{profileId: $profileId, name: $name}';
  }
} 

################################################################################
FILE: lib/obd_lib/models/adapter_config_validator.dart
################################################################################

import 'package:logging/logging.dart';
import 'adapter_config.dart';
import '../protocol/obd_constants.dart';

/// Validates and monitors OBD adapter configurations
///
/// This class provides validation for configuration parameters,
/// runtime monitoring of adapter behavior, and protection for
/// critical parameters.
class AdapterConfigValidator {
  static final Logger _logger = Logger('AdapterConfigValidator');
  
  // Minimum and maximum values for critical parameters
  static const Map<String, Map<String, int>> _parameterLimits = {
    'cheap_elm327': {
      'responseTimeoutMs_min': 200,
      'responseTimeoutMs_max': 350,
      'connectionTimeoutMs_min': 8000,
      'connectionTimeoutMs_max': 12000,
      'commandTimeoutMs_min': 3000,
      'commandTimeoutMs_max': 5000,
      'initCommandDelayMs_min': 250,
      'initCommandDelayMs_max': 350,
      'resetDelayMs_min': 800,
      'resetDelayMs_max': 1200,
    },
    'premium_elm327': {
      'responseTimeoutMs_min': 80,
      'responseTimeoutMs_max': 150,
      'connectionTimeoutMs_min': 4000,
      'connectionTimeoutMs_max': 8000,
      'commandTimeoutMs_min': 1000,
      'commandTimeoutMs_max': 2000,
      'initCommandDelayMs_min': 30,
      'initCommandDelayMs_max': 100,
      'resetDelayMs_min': 200,
      'resetDelayMs_max': 500,
    },
    'elm327_v13': {
      'responseTimeoutMs_min': 120,
      'responseTimeoutMs_max': 200,
      'connectionTimeoutMs_min': 6000,
      'connectionTimeoutMs_max': 10000,
      'commandTimeoutMs_min': 2000,
      'commandTimeoutMs_max': 3000,
      'initCommandDelayMs_min': 80,
      'initCommandDelayMs_max': 150,
      'resetDelayMs_min': 500,
      'resetDelayMs_max': 1000,
    },
    'elm327_v14': {
      'responseTimeoutMs_min': 100,
      'responseTimeoutMs_max': 150,
      'connectionTimeoutMs_min': 6000,
      'connectionTimeoutMs_max': 8000,
      'commandTimeoutMs_min': 1500,
      'commandTimeoutMs_max': 2500,
      'initCommandDelayMs_min': 60,
      'initCommandDelayMs_max': 120,
      'resetDelayMs_min': 400,
      'resetDelayMs_max': 700,
    },
    'elm327_v20': {
      'responseTimeoutMs_min': 70,
      'responseTimeoutMs_max': 120,
      'connectionTimeoutMs_min': 4000,
      'connectionTimeoutMs_max': 6000,
      'commandTimeoutMs_min': 1000,
      'commandTimeoutMs_max': 1500,
      'initCommandDelayMs_min': 30,
      'initCommandDelayMs_max': 80,
      'resetDelayMs_min': 200,
      'resetDelayMs_max': 400,
    },
    'dynamic_elm327': {
      'responseTimeoutMs_min': 80,
      'responseTimeoutMs_max': 350,
      'connectionTimeoutMs_min': 4000,
      'connectionTimeoutMs_max': 12000,
      'commandTimeoutMs_min': 1000,
      'commandTimeoutMs_max': 5000,
      'initCommandDelayMs_min': 30,
      'initCommandDelayMs_max': 350,
      'resetDelayMs_min': 200,
      'resetDelayMs_max': 1200,
    },
  };
  
  // Required configuration parameters that must be validated
  static const List<String> _requiredParameters = [
    'responseTimeoutMs',
    'connectionTimeoutMs',
    'commandTimeoutMs',
    'initCommandDelayMs',
    'resetDelayMs',
    'defaultPollingInterval',
    'slowPollingInterval',
    'engineOffPollingInterval',
    'maxRetries',
  ];
  
  // Metrics for tracking runtime performance
  final Map<String, Map<String, dynamic>> _runtimeMetrics = {};
  
  /// Validate adapter configuration against defined constraints
  ///
  /// Returns a tuple with (isValid, validatedConfig, issues)
  /// where isValid is a boolean, validatedConfig is the adjusted configuration
  /// if needed, and issues is a list of validation issues.
  Map<String, dynamic> validateConfig(AdapterConfig config) {
    final profileId = config.profileId;
    final validationIssues = <String>[];
    bool isValid = true;
    var adjustedConfig = config;
    
    _logger.info('Validating configuration for profile: $profileId');
    
    // Check required parameters
    for (final param in _requiredParameters) {
      if (!_hasParameter(config, param)) {
        validationIssues.add('Missing required parameter: $param');
        isValid = false;
      }
    }
    
    // Check parameter limits
    if (_parameterLimits.containsKey(profileId)) {
      final limits = _parameterLimits[profileId]!;
      
      // Validate and adjust timing parameters if needed
      adjustedConfig = _validateTimingParameters(config, limits, validationIssues);
      
      // If validation failed but we have an adjusted config, we mark as valid
      // but report the issues
      if (config != adjustedConfig) {
        _logger.warning('Configuration adjusted to meet constraints for profile: $profileId');
      }
    } else {
      _logger.warning('No validation limits defined for profile: $profileId');
    }
    
    // Validate Bluetooth parameters
    _validateBluetoothParameters(config, validationIssues);
    
    // Check for safe protocol settings
    _validateProtocolSettings(config, validationIssues);
    
    // Additional validation for cheap adapters
    if (profileId == 'cheap_elm327') {
      _validateCheapAdapterSettings(config, validationIssues);
    }
    
    // Log all validation issues
    for (final issue in validationIssues) {
      _logger.warning('Validation issue: $issue');
    }
    
    return {
      'isValid': isValid || config != adjustedConfig,
      'config': adjustedConfig,
      'issues': validationIssues,
    };
  }
  
  /// Validate and adjust timing parameters based on limits
  AdapterConfig _validateTimingParameters(
    AdapterConfig config, 
    Map<String, int> limits, 
    List<String> validationIssues
  ) {
    var adjustedConfig = config;
    
    // Check each timing parameter
    void validateParam(String param, int value) {
      final minKey = '${param}_min';
      final maxKey = '${param}_max';
      
      if (limits.containsKey(minKey) && limits.containsKey(maxKey)) {
        final min = limits[minKey]!;
        final max = limits[maxKey]!;
        
        if (value < min) {
          validationIssues.add('$param too low: $value (min: $min)');
          // Create adjusted config using copyWith
          adjustedConfig = _updateConfigParam(adjustedConfig, param, min);
        } else if (value > max) {
          validationIssues.add('$param too high: $value (max: $max)');
          // Create adjusted config using copyWith
          adjustedConfig = _updateConfigParam(adjustedConfig, param, max);
        }
      }
    }
    
    validateParam('responseTimeoutMs', config.responseTimeoutMs);
    validateParam('connectionTimeoutMs', config.connectionTimeoutMs);
    validateParam('commandTimeoutMs', config.commandTimeoutMs);
    validateParam('initCommandDelayMs', config.initCommandDelayMs);
    validateParam('resetDelayMs', config.resetDelayMs);
    
    return adjustedConfig;
  }
  
  /// Update a specific parameter in the config using copyWith
  AdapterConfig _updateConfigParam(AdapterConfig config, String param, int value) {
    switch (param) {
      case 'responseTimeoutMs':
        return config.copyWith(responseTimeoutMs: value);
      case 'connectionTimeoutMs':
        return config.copyWith(connectionTimeoutMs: value);
      case 'commandTimeoutMs':
        return config.copyWith(commandTimeoutMs: value);
      case 'initCommandDelayMs':
        return config.copyWith(initCommandDelayMs: value);
      case 'resetDelayMs':
        return config.copyWith(resetDelayMs: value);
      default:
        return config;
    }
  }
  
  /// Check if a parameter exists on the config object
  bool _hasParameter(AdapterConfig config, String param) {
    try {
      switch (param) {
        case 'responseTimeoutMs':
          return config.responseTimeoutMs != null;
        case 'connectionTimeoutMs':
          return config.connectionTimeoutMs != null;
        case 'commandTimeoutMs':
          return config.commandTimeoutMs != null;
        case 'initCommandDelayMs':
          return config.initCommandDelayMs != null;
        case 'resetDelayMs':
          return config.resetDelayMs != null;
        case 'defaultPollingInterval':
          return config.defaultPollingInterval != null;
        case 'slowPollingInterval':
          return config.slowPollingInterval != null;
        case 'engineOffPollingInterval':
          return config.engineOffPollingInterval != null;
        case 'maxRetries':
          return config.maxRetries != null;
        default:
          return false;
      }
    } catch (e) {
      return false;
    }
  }
  
  /// Validate Bluetooth parameters
  void _validateBluetoothParameters(AdapterConfig config, List<String> validationIssues) {
    // Check service UUID
    if (config.serviceUuid != ObdConstants.serviceUuid) {
      validationIssues.add('Invalid service UUID: ${config.serviceUuid}');
    }
    
    // Check notification characteristic UUID
    if (config.notifyCharacteristicUuid != ObdConstants.notifyCharacteristicUuid) {
      validationIssues.add('Invalid notify characteristic UUID: ${config.notifyCharacteristicUuid}');
    }
    
    // Check write characteristic UUID
    if (config.writeCharacteristicUuid != ObdConstants.writeCharacteristicUuid) {
      validationIssues.add('Invalid write characteristic UUID: ${config.writeCharacteristicUuid}');
    }
  }
  
  /// Validate protocol settings
  void _validateProtocolSettings(AdapterConfig config, List<String> validationIssues) {
    // Check OBD protocol
    if (config.obdProtocol != 'AUTO' && 
        config.obdProtocol != 'ISO 14230-4' && 
        config.obdProtocol != 'ISO 15765-4') {
      validationIssues.add('Unsupported OBD protocol: ${config.obdProtocol}');
    }
    
    // Check baud rate
    if (config.baudRate != 9600 && config.baudRate != 10400 && config.baudRate != 38400) {
      validationIssues.add('Unusual baud rate: ${config.baudRate}');
    }
  }
  
  /// Additional validation for cheap adapters
  void _validateCheapAdapterSettings(AdapterConfig config, List<String> validationIssues) {
    // Cheap adapters must have specific flags set
    if (!config.useExtendedInitDelays) {
      validationIssues.add('useExtendedInitDelays must be true for cheap adapters');
    }
    
    if (!config.useLenientParsing) {
      validationIssues.add('useLenientParsing must be true for cheap adapters');
    }
  }
  
  /// Record runtime metrics for an adapter configuration
  /// 
  /// This allows monitoring of adapter behavior over time and can
  /// be used to automatically adjust configuration parameters.
  void recordRuntimeMetrics(String deviceId, AdapterConfig config, Map<String, dynamic> metrics) {
    final profileId = config.profileId;
    final key = '$deviceId:$profileId';
    
    if (!_runtimeMetrics.containsKey(key)) {
      _runtimeMetrics[key] = {
        'deviceId': deviceId,
        'profileId': profileId,
        'commandCount': 0,
        'successCount': 0,
        'failureCount': 0,
        'totalResponseTime': 0,
        'avgResponseTime': 0,
        'maxResponseTime': 0,
        'minResponseTime': null,
        'timeoutCount': 0,
        'lastUpdateTime': DateTime.now().millisecondsSinceEpoch,
        'sampledParameters': <String, List<int>>{},
      };
      
      // Initialize sample collections for timing parameters
      _runtimeMetrics[key]!['sampledParameters']!['responseTime'] = [];
      _runtimeMetrics[key]!['sampledParameters']!['commandDuration'] = [];
    }
    
    // Update metrics
    final data = _runtimeMetrics[key]!;
    data['commandCount'] = (data['commandCount'] as int) + 1;
    
    if (metrics.containsKey('success') && metrics['success'] == true) {
      data['successCount'] = (data['successCount'] as int) + 1;
    } else {
      data['failureCount'] = (data['failureCount'] as int) + 1;
    }
    
    if (metrics.containsKey('responseTime')) {
      final responseTime = metrics['responseTime'] as int;
      data['totalResponseTime'] = (data['totalResponseTime'] as int) + responseTime;
      data['avgResponseTime'] = (data['totalResponseTime'] as int) / (data['commandCount'] as int);
      
      if (data['maxResponseTime'] < responseTime) {
        data['maxResponseTime'] = responseTime;
      }
      
      if (data['minResponseTime'] == null || (data['minResponseTime'] as int) > responseTime) {
        data['minResponseTime'] = responseTime;
      }
      
      // Add to samples
      final samples = (data['sampledParameters']!['responseTime'] as List<int>);
      if (samples.length >= 100) {
        samples.removeAt(0); // Remove oldest sample
      }
      samples.add(responseTime);
    }
    
    if (metrics.containsKey('timeout') && metrics['timeout'] == true) {
      data['timeoutCount'] = (data['timeoutCount'] as int) + 1;
    }
    
    if (metrics.containsKey('commandDuration')) {
      final duration = metrics['commandDuration'] as int;
      final samples = (data['sampledParameters']!['commandDuration'] as List<int>);
      if (samples.length >= 100) {
        samples.removeAt(0); // Remove oldest sample
      }
      samples.add(duration);
    }
    
    // Update timestamp
    data['lastUpdateTime'] = DateTime.now().millisecondsSinceEpoch;
  }
  
  /// Calculate optimized timing parameters based on runtime metrics
  ///
  /// Returns a new configuration with optimized timing parameters
  /// if sufficient data is available.
  AdapterConfig? calculateOptimizedConfig(String deviceId, String profileId) {
    final key = '$deviceId:$profileId';
    
    if (!_runtimeMetrics.containsKey(key)) {
      _logger.info('No runtime metrics available for $deviceId with profile $profileId');
      return null;
    }
    
    final metrics = _runtimeMetrics[key]!;
    final commandCount = metrics['commandCount'] as int;
    
    // Need at least 20 commands to have enough data
    if (commandCount < 20) {
      _logger.info('Insufficient command count for optimization: $commandCount');
      return null;
    }
    
    // Get the current config
    final profile = profileId == 'cheap_elm327' ? 'cheap_elm327' : 'premium_elm327';
    final limits = _parameterLimits[profile]!;
    
    // Get success rate
    final successCount = metrics['successCount'] as int;
    final successRate = successCount / commandCount;
    
    // If success rate is too low, don't try to optimize
    if (successRate < 0.8) {
      _logger.info('Success rate too low for optimization: ${(successRate * 100).toStringAsFixed(1)}%');
      return null;
    }
    
    // Calculate optimized response timeout based on observed response times
    final responseSamples = (metrics['sampledParameters']!['responseTime'] as List<int>);
    
    if (responseSamples.isEmpty) {
      return null;
    }
    
    // Sort samples to find percentiles
    responseSamples.sort();
    final p95Index = ((responseSamples.length - 1) * 0.95).round();
    final p95ResponseTime = responseSamples[p95Index];
    
    // Add 20% margin to the 95th percentile
    int optimizedResponseTimeout = (p95ResponseTime * 1.2).round();
    
    // Clamp to allowed range
    optimizedResponseTimeout = optimizedResponseTimeout.clamp(
      limits['responseTimeoutMs_min']!,
      limits['responseTimeoutMs_max']!
    );
    
    // Get current config
    // Note: In a real implementation, you'd get this from the profile manager
    // For this example, we'll create a placeholder for demonstration
    var currentConfig = AdapterConfig(
      profileId: profileId,
      name: 'Runtime Optimized Config',
      description: 'Automatically optimized configuration based on runtime metrics',
      serviceUuid: ObdConstants.serviceUuid,
      notifyCharacteristicUuid: ObdConstants.notifyCharacteristicUuid,
      writeCharacteristicUuid: ObdConstants.writeCharacteristicUuid,
      responseTimeoutMs: optimizedResponseTimeout,
      connectionTimeoutMs: limits['connectionTimeoutMs_min']!,
      commandTimeoutMs: limits['commandTimeoutMs_min']!,
      initCommandDelayMs: limits['initCommandDelayMs_min']!,
      resetDelayMs: limits['resetDelayMs_min']!,
      defaultPollingInterval: 500,
      slowPollingInterval: 1000,
      engineOffPollingInterval: 3000,
      maxRetries: 2,
      useExtendedInitDelays: profileId == 'cheap_elm327',
      useLenientParsing: profileId == 'cheap_elm327',
      obdProtocol: 'ISO 14230-4',
      baudRate: 10400,
    );
    
    // Optimize command timeout based on command duration samples
    final commandSamples = (metrics['sampledParameters']!['commandDuration'] as List<int>);
    
    if (commandSamples.isNotEmpty) {
      commandSamples.sort();
      final p95Index = ((commandSamples.length - 1) * 0.95).round();
      final p95CommandDuration = commandSamples[p95Index];
      
      // Add 50% margin to the 95th percentile
      int optimizedCommandTimeout = (p95CommandDuration * 1.5).round();
      
      // Clamp to allowed range
      optimizedCommandTimeout = optimizedCommandTimeout.clamp(
        limits['commandTimeoutMs_min']!,
        limits['commandTimeoutMs_max']!
      );
      
      currentConfig = currentConfig.copyWith(commandTimeoutMs: optimizedCommandTimeout);
    }
    
    _logger.info('Generated optimized configuration for $deviceId with profile $profileId');
    return currentConfig;
  }
  
  /// Check if a configuration is safe to update for a given profileId
  ///
  /// This prevents modifications to critical parameters for cheap adapters
  bool isSafeConfigUpdate(String profileId, Map<String, dynamic> updates) {
    // For cheap adapters, block modification of critical parameters
    if (profileId == 'cheap_elm327') {
      // Critical parameters that should not be modified for cheap adapters
      final protectedParameters = [
        'responseTimeoutMs',
        'connectionTimeoutMs',
        'commandTimeoutMs',
        'initCommandDelayMs',
        'resetDelayMs',
        'useExtendedInitDelays',
        'useLenientParsing',
        'obdProtocol',
        'baudRate',
      ];
      
      // Check if any protected parameters are being modified
      for (final param in protectedParameters) {
        if (updates.containsKey(param)) {
          _logger.warning('Attempt to modify protected parameter for cheap adapter: $param');
          return false;
        }
      }
    }
    
    return true;
  }
  
  /// Get runtime statistics summary for a device and profile
  Map<String, dynamic>? getRuntimeStatistics(String deviceId, String profileId) {
    final key = '$deviceId:$profileId';
    
    if (!_runtimeMetrics.containsKey(key)) {
      return null;
    }
    
    final metrics = _runtimeMetrics[key]!;
    final commandCount = metrics['commandCount'] as int;
    final successCount = metrics['successCount'] as int;
    final timeoutCount = metrics['timeoutCount'] as int;
    
    // Calculate statistics
    final successRate = commandCount > 0 ? successCount / commandCount : 0.0;
    final timeoutRate = commandCount > 0 ? timeoutCount / commandCount : 0.0;
    final avgResponseTime = metrics['avgResponseTime'] as double;
    
    return {
      'deviceId': deviceId,
      'profileId': profileId,
      'commandCount': commandCount,
      'successRate': successRate,
      'timeoutRate': timeoutRate,
      'avgResponseTime': avgResponseTime,
      'maxResponseTime': metrics['maxResponseTime'] as int,
      'minResponseTime': metrics['minResponseTime'] as int?,
      'lastUpdateTime': metrics['lastUpdateTime'] as int,
    };
  }
} 

################################################################################
FILE: lib/obd_lib/models/obd_data.dart
################################################################################

/// Represents a decoded OBD-II data response
class ObdData {
  /// The command mode (e.g., '01' for current data)
  final String mode;
  
  /// The Parameter ID (PID) for the response
  final String pid;
  
  /// The raw response bytes
  final List<int> rawData;
  
  /// Human-readable name of the data
  final String name;
  
  /// Decoded value
  final dynamic value;
  
  /// Unit of measurement (e.g., 'km/h', '°C')
  final String unit;
  
  /// Timestamp when the data was received
  final DateTime timestamp;

  /// Creates a new OBD-II data instance
  ObdData({
    required this.mode,
    required this.pid,
    required this.rawData,
    required this.name,
    required this.value,
    required this.unit,
    DateTime? timestamp,
  }) : timestamp = timestamp ?? DateTime.now();
  
  /// Creates a copy of this OBD data with the given fields replaced
  ObdData copyWith({
    String? mode,
    String? pid,
    List<int>? rawData,
    String? name,
    dynamic value,
    String? unit,
    DateTime? timestamp,
  }) {
    return ObdData(
      mode: mode ?? this.mode,
      pid: pid ?? this.pid,
      rawData: rawData ?? this.rawData,
      name: name ?? this.name,
      value: value ?? this.value,
      unit: unit ?? this.unit,
      timestamp: timestamp ?? this.timestamp,
    );
  }
  
  @override
  String toString() {
    return '$name: $value $unit';
  }
} 

################################################################################
FILE: lib/obd_lib/models/obd_pid_config.dart
################################################################################

import 'package:flutter/material.dart';
import '../protocol/obd_constants.dart';

/// Represents configuration for an OBD-II Parameter ID (PID)
class ObdPidConfig {
  /// The PID code (e.g., '05' for coolant temperature)
  final String pid;

  /// Human-readable name to display
  final String displayName;

  /// Unit of measurement (e.g., 'km/h', '°C')
  final String unit;

  /// Icon to display with the data
  final IconData icon;

  /// Importance/priority (lower number = higher priority)
  final int priority;

  /// Creates a new OBD PID configuration
  const ObdPidConfig({
    required this.pid,
    required this.displayName,
    required this.unit,
    required this.icon,
    this.priority = 100,
  });

  /// Standard PIDs with predefined configurations
  static const Map<String, ObdPidConfig> standardPids = {
    // Coolant temperature
    ObdConstants.pidCoolantTemp: ObdPidConfig(
      pid: ObdConstants.pidCoolantTemp,
      displayName: 'Coolant Temp',
      unit: '°C',
      icon: Icons.thermostat,
      priority: 10,
    ),
    
    // Engine RPM
    ObdConstants.pidEngineRpm: ObdPidConfig(
      pid: ObdConstants.pidEngineRpm,
      displayName: 'Engine RPM',
      unit: 'RPM',
      icon: Icons.speed,
      priority: 1,
    ),
    
    // Vehicle speed
    ObdConstants.pidVehicleSpeed: ObdPidConfig(
      pid: ObdConstants.pidVehicleSpeed,
      displayName: 'Vehicle Speed',
      unit: 'km/h', 
      icon: Icons.directions_car,
      priority: 2,
    ),
    
    // Control module voltage
    ObdConstants.pidControlModuleVoltage: ObdPidConfig(
      pid: ObdConstants.pidControlModuleVoltage,
      displayName: 'Voltage',
      unit: 'V',
      icon: Icons.battery_charging_full,
      priority: 20,
    ),

    // Current fuel level
    ObdConstants.pidCurrentFuelLevel: ObdPidConfig(
      pid: ObdConstants.pidCurrentFuelLevel,
      displayName: 'Fuel Level',
      unit: '%',
      icon: Icons.local_gas_station,
    ),

    // Fuel type
    ObdConstants.pidFuelType: ObdPidConfig(
      pid: ObdConstants.pidFuelType,
      displayName: 'Fuel Type',
      unit: '',
      icon: Icons.local_gas_station,
    ),

    // Engine load
    ObdConstants.pidEngineLoad: ObdPidConfig(
      pid: ObdConstants.pidEngineLoad,
      displayName: 'Engine Load',
      unit: '%',
      icon: Icons.speed,
    ),

    // Throttle position
    ObdConstants.pidThrottlePosition: ObdPidConfig(
      pid: ObdConstants.pidThrottlePosition,
      displayName: 'Throttle Position',
      unit: '%',
      icon: Icons.add_to_drive_sharp
    ),

    // Intake manifold absolute pressure
    ObdConstants.pidIntakeManifoldAbsolutePressure: ObdPidConfig(
      pid: ObdConstants.pidIntakeManifoldAbsolutePressure,
      displayName: 'Intake Manifold Absolute Pressure',
      unit: 'kPa',
      icon: Icons.speed,
    ),

    // Intake air temperature
    ObdConstants.pidIntakeAirTemperature: ObdPidConfig(
      pid: ObdConstants.pidIntakeAirTemperature,
      displayName: 'Intake Air Temperature',
      unit: '°C',
      icon: Icons.air
    ),

    // Engine oil temperature
    ObdConstants.pidEngineOilTemperature: ObdPidConfig(
      pid: ObdConstants.pidEngineOilTemperature,
      displayName: 'Engine Oil Temperature',
      unit: '°C',
      icon: Icons.oil_barrel
    ),

    // Ambient air temperature
    ObdConstants.pidAmbientAirTemperature: ObdPidConfig(
      pid: ObdConstants.pidAmbientAirTemperature,
      displayName: 'Ambient Air Temperature',
      unit: '°C',
      icon: Icons.thermostat
    ),

    // Fuel pressure
    ObdConstants.pidFuelPressure: ObdPidConfig(
      pid: ObdConstants.pidFuelPressure,
      displayName: 'Fuel Pressure',
      unit: 'kPa',
      icon: Icons.local_gas_station
    ),
    
    // Mass Air Flow rate
    ObdConstants.pidMassAirFlow: ObdPidConfig(
      pid: ObdConstants.pidMassAirFlow,
      displayName: 'Mass Air Flow',
      unit: 'g/s',
      icon: Icons.air,
      priority: 15,
    ),
    
    // Distance traveled with MIL on
    ObdConstants.pidDistanceMIL: ObdPidConfig(
      pid: ObdConstants.pidDistanceMIL,
      displayName: 'Distance with MIL',
      unit: 'km',
      icon: Icons.warning,
      priority: 40,
    ),
    
    // Fuel rate
    ObdConstants.pidFuelRate: ObdPidConfig(
      pid: ObdConstants.pidFuelRate,
      displayName: 'Fuel Rate',
      unit: 'L/h',
      icon: Icons.local_gas_station,
      priority: 12,
    ),
    
    // Accelerator pedal position
    ObdConstants.pidAcceleratorPosition: ObdPidConfig(
      pid: ObdConstants.pidAcceleratorPosition,
      displayName: 'Accelerator Position',
      unit: '%',
      icon: Icons.pedal_bike,
      priority: 8,
    ),
  };

  /// Get a predefined PID configuration by PID
  static ObdPidConfig getConfig(String pid) {
    return standardPids[pid] ?? ObdPidConfig(
      pid: pid,
      displayName: 'PID $pid',
      unit: '',
      icon: Icons.data_usage,
    );
  }

  /// Get a list of all standard PID configurations
  static List<ObdPidConfig> get allConfigs => 
      standardPids.values.toList()
        ..sort((a, b) => a.priority.compareTo(b.priority));
} 

################################################################################
FILE: lib/obd_lib/models/adapter_config_factory.dart
################################################################################

import 'package:logging/logging.dart';
import '../protocol/obd_constants.dart';
import 'adapter_config.dart';

/// Factory for creating adapter configurations
///
/// This class provides factory methods for creating pre-configured
/// adapter configurations for different types of ELM327 adapters.
class AdapterConfigFactory {
  static final Logger _logger = Logger('AdapterConfigFactory');
  
  // Private constructor to prevent instantiation
  AdapterConfigFactory._();
  
  /// Create a configuration for a cheap ELM327 adapter
  ///
  /// This configuration uses conservative settings optimized for
  /// unreliable, possibly counterfeit adapters.
  /// CRITICAL: These exact settings are required by the cheap adapter according to
  /// bluetooth-elm327-obd-do-not-modify-instruction.mdc and must not be changed.
  static AdapterConfig createCheapElm327Config() {
    _logger.info('Creating configuration for cheap ELM327 adapter');
    
    return AdapterConfig(
      profileId: 'cheap_elm327',
      name: 'Cheap ELM327 Adapter',
      description: 'Configuration for cheap, possibly counterfeit ELM327 adapters. '
          'Uses conservative settings for maximum compatibility with unreliable devices. '
          'The timing settings in this profile must not be modified as per project requirements.',
      
      // Bluetooth settings - must maintain exact UUIDs for compatibility
      serviceUuid: ObdConstants.serviceUuid,
      notifyCharacteristicUuid: ObdConstants.notifyCharacteristicUuid,
      writeCharacteristicUuid: ObdConstants.writeCharacteristicUuid,
      
      // Timing settings - CRITICAL VALUES - DO NOT MODIFY
      // These exact values are required for compatibility with the cheap adapter
      responseTimeoutMs: 300, // Critical value for cheap adapters
      connectionTimeoutMs: 10000, // Critical value for cheap adapters
      commandTimeoutMs: 4000, // Critical value for cheap adapters
      initCommandDelayMs: 300, // Critical value for cheap adapters
      resetDelayMs: 1000, // Critical value for cheap adapters
      
      // Polling intervals
      defaultPollingInterval: 2000, // Slower rate for cheap adapters
      slowPollingInterval: 3000, // Even slower for problematic conditions
      engineOffPollingInterval: 5000, // Very slow when engine is off
      
      // Error handling
      maxRetries: 2, // From original CheapElm327Profile
      
      // Behavior flags - CRITICAL VALUES - DO NOT MODIFY
      useExtendedInitDelays: true, // Critical flag for cheap adapters
      useLenientParsing: true, // Critical flag for cheap adapters
      
      // Protocol settings - CRITICAL VALUES - DO NOT MODIFY
      obdProtocol: 'ISO 14230-4', // KWP (5 baud init)
      baudRate: 10400, // 10.4 kbaud as per ATBRD10
    );
  }
  
  /// Create a configuration for a premium ELM327 adapter
  ///
  /// This configuration uses optimized settings for genuine
  /// or high-quality ELM327 adapters.
  static AdapterConfig createPremiumElm327Config() {
    _logger.info('Creating configuration for premium ELM327 adapter');
    
    return AdapterConfig(
      profileId: 'premium_elm327',
      name: 'Premium ELM327 Adapter',
      description: 'Configuration for genuine or high-quality ELM327 adapters. '
          'Uses optimized settings for better performance and faster response times.',
      
      // Bluetooth settings - keep same UUIDs for consistency
      serviceUuid: ObdConstants.serviceUuid,
      notifyCharacteristicUuid: ObdConstants.notifyCharacteristicUuid,
      writeCharacteristicUuid: ObdConstants.writeCharacteristicUuid,
      
      // Timing settings - optimized for genuine adapters
      // These values are significantly faster than the cheap adapter settings
      responseTimeoutMs: 100, // Faster response expected (was 150)
      connectionTimeoutMs: 6000, // Faster connection (was 8000)
      commandTimeoutMs: 1500, // Faster command timeout (was 2000) 
      initCommandDelayMs: 50, // Faster initialization (was 100)
      resetDelayMs: 300, // Shorter reset delay (was 500)
      
      // Polling intervals - faster for better real-time data
      defaultPollingInterval: 250, // Much faster polling possible with premium adapters (was 500)
      slowPollingInterval: 500, // Moderately slower for problematic conditions (was 1000)
      engineOffPollingInterval: 2000, // Slower when engine is off (was 3000)
      
      // Error handling - fewer retries needed for reliable adapters
      maxRetries: 1, // Premium adapters typically need fewer retries
      
      // Behavior flags - optimized for premium adapters
      useExtendedInitDelays: false, // No need for extended delays with premium adapters
      useLenientParsing: false, // Premium adapters provide properly formatted responses
      
      // Protocol settings - use same protocol for compatibility
      // but with more optimized timing parameters
      obdProtocol: 'ISO 14230-4', // KWP (5 baud init)
      baudRate: 10400, // 10.4 kbaud as per ATBRD10
    );
  }
  
  /// Create a configuration for an ELM327 v1.4 adapter
  ///
  /// This configuration is optimized for genuine ELM327 v1.4 adapters,
  /// which offer improved performance and stability over v1.3.
  static AdapterConfig createElm327V14Config() {
    _logger.info('Creating configuration for ELM327 v1.4 adapter');
    
    return AdapterConfig(
      profileId: 'elm327_v14',
      name: 'ELM327 v1.4 Adapter',
      description: 'Configuration for genuine ELM327 v1.4 adapters. '
          'These adapters offer better performance than v1.3 with improved '
          'stability and data processing capabilities.',
      
      // Bluetooth settings - keep same UUIDs for consistency
      serviceUuid: ObdConstants.serviceUuid,
      notifyCharacteristicUuid: ObdConstants.notifyCharacteristicUuid,
      writeCharacteristicUuid: ObdConstants.writeCharacteristicUuid,
      
      // Timing settings - optimized for v1.4 adapters
      responseTimeoutMs: 120, // Faster than cheap but more reliable than premium
      connectionTimeoutMs: 7000, // Balance between speed and reliability
      commandTimeoutMs: 2000, // Good balance for v1.4 adapters
      initCommandDelayMs: 75, // Slightly faster than cheap adapters
      resetDelayMs: 500, // Moderate reset delay
      
      // Polling intervals - optimized for v1.4 capabilities
      defaultPollingInterval: 350, // Faster than cheap, slower than premium
      slowPollingInterval: 750, // Moderate slowdown for problematic conditions
      engineOffPollingInterval: 2500, // Reasonable interval when engine is off
      
      // Error handling - balanced approach
      maxRetries: 2, // V1.4 adapters benefit from retries but fewer than cheap adapters
      
      // Behavior flags - optimized for v1.4 capabilities
      useExtendedInitDelays: false, // v1.4 adapters don't need extended delays
      useLenientParsing: false, // v1.4 adapters provide properly formatted responses
      
      // Protocol settings - use same protocol for compatibility
      obdProtocol: 'ISO 14230-4', // KWP (5 baud init)
      baudRate: 10400, // 10.4 kbaud as per ATBRD10
    );
  }
  
  /// Create a configuration for an ELM327 v2.0 adapter
  ///
  /// This configuration is optimized for genuine ELM327 v2.0+ adapters,
  /// which offer maximum performance and advanced features.
  static AdapterConfig createElm327V20Config() {
    _logger.info('Creating configuration for ELM327 v2.0 adapter');
    
    return AdapterConfig(
      profileId: 'elm327_v20',
      name: 'ELM327 v2.0+ Adapter',
      description: 'Configuration for genuine ELM327 v2.0 and newer adapters. '
          'These adapters offer maximum performance with advanced features like '
          'message filtering, better timing, and improved reliability.',
      
      // Bluetooth settings - keep same UUIDs for consistency
      serviceUuid: ObdConstants.serviceUuid,
      notifyCharacteristicUuid: ObdConstants.notifyCharacteristicUuid,
      writeCharacteristicUuid: ObdConstants.writeCharacteristicUuid,
      
      // Timing settings - optimized for v2.0 adapters (fastest possible)
      responseTimeoutMs: 80, // V2.0 adapters are very responsive
      connectionTimeoutMs: 5000, // Fast connection for modern adapters
      commandTimeoutMs: 1200, // Very responsive command handling
      initCommandDelayMs: 40, // Minimal delay needed
      resetDelayMs: 250, // Shorter reset delay for modern adapters
      
      // Polling intervals - optimized for v2.0 capabilities (maximum speed)
      defaultPollingInterval: 200, // Very fast polling for real-time data
      slowPollingInterval: 400, // Moderately slower for problematic conditions
      engineOffPollingInterval: 1500, // Faster checking even when engine is off
      
      // Error handling - minimal retries for reliable adapters
      maxRetries: 1, // V2.0 adapters rarely need retries
      
      // Behavior flags - optimized for v2.0 capabilities
      useExtendedInitDelays: false, // V2.0 adapters don't need extended delays
      useLenientParsing: false, // V2.0 adapters provide properly formatted responses
      
      // Protocol settings - use CAN protocol by default for v2.0 adapters
      obdProtocol: 'ISO 15765-4', // CAN (11/500)
      baudRate: 38400, // Higher baud rate for v2.0 adapters
    );
  }
  
  /// Create a configuration for an ELM327 v1.3 adapter
  ///
  /// This configuration is optimized for genuine ELM327 v1.3 adapters,
  /// which are older but still capable units.
  static AdapterConfig createElm327V13Config() {
    _logger.info('Creating configuration for ELM327 v1.3 adapter');
    
    return AdapterConfig(
      profileId: 'elm327_v13',
      name: 'ELM327 v1.3 Adapter',
      description: 'Configuration for genuine ELM327 v1.3 adapters. '
          'These are older adapters with decent performance but lacking '
          'some of the newer features and optimizations.',
      
      // Bluetooth settings - keep same UUIDs for consistency
      serviceUuid: ObdConstants.serviceUuid,
      notifyCharacteristicUuid: ObdConstants.notifyCharacteristicUuid,
      writeCharacteristicUuid: ObdConstants.writeCharacteristicUuid,
      
      // Timing settings - conservative for v1.3 limitations
      responseTimeoutMs: 150, // Moderate timeout for older adapters
      connectionTimeoutMs: 8000, // Longer connection time for older hardware
      commandTimeoutMs: 2500, // More time for command processing
      initCommandDelayMs: 100, // More delay between initialization commands
      resetDelayMs: 700, // Longer reset for older hardware
      
      // Polling intervals - balanced for v1.3 capabilities
      defaultPollingInterval: 500, // Moderate polling interval
      slowPollingInterval: 1000, // Slower for problematic conditions
      engineOffPollingInterval: 3000, // Conservative when engine is off
      
      // Error handling - more retries for older hardware
      maxRetries: 2, // V1.3 adapters benefit from retries
      
      // Behavior flags - balanced for v1.3 capabilities
      useExtendedInitDelays: true, // V1.3 benefits from extended delays
      useLenientParsing: false, // V1.3 adapters provide formatted responses
      
      // Protocol settings - use same protocol for compatibility
      obdProtocol: 'ISO 14230-4', // KWP (5 baud init)
      baudRate: 10400, // 10.4 kbaud as per ATBRD10
    );
  }
  
  /// Create a configuration based on adapter profile ID
  ///
  /// This method returns a configuration matching the given profile ID.
  /// If no matching profile is found, it defaults to the cheap adapter
  /// configuration for maximum compatibility.
  static AdapterConfig createConfig(String profileId) {
    _logger.info('Creating configuration for profile: $profileId');
    
    switch (profileId.toLowerCase()) {
      case 'premium_elm327':
        return createPremiumElm327Config();
      case 'elm327_v13':
        return createElm327V13Config();
      case 'elm327_v14':
        return createElm327V14Config();
      case 'elm327_v20':
        return createElm327V20Config();
      case 'cheap_elm327':
      default:
        // Default to cheap adapter for maximum compatibility
        return createCheapElm327Config();
    }
  }
  
  /// Create a dynamic configuration based on observed adapter behavior
  ///
  /// This method creates a configuration that starts with conservative
  /// settings and can be dynamically adjusted based on adapter performance.
  static AdapterConfig createDynamicConfig() {
    _logger.info('Creating dynamic adapter configuration');
    
    // Start with cheap adapter configuration for maximum compatibility
    final config = createCheapElm327Config();
    
    // Clone and modify to add dynamic behavior flags
    return config.copyWith(
      profileId: 'dynamic_elm327',
      name: 'Dynamic ELM327 Adapter',
      description: 'Dynamic configuration that adjusts based on adapter behavior. '
          'Starts with conservative settings and optimizes if possible.',
    );
  }
} 

################################################################################
FILE: lib/obd_lib/protocol/obd_commands.dart
################################################################################

import '../models/obd_command.dart';
import 'obd_constants.dart';

/// Provides standard OBD-II commands
class ObdCommands {
  // Private constructor to prevent instantiation
  ObdCommands._();
  
  /// Get supported PIDs 01-20
  static final supportedPids = ObdCommand.mode01(
    ObdConstants.pidSupportedPids,
    name: 'Supported PIDs',
    description: 'PIDs supported [01-20]',
  );
  
  /// Get engine coolant temperature
  static final coolantTemperature = ObdCommand.mode01(
    ObdConstants.pidCoolantTemp,
    name: 'Coolant Temperature',
    description: 'Engine coolant temperature',
  );
  
  /// Get engine RPM
  static final engineRpm = ObdCommand.mode01(
    ObdConstants.pidEngineRpm,
    name: 'Engine RPM',
    description: 'Engine revolutions per minute',
  );
  
  /// Get vehicle speed
  static final vehicleSpeed = ObdCommand.mode01(
    ObdConstants.pidVehicleSpeed,
    name: 'Vehicle Speed',
    description: 'Vehicle speed in km/h',
  );
  
  /// Get control module voltage
  static final controlModuleVoltage = ObdCommand.mode01(
    ObdConstants.pidControlModuleVoltage,
    name: 'Control Module Voltage',
    description: 'Control module voltage',
  );
  
  /// ATZ - Reset the ELM327
  static final reset = ObdCommand(
    mode: 'AT',
    pid: 'Z',
    name: 'Reset',
    description: 'Reset the ELM327 adapter',
  );
  
  /// ATE0 - Turn echo off
  static final echoOff = ObdCommand(
    mode: 'AT',
    pid: 'E0',
    name: 'Echo Off',
    description: 'Turn command echo off',
  );
  
  /// ATH0 - Turn headers off
  static final headersOff = ObdCommand(
    mode: 'AT',
    pid: 'H0',
    name: 'Headers Off',
    description: 'Turn headers off',
  );
  
  /// ATL0 - Turn linefeeds off
  static final linebreaksOff = ObdCommand(
    mode: 'AT',
    pid: 'L0',
    name: 'Linefeeds Off',
    description: 'Turn linefeeds off',
  );
  
  /// ATSP4 - Set protocol to ISO 14230-4 KWP (5 baud init)
  static final setProtocol = ObdCommand(
    mode: 'AT',
    pid: 'SP4',
    name: 'Set Protocol',
    description: 'Set protocol to ISO 14230-4 KWP (5 baud init)',
  );
  
  /// ATBRD10 - Set baud rate divisor to 10.4 kbaud
  static final setBaudRate = ObdCommand(
    mode: 'AT',
    pid: 'BRD10',
    name: 'Set Baud Rate',
    description: 'Set baud rate to 10.4 kbaud',
  );
  
  /// ATST20 - Set timeout to 200ms
  static final setTimeout = ObdCommand(
    mode: 'AT',
    pid: 'ST20',
    name: 'Set Timeout',
    description: 'Set timeout to 200ms (20 x 10ms)',
  );
  
  /// Get a list of all standard commands
  static List<ObdCommand> get allCommands => [
    supportedPids,
    coolantTemperature,
    engineRpm,
    vehicleSpeed,
    controlModuleVoltage,
  ];
  
  /// Get a list of initialization commands in the correct order
  static List<ObdCommand> get initializationCommands => [
    reset,
    echoOff,
    headersOff,
    linebreaksOff,
    setProtocol,
    setBaudRate,
    setTimeout,
    supportedPids,
  ];
} 

################################################################################
FILE: lib/obd_lib/protocol/elm327_protocol.dart
################################################################################

import 'dart:async';
import 'dart:math';
import 'package:logging/logging.dart';
import '../interfaces/obd_connection.dart';
import 'obd_protocol.dart';
import '../models/obd_command.dart';
import '../models/obd_data.dart';
import '../models/adapter_config.dart';
import '../models/adapter_config_factory.dart';
import '../models/adapter_config_validator.dart';
import 'obd_constants.dart';
import 'obd_commands.dart';
import 'response_processor/obd_response_processor.dart';
import 'response_processor/processor_factory.dart';
import '../profiles/profile_manager.dart';

/// Helper class for command completion with timeout
class CompleterWithTimeout {
  final Completer<String> completer;
  final Timer timer;
  
  CompleterWithTimeout(this.completer, this.timer);
  
  void complete(String value) {
    if (!completer.isCompleted) {
      completer.complete(value);
    }
  }
  
  void completeError(Object error, [StackTrace? stackTrace]) {
    if (!completer.isCompleted) {
      completer.completeError(error, stackTrace);
    }
  }
  
  void cancel() {
    timer.cancel();
  }
}

/// Unified protocol implementation for all ELM327 adapters
///
/// This class implements the ObdProtocol interface for ELM327 adapters
/// with configuration-driven behavior to support both cheap and premium adapters.
class Elm327Protocol implements ObdProtocol {
  static final Logger _logger = Logger('Elm327Protocol');
  
  /// The underlying connection to the ELM327 adapter
  final ObdConnection connection;
  
  /// The response processor to use for this adapter
  final ObdResponseProcessor responseProcessor;
  
  /// The adapter configuration to use
  final AdapterConfig config;
  
  /// Optional reference to the profile manager for reporting performance metrics
  final ProfileManager? profileManager;
  
  /// Device ID for performance reporting
  final String? deviceId;
  
  /// Configuration validator for runtime monitoring
  final AdapterConfigValidator _configValidator = AdapterConfigValidator();
  
  /// Whether the protocol has been initialized
  bool _isInitialized = false;
  
  /// Whether the protocol is currently connecting
  bool _isConnecting = false;
  
  /// Error message if initialization fails
  String? _errorMessage;
  
  /// Stream controller for decoded OBD data
  final _dataStreamController = StreamController<ObdData>.broadcast();
  
  /// Subscription to the connection's data stream
  StreamSubscription? _connectionSubscription;
  
  /// Debug mode flag
  final bool _isDebugMode;
  
  /// Map to store expected response PIDs
  final Map<String, CompleterWithTimeout> _pendingCommands = {};
  
  /// Currently executing command
  ObdCommand? _currentCommand;
  
  /// Command queue
  final List<ObdCommand> _commandQueue = [];
  
  /// Flag to track if we're currently processing a command
  bool _processingCommand = false;
  
  /// Map to track retried commands and their retry count
  final Map<String, int> _commandRetries = {};
  
  /// Maps to track consecutive identical responses and their timestamps
  final Map<String, String> _lastResponses = {};
  final Map<String, DateTime> _lastResponseTimes = {};
  final Map<String, int> _identicalResponseCounts = {};
  static const int _maxIdenticalResponses = 3;
  
  /// Track recent RPM values to detect acceleration
  final List<int> _lastRpmValues = [];
  final int _maxRpmHistorySize = 3;
  
  /// Track recent speed values to detect anomalies
  final List<int> _lastSpeedValues = [];
  final int _maxSpeedHistorySize = 5;
  
  /// Creates a new ELM327 protocol handler
  /// 
  /// This constructor now handles both cheap and premium adapter types through configuration.
  /// The behavior is driven by the provided adapter configuration rather than subclassing.
  Elm327Protocol(
    this.connection, 
    {
      bool isDebugMode = false,
      String adapterProfile = 'cheap_elm327',
      ObdResponseProcessor? customResponseProcessor,
      AdapterConfig? adapterConfig,
      this.profileManager,
      this.deviceId,
    }) 
    : _isDebugMode = isDebugMode,
      responseProcessor = customResponseProcessor ?? ResponseProcessorFactory.createProcessor(
        adapterProfile,
        (adapterConfig ?? AdapterConfigFactory.createConfig(adapterProfile)).useLenientParsing,
      ),
      config = adapterConfig ?? AdapterConfigFactory.createConfig(adapterProfile) {
    _setupDataStream();
    _logger.info('Created ELM327 protocol handler with profile: ${config.profileId}');
    _logger.info('Using response processor: ${responseProcessor.runtimeType}');
    
    // Log critical configuration values for debugging
    _logger.info('Adapter config: useExtendedInitDelays=${config.useExtendedInitDelays}, '
        'useLenientParsing=${config.useLenientParsing}, '
        'responseTimeout=${config.responseTimeoutMs}ms, '
        'commandTimeout=${config.commandTimeoutMs}ms');
  }
  
  @override
  Stream<ObdData> get obdDataStream => _dataStreamController.stream;
  
  @override
  Stream<String> get dataStream => connection.dataStream;
  
  @override
  bool get isInitialized => _isInitialized;
  
  @override
  bool get isConnected => connection.isConnected;
  
  @override
  bool get isConnecting => _isConnecting;
  
  @override
  String? get errorMessage => _errorMessage;
  
  /// Sets up the data stream from the connection
  void _setupDataStream() {
    _connectionSubscription = connection.dataStream.listen((response) {
      if (_isDebugMode) {
        _logger.fine('Raw response: $response');
      }
      
      // Ignore empty responses and connection status messages
      if (response.isEmpty || 
          response == 'SEARCHING...' || 
          response == 'CONNECTED' || 
          response == 'DISCONNECTED') {
        return;
      }
      
      // Handle the response
      _handleResponse(response);
      
      // Log the received response
      _logger.info('Received: $response');
    });
  }
  
  /// Handle a response from the adapter
  void _handleResponse(String response) {
    // Check for "NO DATA" or "ERROR" messages
    if (response.contains('NO DATA') || response.contains('ERROR')) {
      _logger.warning('Error response: $response');
      
      if (_currentCommand != null) {
        final command = _currentCommand!.command;
        if (_pendingCommands.containsKey(command)) {
          // Check if we should retry
          final retryCount = _commandRetries[command] ?? 0;
          
          if (retryCount < config.maxRetries) {
            // Retry the command
            _logger.info('Retrying command: $command (attempt ${retryCount + 1}/${config.maxRetries})');
            _commandRetries[command] = retryCount + 1;
            _commandQueue.insert(0, _currentCommand!);
            _pendingCommands[command]?.cancel();
            _pendingCommands.remove(command);
          } else {
            // Max retries reached, complete with error
            _logger.warning('Max retries reached for command: $command');
            _pendingCommands[command]?.complete('ERROR');
            _pendingCommands.remove(command);
          }
        }
        
        _currentCommand = null;
        _processingCommand = false;
        
        // Process next command in queue
        Timer(Duration(milliseconds: 100), _processNextCommand);
        return;
      }
    }
    
    // Handle standard responses
    if (_currentCommand != null) {
      final command = _currentCommand!.command;
      
      // Check if this response is for the current command
      if (_pendingCommands.containsKey(command)) {
        // Check for stale or duplicate responses
        final lastResponse = _lastResponses[command];
        final now = DateTime.now();
        
        if (lastResponse == response) {
          // Identical response, increment counter
          _identicalResponseCounts[command] = (_identicalResponseCounts[command] ?? 0) + 1;
          _logger.fine('Identical response for $command: count = ${_identicalResponseCounts[command]}');
          
          // If we've seen too many identical responses, log a warning
          if (_identicalResponseCounts[command]! >= _maxIdenticalResponses) {
            _logger.warning('Too many identical responses for $command: $response');
            
            // For critical commands like RPM, attempt recovery
            if (_currentCommand!.pid == ObdConstants.pidEngineRpm || 
                _currentCommand!.pid == ObdConstants.pidVehicleSpeed) {
              _logger.info('Attempting recovery for important PID: ${_currentCommand!.pid}');
              
              // Reset the counter but continue with this response
              _identicalResponseCounts[command] = 0;
            }
          }
        } else {
          // New response, reset counter
          _identicalResponseCounts[command] = 0;
          _lastResponses[command] = response;
        }
        
        // Track response time for this command
        _lastResponseTimes[command] = now;
        
        // Complete the pending command
        _pendingCommands[command]?.complete(response);
        _pendingCommands.remove(command);
        
        // Reset retry counter on success
        _commandRetries.remove(command);
        
        // Process the data for OBD commands
        if (_currentCommand!.mode == '01') {
          // Process the response to get OBD data
          var data = _processResponseWithValidation(response, _currentCommand!);
          
          if (data != null) {
            // Only add valid data to the stream
            _dataStreamController.add(data);
          }
        }
        
        _currentCommand = null;
        _processingCommand = false;
        
        // Process next command in queue
        Timer(Duration(milliseconds: 100), _processNextCommand);
      }
    }
  }
  
  /// Process the next command in the queue
  Future<void> _processNextCommand() async {
    if (_processingCommand || _commandQueue.isEmpty) {
      return;
    }
    
    _processingCommand = true;
    
    // Prioritize commands in the queue to favor critical values like RPM and speed
    _prioritizeCommandQueue();
    
    final command = _commandQueue.removeAt(0);
    _currentCommand = command;
    
    // Send the command
    await connection.sendCommand(command.command);
  }
  
  /// Prioritize commands in the queue to favor critical values like RPM and speed
  void _prioritizeCommandQueue() {
    if (_commandQueue.isEmpty) return;
    
    // Define critical PIDs to prioritize
    final criticalPids = [ObdConstants.pidEngineRpm, ObdConstants.pidVehicleSpeed];
    
    // Define a second tier of important but non-critical PIDs
    final secondaryPids = [ObdConstants.pidThrottlePosition, ObdConstants.pidEngineLoad];
    
    // Enhanced prioritization algorithm
    // 1. First pass - move critical PIDs to front of queue
    bool movedCritical = false;
    for (int i = 0; i < _commandQueue.length; i++) {
      final command = _commandQueue[i];
      
      // If it's a mode 01 command and has a critical PID
      if (command.mode == '01' && criticalPids.contains(command.pid)) {
        // If it's not already at the front of the queue, move it there
        if (i > 0) {
          _commandQueue.removeAt(i);
          _commandQueue.insert(0, command);
          _logger.fine('Prioritized critical command for PID: ${command.pid}');
          movedCritical = true;
          break; // Only move one command per pass to avoid continuous shuffling
        }
      }
    }
    
    // 2. Second pass - if we didn't move any critical PIDs, try secondary PIDs
    if (!movedCritical) {
      for (int i = 0; i < _commandQueue.length; i++) {
        final command = _commandQueue[i];
        
        // If it's a mode 01 command and has a secondary important PID
        if (command.mode == '01' && secondaryPids.contains(command.pid)) {
          // If it's not already near the front of the queue, move it forward
          if (i > 1) { // Keep at least one spot for critical PIDs
            _commandQueue.removeAt(i);
            _commandQueue.insert(1, command); // Insert after the first item
            _logger.fine('Prioritized secondary command for PID: ${command.pid}');
            break;
          }
        }
      }
    }
    
    // 3. Special handling for throttle position - if engine is accelerating
    // In this case, throttle becomes critical for UI responsiveness
    bool isAccelerating = false;
    
    // Check if RPM is increasing which indicates acceleration
    if (_lastRpmValues.length >= 2) {
      final latestRpm = _lastRpmValues.last;
      final previousRpm = _lastRpmValues[_lastRpmValues.length - 2];
      
      if (latestRpm > previousRpm && latestRpm - previousRpm > 100) {
        isAccelerating = true;
        _logger.fine('Detected acceleration: RPM change from $previousRpm to $latestRpm');
      }
    }
    
    // If accelerating, prioritize throttle position
    if (isAccelerating) {
      for (int i = 0; i < _commandQueue.length; i++) {
        final command = _commandQueue[i];
        
        if (command.mode == '01' && command.pid == ObdConstants.pidThrottlePosition) {
          if (i > 1) { // Keep RPM and speed at front if possible
            _commandQueue.removeAt(i);
            _commandQueue.insert(min(2, _commandQueue.length), command);
            _logger.fine('Prioritized throttle position during acceleration');
          }
          break;
        }
      }
    }
  }
  
  /// Process the response to get OBD data with improved validation
  ObdData? _processResponseWithValidation(String response, ObdCommand command) {
    // Add diagnostic logging for critical PIDs (ADDED)
    if (command.pid == ObdConstants.pidVehicleSpeed || command.pid == ObdConstants.pidEngineRpm) {
      _logDetailedDiagnostics(response, command);
    }
    
    // Process the response to get OBD data
    var data = responseProcessor.processResponse(response, command);
    
    if (data != null) {
      // Apply additional validation based on PID
      if (command.pid == ObdConstants.pidEngineRpm) {
        data = _validateRpmReading(data, response);
        
        // Store valid RPM reading in history for acceleration detection
        if (data != null && data.value is num) {
          final rpm = (data.value as num).toInt();
          _lastRpmValues.add(rpm);
          
          // Keep history at max size
          if (_lastRpmValues.length > _maxRpmHistorySize) {
            _lastRpmValues.removeAt(0);
          }
        }
      } else if (command.pid == ObdConstants.pidVehicleSpeed) {
        data = _validateSpeedReading(data, response);
        
        // Store valid speed reading in history for anomaly detection
        if (data != null && data.value is num) {
          final speed = (data.value as num).toInt();
          _lastSpeedValues.add(speed);
          
          // Keep history at max size
          if (_lastSpeedValues.length > _maxSpeedHistorySize) {
            _lastSpeedValues.removeAt(0);
          }
        }
      } else if (command.pid == ObdConstants.pidThrottlePosition) {
        data = _validateThrottleReading(data, response);
      }
    }
    
    return data;
  }
  
  /// Validate RPM readings to prevent false readings
  /// 
  /// This method detects and corrects known issues with RPM readings:
  /// 1. Premium adapters sometimes return a fixed value (59 RPM) when the engine is off
  /// 2. Some adapters return very low values (1-20 RPM) which aren't physically possible
  /// 3. Cheap adapters might return stale values that need verification
  /// 
  /// Returns null if the reading is determined to be invalid
  ObdData? _validateRpmReading(ObdData data, String rawResponse) {
    // UPDATED: Since we're having OBD issues, this function is modified to pass through
    // all RPM values without restrictive validation to see the raw data coming from the adapter
    
    // Log the raw RPM data for debugging
    _logger.info('Raw RPM data: value=${data.value}, rawBytes=${data.rawData}');
    
    // Extract the RPM value for logging only
    dynamic rpmValue = data.value;
    int rpm = 0;
    
    // Convert to integer just for logging
    if (rpmValue is int) {
      rpm = rpmValue;
    } else if (rpmValue is double) {
      rpm = rpmValue.toInt();
    } else if (rpmValue is String) {
      try {
        rpm = int.parse(rpmValue);
      } catch (e) {
        _logger.warning('Non-integer RPM value: $rpmValue');
      }
    }
    
    // Log the raw response for debugging
    _logger.info('Raw RPM response: "$rawResponse" -> $rpm RPM');
    
    // Return data without validation
    return data.copyWith(timestamp: DateTime.now());
  }
  
  /// Validate speed readings to eliminate erroneous values and reduce lag
  /// 
  /// UPDATED: Made less strict to troubleshoot issues
  ObdData? _validateSpeedReading(ObdData data, String rawResponse) {
    // Log the raw speed data for debugging
    _logger.info('Raw speed data: value=${data.value}, rawBytes=${data.rawData}');
    
    // Extract the speed value for logging only
    dynamic speedValue = data.value;
    int speed = 0;
    
    // Convert to integer just for logging
    if (speedValue is int) {
      speed = speedValue;
    } else if (speedValue is double) {
      speed = speedValue.toInt();
    } else if (speedValue is String) {
      try {
        speed = int.parse(speedValue);
      } catch (e) {
        _logger.warning('Non-integer speed value: $speedValue');
      }
    }
    
    // Log the raw response for debugging
    _logger.info('Raw speed response: "$rawResponse" -> $speed km/h');
    
    // Return data without validation
    return data.copyWith(timestamp: DateTime.now());
  }
  
  /// Validate throttle position readings to filter out anomalous values
  ///
  /// This method checks for physically impossible values or data errors:
  /// 1. Throttle position should be between 0-100%
  /// 2. Some cheap adapters can return erroneous high values
  /// 3. Throttle values sometimes need interpretation depending on the protocol
  ///
  /// Returns null if the reading is determined to be invalid
  ObdData? _validateThrottleReading(ObdData data, String rawResponse) {
    // Extract the throttle value
    dynamic throttleValue = data.value;
    
    if (throttleValue == null) {
      return null;
    }
    
    // Convert to double for easier validation
    double throttle;
    if (throttleValue is int) {
      throttle = throttleValue.toDouble();
    } else if (throttleValue is double) {
      throttle = throttleValue;
    } else if (throttleValue is String) {
      try {
        throttle = double.parse(throttleValue);
      } catch (e) {
        _logger.warning('Invalid throttle value format: $throttleValue');
        return null;
      }
    } else {
      _logger.warning('Unknown throttle value type: ${throttleValue.runtimeType}');
      return null;
    }
    
    // Check for physically impossible values
    // Throttle should be 0-100%
    if (throttle < 0 || throttle > 100) {
      _logger.warning('Ignoring invalid throttle reading: $throttle% (must be 0-100%)');
      return null;
    }
    
    // Some adapters return raw voltage values instead of percentages
    // Raw voltage would typically be between 0-5V
    if (throttle <= 5.0 && rawResponse.toLowerCase().contains('41 11')) {
      // Convert from voltage to percentage (assuming 5V = 100%)
      _logger.info('Converting throttle from voltage ($throttle V) to percentage');
      throttle = (throttle / 5.0) * 100.0;
      
      // Create a new data object with the corrected value
      return ObdData(
        mode: data.mode,
        pid: data.pid,
        rawData: data.rawData,
        name: data.name,
        value: throttle,
        unit: '%',
        timestamp: DateTime.now(),
      );
    }
    
    // Always return a fresh instance with updated timestamp
    return data.copyWith(timestamp: DateTime.now());
  }
  
  @override
  Future<String> sendCommand(String command) async {
    if (!connection.isConnected) {
      _logger.warning('Cannot send command: not connected');
      return '';
    }
    
    final completer = Completer<String>();
    
    // Create a timer to handle timeout
    final timer = Timer(Duration(milliseconds: config.commandTimeoutMs), () {
      if (!completer.isCompleted) {
        _logger.warning('Command timeout: $command');
        completer.complete('TIMEOUT');
        _pendingCommands.remove(command);
        _processingCommand = false;
        _currentCommand = null;
        
        // Process next command in queue
        Timer(Duration(milliseconds: 100), _processNextCommand);
      }
    });
    
    // Store the completer and timer
    _pendingCommands[command] = CompleterWithTimeout(completer, timer);
    
    // Add the command to the queue
    _commandQueue.add(ObdCommand(
      mode: 'AT',
      pid: command.substring(2),
      name: 'Custom Command',
      description: 'Custom command: $command',
    ));
    
    // Process the command queue
    _processNextCommand();
    
    // Wait for the result
    return await completer.future;
  }
  
  @override
  Future<String> sendObdCommand(ObdCommand command) async {
    if (!connection.isConnected) {
      _logger.warning('Cannot send OBD command: not connected');
      return '';
    }
    
    if (!_isInitialized && command != ObdCommands.reset) {
      _logger.warning('Protocol not initialized, initializing now...');
      await initialize();
    }
    
    final completer = Completer<String>();
    
    // Create a timer to handle timeout
    final timer = Timer(Duration(milliseconds: config.commandTimeoutMs), () {
      if (!completer.isCompleted) {
        _logger.warning('Command timeout: ${command.command}');
        completer.complete('TIMEOUT');
        _pendingCommands.remove(command.command);
        _processingCommand = false;
        _currentCommand = null;
        
        // Process next command in queue
        Timer(Duration(milliseconds: 100), _processNextCommand);
      }
    });
    
    // Store the completer and timer
    _pendingCommands[command.command] = CompleterWithTimeout(completer, timer);
    
    // Add the command to the queue
    _commandQueue.add(command);
    
    // Process the command queue
    _processNextCommand();
    
    // Wait for the result
    return await completer.future;
  }
  
  @override
  Future<ObdData?> requestPid(String pid) async {
    if (!connection.isConnected) {
      _logger.warning('Cannot request PID: not connected');
      return null;
    }
    
    if (!_isInitialized) {
      _logger.warning('Protocol not initialized, initializing now...');
      await initialize();
    }
    
    try {
      final command = ObdCommand.mode01(
        pid,
        name: 'PID Request',
        description: 'Request for PID $pid',
      );
      
      final response = await sendObdCommand(command);
      final data = responseProcessor.processResponse(response, command);
      
      // Add special validation for different PIDs
      if (data != null) {
        if (pid == ObdConstants.pidVehicleSpeed) {
          return _validateSpeedReading(data, response);
        } else if (pid == ObdConstants.pidThrottlePosition) {
          return _validateThrottleReading(data, response);
        }
      }
      
      return data;
    } catch (e) {
      _logger.severe('Error requesting PID $pid: $e');
      return null;
    }
  }
  
  @override
  Future<Map<String, ObdData>> requestPids(List<String> pids) async {
    final results = <String, ObdData>{};
    
    for (final pid in pids) {
      final data = await requestPid(pid);
      if (data != null) {
        results[pid] = data;
      }
    }
    
    return results;
  }
  
  /// Execute an OBD command and return the result
  @override
  Future<String> executeCommand(ObdCommand command) async {
    if (!_isInitialized) {
      throw Exception('Protocol not initialized');
    }

    _currentCommand = command;
    
    // Start tracking the command execution time
    final startTime = DateTime.now().millisecondsSinceEpoch;
    String result = '';
    bool isSuccess = false;
    bool isTimeout = false;
    
    try {
      // Use the existing sendObdCommand method
      result = await sendObdCommand(command);
      isSuccess = true;
    } catch (e) {
      _logger.warning('Error executing command ${command.command}: $e');
      
      // Check if the error was a timeout
      isTimeout = e.toString().contains('timeout');
      
      rethrow;
    } finally {
      // Calculate execution time
      final endTime = DateTime.now().millisecondsSinceEpoch;
      final executionTime = endTime - startTime;
      
      // Record command performance metrics
      _recordCommandMetrics(command, isSuccess, executionTime, isTimeout);
      
      // Report to profile manager if available - fix null safety issues
      if (profileManager != null && deviceId != null) {
        if (isSuccess) {
          profileManager?.reportCommandSuccess(deviceId!, config.profileId);
        } else {
          profileManager?.reportCommandFailure(deviceId!, config.profileId);
        }
      }
    }
    
    return result;
  }
  
  /// Record metrics about command execution
  void _recordCommandMetrics(ObdCommand command, bool isSuccess, int executionTime, bool isTimeout) {
    if (deviceId == null) return;
    
    // Estimate response time based on command execution time
    // This is a rough estimate and will be more accurate with real timing data
    final estimatedResponseTime = executionTime ~/ 2;
    
    // Record metrics for this command execution
    _configValidator.recordRuntimeMetrics(deviceId!, config, {
      'success': isSuccess,
      'timeout': isTimeout,
      'responseTime': estimatedResponseTime,
      'commandDuration': executionTime,
      'command': command.command,
    });
    
    // Log performance data for debugging
    if (_isDebugMode) {
      _logger.fine('Command ${command.command} executed in ${executionTime}ms');
      if (isTimeout) {
        _logger.warning('Command ${command.command} timed out');
      }
    }
    
    // If we have a profile manager and device ID, check if we need to adjust the config
    if (profileManager != null && deviceId != null) {
      final stats = _configValidator.getRuntimeStatistics(deviceId!, config.profileId);
      
      if (stats != null) {
        final commandCount = stats['commandCount'] as int;
        final successRate = stats['successRate'] as double;
        
        // If we have enough data and success rate is problematic, log a warning
        if (commandCount >= 20 && successRate < 0.7) {
          _logger.warning('Low success rate (${(successRate * 100).toStringAsFixed(1)}%) '
                        'detected for adapter ${config.profileId}');
          
          // Try to get an optimized configuration based on runtime metrics
          final optimizedConfig = _configValidator.calculateOptimizedConfig(deviceId!, config.profileId);
          
          if (optimizedConfig != null) {
            _logger.info('Optimized configuration available for device: $deviceId');
          }
        }
      }
    }
  }
  
  /// Initialize the protocol
  @override
  Future<bool> initialize() async {
    if (_isInitialized) {
      return true;
    }
    
    if (_isConnecting) {
      return false;
    }
    
    _isConnecting = true;
    
    try {
      // Validate configuration before using it
      final validationResult = _configValidator.validateConfig(config);
      
      if (!validationResult['isValid']) {
        final issues = validationResult['issues'] as List<String>;
        _errorMessage = 'Invalid adapter configuration: ${issues.join(', ')}';
        _logger.severe(_errorMessage);
        return false;
      }
      
      // Use the validated configuration (which might have been adjusted)
      final validatedConfig = validationResult['config'] as AdapterConfig;
      
      // Handle different initialization procedures based on adapter configuration
      try {
        bool initialized;
        
        // Select initialization method based on configuration
        if (validatedConfig.useExtendedInitDelays) {
          _logger.info('Using extended initialization for cheap adapter');
          initialized = await _initializeWithExtendedDelays();
        } else {
          _logger.info('Using standard initialization for premium adapter');
          initialized = await _initializeWithStandardDelays();
        }
        
        if (initialized) {
          _logger.info('Protocol initialized successfully');
          _isInitialized = true;
          _isConnecting = false;
          return true;
        } else {
          _logger.severe('Failed to initialize protocol');
          _errorMessage = 'Failed to initialize protocol';
          
          // Report initialization failure to profile manager
          if (profileManager != null && deviceId != null) {
            profileManager!.reportCommandFailure(deviceId!, config.profileId);
          }
          
          return false;
        }
      } catch (e) {
        _logger.severe('Error initializing protocol: $e');
        _errorMessage = 'Error initializing protocol: $e';
        
        // Report initialization failure to profile manager
        if (profileManager != null && deviceId != null) {
          profileManager!.reportCommandFailure(deviceId!, config.profileId);
        }
        
        return false;
      }
    } catch (e) {
      _errorMessage = 'Initialization failed: $e';
      _logger.severe(_errorMessage);
      _isConnecting = false;
      return false;
    }
  }
  
  /// Initialize with standard delays for premium adapters
  Future<bool> _initializeWithStandardDelays() async {
    _logger.info('Using standard initialization delays');
    
    // Send initialization commands with standard delays
    for (final command in ObdCommands.initializationCommands) {
      _logger.fine('Sending init command: ${command.command}');
      
      try {
        final response = await sendCommandWithTimeout(
          command, 
          timeoutMs: config.commandTimeoutMs,
        );
        
        _logger.fine('Init command response: $response');
        
        // Standard delays between commands
        if (command == ObdCommands.reset) {
          await Future.delayed(Duration(milliseconds: config.resetDelayMs));
        } else {
          await Future.delayed(Duration(milliseconds: config.initCommandDelayMs));
        }
      } catch (e) {
        _logger.warning('Init command failed: ${command.command}', e);
        // Continue with other commands even if one fails
      }
    }
    
    _isInitialized = true;
    return true;
  }
  
  /// Initialize with extended delays for cheap adapters
  ///
  /// This method uses longer delays to ensure reliable initialization 
  /// with cheap or counterfeit adapters.
  Future<bool> _initializeWithExtendedDelays() async {
    _logger.info('Using extended initialization delays for cheap adapter');
    
    // First check if the connection is actually established
    if (!connection.isConnected) {
      _logger.severe('Cannot initialize protocol: connection not established');
      return false;
    }
    
    // Add a larger delay to ensure connection is fully ready for cheap adapters
    await Future.delayed(Duration(milliseconds: 1000));
    
    // Send initialization commands with longer delays
    for (final command in ObdCommands.initializationCommands) {
      _logger.fine('Sending init command: ${command.command}');
      
      try {
        final response = await sendCommandWithTimeout(
          command, 
          timeoutMs: config.commandTimeoutMs + 1000, // Add 1 second for cheap adapters
        );
        
        _logger.fine('Init command response: $response');
        
        // Extended delays for cheap adapters
        if (command == ObdCommands.reset) {
          await Future.delayed(Duration(milliseconds: config.resetDelayMs * 2));
        } else {
          await Future.delayed(Duration(milliseconds: config.initCommandDelayMs * 2));
        }
      } catch (e) {
        _logger.warning('Init command failed: ${command.command}', e);
        // Continue with other commands even if one fails
      }
    }
    
    _isInitialized = true;
    return true;
  }

  /// Send a command with timeout
  Future<String> sendCommandWithTimeout(ObdCommand command, {required int timeoutMs}) async {
    // Adjust timeout for particularly important commands
    int adjustedTimeout = timeoutMs;
    if (command.mode == '01' && 
        (command.pid == ObdConstants.pidEngineRpm || 
         command.pid == ObdConstants.pidVehicleSpeed)) {
      // Use a shorter timeout for critical commands to improve responsiveness
      adjustedTimeout = (timeoutMs * 0.7).toInt(); // 30% faster timeout
      _logger.fine('Using shorter timeout (${adjustedTimeout}ms) for critical command: ${command.command}');
    }
    
    // Special handling for reset command for cheap adapters
    if (command == ObdCommands.reset && config.profileId == 'cheap_elm327') {
      _logger.info('Using special handling for reset command on cheap adapter');
      
      // Send the reset command directly without using the command queue
      await connection.sendCommand(command.command);
      
      // Wait for a longer time after reset for cheap adapters
      await Future.delayed(Duration(milliseconds: config.resetDelayMs * 2));
      
      // Return a mock OK response
      return 'ELM327 v1.5\nOK';
    }
    
    // Normal command handling for other commands
    final completer = Completer<String>();
    
    // Create a timer to handle timeout
    final timer = Timer(Duration(milliseconds: adjustedTimeout), () {
      if (!completer.isCompleted) {
        _logger.warning('Command timeout: ${command.command}');
        completer.complete('TIMEOUT');
      }
    });
    
    // Send the command
    await connection.sendCommand(command.command);
    
    // Set up a subscription to listen for responses
    late StreamSubscription subscription;
    subscription = connection.dataStream.listen((response) {
      if (response.isNotEmpty && 
          response != 'SEARCHING...' && 
          response != 'CONNECTED' && 
          response != 'DISCONNECTED') {
        
        _logger.fine('Received response for ${command.command}: $response');
        
        // Complete the future with the response
        if (!completer.isCompleted) {
          completer.complete(response);
          subscription.cancel();
          timer.cancel();
        }
      }
    });
    
    // Wait for a response or timeout
    final response = await completer.future;
    subscription.cancel();
    
    return response;
  }
  
  @override
  void dispose() {
    _logger.info('Disposing ELM327 protocol');
    
    // Cancel any pending commands
    for (var pendingCommand in _pendingCommands.values) {
      pendingCommand.cancel();
    }
    _pendingCommands.clear();
    
    // Cancel connection subscription
    _connectionSubscription?.cancel();
    
    // Close stream controller
    _dataStreamController.close();
  }

  /// Log detailed diagnostics for critical OBD data
  void _logDetailedDiagnostics(String response, ObdCommand command) {
    _logger.info('📊 DETAILED OBD DIAGNOSTICS 📊');
    _logger.info('PID: ${command.pid} (${command.name})');
    _logger.info('RAW RESPONSE: "${response}"');
    
    // Analyze the response format
    final cleanedResponse = response.replaceAll(RegExp(r'[\r\n>]'), ' ')
                                   .replaceAll(RegExp(r'\s+'), ' ')
                                   .trim()
                                   .toUpperCase();
                                   
    _logger.info('CLEANED: "$cleanedResponse"');
    
    // Try to parse as hex
    try {
      final parts = cleanedResponse.split(' ');
      _logger.info('PARTS: $parts');
      
      // Find the header pattern based on the command
      String expectedHeader;
      if (command.mode == '01') {
        expectedHeader = '41${command.pid.toUpperCase()}';
      } else {
        expectedHeader = '${(int.parse(command.mode, radix: 16) + 40).toRadixString(16).padLeft(2, '0').toUpperCase()}${command.pid.toUpperCase()}';
      }
      
      _logger.info('EXPECTED HEADER: $expectedHeader');
      
      // Look for the header in the response
      bool headerFound = false;
      String? dataSection;
      int dataStartIndex = -1;
      
      // Case 1: Check for the header as a complete part
      for (int i = 0; i < parts.length; i++) {
        if (parts[i] == expectedHeader || parts[i].startsWith(expectedHeader)) {
          headerFound = true;
          if (parts[i] == expectedHeader && i < parts.length - 1) {
            dataStartIndex = i + 1;
            dataSection = parts.sublist(dataStartIndex).join(' ');
          } else if (parts[i].startsWith(expectedHeader)) {
            dataSection = parts[i].substring(expectedHeader.length);
            if (dataSection.isEmpty && i < parts.length - 1) {
              dataStartIndex = i + 1;
              dataSection = parts.sublist(dataStartIndex).join(' ');
            }
          }
          break;
        }
      }
      
      // Case 2: Check for a split header across parts
      if (!headerFound && parts.length >= 2) {
        for (int i = 0; i < parts.length - 1; i++) {
          if (parts[i] == expectedHeader.substring(0, 2) && 
              parts[i+1].startsWith(expectedHeader.substring(2))) {
            headerFound = true;
            dataStartIndex = i + 1;
            String remainder = parts[i+1].substring(expectedHeader.substring(2).length);
            if (remainder.isEmpty) {
              dataStartIndex = i + 2;
              dataSection = parts.sublist(dataStartIndex).join(' ');
            } else {
              dataSection = remainder + (i+2 < parts.length ? ' ' + parts.sublist(i+2).join(' ') : '');
            }
            break;
          }
        }
      }
      
      // Case 3: Check for combined string with header inside
      if (!headerFound) {
        final combined = parts.join('');
        final headerIndex = combined.indexOf(expectedHeader);
        if (headerIndex >= 0) {
          headerFound = true;
          dataSection = combined.substring(headerIndex + expectedHeader.length);
        }
      }
      
      _logger.info('HEADER FOUND: $headerFound');
      _logger.info('DATA SECTION: ${dataSection ?? "None"}');
      
      // Extra analysis for specific PIDs
      if (command.pid == ObdConstants.pidVehicleSpeed) {
        _logger.info('SPEED ANALYSIS:');
        if (dataSection != null && dataSection.isNotEmpty) {
          try {
            // Standard speed calculation: 1st byte * 1 km/h
            int speedByte = -1;
            if (dataSection.length == 2) {
              speedByte = int.parse(dataSection, radix: 16);
            } else {
              // Try to extract the first two characters as a speed byte
              final match = RegExp(r'([0-9A-F]{2})').firstMatch(dataSection);
              if (match != null) {
                speedByte = int.parse(match.group(1)!, radix: 16);
              }
            }
            
            if (speedByte >= 0) {
              _logger.info('SPEED BYTE: $speedByte (hex: 0x${speedByte.toRadixString(16).padLeft(2, '0')})');
              
              // Calculate speed with different multipliers to see what might work
              _logger.info('STANDARD SPEED: ${speedByte * 1} km/h');
              _logger.info('MULTIPLIER 2X: ${speedByte * 2} km/h');
              _logger.info('MULTIPLIER 4X: ${speedByte * 4} km/h');
              _logger.info('MULTIPLIER 0.5X: ${speedByte * 0.5} km/h');
            }
          } catch (e) {
            _logger.info('ERROR PARSING SPEED BYTE: $e');
          }
        }
      } else if (command.pid == ObdConstants.pidEngineRpm) {
        _logger.info('RPM ANALYSIS:');
        if (dataSection != null && dataSection.isNotEmpty) {
          try {
            List<int> rpmBytes = [];
            
            // Try to extract 1 or 2 bytes for RPM
            // Standard format expects 2 bytes
            final matches = RegExp(r'([0-9A-F]{2})').allMatches(dataSection);
            for (final match in matches) {
              if (rpmBytes.length < 2) {
                rpmBytes.add(int.parse(match.group(1)!, radix: 16));
              }
            }
            
            if (rpmBytes.isNotEmpty) {
              _logger.info('RPM BYTES: $rpmBytes');
              
              // Calculate RPM with different formulas
              if (rpmBytes.length >= 2) {
                // Standard formula: ((A * 256) + B) / 4
                final standardRpm = ((rpmBytes[0] * 256) + rpmBytes[1]) / 4;
                _logger.info('STANDARD FORMULA RPM: $standardRpm');
                
                // Alternative formula 1: No division
                final alt1 = (rpmBytes[0] * 256) + rpmBytes[1];
                _logger.info('ALT 1 (NO DIVISION): $alt1');
                
                // Alternative formula 2: Division by 16
                final alt2 = ((rpmBytes[0] * 256) + rpmBytes[1]) / 16;
                _logger.info('ALT 2 (DIV BY 16): $alt2');
                
                // Alternative formula 3: Only use A-byte with multiplier
                final alt3 = rpmBytes[0] * 40;
                _logger.info('ALT 3 (A*40): $alt3');
                
                // Alternative formula 4: Only use B-byte with multiplier
                final alt4 = rpmBytes[1] * 40;
                _logger.info('ALT 4 (B*40): $alt4');
              } else if (rpmBytes.length == 1) {
                // Single byte alternative formulas
                final singleByteA = rpmBytes[0] * 40;
                _logger.info('SINGLE BYTE *40: $singleByteA');
                
                final singleByteB = rpmBytes[0] * 100;
                _logger.info('SINGLE BYTE *100: $singleByteB');
                
                final singleByteC = rpmBytes[0] * 25;
                _logger.info('SINGLE BYTE *25: $singleByteC');
              }
            }
          } catch (e) {
            _logger.info('ERROR PARSING RPM BYTES: $e');
          }
        }
      }
    } catch (e) {
      _logger.info('DIAGNOSTIC PARSING ERROR: $e');
    }
    
    _logger.info('📊 END DIAGNOSTICS 📊');
  }
} 

################################################################################
FILE: lib/obd_lib/protocol/obd_data_parser.dart
################################################################################

import 'package:logging/logging.dart';
import '../models/obd_data.dart';
import '../models/obd_command.dart';
import 'obd_constants.dart';

/// Parser for OBD-II response data
class ObdDataParser {
  static final Logger _logger = Logger('ObdDataParser');
  
  // Private constructor to prevent instantiation
  ObdDataParser._();
  
  /// Parse a raw response string into bytes
  static List<int> parseResponseBytes(String response, String mode, String pid) {
    try {
      // Log raw response before any processing
      _logger.fine('PARSER DEBUG - Raw response for PID $pid: "$response"');
      
      // Clean up the response
      final cleaned = _cleanResponse(response);
      
      // Log cleaned response
      _logger.fine('PARSER DEBUG - After cleaning for PID $pid: "$cleaned"');
      
      // If response is empty or shows an error
      if (cleaned.isEmpty || cleaned.contains('ERROR') || cleaned.contains('NO DATA')) {
        _logger.warning('Empty or error response for PID $pid: "$cleaned"');
        return [];
      }
      
      // Log the raw cleaned response for debugging
      _logger.fine('Cleaned response: $cleaned for PID $pid');
      
      // For mode 01 commands, the response header is '41' followed by the PID
      String expectedHeader;
      if (mode == '01') {
        // For mode 01, the response header is always '41' followed by the PID
        expectedHeader = '41${pid.toUpperCase()}';
      } else {
        // For other modes, calculate header as mode + 0x40
        expectedHeader = '${(int.parse(mode, radix: 16) + 40).toRadixString(16).padLeft(2, '0').toUpperCase()}${pid.toUpperCase()}';
      }
      
      _logger.fine('Looking for header: $expectedHeader in response: $cleaned');
      
      // Split response by spaces
      final parts = cleaned.split(' ');
      _logger.fine('PARSER DEBUG - Split parts: $parts');
      
      List<int> dataBytes = [];
      
      // Remove any non-hex characters that might have been missed in cleaning
      for (int i = 0; i < parts.length; i++) {
        parts[i] = parts[i].replaceAll(RegExp(r'[^A-Fa-f0-9]'), '');
      }
      
      // Remove any empty parts
      parts.removeWhere((part) => part.isEmpty);
      _logger.fine('PARSER DEBUG - Filtered parts: $parts');
      
      if (parts.isEmpty) {
        _logger.warning('No valid hex parts found in response for PID $pid');
        return [];
      }
      
      // Check if we have a standard OBD-II response format
      bool found = false;
      for (int i = 0; i < parts.length; i++) {
        // Case 1: The header is in a single part ("410D00")
        if (parts[i].startsWith(expectedHeader)) {
          String dataHex = parts[i].substring(expectedHeader.length);
          _logger.fine('PARSER DEBUG - Found header in part "$parts[i]", data hex: "$dataHex"');
          
          // Convert data hex to bytes
          for (int j = 0; j < dataHex.length; j += 2) {
            if (j + 2 <= dataHex.length) {
              final byteHex = dataHex.substring(j, j + 2);
              try {
                final byteValue = int.parse(byteHex, radix: 16);
                dataBytes.add(byteValue);
              } catch (e) {
                _logger.warning('Error parsing hex byte: $e');
              }
            }
          }
          found = true;
          break;
        }
        // Case 2: Header is split across parts ("41 0D 00")
        else if (i + 1 < parts.length) {
          // Try to join this part with the next one to see if that makes a header
          final possibleHeaderStart = parts[i];
          final possibleHeaderEnd = parts[i+1];
          
          if (possibleHeaderStart.length <= 2 && possibleHeaderEnd.length <= 2) {
            final joinedHeader = possibleHeaderStart + possibleHeaderEnd;
            
            if (joinedHeader == expectedHeader) {
              // Header found across two parts, data starts at i+2
              _logger.fine('PARSER DEBUG - Found split header at parts $i and ${i+1}, data starts at part ${i+2}');
              
              for (int j = i + 2; j < parts.length; j++) {
                if (parts[j].length == 2) { // Valid hex byte
                  try {
                    final byteValue = int.parse(parts[j], radix: 16);
                    dataBytes.add(byteValue);
                  } catch (e) {
                    _logger.warning('Error parsing split header hex byte: $e');
                    break;
                  }
                } else {
                  break; // Invalid format, stop processing
                }
              }
              found = true;
              break;
            }
          }
        }
      }
      
      // If standard format failed, try a more generic approach for malformed responses
      if (!found && dataBytes.isEmpty) {
        _logger.fine('Standard header pattern not found, trying generic extraction');
        
        // Combine all parts and try to find the header in the combined string
        final combinedResponse = parts.join('');
        _logger.fine('PARSER DEBUG - Combined response: "$combinedResponse"');
        
        // Look for the header pattern anywhere in the response
        final headerIndex = combinedResponse.indexOf(expectedHeader);
        if (headerIndex >= 0 && headerIndex + expectedHeader.length < combinedResponse.length) {
          // Extract all remaining data after the header
          final dataHex = combinedResponse.substring(headerIndex + expectedHeader.length);
          _logger.fine('PARSER DEBUG - Found header at position $headerIndex in combined response, remaining data: "$dataHex"');
          
          // Convert data hex to bytes
          for (int i = 0; i < dataHex.length; i += 2) {
            if (i + 2 <= dataHex.length) {
              final byteHex = dataHex.substring(i, i + 2);
              try {
                final byteValue = int.parse(byteHex, radix: 16);
                dataBytes.add(byteValue);
              } catch (e) {
                _logger.warning('Error parsing fallback hex byte: $e');
                break; // Stop at first error
              }
            }
          }
        }
        
        // If still no data, try a last resort approach for completely mangled responses
        if (dataBytes.isEmpty && parts.isNotEmpty) {
          _logger.warning('Header not found in response, attempting last resort data extraction');
          _logger.fine('PARSER DEBUG - Last resort extraction, parts: $parts');
          
          // Try to interpret any hex bytes as data (useful for some adapters that omit headers)
          for (String part in parts) {
            if (part.length == 2) {
              try {
                final byteValue = int.parse(part, radix: 16);
                dataBytes.add(byteValue);
                _logger.fine('PARSER DEBUG - Extracted byte: $byteValue (hex: $part)');
              } catch (e) {
                // Skip non-hex parts
                _logger.fine('PARSER DEBUG - Skipped non-hex part: $part');
              }
            }
          }
          
          if (dataBytes.isNotEmpty) {
            _logger.fine('Last resort data extraction yielded ${dataBytes.length} bytes');
          }
        }
      }
      
      // PID-specific validation and processing
      if (pid == ObdConstants.pidVehicleSpeed) {
        // Vehicle speed should be just one byte
        if (dataBytes.isNotEmpty) {
          _logger.fine('Raw speed value: ${dataBytes.first}');
          return [dataBytes.first]; // Take only the first byte for speed
        }
      } else if (pid == ObdConstants.pidEngineRpm) {
        // Engine RPM needs exactly 2 bytes
        if (dataBytes.length >= 2) {
          _logger.fine('Raw RPM bytes: ${dataBytes[0]}, ${dataBytes[1]}');
          _logger.fine('PARSER DEBUG - Calculated RPM: ${((dataBytes[0] * 256) + dataBytes[1]) / 4}');
          return [dataBytes[0], dataBytes[1]]; // Take only the first two bytes for RPM
        } else if (dataBytes.length == 1) {
          // Some adapters might send a single byte for zero RPM
          _logger.fine('Only one byte for RPM: ${dataBytes[0]}');
          _logger.fine('PARSER DEBUG - Single byte - Calculated RPM: ${((dataBytes[0] * 256) + 0) / 4}');
          
          // IMPORTANT - This is where we're adding a zero byte which may be causing issues
          return [dataBytes[0], 0]; // Add a zero byte to make it two bytes
        }
      }
      
      _logger.fine('Final extracted data bytes for PID $pid: $dataBytes');
      return dataBytes;
    } catch (e) {
      _logger.warning('Error parsing response "$response" for PID $pid: $e');
      return [];
    }
  }
  
  /// Clean up an OBD response
  static String _cleanResponse(String response) {
    // Log original response
    _logger.fine('PARSER DEBUG - Before cleaning: "$response"');
    
    final result = response
        .replaceAll(RegExp(r'[\r\n>]'), ' ')  // Replace newlines, CR, prompt with space
        .replaceAll(RegExp(r'BUS INIT'), '')  // Remove BUS INIT messages
        .replaceAll(RegExp(r'SEARCHING'), '') // Remove SEARCHING messages
        .replaceAll(RegExp(r'[^A-Fa-f0-9 ]'), '') // Keep only hex chars and spaces
        .replaceAll(RegExp(r'\s+'), ' ')      // Replace multiple spaces with single space
        .trim()
        .toUpperCase();
        
    // Log after cleaning
    _logger.fine('PARSER DEBUG - After cleaning: "$result"');
    
    return result;
  }
  
  /// Decode a response for a specific command
  static ObdData? decodeResponse(String response, ObdCommand command) {
    final bytes = parseResponseBytes(response, command.mode, command.pid);
    
    if (bytes.isEmpty) {
      _logger.warning('No bytes returned from response "$response" for PID ${command.pid}');
      return null;
    }
    
    // Based on the command mode and PID, decode the data appropriately
    if (command.mode == '01') {
      switch (command.pid) {
        case ObdConstants.pidSupportedPids:
          return _decodeSupportedPids(bytes, command);
        case ObdConstants.pidCoolantTemp:
          return _decodeCoolantTemp(bytes, command);
        case ObdConstants.pidEngineRpm:
          return _decodeEngineRpm(bytes, command);
        case ObdConstants.pidVehicleSpeed:
          return _decodeVehicleSpeed(bytes, command);
        case ObdConstants.pidControlModuleVoltage:
          return _decodeControlModuleVoltage(bytes, command);
        case ObdConstants.pidEngineLoad:
          return _decodeEngineLoad(bytes, command);
        case ObdConstants.pidThrottlePosition:
          return _decodeThrottlePosition(bytes, command);
        // New PIDs
        case ObdConstants.pidMassAirFlow:
          return _decodeMassAirFlow(bytes, command);
        case ObdConstants.pidDistanceMIL:
          return _decodeDistanceMIL(bytes, command);
        case ObdConstants.pidFuelRate:
          return _decodeFuelRate(bytes, command);
        case ObdConstants.pidAcceleratorPosition:
          return _decodeAcceleratorPosition(bytes, command);
        // Add missing parsers
        case ObdConstants.pidFuelLevel:
        case ObdConstants.pidCurrentFuelLevel: // Both point to 0x2F
          return _decodeFuelLevel(bytes, command);
        case ObdConstants.pidFuelType:
          return _decodeFuelType(bytes, command);
        case ObdConstants.pidIntakeManifoldAbsolutePressure:
          return _decodeIntakeManifoldPressure(bytes, command);
        case ObdConstants.pidIntakeAirTemperature:
          return _decodeIntakeAirTemperature(bytes, command);
        case ObdConstants.pidEngineOilTemperature:
          return _decodeEngineOilTemperature(bytes, command);
        case ObdConstants.pidAmbientAirTemperature:
          return _decodeAmbientAirTemperature(bytes, command);
        case ObdConstants.pidFuelPressure:
          return _decodeFuelPressure(bytes, command);
        default:
          _logger.warning('Unsupported PID: ${command.pid}');
          return null;
      }
    }
    
    // Return raw data for unsupported modes
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: bytes,
      unit: 'raw',
      rawData: bytes,
    );
  }
  
  /// Decode supported PIDs response
  static ObdData _decodeSupportedPids(List<int> bytes, ObdCommand command) {
    if (bytes.length < 4) return _createErrorData(command);
    
    final supportedPids = <String>[];
    
    // Each bit in the 4 bytes represents support for a specific PID
    for (int i = 0; i < 32; i++) {
      final byteIndex = i ~/ 8;
      final bitIndex = 7 - (i % 8);
      
      if ((bytes[byteIndex] & (1 << bitIndex)) != 0) {
        final pidNumber = i + 1;
        supportedPids.add(pidNumber.toRadixString(16).padLeft(2, '0').toUpperCase());
      }
    }
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: supportedPids,
      unit: 'PIDs',
      rawData: bytes,
    );
  }
  
  /// Decode coolant temperature response
  static ObdData _decodeCoolantTemp(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) return _createErrorData(command);
    
    // A - 40 = Temperature in Celsius
    final temperature = bytes[0] - 40;
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: temperature,
      unit: '°C',
      rawData: bytes,
    );
  }
  
  /// Decode engine RPM response
  static ObdData _decodeEngineRpm(List<int> bytes, ObdCommand command) {
    if (bytes.length < 2) {
      // MODIFIED: Handle single-byte RPM data differently
      if (bytes.length == 1) {
        _logger.fine('Single byte RPM received: ${bytes[0]}');
        
        // Some adapters send a single byte for RPM; in this case,
        // use a different calculation method based on the single byte
        final singleByteRpm = bytes[0] * 25; // Different scaling for single-byte format
        
        _logger.fine('Calculated RPM from single byte: $singleByteRpm');
        
        // Only use this value if it seems reasonable
        if (singleByteRpm > 0 && singleByteRpm < 8000) {
          return ObdData(
            mode: command.mode,
            pid: command.pid,
            name: command.name,
            value: singleByteRpm,
            unit: 'RPM',
            rawData: bytes,
          );
        }
      }
      
      _logger.warning('Not enough bytes for RPM calculation: ${bytes.length}');
      return _createErrorData(command);
    }
    
    // Standard calculation: ((A * 256) + B) / 4 = RPM
    // But some adapters may use different scaling factors
    double rpm = ((bytes[0] * 256) + bytes[1]) / 4;
    
    // Log raw values for debugging
    _logger.fine('Raw RPM values: A=${bytes[0]}, B=${bytes[1]}, formula: ((${bytes[0]} * 256) + ${bytes[1]}) / 4 = $rpm');
    
    // Special case for unreasonable RPM values
    if (rpm > 16000) {
      _logger.warning('Unreasonably high RPM detected: $rpm, attempting alternative calculation');
      
      // Try alternative calculation methods
      
      // Method 1: Single byte with higher multiplier
      final alt1 = bytes[0] * 100;
      
      // Method 2: Treat high byte as noise and use only low byte
      final alt2 = bytes[1] * 40;
      
      // Method 3: Direct division (some adapters don't follow standard formula)
      final alt3 = ((bytes[0] * 256) + bytes[1]) / 16;
      
      _logger.fine('Alternative RPM calculations: alt1=$alt1, alt2=$alt2, alt3=$alt3');
      
      // Choose the most reasonable alternative value
      if (alt1 > 500 && alt1 < 8000) {
        rpm = alt1.toDouble();
        _logger.info('Using alternative RPM calculation #1: $rpm');
      } else if (alt2 > 500 && alt2 < 8000) {
        rpm = alt2.toDouble();
        _logger.info('Using alternative RPM calculation #2: $rpm');
      } else if (alt3 > 500 && alt3 < 8000) {
        rpm = alt3.toDouble();
        _logger.info('Using alternative RPM calculation #3: $rpm');
      } else {
        // If all alternatives are unreasonable, use a moderate default
        _logger.warning('All RPM calculations gave unreasonable values, using 0');
        rpm = 0;
      }
    }
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: rpm.round(),
      unit: 'RPM',
      rawData: bytes,
    );
  }
  
  /// Decode vehicle speed response
  static ObdData _decodeVehicleSpeed(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) {
      _logger.warning('Empty bytes array for vehicle speed');
      return _createErrorData(command);
    }
    
    // MODIFIED: Apply correction for known scaling issue with certain adapters
    // The standard formula is A = Speed in km/h, but some adapters return values 
    // that are consistently too low when driving
    final rawSpeed = bytes[0];
    
    // Enhanced speed calculation with scaling factor
    // This compensates for adapter variations and protocol differences
    final correctionFactor = 4.0; // INCREASED from 1.0 to 4.0 to fix low speed readings
    final speed = rawSpeed * correctionFactor;
    
    // Log raw and corrected values for debugging
    _logger.fine('Raw speed byte: ${bytes[0]} (hex: 0x${bytes[0].toRadixString(16)})');
    _logger.fine('Corrected speed: $speed km/h (factor: $correctionFactor)');
    
    // Sanity check - speeds over 250 km/h are likely errors
    if (rawSpeed > 250) {
      _logger.warning('Unrealistic speed detected: $rawSpeed km/h. Using 0 instead.');
      return ObdData(
        mode: command.mode,
        pid: command.pid,
        name: command.name,
        value: 0,
        unit: 'km/h',
        rawData: bytes,
      );
    }
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: speed.round(),
      unit: 'km/h',
      rawData: bytes,
    );
  }
  
  /// Decode control module voltage response
  static ObdData _decodeControlModuleVoltage(List<int> bytes, ObdCommand command) {
    if (bytes.length < 2) return _createErrorData(command);
    
    // ((A * 256) + B) / 1000 = Voltage
    final voltage = ((bytes[0] * 256) + bytes[1]) / 1000;
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: voltage.toStringAsFixed(1),
      unit: 'V',
      rawData: bytes,
    );
  }
  
  /// Decode engine load response
  static ObdData _decodeEngineLoad(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) return _createErrorData(command);
    
    // A * 100 / 255 = Engine load as percentage
    final load = (bytes[0] * 100) / 255;
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: load.round(),
      unit: '%',
      rawData: bytes,
    );
  }
  
  /// Decode throttle position response
  static ObdData _decodeThrottlePosition(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) return _createErrorData(command);
    
    // A * 100 / 255 = Throttle position as percentage
    final position = (bytes[0] * 100) / 255;
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: position.round(),
      unit: '%',
      rawData: bytes,
    );
  }
  
  /// Decode mass air flow response
  static ObdData _decodeMassAirFlow(List<int> bytes, ObdCommand command) {
    if (bytes.length < 2) return _createErrorData(command);
    
    // ((A * 256) + B) / 100 = Mass Air Flow rate in grams/sec
    final maf = ((bytes[0] * 256) + bytes[1]) / 100;
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: maf,
      unit: 'g/s',
      rawData: bytes,
    );
  }
  
  /// Decode distance traveled with MIL on
  static ObdData _decodeDistanceMIL(List<int> bytes, ObdCommand command) {
    if (bytes.length < 2) return _createErrorData(command);
    
    // (A * 256) + B = Distance in km
    final distance = (bytes[0] * 256) + bytes[1];
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: distance,
      unit: 'km',
      rawData: bytes,
    );
  }
  
  /// Decode fuel rate response
  static ObdData _decodeFuelRate(List<int> bytes, ObdCommand command) {
    if (bytes.length < 2) return _createErrorData(command);
    
    // ((A * 256) + B) / 20 = Fuel consumption rate in L/h
    final rate = ((bytes[0] * 256) + bytes[1]) / 20;
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: rate,
      unit: 'L/h',
      rawData: bytes,
    );
  }
  
  /// Decode accelerator pedal position
  static ObdData _decodeAcceleratorPosition(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) return _createErrorData(command);
    
    // A * 100 / 255 = Accelerator pedal position as percentage
    final position = (bytes[0] * 100) / 255;
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: position.round(),
      unit: '%',
      rawData: bytes,
    );
  }
  
  /// Decode fuel level response (PID 2F)
  static ObdData _decodeFuelLevel(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) return _createErrorData(command);
    
    // A * 100 / 255 = Fuel level as percentage
    final level = (bytes[0] * 100) / 255;
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: level.round(),
      unit: '%',
      rawData: bytes,
    );
  }
  
  /// Decode fuel type response (PID 51)
  static ObdData _decodeFuelType(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) return _createErrorData(command);
    
    // A = Fuel type code
    final fuelTypeCode = bytes[0];
    String fuelType;
    
    // Map fuel type codes according to SAE J1979 standard
    switch (fuelTypeCode) {
      case 0: fuelType = 'Not Available'; break;
      case 1: fuelType = 'Gasoline'; break;
      case 2: fuelType = 'Methanol'; break;
      case 3: fuelType = 'Ethanol'; break;
      case 4: fuelType = 'Diesel'; break;
      case 5: fuelType = 'LPG'; break;
      case 6: fuelType = 'CNG'; break;
      case 7: fuelType = 'Propane'; break;
      case 8: fuelType = 'Electric'; break;
      case 9: fuelType = 'Bifuel: Gasoline/CNG'; break;
      case 10: fuelType = 'Bifuel: Gasoline/LPG'; break;
      case 11: fuelType = 'Bifuel: Gasoline/Ethanol'; break;
      case 12: fuelType = 'Bifuel: Gasoline/Methanol'; break;
      case 13: fuelType = 'Bifuel: Diesel/CNG'; break;
      case 14: fuelType = 'Bifuel: Diesel/LPG'; break;
      case 15: fuelType = 'Bifuel: Diesel/Ethanol'; break;
      case 16: fuelType = 'Bifuel: Diesel/Methanol'; break;
      case 17: fuelType = 'Bifuel: Gasoline/Electric'; break;
      case 18: fuelType = 'Hybrid: Gasoline'; break;
      case 19: fuelType = 'Hybrid: Diesel'; break;
      case 20: fuelType = 'Hybrid: Electric'; break;
      case 21: fuelType = 'Hybrid: Fuel Cell'; break;
      case 22: fuelType = 'Hybrid: Gasoline/Fuel Cell'; break;
      case 23: fuelType = 'Hybrid: Ethanol/Fuel Cell'; break;
      default: fuelType = 'Unknown ($fuelTypeCode)';
    }
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: fuelType,
      unit: '',
      rawData: bytes,
    );
  }
  
  /// Decode intake manifold absolute pressure (PID 0B)
  static ObdData _decodeIntakeManifoldPressure(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) return _createErrorData(command);
    
    // A = Intake manifold pressure in kPa (absolute)
    final pressure = bytes[0];
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: pressure,
      unit: 'kPa',
      rawData: bytes,
    );
  }
  
  /// Decode intake air temperature (PID 0F)
  static ObdData _decodeIntakeAirTemperature(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) return _createErrorData(command);
    
    // A - 40 = Intake air temperature in Celsius
    final temperature = bytes[0] - 40;
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: temperature,
      unit: '°C',
      rawData: bytes,
    );
  }
  
  /// Decode engine oil temperature (PID 5C)
  static ObdData _decodeEngineOilTemperature(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) return _createErrorData(command);
    
    // A - 40 = Oil temperature in Celsius
    final temperature = bytes[0] - 40;
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: temperature,
      unit: '°C',
      rawData: bytes,
    );
  }
  
  /// Decode ambient air temperature (PID 1F)
  static ObdData _decodeAmbientAirTemperature(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) return _createErrorData(command);
    
    // A - 40 = Ambient air temperature in Celsius
    final temperature = bytes[0] - 40;
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: temperature,
      unit: '°C',
      rawData: bytes,
    );
  }
  
  /// Decode fuel pressure (PID 23)
  static ObdData _decodeFuelPressure(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) return _createErrorData(command);
    
    // A * 3 = Fuel pressure in kPa (gauge)
    final pressure = bytes[0] * 3;
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: pressure,
      unit: 'kPa',
      rawData: bytes,
    );
  }
  
  /// Create an error data object when decoding fails
  static ObdData _createErrorData(ObdCommand command) {
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: 'Error',
      unit: '',
      rawData: [],
    );
  }
} 

################################################################################
FILE: lib/obd_lib/protocol/obd_constants.dart
################################################################################

/// Constants for OBD-II protocol
class ObdConstants {
  // Private constructor to prevent instantiation
  ObdConstants._();
  
  /// Service UUID for ELM327 Bluetooth
  /// Using the full UUID format for cross-platform compatibility
  /// The standard format for Bluetooth UUIDs is: 0000XXXX-0000-1000-8000-00805f9b34fb
  /// where XXXX is the short-form UUID
  static const String serviceUuid = '0000fff0-0000-1000-8000-00805f9b34fb';
  
  /// Characteristic UUID for notifications (reading from ELM327)
  static const String notifyCharacteristicUuid = '0000fff1-0000-1000-8000-00805f9b34fb';
  
  /// Characteristic UUID for writing commands to ELM327
  static const String writeCharacteristicUuid = '0000fff2-0000-1000-8000-00805f9b34fb';
  
  /// Command terminator (carriage return)
  static const String commandTerminator = '\r';
  
  /// Response timeout for commands (ms)
  static const int responseTimeoutMs = 300;
  
  /// Connection timeout (ms)
  static const int connectionTimeoutMs = 10000;
  
  /// Command timeout (ms)
  static const int commandTimeoutMs = 4000;
  
  /// Delay between commands during initialization (ms)
  static const int initCommandDelayMs = 300;
  
  /// Delay after reset command (ms)
  static const int resetDelayMs = 1000;
  
  /// Standard OBD-II protocol commands
  static const String resetCommand = 'ATZ';
  static const String echoOffCommand = 'ATE0';
  static const String headersOffCommand = 'ATH0';
  static const String linebreaksOffCommand = 'ATL0';
  static const String protocolKwpCommand = 'ATSP4'; // ISO 14230-4 KWP (5 baud init)
  static const String baudRateCommand = 'ATBRD10'; // 10.4 kbaud
  static const String timeoutCommand = 'ATST20'; // 200ms timeout
  static const String supportedPidsCommand = '0100'; // Get supported PIDs 01-20
  
  /// Standard OBD-II Mode 01 PIDs
  static const String pidSupportedPids = '00'; // PIDs supported 01-20
  static const String pidCoolantTemp = '05'; // Engine coolant temperature
  static const String pidEngineRpm = '0C'; // Engine RPM
  static const String pidVehicleSpeed = '0D'; // Vehicle speed
  static const String pidControlModuleVoltage = '42'; // Control module voltage
  static const String pidCurrentFuelLevel = '2F'; // Current fuel level
  static const String pidFuelType = '51'; // Fuel type
  // engine load
  static const String pidEngineLoad = '04'; // Engine load
  // throttle position
  static const String pidThrottlePosition = '11'; // Throttle position  
  // intake manifold absolute pressure
  static const String pidIntakeManifoldAbsolutePressure = '0B'; // Intake manifold absolute pressure
  // intake air temperature
  static const String pidIntakeAirTemperature = '0F'; // Intake air temperature
  // engine oil temperature
  static const String pidEngineOilTemperature = '5C'; // Engine oil temperature
  // ambient air temperature
  static const String pidAmbientAirTemperature = '1F'; // Ambient air temperature
  // fuel pressure
  static const String pidFuelPressure = '23'; // Fuel pressure
  // fuel level
  static const String pidFuelLevel = '2F'; // Fuel level
  
  /// Standard PIDs for OBD-II
  static const String engineRpmPid = '010C';
  static const String vehicleSpeedPid = '010D';
  static const String coolantTempPid = '0105';
  static const String controlModuleVoltagePid = '0142';
  
  /// ELM327 commands
  static const String setProtocolCommand = 'ATSP0';
  static const String setBaudRateCommand = 'ATBRD';
  
  /// Response prefixes and patterns
  static const String okResponse = 'OK';
  static const String errorResponse = 'ERROR';
  static const String noDataResponse = 'NO DATA';
  static const String searchingResponse = 'SEARCHING';
  
  /// Timeout values (in milliseconds)
  static const int commandTimeout = 2000;
  static const int connectionTimeout = 5000;
  static const int initializationTimeout = 10000;
  
  /// Polling intervals (in milliseconds)
  static const int defaultPollingInterval = 1200;
  static const int fastPollingInterval = 700;
  static const int slowPollingInterval = 2000;
  static const int engineOffPollingInterval = 5000;
  
  // Additional PIDs for eco-driving analysis
  static const String pidMassAirFlow = '10'; // Mass air flow rate (g/s)
  static const String pidDistanceMIL = '21'; // Distance traveled with MIL on (km)
  static const String pidFuelRate = '5E'; // Engine fuel rate (L/h)
  static const String pidAcceleratorPosition = '49'; // Accelerator pedal position D (%)
} 

################################################################################
FILE: lib/obd_lib/protocol/obd_protocol.dart
################################################################################

import 'dart:async';
import '../models/obd_command.dart';
import '../models/obd_data.dart';

/// Protocol interface for OBD-II communication
///
/// This interface defines the contract for OBD-II protocol handlers,
/// allowing different implementations to be used interchangeably.
abstract class ObdProtocol {
  /// Whether the protocol is initialized and ready to communicate
  bool get isInitialized;
  
  /// Whether the protocol is currently connected to a device
  bool get isConnected;
  
  /// Whether the protocol is currently connecting to a device
  bool get isConnecting;
  
  /// The latest error message, if any occurred
  String? get errorMessage;
  
  /// Stream of raw response data from the OBD adapter
  Stream<String> get dataStream;
  
  /// Stream of parsed OBD data
  Stream<ObdData> get obdDataStream;
  
  /// Initialize the protocol
  /// 
  /// This method should be called after establishing a connection.
  /// Returns true if initialization was successful.
  Future<bool> initialize();
  
  /// Send a raw command to the OBD adapter
  /// 
  /// Returns the raw response from the OBD adapter.
  Future<String> sendCommand(String command);
  
  /// Send an OBD command to the OBD adapter
  /// 
  /// Returns the raw response from the OBD adapter.
  Future<String> sendObdCommand(ObdCommand command);
  
  /// Request data for a specific PID
  /// 
  /// Returns the parsed OBD data.
  Future<ObdData?> requestPid(String pid);
  
  /// Request data for a list of PIDs
  /// 
  /// Returns a map of PID to parsed OBD data.
  Future<Map<String, ObdData>> requestPids(List<String> pids);
  
  /// Dispose of any resources used by the protocol
  void dispose();
} 

################################################################################
FILE: lib/obd_lib/protocol/response_processor/cheap_elm327_processor.dart
################################################################################

import 'package:logging/logging.dart';
import '../../models/obd_command.dart';
import '../../models/obd_data.dart';
import '../obd_constants.dart';
import 'obd_response_processor.dart';

/// Processor for cheap ELM327 adapters, which often have non-standard responses
///
/// This processor is more lenient in parsing responses from cheap adapters
/// which may have formatting issues, dropped bytes, or other anomalies.
class CheapElm327Processor extends ObdResponseProcessor {
  static final Logger _logger = Logger('CheapElm327Processor');
  
  /// Whether to use lenient parsing (more tolerant of formatting issues)
  final bool _lenientParsing;
  
  /// Recent speed values for smoothing
  final List<double> _recentSpeedValues = [];
  
  /// Recent throttle values for smoothing
  final List<double> _recentThrottleValues = [];
  
  /// Define the maximum history size for smoothing
  static const int _maxHistorySize = 5;
  
  /// Define smoothing factors for different PIDs
  /// Higher values (closer to 1.0) give more weight to previous readings
  static const double _speedSmoothingFactor = 0.6; // 60% previous, 40% new
  static const double _throttleSmoothingFactor = 0.4; // 40% previous, 60% new
  
  /// Creates a new cheap ELM327 processor
  ///
  /// The [lenientParsing] parameter controls how strict the parsing is.
  /// For cheap adapters, this is typically true by default.
  CheapElm327Processor({
    bool lenientParsing = true,
  }) : _lenientParsing = lenientParsing {
    _logger.info('Created cheap ELM327 processor with lenientParsing=$lenientParsing');
  }
  
  @override
  ObdData? processDecodedData(ObdData data, String response, ObdCommand command) {
    // Apply PID-specific processing
    if (command.pid == ObdConstants.pidVehicleSpeed) {
      return _processSpeedData(data);
    } else if (command.pid == ObdConstants.pidThrottlePosition) {
      return _processThrottleData(data);
    }
    
    // For other PIDs, return the original data
    return data;
  }
  
  /// Apply smoothing to speed data to reduce fluctuations
  ObdData? _processSpeedData(ObdData data) {
    final dynamic rawValue = data.value;
    if (rawValue == null) return data;
    
    // Convert to double for smoothing
    double speedValue;
    if (rawValue is int) {
      speedValue = rawValue.toDouble();
    } else if (rawValue is double) {
      speedValue = rawValue;
    } else if (rawValue is String) {
      try {
        speedValue = double.parse(rawValue);
      } catch (e) {
        return data; // Can't smooth, return original
      }
    } else {
      return data; // Unknown type, return original
    }
    
    // Apply smoothing only if we have previous values and current value is not zero
    // (We don't want to smooth when actually stopping)
    double smoothedSpeed = speedValue;
    if (speedValue > 0 && _recentSpeedValues.isNotEmpty) {
      smoothedSpeed = smoothValue(
        speedValue, 
        _recentSpeedValues, 
        _speedSmoothingFactor, 
        _maxHistorySize
      );
      
      // Round to nearest whole number for speed
      smoothedSpeed = smoothedSpeed.roundToDouble();
      
      _logger.fine('Smoothed speed from $speedValue to $smoothedSpeed km/h');
    }
    
    // Add the original value to history (not the smoothed one)
    // This ensures we're not compounding smoothing effects
    _recentSpeedValues.add(speedValue);
    if (_recentSpeedValues.length > _maxHistorySize) {
      _recentSpeedValues.removeAt(0);
    }
    
    // Return a new data object with the smoothed value
    return data.copyWith(
      value: smoothedSpeed.toInt(),
      timestamp: DateTime.now(),
    );
  }
  
  /// Apply smoothing to throttle data to reduce fluctuations
  ObdData? _processThrottleData(ObdData data) {
    final dynamic rawValue = data.value;
    if (rawValue == null) return data;
    
    // Convert to double for smoothing
    double throttleValue;
    if (rawValue is int) {
      throttleValue = rawValue.toDouble();
    } else if (rawValue is double) {
      throttleValue = rawValue;
    } else if (rawValue is String) {
      try {
        throttleValue = double.parse(rawValue);
      } catch (e) {
        return data; // Can't smooth, return original
      }
    } else {
      return data; // Unknown type, return original
    }
    
    // Apply throttle-specific corrections for cheap adapters
    
    // Some adapters incorrectly report very low values when throttle is released
    // This creates a "dead zone" effect where throttle appears stuck
    if (throttleValue < 3.0) {
      // For very low readings, snap to zero for better UI response
      _logger.fine('Correcting low throttle value from $throttleValue% to 0%');
      throttleValue = 0.0;
    }
    
    // Apply smoothing for non-zero throttle values to reduce jitter
    double smoothedThrottle = throttleValue;
    if (throttleValue > 0 && _recentThrottleValues.isNotEmpty) {
      // Accelerator pedal movement should be more responsive than speed changes
      smoothedThrottle = smoothValue(
        throttleValue, 
        _recentThrottleValues, 
        _throttleSmoothingFactor, 
        _maxHistorySize
      );
      
      _logger.fine('Smoothed throttle from $throttleValue% to $smoothedThrottle%');
    }
    
    // Add the original value to history
    _recentThrottleValues.add(throttleValue);
    if (_recentThrottleValues.length > _maxHistorySize) {
      _recentThrottleValues.removeAt(0);
    }
    
    // Return a new data object with the smoothed value
    return data.copyWith(
      value: smoothedThrottle,
      timestamp: DateTime.now(),
    );
  }
  
  @override
  ObdData? processResponse(String response, ObdCommand command) {
    // Apply cheap adapter-specific preprocessing before normal processing
    final modifiedResponse = _preprocessResponse(response, command);
    
    // Use the standard processing logic from the base class
    return super.processResponse(modifiedResponse, command);
  }
  
  /// Preprocess the response to handle common issues with cheap adapters
  String _preprocessResponse(String response, ObdCommand command) {
    if (response.isEmpty) return response;
    
    // Many cheap adapters send garbage characters or have inconsistent formatting
    String processed = response;
    
    // Remove common garbage characters sent by cheap adapters
    processed = processed.replaceAll(RegExp(r'[\x00-\x1F]'), '');
    
    // Some adapters send "NODATA" without space
    if (processed.contains('NODATA')) {
      processed = processed.replaceAll('NODATA', 'NO DATA');
    }
    
    // Some adapters use non-standard response formats
    if (_lenientParsing) {
      // Try to extract valid hex from responses with bad formatting
      final hexPattern = RegExp(r'[0-9A-Fa-f]{2,}');
      final matches = hexPattern.allMatches(processed);
      
      if (matches.isNotEmpty) {
        // Check if this looks like a normal OBD response with expected header
        final normalObd = RegExp(r'41 ' + command.pid);
        if (!normalObd.hasMatch(processed)) {
          // This may be a malformed response, try to reconstruct it
          final hexParts = matches.map((m) => m.group(0)).toList();
          
          // Check if we have enough parts to form a valid response
          if (hexParts.length >= 2) {
            // Try to form a standard mode+PID response format
            processed = '41 ${command.pid} ${hexParts.skip(1).join(' ')}';
            _logger.fine('Reconstructed malformed response to: $processed');
          }
        }
      }
    }
    
    return processed;
  }
  
  @override
  List<int> parseResponseBytes(String response, String mode, String pid) {
    try {
      // Log raw response before any processing
      _logger.fine('Cheap ELM - Raw response for PID $pid: "$response"');
      
      // Clean up the response
      final cleaned = cleanResponse(response);
      
      // Log cleaned response
      _logger.fine('Cheap ELM - After cleaning for PID $pid: "$cleaned"');
      
      // If response is empty or shows an error
      if (cleaned.isEmpty || cleaned.contains('ERROR') || cleaned.contains('NO DATA')) {
        _logger.warning('Empty or error response for PID $pid: "$cleaned"');
        return [];
      }
      
      // Split response by spaces
      final parts = cleaned.split(' ');
      _logger.fine('Cheap ELM - Split parts: $parts');
      
      List<int> dataBytes = [];
      
      // Remove any non-hex characters that might have been missed in cleaning
      for (int i = 0; i < parts.length; i++) {
        parts[i] = parts[i].replaceAll(RegExp(r'[^A-Fa-f0-9]'), '');
      }
      
      // Remove any empty parts
      parts.removeWhere((part) => part.isEmpty);
      
      if (parts.isEmpty) {
        _logger.warning('No valid hex parts found in response for PID $pid');
        return [];
      }
      
      // For cheap adapters, often the headers are missing or malformed
      // Go straight to the "last resort" approach
      for (String part in parts) {
        if (part.length == 2) {
          try {
            final byteValue = int.parse(part, radix: 16);
            dataBytes.add(byteValue);
            _logger.fine('Cheap ELM - Extracted byte: $byteValue (hex: $part)');
          } catch (e) {
            // Skip non-hex parts
            _logger.fine('Cheap ELM - Skipped non-hex part: $part');
          }
        }
      }
      
      // PID-specific validation and processing
      if (pid == ObdConstants.pidVehicleSpeed) {
        // Vehicle speed should be just one byte
        if (dataBytes.isNotEmpty) {
          _logger.fine('Raw speed value: ${dataBytes.first}');
          return [dataBytes.first]; // Take only the first byte for speed
        }
      } else if (pid == ObdConstants.pidEngineRpm) {
        // Engine RPM needs exactly 2 bytes
        if (dataBytes.length >= 2) {
          _logger.fine('Raw RPM bytes: ${dataBytes[0]}, ${dataBytes[1]}');
          _logger.fine('Cheap ELM - Calculated RPM: ${((dataBytes[0] * 256) + dataBytes[1]) / 4}');
          return [dataBytes[0], dataBytes[1]]; // Take only the first two bytes for RPM
        } else if (dataBytes.length == 1) {
          // Some adapters might send a single byte for zero RPM
          _logger.fine('Only one byte for RPM: ${dataBytes[0]}');
          
          // Treat single byte as low byte (B) instead of high byte (A)
          // This matches the behavior in PremiumElm327Processor and produces more realistic values
          _logger.fine('Cheap ELM - Single byte - Calculated RPM: ${((0 * 256) + dataBytes[0]) / 4}');
          return [0, dataBytes[0]]; // Use as low byte, not high byte
        }
      }
      
      _logger.fine('Final extracted data bytes for PID $pid: $dataBytes');
      return dataBytes;
    } catch (e) {
      _logger.warning('Error parsing response "$response" for PID $pid: $e');
      return [];
    }
  }
  
  @override
  String cleanResponse(String response) {
    // Cheap adapters often have additional non-standard characters
    // This more aggressive cleaning helps handle their quirks
    return response
        .replaceAll(RegExp(r'[\r\n>]'), ' ')  // Replace newlines, CR, prompt with space
        .replaceAll(RegExp(r'BUS INIT'), '')  // Remove BUS INIT messages
        .replaceAll(RegExp(r'SEARCHING'), '') // Remove SEARCHING messages
        .replaceAll(RegExp(r'STOPPED'), '')   // Remove STOPPED messages
        .replaceAll(RegExp(r'DATA ERROR'), '') // Remove DATA ERROR messages
        .replaceAll(RegExp(r'CAN ERROR'), '')  // Remove CAN ERROR messages
        .replaceAll(RegExp(r'UNABLE TO CONNECT'), '') // Remove connection error messages
        .replaceAll(RegExp(r'[^A-Fa-f0-9 ]'), '') // Keep only hex chars and spaces
        .replaceAll(RegExp(r'\s+'), ' ')      // Replace multiple spaces with single space
        .trim()
        .toUpperCase();
  }
} 

################################################################################
FILE: lib/obd_lib/protocol/response_processor/premium_elm327_processor.dart
################################################################################

import 'package:logging/logging.dart';
import '../../models/obd_command.dart';
import '../../models/obd_data.dart';
import '../obd_constants.dart';
import 'obd_response_processor.dart';

/// Processor for premium ELM327 adapters, which follow the standard OBD-II protocol more closely
///
/// This processor handles the more structured response formats from premium adapters
/// with proper headers and standardized formatting.
class PremiumElm327Processor extends ObdResponseProcessor {
  final Logger _logger = Logger('PremiumElm327Processor');
  
  // Validation thresholds
  static const int MAX_VALID_SPEED_KMH = 220; // Maximum realistic speed in km/h
  static const int MAX_VALID_RPM = 8000; // Maximum realistic RPM
  static const int MAX_VALID_COOLANT_TEMP = 150; // Maximum realistic coolant temperature in °C
  
  /// Whether to use lenient parsing (more tolerant of formatting issues)
  final bool lenientParsing;
  
  /// Whether to use adaptive timeouts based on response times
  final bool adaptiveTimeout;
  
  /// Multiplier to apply to timeouts (for different adapter versions)
  final double timeoutMultiplier;
  
  /// Recent speed values for smoothing
  final List<double> _recentSpeedValues = [];
  
  /// Define the maximum history size for smoothing
  static const int _maxHistorySize = 3;
  
  /// Define smoothing factors for different PIDs
  /// Premium adapters need less smoothing
  static const double _speedSmoothingFactor = 0.4; // 40% previous, 60% new
  
  /// Creates a new processor for premium ELM327 adapters
  PremiumElm327Processor({
    this.lenientParsing = false,
    this.adaptiveTimeout = true,
    this.timeoutMultiplier = 1.0,
  }) {
    _logger.info('Created premium ELM327 processor with lenientParsing=$lenientParsing, '
          'adaptiveTimeout=$adaptiveTimeout, timeoutMultiplier=$timeoutMultiplier');
  }
  
  @override
  ObdData? processDecodedData(ObdData data, String response, ObdCommand command) {
    // Apply PID-specific processing
    if (command.pid == ObdConstants.pidVehicleSpeed) {
      return _processSpeedData(data);
    }
    
    // For other PIDs, return the original data
    return data;
  }
  
  /// Apply minimal smoothing to speed data for premium adapters
  ObdData? _processSpeedData(ObdData data) {
    final dynamic rawValue = data.value;
    if (rawValue == null) return data;
    
    // Convert to double for smoothing
    double speedValue;
    if (rawValue is int) {
      speedValue = rawValue.toDouble();
    } else if (rawValue is double) {
      speedValue = rawValue;
    } else if (rawValue is String) {
      try {
        speedValue = double.parse(rawValue);
      } catch (e) {
        return data; // Can't smooth, return original
      }
    } else {
      return data; // Unknown type, return original
    }
    
    // Apply minimal smoothing only if we have previous values
    // Premium adapters generally need less smoothing
    double smoothedSpeed = speedValue;
    if (_recentSpeedValues.isNotEmpty) {
      smoothedSpeed = smoothValue(
        speedValue, 
        _recentSpeedValues, 
        _speedSmoothingFactor, 
        _maxHistorySize
      );
      
      // Round to nearest whole number for speed
      smoothedSpeed = smoothedSpeed.roundToDouble();
    }
    
    // Add the original value to history
    _recentSpeedValues.add(speedValue);
    if (_recentSpeedValues.length > _maxHistorySize) {
      _recentSpeedValues.removeAt(0);
    }
    
    // Return a new data object with the smoothed value
    return data.copyWith(
      value: smoothedSpeed.toInt(),
      timestamp: DateTime.now(),
    );
  }
  
  @override
  ObdData? processResponse(String response, ObdCommand command) {
    final bytes = parseResponseBytes(response, command.mode, command.pid);
    
    if (bytes.isEmpty) {
      _logger.warning('No bytes returned from response "$response" for PID ${command.pid}');
      return null;
    }
    
    // Based on the command mode and PID, decode the data appropriately
    if (command.mode == '01') {
      switch (command.pid) {
        case ObdConstants.pidSupportedPids:
          return _decodeSupportedPids(bytes, command);
        case ObdConstants.pidCoolantTemp:
          return _decodeCoolantTemp(bytes, command);
        case ObdConstants.pidEngineRpm:
          return decodeEngineRpm(bytes, command);
        case ObdConstants.pidVehicleSpeed:
          return decodeVehicleSpeed(bytes, command);
        case ObdConstants.pidControlModuleVoltage:
          return _decodeControlModuleVoltage(bytes, command);
        default:
          _logger.warning('Unsupported PID: ${command.pid}');
          return null;
      }
    }
    
    // Return raw data for unsupported modes
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: bytes,
      unit: 'raw',
      rawData: bytes,
    );
  }
  
  @override
  List<int> parseResponseBytes(String response, String mode, String pid) {
    try {
      // Log raw response before any processing
      _logger.fine('Premium ELM - Raw response for PID $pid: "$response"');
      
      // Clean up the response
      final cleaned = cleanResponse(response);
      
      // Log cleaned response
      _logger.fine('Premium ELM - After cleaning for PID $pid: "$cleaned"');
      
      // If response is empty or shows an error
      if (cleaned.isEmpty || cleaned.contains('ERROR') || cleaned.contains('NO DATA')) {
        _logger.warning('Empty or error response for PID $pid: "$cleaned"');
        return [];
      }
      
      // For mode 01 commands, the response header is '41' followed by the PID
      String expectedHeader;
      if (mode == '01') {
        // For mode 01, the response header is always '41' followed by the PID
        expectedHeader = '41${pid.toUpperCase()}';
      } else {
        // For other modes, calculate header as mode + 0x40
        expectedHeader = '${(int.parse(mode, radix: 16) + 40).toRadixString(16).padLeft(2, '0').toUpperCase()}${pid.toUpperCase()}';
      }
      
      _logger.fine('Premium ELM - Looking for header: $expectedHeader in response: $cleaned');
      
      // Premium adapters often send responses in standard format with proper headers
      
      // Split response by spaces
      final parts = cleaned.split(' ');
      _logger.fine('Premium ELM - Split parts: $parts');
      
      List<int> dataBytes = [];
      
      // Remove any non-hex characters that might have been missed in cleaning
      for (int i = 0; i < parts.length; i++) {
        parts[i] = parts[i].replaceAll(RegExp(r'[^A-Fa-f0-9]'), '');
      }
      
      // Remove any empty parts
      parts.removeWhere((part) => part.isEmpty);
      
      if (parts.isEmpty) {
        _logger.warning('No valid hex parts found in response for PID $pid');
        return [];
      }
      
      // First try standard format where header and data are in separate parts
      bool found = false;
      
      // Case 1: Header and PID as separate parts (e.g., "41 0C 1A 2B")
      for (int i = 0; i < parts.length - 1; i++) {
        if (parts[i] == '41' && parts[i + 1] == pid.toUpperCase()) {
          _logger.fine('Premium ELM - Found standard format header at index $i');
          
          // Extract data bytes (starting from i+2)
          for (int j = i + 2; j < parts.length; j++) {
            if (parts[j].length == 2) {
              try {
                final byteValue = int.parse(parts[j], radix: 16);
                dataBytes.add(byteValue);
                _logger.fine('Premium ELM - Extracted byte: $byteValue (hex: ${parts[j]})');
              } catch (e) {
                _logger.warning('Error parsing hex byte: $e');
              }
            }
          }
          found = true;
          break;
        }
      }
      
      // Case 2: Header and PID combined (e.g., "410C 1A 2B")
      if (!found) {
        for (int i = 0; i < parts.length; i++) {
          if (parts[i] == expectedHeader || parts[i].startsWith(expectedHeader)) {
            _logger.fine('Premium ELM - Found combined header at index $i');
            
            // If header and data are in the same part, extract the data portion
            if (parts[i].length > expectedHeader.length) {
              String dataHex = parts[i].substring(expectedHeader.length);
              
              // Parse data hex into bytes
              for (int j = 0; j < dataHex.length; j += 2) {
                if (j + 2 <= dataHex.length) {
                  try {
                    final byteValue = int.parse(dataHex.substring(j, j + 2), radix: 16);
                    dataBytes.add(byteValue);
                    _logger.fine('Premium ELM - Extracted byte: $byteValue from combined header');
                  } catch (e) {
                    _logger.warning('Error parsing hex byte: $e');
                  }
                }
              }
            }
            
            // Also check subsequent parts for additional data bytes
            for (int j = i + 1; j < parts.length; j++) {
              if (parts[j].length == 2) {
                try {
                  final byteValue = int.parse(parts[j], radix: 16);
                  dataBytes.add(byteValue);
                  _logger.fine('Premium ELM - Extracted byte: $byteValue (hex: ${parts[j]})');
                } catch (e) {
                  _logger.warning('Error parsing hex byte: $e');
                }
              }
            }
            
            found = true;
            break;
          }
        }
      }
      
      // Case 3: Fallback for non-standard responses (similar to cheap processor)
      if (!found || dataBytes.isEmpty) {
        _logger.fine('Premium ELM - No standard format found, trying fallback approach');
        
        for (String part in parts) {
          if (part.length == 2) {
            try {
              final byteValue = int.parse(part, radix: 16);
              dataBytes.add(byteValue);
              _logger.fine('Premium ELM - Fallback - Extracted byte: $byteValue (hex: $part)');
            } catch (e) {
              // Skip non-hex parts
              _logger.fine('Premium ELM - Fallback - Skipped non-hex part: $part');
            }
          }
        }
      }
      
      // PID-specific validation and processing (similar to cheap processor)
      if (pid == ObdConstants.pidVehicleSpeed) {
        // Vehicle speed should be just one byte
        if (dataBytes.isNotEmpty) {
          _logger.fine('Raw speed value: ${dataBytes.first}');
          return [dataBytes.first]; // Take only the first byte for speed
        }
      } else if (pid == ObdConstants.pidEngineRpm) {
        // Engine RPM needs exactly 2 bytes
        if (dataBytes.length >= 2) {
          _logger.fine('Raw RPM bytes: ${dataBytes[0]}, ${dataBytes[1]}');
          return [dataBytes[0], dataBytes[1]]; // Take only the first two bytes for RPM
        } else if (dataBytes.length == 1) {
          // Some adapters might send a single byte for zero RPM
          _logger.fine('Only one byte for RPM: ${dataBytes[0]}');
          return [0, dataBytes[0]]; // Use as low byte, not high byte
        }
      }
      
      _logger.fine('Final extracted data bytes for PID $pid: $dataBytes');
      return dataBytes;
    } catch (e) {
      _logger.warning('Error parsing response "$response" for PID $pid: $e');
      return [];
    }
  }
  
  /// Decode supported PIDs response
  ObdData _decodeSupportedPids(List<int> bytes, ObdCommand command) {
    if (bytes.length < 4) return createErrorData(command);
    
    final supportedPids = <String>[];
    
    // Each bit in the 4 bytes represents support for a specific PID
    for (int i = 0; i < 32; i++) {
      final byteIndex = i ~/ 8;
      final bitIndex = 7 - (i % 8);
      
      if ((bytes[byteIndex] & (1 << bitIndex)) != 0) {
        final pidNumber = i + 1;
        supportedPids.add(pidNumber.toRadixString(16).padLeft(2, '0').toUpperCase());
      }
    }
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: supportedPids,
      unit: 'PIDs',
      rawData: bytes,
    );
  }
  
  /// Decode coolant temperature response
  ObdData _decodeCoolantTemp(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) return createErrorData(command);
    
    // A - 40 = Temperature in Celsius
    int temperature = bytes[0] - 40;
    
    // Validate temperature range
    if (temperature > MAX_VALID_COOLANT_TEMP || temperature < -40) {
      _logger.warning('Unrealistic coolant temperature: $temperature°C. Using 0 instead.');
      temperature = 0;
    }
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: temperature,
      unit: '°C',
      rawData: bytes,
    );
  }
  
  /// Decode engine RPM response - Override from parent class
  @override
  ObdData decodeEngineRpm(List<int> bytes, ObdCommand command) {
    // If we have no bytes or if it's a STOPPED signal, return 0 RPM
    if (bytes.isEmpty) {
      _logger.warning('No bytes available for RPM calculation');
      return ObdData(
        mode: command.mode,
        pid: command.pid,
        name: command.name,
        value: 0,
        unit: 'RPM',
        rawData: [],
      );
    }
    
    // Handle case where only one byte is available
    if (bytes.length == 1) {
      // If only one byte, treat it as the low byte (B) for formula ((A * 256) + B) / 4
      _logger.fine('Only one byte available for RPM: treating ${bytes[0]} as low byte');
      double rpm = bytes[0] / 4.0; // B/4 since A=0
      
      return ObdData(
        mode: command.mode,
        pid: command.pid,
        name: command.name,
        value: rpm.round(),
        unit: 'RPM',
        rawData: bytes,
      );
    }
    
    // Standard case with 2 bytes
    // Calculate RPM: ((A * 256) + B) / 4
    double rpm = ((bytes[0] * 256) + bytes[1]) / 4;
    
    // Log the raw calculation for debugging
    _logger.fine('Raw RPM values: A=${bytes[0]}, B=${bytes[1]}, formula: ((${bytes[0]} * 256) + ${bytes[1]}) / 4 = $rpm');
    
    // More lenient validation - only reject truly unrealistic values (like > 20,000 RPM)
    // Most car engines redline between 5,000-9,000 RPM, with some exotic cars going up to 12,000
    // We'll be more permissive here to match the cheap processor behavior
    if (rpm > 20000) {
      _logger.warning('Extremely unrealistic RPM calculated: $rpm. Capping to 8000 RPM.');
      rpm = 8000;
    }
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: rpm.round(),
      unit: 'RPM',
      rawData: bytes,
    );
  }
  
  /// Decode vehicle speed response - Override from parent class
  @override
  ObdData decodeVehicleSpeed(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) return createErrorData(command);
    
    // Speed is simply the value of A in km/h
    int speed = bytes[0];
    
    // Log the raw speed value for debugging
    _logger.fine('Raw speed value: $speed km/h (hex: 0x${bytes[0].toRadixString(16).padLeft(2, '0')})');
    
    // Validate speed range
    if (speed > MAX_VALID_SPEED_KMH) {
      _logger.warning('Unrealistic speed calculated: $speed km/h. Using 0 instead.');
      speed = 0;
    }
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: speed,
      unit: 'km/h',
      rawData: bytes,
    );
  }
  
  /// Decode control module voltage response
  ObdData _decodeControlModuleVoltage(List<int> bytes, ObdCommand command) {
    if (bytes.length < 2) return createErrorData(command);
    
    // ((A * 256) + B) / 1000 = Voltage
    final voltage = ((bytes[0] * 256) + bytes[1]) / 1000;
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: voltage.toStringAsFixed(1),
      unit: 'V',
      rawData: bytes,
    );
  }
} 

################################################################################
FILE: lib/obd_lib/protocol/response_processor/obd_response_processor.dart
################################################################################

import 'package:logging/logging.dart';
import '../../models/obd_command.dart';
import '../../models/obd_data.dart';
import '../obd_data_parser.dart';

/// Base class for OBD response processors
/// 
/// This abstract class defines the interface for processing OBD responses
/// and converting them to [ObdData] objects.
abstract class ObdResponseProcessor {
  static final Logger _logger = Logger('ObdResponseProcessor');
  
  /// Process a raw response string and return an OBD data object
  /// 
  /// This method is responsible for:
  /// 1. Extracting relevant data from the raw response string
  /// 2. Converting the data to a structured OBD data object
  /// 3. Performing any necessary validation or filtering
  /// 
  /// Returns null if the response is invalid or could not be processed
  ObdData? processResponse(String response, ObdCommand command) {
    if (response.isEmpty) {
      _logger.warning('Empty response for command: ${command.command}');
      return null;
    }
    
    if (response.contains('NO DATA') || 
        response.contains('ERROR') || 
        response.contains('UNABLE TO CONNECT') ||
        response.contains('TIMEOUT')) {
      _logger.warning('Error response for command ${command.command}: $response');
      return null;
    }
    
    try {
      // Use the data parser to decode the response
      final data = ObdDataParser.decodeResponse(response, command);
      
      if (data != null) {
        // Let derived classes perform additional processing
        return processDecodedData(data, response, command);
      }
      
      return null;
    } catch (e) {
      _logger.severe('Error processing response for ${command.command}: $e');
      return null;
    }
  }
  
  /// Additional processing steps for decoded data
  /// 
  /// This method allows derived classes to perform additional processing
  /// on the decoded data, such as filtering, normalization, or smoothing.
  /// 
  /// The default implementation returns the data unmodified.
  ObdData? processDecodedData(ObdData data, String response, ObdCommand command) {
    return data;
  }
  
  /// Apply smoothing to a numeric value using a specific algorithm
  /// 
  /// This helper method allows derived classes to apply smoothing to measurements
  /// that might experience jitter or fluctuations due to adapter limitations.
  /// 
  /// Parameters:
  /// - newValue: the latest reading value
  /// - previousValues: a list of recent previous readings
  /// - smoothingFactor: 0-1 value determining smoothing intensity (0.8 = 80% previous, 20% new)
  /// - maxPreviousValues: the maximum number of previous values to consider
  double smoothValue(
    double newValue,
    List<double> previousValues,
    double smoothingFactor,
    int maxPreviousValues,
  ) {
    if (previousValues.isEmpty) {
      return newValue;
    }
    
    // Ensure we're not using too many previous values
    while (previousValues.length > maxPreviousValues) {
      previousValues.removeAt(0);
    }
    
    // Calculate weighted average with exponential weighting
    double smoothedValue = newValue * (1 - smoothingFactor);
    
    // Apply higher weight to more recent values
    for (int i = 0; i < previousValues.length; i++) {
      // Weight decreases exponentially as we go further back in history
      final weight = smoothingFactor * pow(0.5, i.toDouble());
      smoothedValue += previousValues[previousValues.length - 1 - i] * weight;
    }
    
    return smoothedValue;
  }
  
  /// Helper method: exponential function for smoothing
  double pow(double base, double exponent) {
    return base == 0 ? 0 : base * pow(base, exponent - 1);
  }
  
  /// Parse a raw response string into bytes for a specific PID
  List<int> parseResponseBytes(String response, String mode, String pid);
  
  /// Create error data for invalid responses
  ObdData createErrorData(ObdCommand command) {
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: null,
      unit: '',
      rawData: [],
    );
  }
  
  /// Clean up an OBD response - may be overridden by specific processors
  String cleanResponse(String response) {
    return response
        .replaceAll(RegExp(r'[\r\n>]'), ' ')  // Replace newlines, CR, prompt with space
        .replaceAll(RegExp(r'BUS INIT'), '')  // Remove BUS INIT messages
        .replaceAll(RegExp(r'SEARCHING'), '') // Remove SEARCHING messages
        .replaceAll(RegExp(r'[^A-Fa-f0-9 ]'), '') // Keep only hex chars and spaces
        .replaceAll(RegExp(r'\s+'), ' ')      // Replace multiple spaces with single space
        .trim()
        .toUpperCase();
  }
  
  /// Decode engine RPM response
  ObdData decodeEngineRpm(List<int> bytes, ObdCommand command) {
    if (bytes.length < 2) return createErrorData(command);
    
    // ((A * 256) + B) / 4 = RPM
    final rpm = ((bytes[0] * 256) + bytes[1]) / 4;
    
    // Log raw values for debugging
    _logger.fine('Raw RPM values: A=${bytes[0]}, B=${bytes[1]}, formula: ((${bytes[0]} * 256) + ${bytes[1]}) / 4 = $rpm');
    
    // Validate the RPM value (sanity check)
    if (rpm > 10000) {
      _logger.warning('Unrealistic RPM calculated: $rpm. Using 0 instead.');
      return ObdData(
        mode: command.mode,
        pid: command.pid,
        name: command.name,
        value: 0,
        unit: 'RPM',
        rawData: bytes,
      );
    }
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: rpm.round(),
      unit: 'RPM',
      rawData: bytes,
    );
  }
  
  /// Decode vehicle speed response
  ObdData decodeVehicleSpeed(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) {
      _logger.warning('Empty bytes array for vehicle speed');
      return createErrorData(command);
    }
    
    // A = Speed in km/h (first byte only)
    final speed = bytes[0];
    
    // Log raw value for debugging
    _logger.fine('Raw speed value: ${bytes[0]} km/h (hex: 0x${bytes[0].toRadixString(16)})');
    
    // Sanity check - speeds over 250 km/h are likely errors
    if (speed > 250) {
      _logger.warning('Unrealistic speed detected: $speed km/h. Using 0 instead.');
      return ObdData(
        mode: command.mode,
        pid: command.pid,
        name: command.name,
        value: 0,
        unit: 'km/h',
        rawData: bytes,
      );
    }
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: speed,
      unit: 'km/h',
      rawData: bytes,
    );
  }
} 

################################################################################
FILE: lib/obd_lib/protocol/response_processor/base_response_processor.dart
################################################################################

import 'package:logging/logging.dart';
import '../../models/obd_command.dart';
import '../../models/obd_data.dart';
import '../obd_constants.dart';
import 'obd_response_processor.dart';

/// Base implementation of the OBD response processor with common functionality
/// This class provides shared implementation details used by both cheap and premium processors
abstract class BaseResponseProcessor extends ObdResponseProcessor {
  final Logger _logger = Logger('BaseResponseProcessor');
  
  // Validation thresholds shared by all processor types
  static const int MAX_VALID_SPEED_KMH = 220; // Maximum realistic speed in km/h
  static const int MAX_VALID_RPM = 8000; // Maximum realistic RPM
  static const int MAX_VALID_COOLANT_TEMP = 150; // Maximum realistic coolant temperature in °C
  
  @override
  ObdData? processResponse(String response, ObdCommand command) {
    final bytes = parseResponseBytes(response, command.mode, command.pid);
    
    if (bytes.isEmpty) {
      _logger.warning('No bytes returned from response "$response" for PID ${command.pid}');
      return null;
    }
    
    // Based on the command mode and PID, decode the data appropriately
    if (command.mode == '01') {
      switch (command.pid) {
        case ObdConstants.pidSupportedPids:
          return decodeSupportedPids(bytes, command);
        case ObdConstants.pidCoolantTemp:
          return decodeCoolantTemp(bytes, command);
        case ObdConstants.pidEngineRpm:
          return decodeEngineRpm(bytes, command);
        case ObdConstants.pidVehicleSpeed:
          return decodeVehicleSpeed(bytes, command);
        case ObdConstants.pidControlModuleVoltage:
          return decodeControlModuleVoltage(bytes, command);
        default:
          _logger.warning('Unsupported PID: ${command.pid}');
          return null;
      }
    }
    
    // Return raw data for unsupported modes
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: bytes,
      unit: 'raw',
      rawData: bytes,
    );
  }
  
  /// Decode supported PIDs response
  ObdData decodeSupportedPids(List<int> bytes, ObdCommand command) {
    if (bytes.length < 4) return createErrorData(command);
    
    final supportedPids = <String>[];
    
    // Each bit in the 4 bytes represents support for a specific PID
    for (int i = 0; i < 32; i++) {
      final byteIndex = i ~/ 8;
      final bitIndex = 7 - (i % 8);
      
      if ((bytes[byteIndex] & (1 << bitIndex)) != 0) {
        final pidNumber = i + 1;
        final pidHex = pidNumber.toRadixString(16).padLeft(2, '0').toUpperCase();
        supportedPids.add(pidHex);
      }
    }
    
    _logger.fine('Supported PIDs: $supportedPids');
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: supportedPids,
      unit: 'PIDs',
      rawData: bytes,
    );
  }
  
  /// Decode coolant temperature response
  ObdData decodeCoolantTemp(List<int> bytes, ObdCommand command) {
    if (bytes.isEmpty) return createErrorData(command);
    
    // A - 40 = Temperature in °C
    final tempC = bytes[0] - 40;
    
    // Log raw value for debugging
    _logger.fine('Raw coolant temp value: ${bytes[0]} (${bytes[0].toRadixString(16)}), calculated: $tempC °C');
    
    // Validate the temperature (sanity check)
    if (tempC < -40 || tempC > MAX_VALID_COOLANT_TEMP) {
      _logger.warning('Unrealistic coolant temperature: $tempC °C. Using 0 instead.');
      return ObdData(
        mode: command.mode,
        pid: command.pid,
        name: command.name,
        value: 0,
        unit: '°C',
        rawData: bytes,
      );
    }
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: tempC,
      unit: '°C',
      rawData: bytes,
    );
  }
  
  /// Decode control module voltage response
  ObdData decodeControlModuleVoltage(List<int> bytes, ObdCommand command) {
    if (bytes.length < 2) return createErrorData(command);
    
    // ((A * 256) + B) / 1000 = Voltage in V
    final voltage = ((bytes[0] * 256) + bytes[1]) / 1000;
    
    // Log raw values for debugging
    _logger.fine('Raw voltage values: A=${bytes[0]}, B=${bytes[1]}, formula: ((${bytes[0]} * 256) + ${bytes[1]}) / 1000 = $voltage V');
    
    // Validate the voltage (sanity check)
    if (voltage < 5 || voltage > 20) {
      _logger.warning('Unrealistic voltage calculated: $voltage V. Using 12 instead.');
      return ObdData(
        mode: command.mode,
        pid: command.pid,
        name: command.name,
        value: 12.0,
        unit: 'V',
        rawData: bytes,
      );
    }
    
    return ObdData(
      mode: command.mode,
      pid: command.pid,
      name: command.name,
      value: voltage,
      unit: 'V',
      rawData: bytes,
    );
  }
  
  /// Template method to be implemented by specific processors
  /// Each processor type will implement its own parsing strategy
  @override
  List<int> parseResponseBytes(String response, String mode, String pid);
} 

################################################################################
FILE: lib/obd_lib/protocol/response_processor/processor_factory.dart
################################################################################

import 'package:logging/logging.dart';
import 'obd_response_processor.dart';
import 'cheap_elm327_processor.dart';
import 'premium_elm327_processor.dart';
// Import additional processor classes as needed

/// Factory for creating appropriate response processors based on adapter type
///
/// This class provides factory methods for creating response processors
/// that are appropriate for different types of adapters.
class ResponseProcessorFactory {
  static final Logger _logger = Logger('ResponseProcessorFactory');
  
  // Private constructor to prevent instantiation
  ResponseProcessorFactory._();
  
  /// Creates the appropriate response processor for the adapter profile
  static ObdResponseProcessor createProcessor(String adapterProfile, bool lenientParsing) {
    _logger.info('Creating response processor for adapter profile: $adapterProfile');
    
    switch (adapterProfile) {
      case 'cheap_elm327':
        return CheapElm327Processor(lenientParsing: lenientParsing);
      case 'premium_elm327':
        return PremiumElm327Processor(lenientParsing: lenientParsing);
      case 'elm327_v13':
        // v1.3 adapters use a processor similar to premium but with some adjustments
        return PremiumElm327Processor(
          lenientParsing: lenientParsing,
          adaptiveTimeout: true,
          timeoutMultiplier: 1.25, // Older adapters need longer timeouts
        );
      case 'elm327_v15':
        // v1.5 adapters are a good middle ground
        return PremiumElm327Processor(
          lenientParsing: lenientParsing,
          adaptiveTimeout: true,
          timeoutMultiplier: 1.1, // Slightly longer timeouts
        );
      case 'elm327_v20':
        // v2.0+ adapters are faster
        return PremiumElm327Processor(
          lenientParsing: lenientParsing,
          adaptiveTimeout: true,
          timeoutMultiplier: 0.9, // Slightly shorter timeouts for newer adapters
        );
      default:
        // Default to cheap ELM327 processor as it's more robust
        return CheapElm327Processor(lenientParsing: lenientParsing);
    }
  }
} 

################################################################################
FILE: lib/obd_lib/cli/test_commands.dart
################################################################################

import 'dart:async';
import 'package:logging/logging.dart';
import '../interfaces/obd_connection.dart';
import '../protocol/elm327_protocol.dart';
import '../protocol/obd_constants.dart';
import '../models/obd_command.dart';

/// Class containing commands for testing OBD functionality
class TestCommands {
  static final Logger _logger = Logger('TestCommands');
  
  /// Test speed and throttle position readings with smoothing and improved validation
  static Future<void> testSpeedAndThrottleReadings({
    required ObdConnection connection,
    int iterations = 10,
    int delayMs = 500,
  }) async {
    _logger.info('Testing speed and throttle readings with improved processing');
    
    // Initialize protocol
    final protocol = Elm327Protocol(connection, isDebugMode: true);
    
    // Initialize the protocol
    if (!await protocol.initialize()) {
      _logger.severe('Failed to initialize protocol');
      return;
    }
    
    _logger.info('Protocol initialized successfully');
    
    // Set up a stream subscription for data
    StreamSubscription? subscription;
    subscription = protocol.obdDataStream.listen((data) {
      if (data.pid == ObdConstants.pidVehicleSpeed) {
        _logger.info('Speed: ${data.value} ${data.unit}');
      } else if (data.pid == ObdConstants.pidThrottlePosition) {
        _logger.info('Throttle: ${data.value} ${data.unit}');
      } else if (data.pid == ObdConstants.pidEngineRpm) {
        _logger.info('RPM: ${data.value} ${data.unit}');
      }
    });
    
    // Create commands to test
    final speedCommand = ObdCommand.mode01(
      ObdConstants.pidVehicleSpeed,
      name: 'Vehicle Speed',
      description: 'Current vehicle speed',
    );
    
    final throttleCommand = ObdCommand.mode01(
      ObdConstants.pidThrottlePosition,
      name: 'Throttle Position',
      description: 'Current throttle position',
    );
    
    final rpmCommand = ObdCommand.mode01(
      ObdConstants.pidEngineRpm,
      name: 'Engine RPM',
      description: 'Current engine RPM',
    );
    
    // Run the test for specified iterations
    for (int i = 0; i < iterations; i++) {
      _logger.info('Iteration ${i + 1}/$iterations');
      
      try {
        // Request RPM
        await protocol.sendObdCommand(rpmCommand);
        
        // Request speed
        await protocol.sendObdCommand(speedCommand);
        
        // Request throttle position
        await protocol.sendObdCommand(throttleCommand);
        
        // Wait for the next iteration
        await Future.delayed(Duration(milliseconds: delayMs));
      } catch (e) {
        _logger.severe('Error during test: $e');
      }
    }
    
    // Cancel the subscription
    await subscription.cancel();
    
    _logger.info('Test completed');
  }
} 

################################################################################
FILE: lib/obd_lib/bluetooth/response_processor.dart
################################################################################

import 'dart:convert';
import 'package:logging/logging.dart';

/// Interface for processing OBD adapter responses
///
/// This interface allows for adapter-specific processing of command
/// strings and response data, enabling different adapters to use
/// different data formats without requiring subclassing.
abstract class ResponseProcessor {
  /// Process an outgoing command before sending to the adapter
  String processOutgoingCommand(String command);
  
  /// Process incoming raw data from the adapter
  /// 
  /// Takes raw bytes from the adapter and returns a decoded string.
  /// This allows adapter-specific handling of special characters,
  /// encoding issues, etc.
  String processIncomingData(List<int> data, bool isDebugMode);
}

/// Standard response processor for most ELM327 adapters
///
/// Uses standard UTF-8 encoding with basic sanitization.
class StandardResponseProcessor implements ResponseProcessor {
  final Logger _logger = Logger('StandardResponseProcessor');
  
  @override
  String processOutgoingCommand(String command) {
    // No special processing needed for standard adapters
    return command;
  }
  
  @override
  String processIncomingData(List<int> data, bool isDebugMode) {
    if (data.isEmpty) return '';
    
    try {
      // Log the raw bytes for debugging
      if (isDebugMode) {
        _logger.fine('Received raw bytes: ${data.map((b) => '0x${b.toRadixString(16).padLeft(2, '0')}').join(' ')}');
      }
      
      // Basic sanitization - keep only valid ASCII printable chars and control chars
      final cleanedData = data.where((byte) => 
        byte == 0x0D || // CR
        byte == 0x0A || // LF
        byte == 0x3E || // >
        (byte >= 0x20 && byte <= 0x7E) // Printable ASCII
      ).toList();
      
      // Log if data was sanitized
      if (isDebugMode && cleanedData.length != data.length) {
        _logger.fine('Sanitized ${data.length - cleanedData.length} non-printable bytes from response');
      }
      
      // Convert the cleaned data to a string
      String receivedText;
      try {
        receivedText = utf8.decode(cleanedData);
      } catch (e) {
        // If decoding still fails, use a more robust approach
        _logger.warning('UTF-8 decode failed, using direct character conversion: $e');
        receivedText = cleanedData.map((b) => String.fromCharCode(b)).join('');
      }
      
      if (isDebugMode) {
        _logger.fine('Decoded text: $receivedText');
      }
      
      return receivedText;
    } catch (e) {
      _logger.warning('Error processing incoming data: $e');
      return ''; // Return empty string on error
    }
  }
}

/// Premium response processor for high-quality ELM327 adapters
///
/// Handles specific encoding issues observed with premium adapters,
/// particularly the 0xFC byte that can cause UTF-8 decoding errors.
class PremiumResponseProcessor implements ResponseProcessor {
  final Logger _logger = Logger('PremiumResponseProcessor');
  
  @override
  String processOutgoingCommand(String command) {
    // Add a small delay before each command
    // This is handled in the protocol, not here
    return command;
  }
  
  @override
  String processIncomingData(List<int> data, bool isDebugMode) {
    if (data.isEmpty) return '';
    
    try {
      // Log the raw bytes for debugging
      if (isDebugMode) {
        _logger.fine('Premium received raw bytes: ${data.map((b) => '0x${b.toRadixString(16).padLeft(2, '0')}').join(' ')}');
      }
      
      // More aggressive filtering for premium adapters
      // Specifically exclude the 0xFC byte that causes UTF-8 decoding issues
      final cleanedData = data.where((byte) => 
        byte == 0x0D || // CR
        byte == 0x0A || // LF
        byte == 0x3E || // >
        (byte >= 0x20 && byte <= 0x7E) && // Printable ASCII
        byte != 0xFC // Exclude the problematic byte
      ).toList();
      
      // Log if data was sanitized
      if (isDebugMode && cleanedData.length != data.length) {
        _logger.fine('Premium sanitized ${data.length - cleanedData.length} non-standard bytes from response');
      }
      
      // Try UTF-8 first, fall back to Latin1
      String receivedText;
      try {
        receivedText = utf8.decode(cleanedData);
      } catch (e) {
        // Latin1 can handle all byte values 0-255
        _logger.warning('Premium UTF-8 decode failed, using Latin1 encoding: $e');
        receivedText = latin1.decode(cleanedData);
      }
      
      if (isDebugMode) {
        _logger.fine('Premium decoded text: $receivedText');
      }
      
      return receivedText;
    } catch (e) {
      _logger.warning('Premium error processing incoming data: $e');
      return ''; // Return empty string on error
    }
  }
} 

################################################################################
FILE: lib/obd_lib/bluetooth/bluetooth_scanner.dart
################################################################################

import 'dart:async';
import 'package:flutter_reactive_ble/flutter_reactive_ble.dart' hide Logger;
import 'package:logging/logging.dart';
import '../models/bluetooth_device.dart';

/// Scanner for discovering Bluetooth devices
class BluetoothScanner {
  static final Logger _logger = Logger('BluetoothScanner');
  
  /// The Flutter Reactive BLE instance
  final FlutterReactiveBle _ble;
  
  /// Stream controller for discovered devices
  final _deviceStreamController = StreamController<List<BluetoothDevice>>.broadcast();
  
  /// List of discovered devices
  final List<BluetoothDevice> _discoveredDevices = [];
  
  /// Scan subscription
  StreamSubscription? _scanSubscription;
  
  /// Whether a scan is in progress
  bool _isScanning = false;
  
  /// Creates a new Bluetooth scanner
  BluetoothScanner({FlutterReactiveBle? ble}) : _ble = ble ?? FlutterReactiveBle();
  
  /// Stream of discovered devices
  Stream<List<BluetoothDevice>> get devices => _deviceStreamController.stream;
  
  /// Whether a scan is in progress
  bool get isScanning => _isScanning;
  
  /// Start scanning for Bluetooth devices
  Future<void> startScan({Duration? timeout}) async {
    if (_isScanning) {
      _logger.warning('Scan already in progress');
      return;
    }
    
    _logger.info('Starting Bluetooth scan');
    _isScanning = true;
    _discoveredDevices.clear();
    _deviceStreamController.add(_discoveredDevices);
    
    try {
      _scanSubscription = _ble.scanForDevices(
        withServices: [], // Empty list means scan for all devices
        scanMode: ScanMode.lowLatency,
      ).listen((device) {
        // Only add devices that have a name
        if (device.name.isNotEmpty) {
          _handleDiscoveredDevice(device);
        }
      }, onError: (error) {
        _logger.severe('Scan error: $error');
      });
      
      // Set up a timeout if specified
      if (timeout != null) {
        Future.delayed(timeout, () => stopScan());
      }
    } catch (e) {
      _logger.severe('Error starting scan: $e');
      _isScanning = false;
    }
  }
  
  /// Stop scanning for Bluetooth devices
  Future<void> stopScan() async {
    if (!_isScanning) {
      return;
    }
    
    _logger.info('Stopping Bluetooth scan');
    
    await _scanSubscription?.cancel();
    _scanSubscription = null;
    _isScanning = false;
  }
  
  /// Handle a discovered device
  void _handleDiscoveredDevice(DiscoveredDevice device) {
    final bluetoothDevice = BluetoothDevice(
      id: device.id,
      name: device.name,
      rssi: device.rssi,
      isConnectable: device.connectable == Connectable.available,
    );
    
    // Check if we already discovered this device
    final index = _discoveredDevices.indexWhere((d) => d.id == bluetoothDevice.id);
    
    if (index >= 0) {
      // Update the existing device
      _discoveredDevices[index] = bluetoothDevice;
    } else {
      // Add the new device
      _discoveredDevices.add(bluetoothDevice);
      // Use fine level for device discovery to reduce log spam
      _logger.fine('Discovered device: ${bluetoothDevice.name} (${bluetoothDevice.id})');
    }
    
    // Notify listeners
    _deviceStreamController.add(_discoveredDevices);
  }
  
  /// Dispose the scanner and release resources
  Future<void> dispose() async {
    await stopScan();
    await _deviceStreamController.close();
  }
} 

################################################################################
FILE: lib/obd_lib/bluetooth/bluetooth_connection.dart
################################################################################

import 'dart:async';
import 'dart:convert';
import 'package:flutter_reactive_ble/flutter_reactive_ble.dart' hide Logger;
import 'package:logging/logging.dart';
import '../interfaces/obd_connection.dart';
import '../protocol/obd_constants.dart';
import 'response_processor.dart';

/// Bluetooth implementation of OBD connection for ELM327 adapters
class BluetoothConnection implements ObdConnection {
  static final Logger _logger = Logger('BluetoothConnection');
  
  /// The device ID to connect to
  final String _deviceId;
  
  /// The Flutter Reactive BLE instance
  final FlutterReactiveBle _ble;
  
  /// Debug mode flag
  final bool _isDebugMode;
  
  /// Connection status
  bool _isConnected = false;
  
  /// Stream controller for incoming data
  final _dataStreamController = StreamController<String>.broadcast();
  
  /// Subscription to connection state changes
  StreamSubscription? _connectionSubscription;
  
  /// Subscription to characteristic notifications
  StreamSubscription? _characteristicSubscription;
  
  /// Write characteristic for sending commands
  QualifiedCharacteristic? _writeCharacteristic;
  
  /// Notify characteristic for receiving responses
  QualifiedCharacteristic? _notifyCharacteristic;
  
  /// Response buffer for collecting partial responses
  final StringBuffer _responseBuffer = StringBuffer();
  
  /// Response timer for processing complete responses
  Timer? _responseTimer;
  
  /// Flag to track when we're waiting for a response
  bool _awaitingResponse = false;
  
  /// The last command sent - for debugging purposes
  String _lastCommand = '';
  
  /// The response processor to use for this connection
  final ResponseProcessor _responseProcessor;
  
  /// Creates a new Bluetooth connection to an OBD-II adapter
  BluetoothConnection(
    this._deviceId, {
    FlutterReactiveBle? ble,
    bool isDebugMode = false,
    ResponseProcessor? responseProcessor,
  })  : _ble = ble ?? FlutterReactiveBle(),
        _isDebugMode = isDebugMode,
        _responseProcessor = responseProcessor ?? StandardResponseProcessor();
  
  /// Get the device ID
  String get deviceId => _deviceId;
  
  @override
  Stream<String> get dataStream => _dataStreamController.stream;
  
  @override
  bool get isConnected => _isConnected;
  
  @override
  Future<bool> connect() async {
    _logger.info('Connecting to Bluetooth device: $_deviceId');
    
    try {
      // Connect to the device with proper timeout based on platform
      // Android typically needs a longer timeout for BLE connection
      final connectionTimeout = const Duration(milliseconds: ObdConstants.connectionTimeoutMs);
      
      _connectionSubscription = _ble.connectToDevice(
        id: _deviceId,
        connectionTimeout: connectionTimeout,
      ).listen((connectionState) {
        _handleConnectionStateChange(connectionState);
      }, onError: (error) {
        _logger.severe('Connection error: $error');
        _isConnected = false;
        _dataStreamController.add('ERROR: $error');
      });
      
      // Wait for connection to establish with a reasonable timeout
      // The completion timeout is longer than the connection timeout to account for service discovery
      final completer = Completer<bool>();
      
      // Set up a timer to handle connection timeout
      Timer? timeoutTimer;
      timeoutTimer = Timer(Duration(milliseconds: ObdConstants.connectionTimeoutMs * 2), () {
        if (!completer.isCompleted) {
          _logger.warning('Connection timed out');
          completer.complete(false);
        }
      });
      
      // Listen for connection state changes
      final subscription = _dataStreamController.stream.listen((data) {
        if (data == 'CONNECTED' && !completer.isCompleted) {
          timeoutTimer?.cancel();
          completer.complete(true);
        } else if (data.startsWith('ERROR:') && !completer.isCompleted) {
          timeoutTimer?.cancel();
          completer.complete(false);
        }
      });
      
      // Wait for connection result
      final result = await completer.future;
      
      // Clean up
      subscription.cancel();
      timeoutTimer.cancel();
      
      return result;
    } catch (e) {
      _logger.severe('Failed to connect: $e');
      return false;
    }
  }
  
  /// Handle connection state changes
  void _handleConnectionStateChange(ConnectionStateUpdate state) {
    _logger.info('Connection state: ${state.connectionState}');
    
    switch (state.connectionState) {
      case DeviceConnectionState.connected:
        _isConnected = true;
        _dataStreamController.add('CONNECTED');
        _discoverServices();
        break;
      case DeviceConnectionState.disconnected:
        _isConnected = false;
        _clearResponseBuffer();
        _dataStreamController.add('DISCONNECTED');
        break;
      default:
        // Ignore other states
        break;
    }
  }
  
  /// Discover services and characteristics
  Future<void> _discoverServices() async {
    _logger.info('Discovering services...');
    
    try {
      // Use the original method with @SuppressWarnings to avoid linter warnings
      // ignore: deprecated_member_use
      final services = await _ble.discoverServices(_deviceId);
      _logger.info('Found ${services.length} services');
      
      // Get the target UUIDs with proper formatting for cross-platform compatibility
      // Match either the full UUID or the short 4-character UUID
      final targetServiceUuid = ObdConstants.serviceUuid.toLowerCase();
      final targetNotifyUuid = ObdConstants.notifyCharacteristicUuid.toLowerCase();
      final targetWriteUuid = ObdConstants.writeCharacteristicUuid.toLowerCase();
      
      // Extract short UUIDs (the 4-character version) for alternative matching
      final shortServiceUuid = targetServiceUuid.contains('0000') ? 
          targetServiceUuid.split('-')[0].substring(4, 8) : 
          targetServiceUuid;
      
      final shortNotifyUuid = targetNotifyUuid.contains('0000') ? 
          targetNotifyUuid.split('-')[0].substring(4, 8) : 
          targetNotifyUuid;
      
      final shortWriteUuid = targetWriteUuid.contains('0000') ? 
          targetWriteUuid.split('-')[0].substring(4, 8) : 
          targetWriteUuid;
      
      // Log the UUIDs we're looking for
      _logger.info('Looking for service UUID: $targetServiceUuid or $shortServiceUuid');
      _logger.info('Looking for notify UUID: $targetNotifyUuid or $shortNotifyUuid');
      _logger.info('Looking for write UUID: $targetWriteUuid or $shortWriteUuid');
      
      // For cross-platform compatibility, we need to handle UUID matching
      // with flexible rules that work on both Android and iOS
      bool isTargetService(String serviceIdStr) {
        // Convert to lowercase for case-insensitive comparison
        serviceIdStr = serviceIdStr.toLowerCase();
        
        // Check multiple formats: full UUID or the short 4-character version
        return serviceIdStr.contains(targetServiceUuid) || 
               serviceIdStr.contains(shortServiceUuid);
      }
      
      bool isTargetCharacteristic(String charIdStr, String fullUuid, String shortUuid) {
        // Convert to lowercase for case-insensitive comparison
        charIdStr = charIdStr.toLowerCase();
        
        // Check multiple formats
        return charIdStr.contains(fullUuid) || 
               charIdStr.contains(shortUuid);
      }
      
      // Log all services and characteristics for debugging
      for (final service in services) {
        // Get service UUID string
        final serviceIdStr = service.serviceId.toString().toLowerCase();
        _logger.info('Service: $serviceIdStr');
        
        // Check if this is the service we're looking for
        final isOurTargetService = isTargetService(serviceIdStr);
        
        for (final characteristic in service.characteristics) {
          // Get characteristic UUID string
          final characteristicIdStr = characteristic.characteristicId.toString().toLowerCase();
          
          // Log properties for debugging
          final propertyFlags = <String>[];
          if (characteristic.isReadable) propertyFlags.add('READ');
          if (characteristic.isWritableWithoutResponse) propertyFlags.add('WRITE_NO_RESPONSE');
          if (characteristic.isWritableWithResponse) propertyFlags.add('WRITE');
          if (characteristic.isNotifiable) propertyFlags.add('NOTIFY');
          if (characteristic.isIndicatable) propertyFlags.add('INDICATE');
          
          _logger.info('  Characteristic: $characteristicIdStr [${propertyFlags.join(", ")}]');
          
          // If this is our target service, look for the characteristics
          if (isOurTargetService) {
            // Set up the write characteristic
            if ((characteristic.isWritableWithResponse || characteristic.isWritableWithoutResponse) &&
                isTargetCharacteristic(characteristicIdStr, targetWriteUuid, shortWriteUuid)) {
              _writeCharacteristic = QualifiedCharacteristic(
                serviceId: service.serviceId,
                characteristicId: characteristic.characteristicId,
                deviceId: _deviceId,
              );
              _logger.info('  Selected for WRITE: ${characteristic.characteristicId}');
            }
            
            // Set up the notify characteristic
            if ((characteristic.isNotifiable || characteristic.isIndicatable) &&
                isTargetCharacteristic(characteristicIdStr, targetNotifyUuid, shortNotifyUuid)) {
              _notifyCharacteristic = QualifiedCharacteristic(
                serviceId: service.serviceId,
                characteristicId: characteristic.characteristicId,
                deviceId: _deviceId,
              );
              _logger.info('  Selected for NOTIFY: ${characteristic.characteristicId}');
            }
          }
        }
      }
      
      // If we found the characteristics, set up the communication
      if (_notifyCharacteristic != null) {
        await _subscribeToNotifications();
      } else {
        _logger.warning('No notify characteristic found');
        _dataStreamController.add('ERROR: No notify characteristic found');
        // Update connection status since we can't communicate without notify characteristic
        _isConnected = false;
      }
      
      if (_writeCharacteristic == null) {
        _logger.warning('No write characteristic found');
        _dataStreamController.add('ERROR: No write characteristic found');
        // Update connection status since we can't communicate without write characteristic
        _isConnected = false;
      }
      
      // Connection is only complete if we have both characteristics
      if (_notifyCharacteristic != null && _writeCharacteristic != null) {
        _logger.info('Bluetooth fully connected with all required characteristics');
        // Wait an additional 2000ms as required by the rules for proper connection
        await Future.delayed(const Duration(milliseconds: 2000));
      } else {
        _logger.warning('Bluetooth connected but missing required characteristics');
        _isConnected = false;
      }
    } catch (e) {
      _logger.severe('Service discovery error: $e');
      _dataStreamController.add('ERROR: Service discovery error: $e');
      _isConnected = false;
    }
  }
  
  /// Subscribe to notifications from the OBD-II adapter
  Future<void> _subscribeToNotifications() async {
    if (_notifyCharacteristic == null) return;
    
    _logger.info('Subscribing to notifications');
    
    try {
      _characteristicSubscription = _ble.subscribeToCharacteristic(_notifyCharacteristic!).listen(
        (data) => _handleIncomingData(data),
        onError: (error) {
          _logger.severe('Notification error: $error');
          _dataStreamController.add('ERROR: Notification error: $error');
        },
      );
      
      _logger.info('Subscribed to notifications successfully');
    } catch (e) {
      _logger.severe('Failed to subscribe to notifications: $e');
      _dataStreamController.add('ERROR: Failed to subscribe to notifications: $e');
    }
  }
  
  /// Clear the response buffer and cancel the timer
  void _clearResponseBuffer() {
    _responseBuffer.clear();
    _responseTimer?.cancel();
    _responseTimer = null;
    _awaitingResponse = false;
  }
  
  /// Check if the response appears to be complete
  bool _isResponseComplete(String response) {
    // Check for common patterns indicating a complete response
    return response.endsWith('\r\n>') || 
           response.endsWith('\r>') || 
           response.endsWith('\n>') || 
           response.endsWith('>') ||
           response.contains('NO DATA') ||
           response.contains('ERROR');
  }
  
  /// Handle incoming data from the OBD-II adapter
  void _handleIncomingData(List<int> data) {
    if (data.isEmpty) return;
    
    try {
      // Use the response processor to handle adapter-specific data processing
      final receivedText = _responseProcessor.processIncomingData(data, _isDebugMode);
      
      // Add to the response buffer
      _responseBuffer.write(receivedText);
      final bufferContent = _responseBuffer.toString();
      
      // Reset the response timer
      _responseTimer?.cancel();
      _responseTimer = Timer(const Duration(milliseconds: ObdConstants.responseTimeoutMs), () {
        if (_responseBuffer.isEmpty) return;
        
        final response = _responseBuffer.toString().trim();
        _responseBuffer.clear();
        _awaitingResponse = false;
        
        if (response.isNotEmpty) {
          if (_isDebugMode) {
            _logger.info('Complete response (timeout) for command $_lastCommand: $response');
          } else {
            _logger.info('Complete response (timeout): $response');
          }
          _dataStreamController.add(response);
        }
      });
      
      // If the response appears complete, process it immediately
      if (_isResponseComplete(bufferContent)) {
        _responseTimer?.cancel();
        final response = bufferContent.trim();
        _responseBuffer.clear();
        _awaitingResponse = false;
        
        if (response.isNotEmpty) {
          if (_isDebugMode) {
            _logger.info('Complete response for command $_lastCommand: $response');
          } else {
            _logger.info('Complete response: $response');
          }
          _dataStreamController.add(response);
        }
      }
    } catch (e) {
      _logger.warning('Error handling incoming data: $e');
      
      // In case of error, clear the buffer and reset
      _clearResponseBuffer();
    }
  }
  
  @override
  Future<void> sendCommand(String command) async {
    if (!_isConnected) {
      _logger.warning('Cannot send command: not connected');
      _dataStreamController.add('ERROR: Cannot send command - not connected');
      return;
    }
    
    if (_writeCharacteristic == null) {
      _logger.warning('Cannot send command: no write characteristic');
      _dataStreamController.add('ERROR: Cannot send command - no write characteristic');
      return;
    }
    
    // Wait for any previous command to complete
    int attempts = 0;
    while (_awaitingResponse && attempts < 10) {
      await Future.delayed(const Duration(milliseconds: 50));
      attempts++;
    }
    
    // Process the command through the response processor
    final processedCommand = _responseProcessor.processOutgoingCommand(command);
    
    // Add the command terminator
    final fullCommand = processedCommand + ObdConstants.commandTerminator;
    _lastCommand = command;
    _awaitingResponse = true;
    
    if (_isDebugMode) {
      _logger.fine('Sending command: $command');
    }
    
    try {
      // Use write with response for more reliable communication
      await _ble.writeCharacteristicWithResponse(
        _writeCharacteristic!,
        value: utf8.encode(fullCommand),
      );
      
      if (_isDebugMode) {
        _logger.fine('Command sent successfully');
      }
    } catch (e) {
      _logger.severe('Error sending command: $e');
      _dataStreamController.add('ERROR: Failed to send command: $e');
      _awaitingResponse = false;
    }
  }
  
  @override
  Future<void> disconnect() async {
    _logger.info('Disconnecting from Bluetooth device');
    
    _isConnected = false;
    _clearResponseBuffer();
    await _characteristicSubscription?.cancel();
    await _connectionSubscription?.cancel();
    
    _characteristicSubscription = null;
    _connectionSubscription = null;
    
    _logger.info('Disconnected');
  }
  
  @override
  Future<void> dispose() async {
    _logger.info('Disposing Bluetooth connection');
    
    await disconnect();
    await _dataStreamController.close();
    
    _logger.info('Disposed');
  }
} 

################################################################################
FILE: lib/obd_lib/profiles/premium_elm327_profile.dart
################################################################################

import 'dart:async';
import 'package:logging/logging.dart';

import '../interfaces/obd_connection.dart';
import '../models/adapter_config.dart';
import '../models/adapter_config_factory.dart';
import '../protocol/obd_protocol.dart';
import '../protocol/elm327_protocol.dart';
import 'adapter_profile.dart';
import 'profile_manager.dart';

/// Profile for premium ELM327 adapters
///
/// This profile is optimized for more reliable, genuine ELM327 adapters
/// with better response times and stability.
class PremiumElm327Profile implements AdapterProfile {
  static final Logger _logger = Logger('PremiumElm327Profile');
  
  /// The configuration for this adapter
  @override
  final AdapterConfig config;
  
  /// Create a new premium ELM327 profile with default configuration
  PremiumElm327Profile() : config = AdapterConfigFactory.createPremiumElm327Config() {
    _logger.info('Created premium ELM327 profile with default configuration');
  }
  
  /// Create a new premium ELM327 profile with custom configuration
  PremiumElm327Profile.withConfig(this.config) {
    _logger.info('Created premium ELM327 profile with custom configuration');
  }
  
  @override
  String get profileId => 'premium_elm327';
  
  @override
  String get adapterName => 'Premium ELM327 Adapter';
  
  @override
  String get description => 
      'Profile for premium, genuine ELM327 adapters. '
      'Uses optimized settings for faster polling and better reliability.';
  
  // Bluetooth UUIDs - use the values from config for consistency
  @override
  String get serviceUuid => config.serviceUuid;
  
  @override
  String get notifyCharacteristicUuid => config.notifyCharacteristicUuid;
  
  @override
  String get writeCharacteristicUuid => config.writeCharacteristicUuid;
  
  // Timing parameters - use values from config for consistency
  @override
  int get responseTimeoutMs => config.responseTimeoutMs;
  
  @override
  int get connectionTimeoutMs => config.connectionTimeoutMs;
  
  @override
  int get commandTimeoutMs => config.commandTimeoutMs;
  
  @override
  int get initCommandDelayMs => config.initCommandDelayMs;
  
  @override
  int get resetDelayMs => config.resetDelayMs;
  
  // Polling intervals - use values from config for consistency
  @override
  int get defaultPollingInterval => config.defaultPollingInterval;
  
  @override
  int get slowPollingInterval => config.slowPollingInterval;
  
  @override
  int get engineOffPollingInterval => config.engineOffPollingInterval;
  
  // Error handling - use values from config for consistency
  @override
  int get maxRetries => config.maxRetries;
  
  @override
  Future<ObdProtocol> createProtocol(ObdConnection connection, {
    bool isDebugMode = false,
    ProfileManager? profileManager,
    String? deviceId,
  }) async {
    _logger.info('Creating protocol for premium ELM327 adapter');
    
    // Create a protocol instance with the appropriate configuration for premium adapters
    final protocol = Elm327Protocol(
      connection,
      isDebugMode: isDebugMode,
      adapterProfile: profileId,
      adapterConfig: config,
      profileManager: profileManager,
      deviceId: deviceId,
    );
    
    // Verify that configuration is appropriate for premium adapter
    if (config.useExtendedInitDelays) {
      _logger.warning('Warning: Premium ELM327 adapter configured with extended delays. '
          'This may not be optimal for performance.');
    }
    
    // Perform additional verification specific to premium adapters
    if (config.responseTimeoutMs > 200) {
      _logger.warning('Warning: Premium ELM327 adapter configured with long response timeout. '
          'This is typically not necessary for genuine adapters.');
    }
    
    return protocol;
  }
  
  @override
  Future<double> testCompatibility(ObdConnection connection, {bool isDebugMode = false}) async {
    _logger.info('Testing compatibility for premium ELM327 adapter');
    
    try {
      // Track specific indicators of premium adapter capabilities
      bool versionIndicatesPremium = false;
      bool formatIndicatesPremium = false;
      bool performanceIndicatesPremium = false;
      
      // Reset the adapter
      final resetResponse = await _sendCommandWithResponse(connection, 'ATZ');
      await Future.delayed(Duration(milliseconds: resetDelayMs));
      
      // Check if reset response looks like a premium adapter
      final resetCompatibility = _checkResponseFormat(resetResponse);
      
      // Check for version information indicating premium adapter
      if (resetResponse.contains('v1.5') || 
          resetResponse.contains('v2.1') ||
          resetResponse.contains('v2.2') ||
          resetResponse.contains('v2.3')) {
        versionIndicatesPremium = true;
        _logger.info('Version number indicates premium adapter: $resetResponse');
      }
      
      // Check for well-formatted response indicating premium adapter
      if (resetResponse.contains('ELM327') && resetResponse.contains('>') && !resetResponse.contains('?')) {
        formatIndicatesPremium = true;
        _logger.info('Response format indicates premium adapter');
      }
      
      // Turn echo off
      await connection.sendCommand('ATE0');
      await Future.delayed(Duration(milliseconds: initCommandDelayMs));
      
      // Get ELM version (AT@1) and measure response time
      final stopwatch = Stopwatch()..start();
      final versionResponse = await _sendCommandWithResponse(connection, 'AT@1');
      final responseTime = stopwatch.elapsedMilliseconds;
      stopwatch.stop();
      
      // Fast response time indicates premium adapter
      if (responseTime < 100) {
        performanceIndicatesPremium = true;
        _logger.info('Fast response time (${responseTime}ms) indicates premium adapter');
      }
      
      // Check if version response looks like a premium adapter
      final versionCompatibility = _checkResponseFormat(versionResponse);
      
      // Test additional advanced commands that premium adapters should support
      final supportedResponse = await _sendCommandWithResponse(connection, 'ATDPN');
      final protocolExistsResponse = await _sendCommandWithResponse(connection, 'ATDESC');
      
      // Premium adapters typically support more commands
      final advancedCommandSupport = supportedResponse.contains('OK') || !supportedResponse.contains('?');
      
      // Get supported PIDs (mode 01 pid 00)
      final pidsResponse = await _sendCommandWithResponse(connection, '0100');
      
      // Check if PIDs response has proper format
      final pidsCompatibility = _checkPidResponseFormat(pidsResponse);
      
      // Calculate overall compatibility score with more emphasis on premium-specific indicators
      double overallScore = 0.0;
      
      // Version indicators (30%)
      if (versionIndicatesPremium) {
        overallScore += 0.3;
      }
      
      // Format indicators (30%)
      overallScore += resetCompatibility * 0.15;
      overallScore += versionCompatibility * 0.15;
      
      // Performance indicators (20%)
      if (performanceIndicatesPremium) {
        overallScore += 0.2;
      }
      
      // Advanced features (10%)
      if (advancedCommandSupport) {
        overallScore += 0.1;
      }
      
      // Data format (10%)
      overallScore += pidsCompatibility * 0.1;
      
      _logger.info('Premium adapter compatibility score: $overallScore');
      
      // Add a bias against extremely low scores to avoid misidentification
      if (overallScore < 0.3) {
        overallScore = 0.1; // Very low score for unlikely matches
      }
      
      return overallScore;
    } catch (e) {
      _logger.warning('Error testing premium compatibility: $e');
      return 0.1;  // Low compatibility if errors occurred
    }
  }
  
  /// Send a command and wait for a response
  Future<String> _sendCommandWithResponse(ObdConnection connection, String command) async {
    final completer = Completer<String>();
    var responseBuffer = '';
    late StreamSubscription subscription;
    
    subscription = connection.dataStream.listen((data) {
      responseBuffer += data;
      
      // When we get a complete response (ends with prompt or has enough data)
      if (data.contains('>') || responseBuffer.length > 20) {
        if (!completer.isCompleted) {
          completer.complete(responseBuffer);
          subscription.cancel();
        }
      }
    });
    
    // Send the command
    await connection.sendCommand(command);
    
    // Set a timeout using the config value
    final timeout = Timer(Duration(milliseconds: commandTimeoutMs), () {
      if (!completer.isCompleted) {
        completer.complete(responseBuffer);
        subscription.cancel();
      }
    });
    
    try {
      return await completer.future;
    } finally {
      timeout.cancel();
    }
  }
  
  /// Check if a response follows premium adapter format
  double _checkResponseFormat(String response) {
    if (response.isEmpty) return 0.0;
    
    double score = 0.0;
    
    // Look for well-formed responses
    if (response.contains('ELM327')) score += 0.3;
    if (response.contains('v1.5') || 
        response.contains('v2.1') || 
        response.contains('v2.2') || 
        response.contains('v2.3')) {
      score += 0.3; // Higher score for version numbers (was 0.2)
    }
    if (response.contains('OK')) score += 0.2;
    if (response.contains('>')) score += 0.1;
    
    // Additional checks for premium adapter characteristics
    if (!response.contains('?')) score += 0.2;
    if (response.split('\r').length >= 2 || response.split('\n').length >= 2) {
      score += 0.1; // Proper line formatting
    }
    
    // Check for consistent formatting (lines ending with proper CR/LF)
    if ((response.contains('\r\n') || response.contains('\n\r')) && 
        !response.contains('??')) {
      score += 0.1;
    }
    
    return score;
  }
  
  /// Check if a PID response has the expected format for premium adapters
  double _checkPidResponseFormat(String response) {
    if (response.isEmpty) return 0.0;
    
    double score = 0.0;
    
    // Premium adapters typically respond with clean, structured data
    if (response.contains('41 00')) score += 0.4;
    if (!response.contains('SEARCHING')) score += 0.2;
    if (!response.contains('ERROR')) score += 0.2;
    if (response.split(' ').length >= 4) score += 0.2;  // Should have at least 4 parts
    
    // Additional checks for proper data formatting in premium adapters
    if (response.contains('41 00') && response.contains('>')) {
      score += 0.2; // Proper complete response with prompt
    }
    
    // Check for lack of repeat data (some cheap adapters repeat data)
    final lines = response.split('\r');
    final uniqueLines = lines.toSet().length;
    if (uniqueLines == lines.length) {
      score += 0.1; // No duplicate lines
    }
    
    // Check for proper byte spacing (premium adapters typically use space between bytes)
    if (response.contains(' ') && !response.contains('NO DATA')) {
      score += 0.1;
    }
    
    // Normalize to 0.0-1.0 range
    return score > 1.0 ? 1.0 : score;
  }
} 

################################################################################
FILE: lib/obd_lib/profiles/elm327_v20_profile.dart
################################################################################

import 'dart:async';
import 'package:logging/logging.dart';

import '../interfaces/obd_connection.dart';
import '../protocol/obd_protocol.dart';
import '../protocol/elm327_protocol.dart';
import '../models/adapter_config.dart';
import '../models/adapter_config_factory.dart';
import '../protocol/response_processor/processor_factory.dart';
import 'adapter_profile.dart';
import 'profile_manager.dart';

/// Profile for ELM327 v2.0+ adapters
///
/// This profile targets genuine ELM327 v2.0 and newer adapters, which offer
/// maximum performance with advanced features like message filtering,
/// better timing, and improved reliability.
class Elm327V20Profile extends AdapterProfile {
  static final Logger _logger = Logger('Elm327V20Profile');
  
  /// Configuration for this adapter profile
  final AdapterConfig _config;
  
  /// Create a new ELM327 v2.0 profile with default configuration
  Elm327V20Profile() : _config = AdapterConfigFactory.createElm327V20Config();
  
  /// Create a new ELM327 v2.0 profile with custom configuration
  Elm327V20Profile.withConfig(this._config);
  
  @override
  AdapterConfig get config => _config;
  
  @override
  Future<ObdProtocol> createProtocol(ObdConnection connection, {
    bool isDebugMode = false,
    ProfileManager? profileManager,
    String? deviceId,
  }) async {
    _logger.info('Creating ELM327 v2.0 protocol handler');
    
    // Create processor specifically optimized for v2.0 adapters
    final processor = ResponseProcessorFactory.createProcessor(
      'elm327_v20',
      _config.useLenientParsing,
    );
    
    return Elm327Protocol(
      connection,
      isDebugMode: isDebugMode,
      customResponseProcessor: processor,
      adapterConfig: _config,
      profileManager: profileManager,
      deviceId: deviceId,
    );
  }
  
  @override
  Future<double> testCompatibility(ObdConnection connection, {bool isDebugMode = false}) async {
    _logger.info('Testing compatibility for ELM327 v2.0 adapter');
    
    double score = 0.0;
    int totalTests = 0;
    
    try {
      // Create a temporary protocol instance for testing
      final protocol = await createProtocol(connection, isDebugMode: isDebugMode);
      
      // Test 1: Version check - look for v2.0+ in the adapter version string
      final version = await protocol.sendCommand('ATI');
      if (version.toLowerCase().contains('elm327 v2.0') || 
          version.toLowerCase().contains('elm327 v2.1') || 
          version.toLowerCase().contains('elm327 v2.2')) {
        score += 1.0;
        totalTests++;
      } else if (version.toLowerCase().contains('elm327') && 
                (version.toLowerCase().contains('2.0') || 
                 version.toLowerCase().contains('2.1') || 
                 version.toLowerCase().contains('2.2'))) {
        // Partial match, some adapters don't format version string exactly
        score += 0.8;
        totalTests++;
      } else {
        // Not a v2.0+ adapter
        score += 0.0;
        totalTests++;
      }
      
      // Test 2: CAN specific commands - v2.0 adapters have advanced CAN capabilities
      final canTest = await protocol.sendCommand('ATCF');
      if (!canTest.contains('?') && !canTest.contains('ERROR')) {
        score += 1.0;
        totalTests++;
      } else {
        score += 0.0;
        totalTests++;
      }
      
      // Test 3: Test for message filtering capability (v2.0+ feature)
      final cmTest = await protocol.sendCommand('ATCM');
      if (!cmTest.contains('?') && !cmTest.contains('ERROR')) {
        score += 1.0;
        totalTests++;
      } else {
        score += 0.0;
        totalTests++;
      }
      
      // Test 4: Speed test - v2.0 adapters are much faster
      final stopwatch = Stopwatch()..start();
      await protocol.sendCommand('ATH1');
      stopwatch.stop();
      
      // v2.0 adapters are very responsive (<30ms response time)
      if (stopwatch.elapsedMilliseconds < 30) {
        score += 1.0;
        totalTests++;
      } else if (stopwatch.elapsedMilliseconds < 50) {
        score += 0.5;
        totalTests++;
      } else {
        // Too slow for a v2.0 adapter
        score += 0.0;
        totalTests++;
      }
      
      // Test 5: Advanced protocol support - v2.0 supports more protocols
      final protocolTest = await protocol.sendCommand('ATDPN');
      // Genuine v2.0 adapters return protocol number without errors
      if (!protocolTest.contains('?') && protocolTest.trim().length <= 2) {
        score += 1.0;
        totalTests++;
      } else {
        score += 0.0;
        totalTests++;
      }
      
      // Calculate final score (0.0 to 1.0)
      return totalTests > 0 ? score / totalTests : 0.0;
    } catch (e) {
      _logger.warning('Error during compatibility test: $e');
      return 0.0; // Not compatible if exceptions occur
    }
  }
} 

################################################################################
FILE: lib/obd_lib/profiles/cheap_elm327_profile.dart
################################################################################

import 'dart:async';
import 'package:logging/logging.dart';

import '../interfaces/obd_connection.dart';
import '../models/adapter_config.dart';
import '../models/adapter_config_factory.dart';
import '../protocol/elm327_protocol.dart';
import '../protocol/obd_constants.dart';
import '../protocol/obd_protocol.dart';
import 'adapter_profile.dart';
import 'profile_manager.dart';

/// Profile for the cheap ELM327 adapter
///
/// This profile preserves the exact configuration and behavior
/// of the original implementation for the cheap, unreliable adapter.
class CheapElm327Profile implements AdapterProfile {
  static final Logger _logger = Logger('CheapElm327Profile');
  
  /// The configuration for this adapter
  @override
  final AdapterConfig config;
  
  /// Create a new cheap ELM327 profile with default configuration
  CheapElm327Profile() : config = AdapterConfigFactory.createCheapElm327Config() {
    _logger.info('Created cheap ELM327 profile with default configuration');
  }
  
  /// Create a new cheap ELM327 profile with custom configuration
  CheapElm327Profile.withConfig(this.config) {
    _logger.info('Created cheap ELM327 profile with custom configuration');
  }

  @override
  String get profileId => 'cheap_elm327';
  
  @override
  String get adapterName => 'Cheap ELM327 Adapter';
  
  @override
  String get description => 
      'Profile for cheap, possibly counterfeit ELM327 adapters. '
      'Uses conservative settings for maximum compatibility with unreliable devices.';
  
  @override
  String get serviceUuid => ObdConstants.serviceUuid;
  
  @override
  String get notifyCharacteristicUuid => ObdConstants.notifyCharacteristicUuid;
  
  @override
  String get writeCharacteristicUuid => ObdConstants.writeCharacteristicUuid;
  
  @override
  int get responseTimeoutMs => ObdConstants.responseTimeoutMs;
  
  @override
  int get connectionTimeoutMs => ObdConstants.connectionTimeoutMs;
  
  @override
  int get commandTimeoutMs => ObdConstants.commandTimeoutMs;
  
  @override
  int get initCommandDelayMs => ObdConstants.initCommandDelayMs;
  
  @override
  int get resetDelayMs => ObdConstants.resetDelayMs;
  
  @override
  int get defaultPollingInterval => ObdConstants.defaultPollingInterval;
  
  @override
  int get slowPollingInterval => ObdConstants.slowPollingInterval;
  
  @override
  int get engineOffPollingInterval => ObdConstants.engineOffPollingInterval;
  
  @override
  int get maxRetries => 2; // Original value from elm327_protocol.dart

  @override
  Future<ObdProtocol> createProtocol(ObdConnection connection, {
    bool isDebugMode = false,
    ProfileManager? profileManager,
    String? deviceId,
  }) async {
    _logger.info('Creating protocol for cheap ELM327 adapter');
    
    // Create a protocol instance with the appropriate configuration for cheap adapters
    final protocol = Elm327Protocol(
      connection,
      isDebugMode: isDebugMode,
      adapterProfile: profileId,
      adapterConfig: config,
      profileManager: profileManager,
      deviceId: deviceId,
    );
    
    // Verify that critical configuration is set correctly
    if (!config.useExtendedInitDelays) {
      _logger.warning('Warning: Cheap ELM327 adapter without extended delays may not initialize properly');
    }
    
    if (!config.useLenientParsing) {
      _logger.warning('Warning: Cheap ELM327 adapter without lenient parsing may not interpret data correctly');
    }
    
    return protocol;
  }
  
  @override
  Future<double> testCompatibility(ObdConnection connection, {bool isDebugMode = false}) async {
    _logger.info('Testing compatibility for cheap ELM327 adapter');
    
    try {
      // Send a couple of common commands to test adapter response format
      
      // Reset the adapter
      await connection.sendCommand('ATZ');
      await Future.delayed(Duration(milliseconds: resetDelayMs));
      
      // Turn echo off
      await connection.sendCommand('ATE0');
      await Future.delayed(Duration(milliseconds: initCommandDelayMs));
      
      // Get ELM version (AT@1)
      await connection.sendCommand('AT@1');
      
      // We'll rate compatibility based on receiving any response 
      // because the cheap adapters are less predictable
      
      // For cheap adapters, assume higher compatibility since we're using
      // the most lenient settings by default
      return 0.8;  // Fairly high compatibility score
    } catch (e) {
      _logger.warning('Error testing compatibility: $e');
      return 0.3;  // Some compatibility due to lenient settings
    }
  }
} 

################################################################################
FILE: lib/obd_lib/profiles/elm327_v13_profile.dart
################################################################################

import 'dart:async';
import 'package:logging/logging.dart';

import '../interfaces/obd_connection.dart';
import '../protocol/obd_protocol.dart';
import '../protocol/elm327_protocol.dart';
import '../models/adapter_config.dart';
import '../models/adapter_config_factory.dart';
import '../protocol/response_processor/processor_factory.dart';
import 'adapter_profile.dart';
import 'profile_manager.dart';

/// Profile for ELM327 v1.3 adapters
///
/// This profile targets genuine ELM327 v1.3 adapters, which are
/// older but still capable devices that require specific handling.
class Elm327V13Profile extends AdapterProfile {
  static final Logger _logger = Logger('Elm327V13Profile');
  
  /// Configuration for this adapter profile
  final AdapterConfig _config;
  
  /// Create a new ELM327 v1.3 profile with default configuration
  Elm327V13Profile() : _config = AdapterConfigFactory.createElm327V13Config();
  
  /// Create a new ELM327 v1.3 profile with custom configuration
  Elm327V13Profile.withConfig(this._config);
  
  @override
  AdapterConfig get config => _config;
  
  @override
  Future<ObdProtocol> createProtocol(ObdConnection connection, {
    bool isDebugMode = false,
    ProfileManager? profileManager,
    String? deviceId,
  }) async {
    _logger.info('Creating ELM327 v1.3 protocol handler');
    
    // Create processor specifically optimized for v1.3 adapters
    final processor = ResponseProcessorFactory.createProcessor(
      'elm327_v13',
      _config.useLenientParsing,
    );
    
    return Elm327Protocol(
      connection,
      isDebugMode: isDebugMode,
      customResponseProcessor: processor,
      adapterConfig: _config,
      profileManager: profileManager,
      deviceId: deviceId,
    );
  }
  
  @override
  Future<double> testCompatibility(ObdConnection connection, {bool isDebugMode = false}) async {
    _logger.info('Testing compatibility for ELM327 v1.3 adapter');
    
    double score = 0.0;
    int totalTests = 0;
    
    try {
      // Create a temporary protocol instance for testing
      final protocol = await createProtocol(connection, isDebugMode: isDebugMode);
      
      // Test 1: Version check - look for v1.3 in the adapter version string
      final version = await protocol.sendCommand('ATI');
      if (version.toLowerCase().contains('elm327 v1.3')) {
        score += 1.0;
        totalTests++;
      } else if (version.toLowerCase().contains('elm327') && 
                 version.toLowerCase().contains('1.3')) {
        // Partial match, some adapters don't format version string exactly
        score += 0.8;
        totalTests++;
      } else {
        // Not a v1.3 adapter
        score += 0.0;
        totalTests++;
      }
      
      // Test 2: Protocol capabilities specific to v1.3
      // Many v1.3 adapters still support the STI command
      final stiResponse = await protocol.sendCommand('ATSTI');
      if (!stiResponse.contains('?') && !stiResponse.contains('ERROR')) {
        score += 1.0;
        totalTests++;
      } else {
        score += 0.0;
        totalTests++;
      }
      
      // Test 3: Check if adapter supports ISO 14230-4 (KWP)
      final kwpTest = await protocol.sendCommand('ATSP5');
      if (!kwpTest.contains('?') && !kwpTest.contains('ERROR')) {
        score += 1.0;
        totalTests++;
      } else {
        score += 0.0;
        totalTests++;
      }
      
      // Test 4: Timing test - v1.3 adapters are slower than newer versions
      final stopwatch = Stopwatch()..start();
      await protocol.sendCommand('ATH1');
      stopwatch.stop();
      
      // v1.3 adapters are typically slower (>50ms response time)
      if (stopwatch.elapsedMilliseconds > 50 && stopwatch.elapsedMilliseconds < 150) {
        score += 1.0;
        totalTests++;
      } else if (stopwatch.elapsedMilliseconds <= 50) {
        // Too fast for a v1.3 adapter, likely a newer version
        score += 0.0;
        totalTests++;
      } else if (stopwatch.elapsedMilliseconds >= 150) {
        // Too slow even for a v1.3 adapter, might be a cheap clone
        score += 0.5;
        totalTests++;
      }
      
      // Calculate final score (0.0 to 1.0)
      return totalTests > 0 ? score / totalTests : 0.0;
    } catch (e) {
      _logger.warning('Error during compatibility test: $e');
      return 0.0; // Not compatible if exceptions occur
    }
  }
} 

################################################################################
FILE: lib/obd_lib/profiles/mock_adapter_profile.dart
################################################################################

import 'dart:async';
import 'package:logging/logging.dart';

import '../interfaces/obd_connection.dart';
import '../models/adapter_config.dart';
import '../protocol/obd_constants.dart';
import '../protocol/obd_protocol.dart';
import '../mocks/mock_elm327_protocol.dart';
import 'adapter_profile.dart';
import 'profile_manager.dart';

/// Profile for mock ELM327 adapter used in testing
///
/// This profile simulates an ELM327 adapter for testing purposes
/// without requiring actual hardware.
class MockAdapterProfile implements AdapterProfile {
  static final Logger _logger = Logger('MockAdapterProfile');
  
  /// The configuration for this adapter
  @override
  final AdapterConfig config;
  
  /// Configuration for the mock profile
  final String? scenarioName;
  final Map<String, List<dynamic>>? testData;
  final bool simulateConnectionIssues;
  final double connectionReliability;

  /// Creates a new MockAdapterProfile with optional configuration
  MockAdapterProfile({
    this.scenarioName,
    this.testData,
    this.simulateConnectionIssues = false,
    this.connectionReliability = 1.0,
    AdapterConfig? adapterConfig,
  }) : config = adapterConfig ?? _createDefaultMockConfig() {
    _logger.info('Created mock adapter profile with ${config.profileId} configuration');
  }
  
  /// Implement all getters from AdapterProfile
  @override
  String get profileId => config.profileId;
  
  @override
  String get adapterName => config.name;
  
  @override
  String get description => config.description;
  
  @override
  String get serviceUuid => config.serviceUuid;
  
  @override
  String get notifyCharacteristicUuid => config.notifyCharacteristicUuid;
  
  @override
  String get writeCharacteristicUuid => config.writeCharacteristicUuid;
  
  @override
  int get responseTimeoutMs => config.responseTimeoutMs;
  
  @override
  int get connectionTimeoutMs => config.connectionTimeoutMs;
  
  @override
  int get commandTimeoutMs => config.commandTimeoutMs;
  
  @override
  int get initCommandDelayMs => config.initCommandDelayMs;
  
  @override
  int get resetDelayMs => config.resetDelayMs;
  
  @override
  int get defaultPollingInterval => config.defaultPollingInterval;
  
  @override
  int get slowPollingInterval => config.slowPollingInterval;
  
  @override
  int get engineOffPollingInterval => config.engineOffPollingInterval;
  
  @override
  int get maxRetries => config.maxRetries;
  
  /// Create a default mock configuration with fast response times for testing
  static AdapterConfig _createDefaultMockConfig() {
    return AdapterConfig(
      profileId: 'mock_elm327',
      name: 'Mock ELM327 Adapter',
      description: 'Profile for testing without actual hardware. '
          'Simulates OBD-II communication with configurable behavior.',
      serviceUuid: ObdConstants.serviceUuid,
      notifyCharacteristicUuid: ObdConstants.notifyCharacteristicUuid,
      writeCharacteristicUuid: ObdConstants.writeCharacteristicUuid,
      responseTimeoutMs: 50, // Very fast for tests
      connectionTimeoutMs: 500, // Very fast for tests
      commandTimeoutMs: 100, // Very fast for tests
      initCommandDelayMs: 10, // Very fast for tests
      resetDelayMs: 50, // Very fast for tests
      defaultPollingInterval: 100, // Very fast for tests
      slowPollingInterval: 200, // Very fast for tests
      engineOffPollingInterval: 500, // Very fast for tests
      maxRetries: 0, // No retries needed for mocks
      useExtendedInitDelays: false, // No need for extended delays in tests
      useLenientParsing: true, // Use lenient parsing for flexible test data
      obdProtocol: 'AUTO', // Use auto protocol detection
      baudRate: 10400, // Standard baud rate
    );
  }
  
  @override
  Future<ObdProtocol> createProtocol(ObdConnection connection, {
    bool isDebugMode = false,
    ProfileManager? profileManager,
    String? deviceId,
  }) async {
    _logger.info('Creating mock protocol');
    return MockElm327Protocol(
      connection,
      scenarioName: scenarioName,
      testData: testData,
      simulateConnectionIssues: simulateConnectionIssues,
      connectionReliability: connectionReliability,
      isDebugMode: isDebugMode,
      adapterConfig: config,
    );
  }
  
  @override
  Future<double> testCompatibility(ObdConnection connection, {bool isDebugMode = false}) async {
    // Mock adapters always claim to be compatible
    return 1.0;
  }
} 

################################################################################
FILE: lib/obd_lib/profiles/elm327_v14_profile.dart
################################################################################

import 'dart:async';
import 'package:logging/logging.dart';

import '../interfaces/obd_connection.dart';
import '../protocol/obd_protocol.dart';
import '../protocol/elm327_protocol.dart';
import '../models/adapter_config.dart';
import '../models/adapter_config_factory.dart';
import '../protocol/response_processor/processor_factory.dart';
import 'adapter_profile.dart';
import 'profile_manager.dart';

/// Profile for ELM327 v1.4 adapters
///
/// This profile targets genuine ELM327 v1.4 adapters, which offer
/// better performance and reliability than cheap clones.
/// The v1.4 adapters have some improvements over v1.3 but lack 
/// some advanced features of v2.0.
class Elm327V14Profile extends AdapterProfile {
  static final Logger _logger = Logger('Elm327V14Profile');
  
  /// Configuration for this adapter profile
  final AdapterConfig _config;
  
  /// Create a new ELM327 v1.4 profile with default configuration
  Elm327V14Profile() : _config = AdapterConfigFactory.createElm327V14Config();
  
  /// Create a new ELM327 v1.4 profile with custom configuration
  Elm327V14Profile.withConfig(this._config);
  
  @override
  AdapterConfig get config => _config;
  
  @override
  Future<ObdProtocol> createProtocol(ObdConnection connection, {
    bool isDebugMode = false,
    ProfileManager? profileManager,
    String? deviceId,
  }) async {
    _logger.info('Creating ELM327 v1.4 protocol handler');
    
    // Create processor specifically optimized for v1.4 adapters
    final processor = ResponseProcessorFactory.createProcessor(
      'elm327_v14', 
      _config.useLenientParsing,
    );
    
    return Elm327Protocol(
      connection,
      isDebugMode: isDebugMode,
      customResponseProcessor: processor,
      adapterConfig: _config,
      profileManager: profileManager,
      deviceId: deviceId,
    );
  }
  
  @override
  Future<double> testCompatibility(ObdConnection connection, {bool isDebugMode = false}) async {
    _logger.info('Testing compatibility for ELM327 v1.4 adapter');
    
    double score = 0.0;
    int totalTests = 0;
    
    try {
      // Create a temporary protocol instance for testing
      final protocol = await createProtocol(connection, isDebugMode: isDebugMode);
      
      // Test 1: Version check - look for v1.4 in the adapter version string
      final version = await protocol.sendCommand('ATI');
      if (version.toLowerCase().contains('elm327 v1.4')) {
        score += 1.0;
        totalTests++;
      } else if (version.toLowerCase().contains('elm327') && 
                 version.toLowerCase().contains('1.4')) {
        // Partial match, some adapters don't format version string exactly
        score += 0.8;
        totalTests++;
      } else {
        // Not a v1.4 adapter
        score += 0.0;
        totalTests++;
      }
      
      // Test 2: Voltage reading capability (all v1.4+ adapters should support this)
      final voltageResponse = await protocol.sendCommand('ATRV');
      if (voltageResponse.isNotEmpty && voltageResponse.contains('.')) {
        score += 1.0;
        totalTests++;
      } else {
        score += 0.0;
        totalTests++;
      }
      
      // Test 3: Memory capability test
      final memoryRead = await protocol.sendCommand('ATCR');
      if (!memoryRead.contains('ERROR') && !memoryRead.contains('?')) {
        score += 1.0;
        totalTests++;
      } else {
        score += 0.0;
        totalTests++;
      }
      
      // Test 4: Protocol detection speed
      final stopwatch = Stopwatch()..start();
      await protocol.sendCommand('ATSP0');
      stopwatch.stop();
      
      // v1.4 adapters should be able to process this command quickly
      if (stopwatch.elapsedMilliseconds < 50) {
        score += 1.0;
        totalTests++;
      } else if (stopwatch.elapsedMilliseconds < 100) {
        score += 0.5;
        totalTests++;
      } else {
        score += 0.0;
        totalTests++;
      }
      
      // Calculate final score (0.0 to 1.0)
      return totalTests > 0 ? score / totalTests : 0.0;
    } catch (e) {
      _logger.warning('Error during compatibility test: $e');
      return 0.0; // Not compatible if exceptions occur
    }
  }
} 

################################################################################
FILE: lib/obd_lib/profiles/adapter_profile.dart
################################################################################

import 'dart:async';

import '../interfaces/obd_connection.dart';
import '../protocol/obd_protocol.dart';
import '../models/adapter_config.dart';
import 'profile_manager.dart';

/// Abstract class for OBD-II adapter profiles
///
/// This class encapsulates adapter-specific settings and behaviors,
/// allowing different adapter implementations to be used interchangeably.
abstract class AdapterProfile {
  /// Get the adapter configuration for this profile
  AdapterConfig get config;
  
  /// Unique identifier for the profile
  String get profileId => config.profileId;
  
  /// Human-readable name of the adapter
  String get adapterName => config.name;
  
  /// Description of the adapter
  String get description => config.description;
  
  /// Bluetooth service UUID for this adapter
  String get serviceUuid => config.serviceUuid;
  
  /// Characteristic UUID for notifications (reading from adapter)
  String get notifyCharacteristicUuid => config.notifyCharacteristicUuid;
  
  /// Characteristic UUID for writing commands to adapter
  String get writeCharacteristicUuid => config.writeCharacteristicUuid;
  
  /// Response timeout for commands (ms)
  int get responseTimeoutMs => config.responseTimeoutMs;
  
  /// Connection timeout (ms)
  int get connectionTimeoutMs => config.connectionTimeoutMs;
  
  /// Command timeout (ms)
  int get commandTimeoutMs => config.commandTimeoutMs;
  
  /// Delay between commands during initialization (ms)
  int get initCommandDelayMs => config.initCommandDelayMs;
  
  /// Delay after reset command (ms)
  int get resetDelayMs => config.resetDelayMs;
  
  /// Default polling interval when engine is running (ms)
  int get defaultPollingInterval => config.defaultPollingInterval;
  
  /// Slow polling interval for unreliable adapters (ms)
  int get slowPollingInterval => config.slowPollingInterval;
  
  /// Polling interval when engine is off (ms)
  int get engineOffPollingInterval => config.engineOffPollingInterval;
  
  /// Maximum number of retries per command
  int get maxRetries => config.maxRetries;
  
  /// Create a protocol handler for this adapter profile
  ///
  /// This method creates and returns an ObdProtocol implementation
  /// appropriate for this adapter profile.
  Future<ObdProtocol> createProtocol(ObdConnection connection, {
    bool isDebugMode = false,
    ProfileManager? profileManager,
    String? deviceId,
  });
  
  /// Test if the adapter is compatible with this profile
  ///
  /// This method tests if a connected adapter is compatible with this profile.
  /// Returns a compatibility score from 0.0 (incompatible) to 1.0 (perfect match).
  Future<double> testCompatibility(ObdConnection connection, {bool isDebugMode = false});
} 

################################################################################
FILE: lib/obd_lib/profiles/profile_manager.dart
################################################################################

import 'dart:async';
import 'dart:math' as math;
import 'package:logging/logging.dart';

import '../interfaces/obd_connection.dart';
import '../bluetooth/bluetooth_connection.dart';
import '../mocks/mock_connection.dart';
import '../protocol/obd_protocol.dart';
import '../protocol/elm327_protocol.dart';
import 'adapter_profile.dart';
import 'cheap_elm327_profile.dart';
import 'premium_elm327_profile.dart';
import 'elm327_v13_profile.dart';
import 'elm327_v14_profile.dart';
import 'elm327_v20_profile.dart';
import 'mock_adapter_profile.dart';
import '../models/adapter_config.dart';
import '../models/adapter_config_factory.dart';
import '../models/adapter_config_validator.dart';

/// Class responsible for selecting and managing OBD adapter profiles
///
/// This class handles detection, selection, and management of
/// adapter profiles based on compatibility testing.
class ProfileManager {
  static final Logger _logger = Logger('ProfileManager');
  
  /// List of available adapter profiles
  final List<AdapterProfile> _profiles = [];
  
  /// The last used profile ID, if any
  String? _lastUsedProfileId;
  
  /// Whether a manual profile has been selected
  bool _manualProfileSelected = false;
  
  /// Cache of device-specific compatibility scores
  final Map<String, Map<String, double>> _deviceCompatibilityCache = {};
  
  /// Cache of configurations that have been dynamically adjusted
  final Map<String, AdapterConfig> _dynamicConfigCache = {};
  
  /// Number of successful commands with a specific config
  final Map<String, int> _configSuccessMap = {};
  
  /// Number of failed commands with a specific config
  final Map<String, int> _configFailureMap = {};
  
  /// NEW: Track metrics about adapter detection over time
  final Map<String, Map<String, dynamic>> _adapterMetricsMap = {};
  
  /// Configuration validator for validating and monitoring adapters
  final AdapterConfigValidator _configValidator = AdapterConfigValidator();
  
  /// Creates a new profile manager
  ProfileManager() {
    _initializeProfiles();
  }
  
  /// Initialize the available profiles
  void _initializeProfiles() {
    _logger.info('Initializing OBD adapter profiles');
    
    // Add the version-specific profiles
    // Order matters: we try more advanced adapters first
    _profiles.add(Elm327V20Profile());
    _profiles.add(Elm327V14Profile());
    _profiles.add(Elm327V13Profile());
    
    // Add the generic profiles for backward compatibility
    _profiles.add(PremiumElm327Profile());
    _profiles.add(CheapElm327Profile());
    
    // Add the dynamic profile
    _profiles.add(_createDynamicProfile());
    
    // Add the mock profile for testing
    _profiles.add(MockAdapterProfile());
    
    _logger.info('Loaded ${_profiles.length} adapter profiles');
  }
  
  /// Create a dynamic profile with auto-adjusting configuration
  AdapterProfile _createDynamicProfile() {
    // Create a dynamic configuration that starts conservative
    // but can be optimized based on adapter performance
    final dynamicConfig = AdapterConfigFactory.createDynamicConfig();
    
    // Validate the dynamic configuration
    final validationResult = _configValidator.validateConfig(dynamicConfig);
    
    if (validationResult['isValid'] as bool) {
      final validatedConfig = validationResult['config'] as AdapterConfig;
      
      // Create a premium profile with this validated dynamic configuration
      return PremiumElm327Profile.withConfig(validatedConfig);
    } else {
      // Log validation issues but continue with the original config
      final issues = validationResult['issues'] as List<String>;
      _logger.warning('Dynamic config validation issues: ${issues.join(', ')}');
      
      // Create a premium profile with the original dynamic configuration
      return PremiumElm327Profile.withConfig(dynamicConfig);
    }
  }
  
  /// Get a list of available profile IDs
  List<String> get availableProfileIds => 
      _profiles.map((profile) => profile.profileId).toList();
  
  /// Get a list of available profiles with names
  List<Map<String, String>> get profilesList => _profiles.map((profile) => {
    'id': profile.profileId,
    'name': profile.adapterName,
  }).toList();
  
  /// Get a profile by ID
  AdapterProfile? getProfile(String profileId) {
    try {
      return _profiles.firstWhere((profile) => profile.profileId == profileId);
    } catch (e) {
      _logger.warning('Profile not found: $profileId');
      return null;
    }
  }
  
  /// Set a specific profile to be used
  ///
  /// This will override automatic profile detection
  void setManualProfile(String profileId) {
    final profile = getProfile(profileId);
    if (profile != null) {
      _lastUsedProfileId = profileId;
      _manualProfileSelected = true;
      _logger.info('Manually selected profile: ${profile.adapterName}');
    } else {
      _logger.warning('Cannot select unknown profile: $profileId');
    }
  }
  
  /// Clear manual profile selection
  ///
  /// This will re-enable automatic profile detection
  void clearManualProfile() {
    _manualProfileSelected = false;
    _logger.info('Cleared manual profile selection, automatic detection enabled');
  }
  
  /// Report a successful command execution with a specific device and profile
  /// 
  /// This is used to track adapter performance with different profiles
  void reportCommandSuccess(String deviceId, String profileId) {
    final cacheKey = '$deviceId:$profileId';
    _configSuccessMap[cacheKey] = (_configSuccessMap[cacheKey] ?? 0) + 1;
    
    // Record runtime metrics for the successful command
    final profile = getProfile(profileId);
    if (profile != null) {
      _configValidator.recordRuntimeMetrics(deviceId, profile.config, {
        'success': true,
        'responseTime': profile.config.responseTimeoutMs ~/ 2, // Estimate based on configured timeout
        'commandDuration': profile.config.commandTimeoutMs ~/ 2, // Estimate based on configured timeout
      });
    }
    
    // If we have sufficient data, update the cached configuration
    _updateDynamicConfigurationIfNeeded(deviceId, profileId);
    
    // NEW: Update metrics tracking for successful connections
    if (_adapterMetricsMap.containsKey(deviceId)) {
      final metrics = _adapterMetricsMap[deviceId]!;
      metrics['successfulConnections'] = (metrics['successfulConnections'] as int) + 1;
      
      // Calculate success rate
      final successfulConnections = metrics['successfulConnections'] as int;
      final failedConnections = metrics['failedConnections'] as int;
      final totalConnections = successfulConnections + failedConnections;
      
      if (totalConnections > 0) {
        final successRate = successfulConnections / totalConnections;
        metrics['successRate'] = successRate;
        
        // Log if success rate is very high or very low
        if (totalConnections >= 10) {
          if (successRate > 0.95) {
            _logger.info('Device $deviceId has excellent success rate: ${(successRate * 100).toStringAsFixed(1)}%');
          } else if (successRate < 0.7) {
            _logger.warning('Device $deviceId has concerning success rate: ${(successRate * 100).toStringAsFixed(1)}%');
          }
        }
      }
    }
  }
  
  /// Report a command failure with a specific device and profile
  ///
  /// This is used to track adapter problems with different profiles
  void reportCommandFailure(String deviceId, String profileId) {
    final cacheKey = '$deviceId:$profileId';
    _configFailureMap[cacheKey] = (_configFailureMap[cacheKey] ?? 0) + 1;
    
    // Record runtime metrics for the failed command
    final profile = getProfile(profileId);
    if (profile != null) {
      _configValidator.recordRuntimeMetrics(deviceId, profile.config, {
        'success': false,
        'timeout': true,
        'responseTime': profile.config.responseTimeoutMs, // Assume timeout
        'commandDuration': profile.config.commandTimeoutMs, // Assume timeout
      });
    }
    
    // If we have too many failures, force a configuration update
    if ((_configFailureMap[cacheKey] ?? 0) > 5) {
      _forceDynamicConfigurationUpdate(deviceId, profileId);
    }
    
    // NEW: Update metrics tracking for failed connections
    if (_adapterMetricsMap.containsKey(deviceId)) {
      final metrics = _adapterMetricsMap[deviceId]!;
      metrics['failedConnections'] = (metrics['failedConnections'] as int) + 1;
      
      // Check for repeated failures with the same profile
      final profileFailures = _configFailureMap[cacheKey] ?? 0;
      
      if (profileFailures >= 3) {
        _logger.warning('Device $deviceId has $profileFailures consecutive failures with profile $profileId');
        
        // If we have metrics history, check if this is potentially the wrong profile
        final history = metrics['detectionHistory'] as List<Map<String, dynamic>>;
        
        if (history.isNotEmpty) {
          final lastDetection = history.last;
          final scores = lastDetection['scores'] as Map<String, double>;
          
          // Get all profiles sorted by score
          final sortedProfiles = scores.entries.toList()
            ..sort((a, b) => b.value.compareTo(a.value));
          
          if (sortedProfiles.length > 1 && 
              sortedProfiles.first.key == profileId && 
              sortedProfiles.first.value - sortedProfiles[1].value < 0.15) {
            
            // The chosen profile only marginally beat the second-best profile
            final alternativeProfile = sortedProfiles[1].key;
            _logger.info('Consider trying alternative profile $alternativeProfile '
                      'due to repeated failures with $profileId');
          }
        }
      }
    }
  }
  
  /// Update dynamic configuration based on adapter performance
  void _updateDynamicConfigurationIfNeeded(String deviceId, String profileId) {
    // Try to get an optimized configuration based on runtime metrics
    final optimizedConfig = _configValidator.calculateOptimizedConfig(deviceId, profileId);
    
    if (optimizedConfig != null) {
      // Validate the optimized configuration
      final validationResult = _configValidator.validateConfig(optimizedConfig);
      
      if (validationResult['isValid'] as bool) {
        // Use the validated configuration
        final validatedConfig = validationResult['config'] as AdapterConfig;
        
        // Update the cache with the validated configuration
        _dynamicConfigCache[deviceId] = validatedConfig;
        
        _logger.info('Updated dynamic configuration for device: $deviceId');
        
        // Reset counters
        final cacheKey = '$deviceId:$profileId';
        _configSuccessMap[cacheKey] = 0;
        _configFailureMap[cacheKey] = 0;
      } else {
        // Log validation issues
        final issues = validationResult['issues'] as List<String>;
        _logger.warning('Optimized configuration failed validation: ${issues.join(', ')}');
      }
    }
  }
  
  /// Force an update to a more conservative configuration after too many failures
  void _forceDynamicConfigurationUpdate(String deviceId, String profileId) {
    final cacheKey = '$deviceId:$profileId';
    
    // Get or create a configuration
    AdapterConfig currentConfig;
    if (_dynamicConfigCache.containsKey(deviceId)) {
      currentConfig = _dynamicConfigCache[deviceId]!;
    } else {
      final profile = getProfile(profileId);
      if (profile != null) {
        currentConfig = profile.config;
      } else {
        currentConfig = AdapterConfigFactory.createCheapElm327Config();
      }
    }
    
    // Make it more conservative
    final newConfig = currentConfig.copyWith(
      useExtendedInitDelays: true,
      useLenientParsing: true,
      responseTimeoutMs: _increaseWithLimit(currentConfig.responseTimeoutMs, 50, 300),
      commandTimeoutMs: _increaseWithLimit(currentConfig.commandTimeoutMs, 500, 4000),
      initCommandDelayMs: _increaseWithLimit(currentConfig.initCommandDelayMs, 50, 300),
      resetDelayMs: _increaseWithLimit(currentConfig.resetDelayMs, 100, 1000),
      maxRetries: _increaseWithLimit(currentConfig.maxRetries, 1, 3),
    );
    
    // Validate the new configuration
    final validationResult = _configValidator.validateConfig(newConfig);
    
    if (validationResult['isValid'] as bool) {
      final validatedConfig = validationResult['config'] as AdapterConfig;
      
      _logger.warning('Forced conservative configuration for device $deviceId after multiple failures');
      
      // Update the cache with the validated configuration
      _dynamicConfigCache[deviceId] = validatedConfig;
      
      // Reset failure counter
      _configFailureMap[cacheKey] = 0;
    } else {
      // If validation failed, fall back to the factory default
      _logger.warning('Validation failed for forced configuration update, falling back to factory default');
      _dynamicConfigCache[deviceId] = AdapterConfigFactory.createCheapElm327Config();
      _configFailureMap[cacheKey] = 0;
    }
  }
  
  /// Get a dynamically adjusted configuration for a device
  ///
  /// This now validates the configuration before returning it
  AdapterConfig? getDynamicConfiguration(String deviceId) {
    if (!_dynamicConfigCache.containsKey(deviceId)) {
      return null;
    }
    
    final config = _dynamicConfigCache[deviceId]!;
    
    // Validate the configuration before returning it
    final validationResult = _configValidator.validateConfig(config);
    
    if (validationResult['isValid'] as bool) {
      return validationResult['config'] as AdapterConfig;
    } else {
      // If validation fails, return null and log the issues
      final issues = validationResult['issues'] as List<String>;
      _logger.warning('Dynamic configuration failed validation: ${issues.join(', ')}');
      return null;
    }
  }
  
  /// Helper to decrease a value with a lower limit
  int _decreaseWithLimit(int current, int decreaseAmount, int lowerLimit) {
    return (current - decreaseAmount) < lowerLimit ? lowerLimit : current - decreaseAmount;
  }
  
  /// Helper to increase a value with an upper limit
  int _increaseWithLimit(int current, int increaseAmount, int upperLimit) {
    return (current + increaseAmount) > upperLimit ? upperLimit : current + increaseAmount;
  }
  
  /// Resolve the appropriate profile for a device ID
  ///
  /// This method creates a connection, tests each profile, and returns the best match
  /// Enhanced with more robust detection and caching of results
  Future<AdapterProfile> resolveProfileForDevice(String deviceId, {bool isDebugMode = false}) async {
    _logger.info('Resolving adapter profile for device: $deviceId');
    
    // If a manual profile is selected, use it
    if (_manualProfileSelected && _lastUsedProfileId != null) {
      final profile = getProfile(_lastUsedProfileId!);
      if (profile != null) {
        _logger.info('Using manually selected profile: ${profile.adapterName}');
        
        // If this is the mock profile, we don't need to create a real connection
        if (profile is MockAdapterProfile) {
          return profile;
        }
        
        return profile;
      }
    }
    
    // Check if we're using the mock device ID
    if (deviceId == 'MOCK_DEVICE') {
      _logger.info('Detected mock device ID, using mock profile');
      return _profiles.firstWhere((p) => p is MockAdapterProfile);
    }
    
    // Check the device cache first
    if (_deviceCompatibilityCache.containsKey(deviceId)) {
      final cachedResults = _deviceCompatibilityCache[deviceId]!;
      
      _logger.info('Found cached compatibility results for device: $deviceId');
      
      // Find the profile with the highest compatibility score
      String bestProfileId = _profiles.first.profileId;
      double bestScore = 0;
      
      cachedResults.forEach((profileId, score) {
        if (score > bestScore) {
          bestScore = score;
          bestProfileId = profileId;
        }
      });
      
      // NEW: Apply confidence threshold logic
      final confidenceThreshold = _getConfidenceThreshold(bestProfileId, bestScore);
      _logger.info('Confidence threshold for $bestProfileId: $confidenceThreshold (score: $bestScore)');
      
      // NEW: If the score doesn't exceed the threshold, use a fallback approach
      if (bestScore < confidenceThreshold) {
        _logger.info('Cached best profile score ($bestScore) below confidence threshold ($confidenceThreshold), performing new detection');
        // Clear the cache for this device to force a fresh detection
        _deviceCompatibilityCache.remove(deviceId);
      } else {
        // If we have a dynamic configuration for this device, use it with the best profile
        if (_dynamicConfigCache.containsKey(deviceId)) {
          _logger.info('Using dynamically adjusted configuration for device: $deviceId');
          
          // Create a dynamic profile with the cached configuration
          final dynamicConfig = _dynamicConfigCache[deviceId]!;
          
          // Use premium or cheap profile template based on the best match
          if (bestProfileId == 'premium_elm327') {
            return PremiumElm327Profile.withConfig(dynamicConfig);
          } else {
            return CheapElm327Profile.withConfig(dynamicConfig);
          }
        }
        
        // Otherwise, use the cached best profile
        final bestProfile = getProfile(bestProfileId);
        if (bestProfile != null) {
          _logger.info('Using cached best profile: ${bestProfile.adapterName} (score: $bestScore)');
          return bestProfile;
        }
      }
    }
    
    // Try to use the last successfully used profile first
    if (_lastUsedProfileId != null) {
      final lastProfile = getProfile(_lastUsedProfileId!);
      if (lastProfile != null) {
        _logger.info('Trying last used profile: ${lastProfile.adapterName}');
        final connection = BluetoothConnection(deviceId, isDebugMode: isDebugMode);
        
        // Test if the connection still works with this profile
        final compatibility = await _testProfileCompatibility(lastProfile, connection);
        await connection.disconnect();
        
        // NEW: Apply confidence threshold logic for last used profile
        final confidenceThreshold = _getConfidenceThreshold(lastProfile.profileId, compatibility) * 0.9;
        
        if (compatibility > confidenceThreshold) {
          _logger.info('Last used profile is still compatible (score: $compatibility, threshold: $confidenceThreshold)');
          return lastProfile;
        }
      }
    }
    
    // Create a new connection for testing
    final connection = BluetoothConnection(deviceId, isDebugMode: isDebugMode);
    
    try {
      // Connect to the device
      final connected = await connection.connect();
      if (!connected) {
        _logger.warning('Failed to connect to device for profile testing');
        // Fall back to the cheap profile for compatibility
        return _profiles.firstWhere((p) => p is CheapElm327Profile);
      }
      
      // Test each profile and find the best match
      final results = <String, double>{};
      
      // NEW: Use two passes for better discrimination
      // First pass: test the most likely profiles based on previous experience
      final profilesFirstPass = <AdapterProfile>[];
      final profilesSecondPass = <AdapterProfile>[];
      
      // Sort profiles by likelihood based on previous success
      for (final profile in _profiles) {
        // Skip the mock profile for real devices
        if (profile is MockAdapterProfile) {
          continue;
        }
        
        // Prioritize known profiles
        if (_lastUsedProfileId == profile.profileId) {
          profilesFirstPass.insert(0, profile);
        } else if (profile.profileId == 'premium_elm327') {
          profilesFirstPass.add(profile);
        } else if (profile.profileId == 'cheap_elm327') {
          profilesFirstPass.add(profile);
        } else {
          profilesSecondPass.add(profile);
        }
      }
      
      // Test first pass profiles
      for (final profile in profilesFirstPass) {
        _logger.info('Testing compatibility with profile (first pass): ${profile.adapterName}');
        
        // Enhanced profile testing with multiple specific tests
        final compatibility = await _enhancedProfileTesting(profile, connection);
        results[profile.profileId] = compatibility;
        
        _logger.info('Profile ${profile.adapterName} compatibility score: $compatibility');
      }
      
      // Find the best profile from first pass
      String bestProfileId = '';
      double bestScore = 0;
      
      results.forEach((profileId, score) {
        if (score > bestScore) {
          bestScore = score;
          bestProfileId = profileId;
        }
      });
      
      // Check if first pass found a highly confident match
      final confidenceThreshold = _getConfidenceThreshold(bestProfileId, bestScore);
      
      if (bestScore >= confidenceThreshold && bestProfileId.isNotEmpty) {
        _logger.info('Found high confidence match in first pass: $bestProfileId (score: $bestScore)');
      } else {
        // If first pass didn't find a confident match, try second pass
        _logger.info('First pass did not yield confident result, trying additional profiles');
        
        for (final profile in profilesSecondPass) {
          _logger.info('Testing compatibility with profile (second pass): ${profile.adapterName}');
          
          final compatibility = await _enhancedProfileTesting(profile, connection);
          results[profile.profileId] = compatibility;
          
          _logger.info('Profile ${profile.adapterName} compatibility score: $compatibility');
        }
      }
      
      // Find the profile with the highest compatibility score from all results
      bestProfileId = '';
      bestScore = 0;
      
      results.forEach((profileId, score) {
        if (score > bestScore) {
          bestScore = score;
          bestProfileId = profileId;
        }
      });
      
      // Cache the results for future use
      _deviceCompatibilityCache[deviceId] = results;
      
      // Get the best profile
      final bestProfile = bestProfileId.isNotEmpty 
          ? getProfile(bestProfileId)!
          : _profiles.firstWhere((p) => p is CheapElm327Profile);
      
      // NEW: Add adapter type classification based on scoring patterns
      final adapterClassification = _classifyAdapter(results);
      _logger.info('Adapter classification: $adapterClassification');
      
      // NEW: Track metrics for this detection
      _trackAdapterMetrics(deviceId, results, bestProfileId, adapterClassification);
      
      _logger.info('Selected best profile: ${bestProfile.adapterName} (score: $bestScore, classification: $adapterClassification)');
      
      // Remember this profile for next time
      _lastUsedProfileId = bestProfileId;
      
      return bestProfile;
    } finally {
      // Always disconnect when done testing
      await connection.disconnect();
    }
  }
  
  /// NEW: Determine the appropriate confidence threshold for a profile
  double _getConfidenceThreshold(String profileId, double score) {
    // Different profiles require different confidence thresholds
    switch (profileId) {
      case 'premium_elm327':
        // Premium adapters need higher confidence due to optimizations
        return 0.65;
      case 'cheap_elm327':
        // Cheap adapter can use a lower threshold as it's more conservative
        return 0.4;
      default:
        // Default threshold for other profiles
        return 0.5;
    }
  }
  
  /// NEW: Classify the adapter based on scoring patterns
  String _classifyAdapter(Map<String, double> results) {
    final premiumScore = results['premium_elm327'] ?? 0.0;
    final cheapScore = results['cheap_elm327'] ?? 0.0;
    
    // Calculate the difference and ratio between scores
    final difference = premiumScore - cheapScore;
    final ratio = premiumScore > 0 ? cheapScore / premiumScore : 0.0;
    
    if (premiumScore > 0.75 && difference > 0.3) {
      return 'Definite Premium Adapter';
    } else if (premiumScore > 0.6 && difference > 0.2) {
      return 'Likely Premium Adapter';
    } else if (cheapScore > 0.75 && difference < -0.3) {
      return 'Definite Cheap Adapter';
    } else if (cheapScore > 0.6 && difference < -0.2) {
      return 'Likely Cheap Adapter';
    } else if (ratio > 0.85 && ratio < 1.15) {
      return 'Hybrid/Ambiguous Adapter';
    } else if (premiumScore < 0.4 && cheapScore < 0.4) {
      return 'Unknown/Problematic Adapter';
    } else {
      return 'Standard Adapter';
    }
  }
  
  /// Enhanced profile testing with specific adapter tests
  Future<double> _enhancedProfileTesting(AdapterProfile profile, ObdConnection connection) async {
    _logger.info('Running enhanced compatibility tests for profile: ${profile.profileId}');
    
    try {
      // First do the standard compatibility test
      final basicCompatibility = await _testProfileCompatibility(profile, connection);
      
      // If extremely low compatibility, don't bother with other tests
      if (basicCompatibility < 0.2) {
        return basicCompatibility;
      }
      
      // Run specific compatibility tests to better differentiate adapters
      final testResults = <double>[];
      
      // Test 1: Response time test (more important)
      final responseTimeScore = await _testResponseTime(connection, profile);
      testResults.add(responseTimeScore);
      
      // Test 2: Protocol support test
      final protocolSupportScore = await _testProtocolSupport(connection, profile);
      testResults.add(protocolSupportScore);
      
      // Test 3: Command format test (more important)
      final commandFormatScore = await _testCommandFormat(connection, profile);
      testResults.add(commandFormatScore);
      
      // Test 4: Advanced features test (new)
      final advancedFeaturesScore = await _testAdvancedFeatures(connection, profile);
      testResults.add(advancedFeaturesScore);
      
      // Test 5: Stability test (new)
      final stabilityScore = await _testStability(connection, profile);
      testResults.add(stabilityScore);
      
      // NEW Test 6: Protocol reset response test
      final protocolResetScore = await _testProtocolReset(connection, profile);
      testResults.add(protocolResetScore);

      // NEW Test 7: Data consistency test
      final dataConsistencyScore = await _testDataConsistency(connection, profile);
      testResults.add(dataConsistencyScore);
      
      // NEW Test 8: Multi-frame message handling
      final multiFrameScore = await _testMultiFrameMessages(connection, profile);
      testResults.add(multiFrameScore);
      
      // Calculate final score as weighted average with refined weights
      final finalScore = (basicCompatibility * 0.15) +         // Basic compatibility (reduced from 20% to 15%)
                         (responseTimeScore * 0.20) +           // Response time test (reduced from 25% to 20%)
                         (protocolSupportScore * 0.10) +        // Protocol support test (reduced from 15% to 10%)
                         (commandFormatScore * 0.15) +          // Command format test (reduced from 20% to 15%)
                         (advancedFeaturesScore * 0.10) +       // Advanced features test (unchanged at 10%)
                         (stabilityScore * 0.10) +              // Stability test (unchanged at 10%)
                         (protocolResetScore * 0.05) +          // NEW Protocol reset test (5%)
                         (dataConsistencyScore * 0.10) +        // NEW Data consistency test (10%)
                         (multiFrameScore * 0.05);              // NEW Multi-frame message test (5%)
      
      _logger.info('Enhanced compatibility scores for ${profile.profileId}: ' 
                  'basic=$basicCompatibility, response=$responseTimeScore, ' 
                  'protocol=$protocolSupportScore, format=$commandFormatScore, ' 
                  'advanced=$advancedFeaturesScore, stability=$stabilityScore, '
                  'reset=$protocolResetScore, consistency=$dataConsistencyScore, '
                  'multiframe=$multiFrameScore, final=$finalScore');
      
      // For cheap_elm327 profile, always ensure minimum compatibility
      // This guarantees that the cheap adapter profile is always a fallback option
      if (profile.profileId == 'cheap_elm327' && finalScore < 0.4) {
        final adjustedScore = 0.4;
        _logger.info('Adjusting cheap adapter score from $finalScore to $adjustedScore to ensure fallback compatibility');
        return adjustedScore;
      }
      
      return finalScore;
    } catch (e) {
      _logger.warning('Error during enhanced profile testing: $e');
      
      // If an error occurs during testing, ensure the cheap profile gets a minimum score
      // to serve as a fallback option
      if (profile.profileId == 'cheap_elm327') {
        return 0.4;  // Ensure cheap profile is always viable as fallback
      }
      
      return 0.1;  // Low score for other profiles if testing fails
    }
  }
  
  /// Test the adapter's response time
  Future<double> _testResponseTime(ObdConnection connection, AdapterProfile profile) async {
    try {
      // Take multiple measurements for more accuracy
      final measurements = <int>[];
      final numTests = 3;
      
      for (int i = 0; i < numTests; i++) {
        // Measure response time for a simple command
        final stopwatch = Stopwatch()..start();
        
        // Send a simple command and wait for response
        await _sendCommandWithResponse(connection, i == 0 ? 'AT@1' : i == 1 ? 'ATI' : 'ATE0', timeout: 1000);
        
        // Stop timer
        stopwatch.stop();
        measurements.add(stopwatch.elapsedMilliseconds);
        
        // Small delay between tests
        await Future.delayed(Duration(milliseconds: 50));
      }
      
      // Calculate median response time (more robust than average)
      measurements.sort();
      final responseTime = measurements[measurements.length ~/ 2];
      
      _logger.info('Response time for ${profile.profileId}: $responseTime ms (median of $measurements)');
      
      // Score based on response time with more granular scoring
      // For premium adapters, we expect faster responses
      if (profile.profileId == 'premium_elm327') {
        if (responseTime < 50) return 1.0;    // Extremely fast (was < 100)
        if (responseTime < 100) return 0.9;   // Very fast (new category)
        if (responseTime < 150) return 0.8;   // Fast (was < 200)
        if (responseTime < 200) return 0.7;   // Moderately fast (new category)
        if (responseTime < 250) return 0.6;   // Average (was < 300)
        if (responseTime < 300) return 0.5;   // Below average (new category)
        if (responseTime < 400) return 0.4;   // Slow (was < 500)
        if (responseTime < 500) return 0.3;   // Very slow (new category)
        return 0.2;                           // Extremely slow
      } else {
        // For cheap adapters, we're more forgiving
        if (responseTime < 150) return 1.0;   // Extremely fast for cheap adapter (was < 200)
        if (responseTime < 250) return 0.9;   // Very fast (new category)
        if (responseTime < 350) return 0.8;   // Fast (was < 400)
        if (responseTime < 450) return 0.7;   // Moderately fast (new category)
        if (responseTime < 550) return 0.6;   // Average (was < 600)
        if (responseTime < 650) return 0.5;   // Below average (new category)
        if (responseTime < 750) return 0.4;   // Slow (was < 800)
        if (responseTime < 850) return 0.3;   // Very slow (new category)
        return 0.2;                           // Extremely slow
      }
    } catch (e) {
      _logger.warning('Error testing response time: $e');
      return 0.0;
    }
  }
  
  /// Test protocol support
  Future<double> _testProtocolSupport(ObdConnection connection, AdapterProfile profile) async {
    try {
      // Try to set specific protocol
      final response = await _sendCommandWithResponse(connection, 'ATSP5', timeout: 1000);
      
      if (response.contains('OK')) {
        return 1.0;
      } else if (response.contains('?')) {
        return 0.3;  // Protocol command not supported
      } else if (response.isEmpty) {
        return 0.1;  // No response
      } else {
        return 0.5;  // Some response, but not OK
      }
    } catch (e) {
      _logger.warning('Error testing protocol support: $e');
      return 0.0;
    }
  }
  
  /// Test command format handling
  Future<double> _testCommandFormat(ObdConnection connection, AdapterProfile profile) async {
    try {
      // Test standard OBD protocol command
      final response = await _sendCommandWithResponse(connection, '0100', timeout: 1000);
      
      double score = 0.0;
      
      // Premium adapters should format responses correctly
      if (profile.profileId == 'premium_elm327') {
        if (response.contains('41 00')) score += 0.7;
        if (response.contains('41 00') && response.contains('>')) score += 0.3;
        if (response.contains('NO DATA') || response.contains('ERROR')) score -= 0.5;
      } else {
        // Cheap adapters might return data in various formats
        if (response.contains('41 00') || response.contains('4100')) score += 0.5;
        if (response.contains('>')) score += 0.2;
        if (response.contains('41')) score += 0.3;
        if (response.contains('NO DATA') || response.contains('ERROR')) score -= 0.3;
      }
      
      return math.max(0.0, score);
    } catch (e) {
      _logger.warning('Error testing command format: $e');
      return 0.0;
    }
  }
  
  /// Send a command and wait for a response with timeout
  Future<String> _sendCommandWithResponse(ObdConnection connection, String command, {int timeout = 2000}) async {
    final completer = Completer<String>();
    late StreamSubscription subscription;
    String buffer = '';
    
    // Set up a timeout
    final timer = Timer(Duration(milliseconds: timeout), () {
      if (!completer.isCompleted) {
        completer.complete(buffer);
        subscription.cancel();
      }
    });
    
    // Listen for responses
    subscription = connection.dataStream.listen((data) {
      buffer += data;
      
      // Complete when we get a prompt or enough data
      if (data.contains('>') || buffer.length > 30) {
        if (!completer.isCompleted) {
          completer.complete(buffer);
          timer.cancel();
          subscription.cancel();
        }
      }
    });
    
    // Send the command
    await connection.sendCommand(command);
    
    return await completer.future;
  }
  
  /// Test an adapter's compatibility with a specific profile
  Future<double> _testProfileCompatibility(AdapterProfile profile, ObdConnection connection) async {
    try {
      // Test the profile's compatibility
      return await profile.testCompatibility(connection);
    } catch (e) {
      _logger.warning('Error testing profile ${profile.profileId}: $e');
      return 0.0;
    }
  }
  
  /// Test advanced adapter features that only premium adapters typically support
  Future<double> _testAdvancedFeatures(ObdConnection connection, AdapterProfile profile) async {
    try {
      _logger.info('Testing advanced features for ${profile.profileId}');
      
      // Counter for supported advanced commands
      int supportedCommands = 0;
      int totalCommands = 6; // Increased from 4 to 6
      
      // Test 1: Describe Protocol (ATDESC)
      final protocolDescResponse = await _sendCommandWithResponse(connection, 'ATDESC', timeout: 500);
      if (!protocolDescResponse.contains('?') && protocolDescResponse.isNotEmpty) {
        supportedCommands++;
      }
      
      // Test 2: Read Voltage (ATRV)
      final voltageResponse = await _sendCommandWithResponse(connection, 'ATRV', timeout: 500);
      if (voltageResponse.contains('.') && !voltageResponse.contains('?')) {
        supportedCommands++;
      }
      
      // Test 3: OBD Requirements (ATI3)
      final obdReqResponse = await _sendCommandWithResponse(connection, 'ATI3', timeout: 500);
      if (!obdReqResponse.contains('?') && obdReqResponse.length > 5) {
        supportedCommands++;
      }
      
      // Test 4: Protocol Auto (ATSP0)
      final protocolAutoResponse = await _sendCommandWithResponse(connection, 'ATSP0', timeout: 500);
      if (protocolAutoResponse.contains('OK')) {
        supportedCommands++;
      }
      
      // NEW Test 5: Monitor status (AT MS)
      final monitorStatusResponse = await _sendCommandWithResponse(connection, 'AT MS', timeout: 500);
      if (!monitorStatusResponse.contains('?') && monitorStatusResponse.length > 2) {
        supportedCommands++;
      }
      
      // NEW Test 6: Programmable parameter control (ATPP)
      final programmableParamResponse = await _sendCommandWithResponse(connection, 'ATPP00 SV 00', timeout: 500);
      if (!programmableParamResponse.contains('?') && !programmableParamResponse.contains('ERROR')) {
        supportedCommands++;
      }
      
      // Calculate score based on supported commands
      final score = supportedCommands / totalCommands;
      
      _logger.info('Advanced features score for ${profile.profileId}: $score ($supportedCommands/$totalCommands)');
      
      // Adjust scoring based on profile expectations
      // Premium adapters are expected to support more features
      if (profile.profileId == 'premium_elm327') {
        // For premium profile, low feature support should be penalized more
        return score < 0.5 ? score * 0.5 : score;
      } else {
        // For cheap adapters, feature support is a bonus but not expected
        return score * 0.7 + 0.3; // Minimum 0.3 score for cheap adapters
      }
    } catch (e) {
      _logger.warning('Error testing advanced features: $e');
      
      // For cheap adapters, failure is not critical
      return profile.profileId == 'cheap_elm327' ? 0.5 : 0.1;
    }
  }
  
  /// Test adapter stability by sending multiple commands in quick succession
  Future<double> _testStability(ObdConnection connection, AdapterProfile profile) async {
    try {
      _logger.info('Testing stability for ${profile.profileId}');
      
      // Number of successful commands
      int successfulCommands = 0;
      // Total number of commands to test
      final totalCommands = 5;
      
      // Simple command sequence
      final commands = [
        'ATE0', // Echo off
        'ATL0', // Linefeeds off
        'ATH0', // Headers off
        'ATS0', // Spaces off
        'ATI',  // Identify
      ];
      
      // Send commands with minimal delay and count successful responses
      for (final command in commands) {
        final response = await _sendCommandWithResponse(
          connection, 
          command, 
          timeout: profile.profileId == 'premium_elm327' ? 300 : 600
        );
        
        if (response.isNotEmpty && !response.contains('?') && (response.contains('OK') || response.contains('ELM'))) {
          successfulCommands++;
        }
        
        // Add minimal delay between commands to test stability
        await Future.delayed(Duration(milliseconds: 50));
      }
      
      // Calculate score based on successful commands
      final score = successfulCommands / totalCommands;
      
      _logger.info('Stability score for ${profile.profileId}: $score ($successfulCommands/$totalCommands)');
      
      // Adjust score based on profile expectations
      if (profile.profileId == 'premium_elm327') {
        // Premium adapters should have high stability
        return score < 0.8 ? score * 0.6 : score;
      } else {
        // Cheap adapters get more lenient scoring for stability
        return score * 0.7 + 0.3; // Minimum 0.3 score
      }
      
    } catch (e) {
      _logger.warning('Error testing stability: $e');
      
      // For cheap adapters, failure is not critical
      return profile.profileId == 'cheap_elm327' ? 0.5 : 0.1;
    }
  }
  
  /// NEW: Test protocol reset behavior
  /// Premium adapters tend to have more consistent reset behavior
  Future<double> _testProtocolReset(ObdConnection connection, AdapterProfile profile) async {
    try {
      _logger.info('Testing protocol reset behavior for ${profile.profileId}');
      
      // Reset and observe the response quality
      await connection.sendCommand('ATZ');
      await Future.delayed(Duration(milliseconds: profile.resetDelayMs));
      
      // Create a buffer for the response
      String responseBuffer = '';
      int timeoutMs = 500;
      
      // Listen to response with timeout
      final completer = Completer<String>();
      late StreamSubscription subscription;
      
      subscription = connection.dataStream.listen((data) {
        responseBuffer += data;
        
        // Complete when we get a prompt or enough data
        if (data.contains('>') || responseBuffer.contains('ELM327')) {
          if (!completer.isCompleted) {
            completer.complete(responseBuffer);
            subscription.cancel();
          }
        }
      });
      
      // Set timeout
      final timer = Timer(Duration(milliseconds: timeoutMs), () {
        if (!completer.isCompleted) {
          completer.complete(responseBuffer);
          subscription.cancel();
        }
      });
      
      try {
        responseBuffer = await completer.future;
      } finally {
        timer.cancel();
      }
      
      // Analyze reset response
      double score = 0.0;
      
      // Premium adapters typically show version number after reset
      if (responseBuffer.contains('v1.5') || 
          responseBuffer.contains('v2.1') || 
          responseBuffer.contains('v2.2') || 
          responseBuffer.contains('v2.3')) {
        score += 0.5;
      }
      
      // Clear formatting indicates a premium adapter
      if (responseBuffer.contains('\r\n') && responseBuffer.contains('>')) {
        score += 0.3;
      }
      
      // Complete response with prompt
      if (responseBuffer.contains('ELM327') && responseBuffer.contains('>')) {
        score += 0.2;
      }
      
      // Normalize score
      score = score > 1.0 ? 1.0 : score;
      
      _logger.info('Protocol reset score for ${profile.profileId}: $score');
      
      return score;
    } catch (e) {
      _logger.warning('Error testing protocol reset: $e');
      return profile.profileId == 'cheap_elm327' ? 0.5 : 0.1;
    }
  }
  
  /// NEW: Test data consistency by requesting the same data multiple times
  Future<double> _testDataConsistency(ObdConnection connection, AdapterProfile profile) async {
    try {
      _logger.info('Testing data consistency for ${profile.profileId}');
      
      final testCommand = '0100'; // Mode 01, PID 00 (supported PIDs)
      final results = <String>[];
      
      // Send the same command 3 times
      for (int i = 0; i < 3; i++) {
        final response = await _sendCommandWithResponse(connection, testCommand, timeout: profile.responseTimeoutMs * 2);
        results.add(response);
        await Future.delayed(Duration(milliseconds: 100));
      }
      
      // Analyze consistency
      double score = 0.0;
      
      // Check if responses are consistently formatted
      bool allHavePrompt = results.every((r) => r.contains('>'));
      bool allHaveResponse = results.every((r) => r.contains('41 00') || r.contains('4100'));
      
      // Check for consistent response lengths
      int maxLengthDiff = 0;
      for (int i = 0; i < results.length - 1; i++) {
        int diff = (results[i].length - results[i+1].length).abs();
        maxLengthDiff = diff > maxLengthDiff ? diff : maxLengthDiff;
      }
      
      // Premium adapters should have very consistent responses
      if (profile.profileId == 'premium_elm327') {
        if (allHavePrompt) score += 0.3;
        if (allHaveResponse) score += 0.3;
        if (maxLengthDiff < 5) score += 0.4;
        if (maxLengthDiff < 10 && maxLengthDiff >= 5) score += 0.2;
      } else {
        // Cheap adapters get more lenient scoring
        if (allHavePrompt) score += 0.2;
        if (allHaveResponse) score += 0.3;
        if (maxLengthDiff < 10) score += 0.3;
        if (maxLengthDiff < 20 && maxLengthDiff >= 10) score += 0.2;
      }
      
      // Normalize score
      score = score > 1.0 ? 1.0 : score;
      
      _logger.info('Data consistency score for ${profile.profileId}: $score (maxDiff: $maxLengthDiff)');
      
      return score;
    } catch (e) {
      _logger.warning('Error testing data consistency: $e');
      return profile.profileId == 'cheap_elm327' ? 0.5 : 0.1;
    }
  }
  
  /// NEW: Test multi-frame message handling
  /// Premium adapters typically handle multi-frame messages better
  Future<double> _testMultiFrameMessages(ObdConnection connection, AdapterProfile profile) async {
    try {
      _logger.info('Testing multi-frame message handling for ${profile.profileId}');
      
      // Request VIN (Vehicle Identification Number) which typically requires multiple frames
      final response = await _sendCommandWithResponse(connection, '0902', timeout: profile.responseTimeoutMs * 3);
      
      double score = 0.0;
      
      // Premium adapters should handle these messages correctly
      if (profile.profileId == 'premium_elm327') {
        // Check for proper multi-line response format
        if (response.contains('49 02')) score += 0.4;
        
        // Check for multi-line response lines
        final lines = response.split('\r').where((l) => l.trim().isNotEmpty).toList();
        if (lines.length > 1) score += 0.3;
        
        // Check for completion indicator
        if (response.contains('>')) score += 0.3;
      } else {
        // More lenient scoring for cheap adapters
        if (response.contains('49') || response.contains('49 02') || response.contains('4902')) score += 0.4;
        if (!response.contains('?') && !response.contains('ERROR')) score += 0.3;
        if (response.contains('>')) score += 0.3;
      }
      
      // Normalize score
      score = score > 1.0 ? 1.0 : score;
      
      _logger.info('Multi-frame message score for ${profile.profileId}: $score');
      
      return score;
    } catch (e) {
      _logger.warning('Error testing multi-frame messages: $e');
      return profile.profileId == 'cheap_elm327' ? 0.5 : 0.1;
    }
  }
  
  /// Create a protocol handler for a device using the best matching profile
  /// with a progressive enhancement approach
  ///
  /// This method determines the appropriate profile and creates a protocol
  /// with progressive enhancement based on observed adapter behavior
  Future<ObdProtocol> createProtocolForDevice(String deviceId, {bool isDebugMode = false}) async {
    _logger.info('Creating protocol for device: $deviceId');
    
    // Handle mock device special case
    if (deviceId == 'MOCK_DEVICE') {
      _logger.info('Detected mock device ID, using mock profile');
      final mockProfile = _profiles.firstWhere((p) => p is MockAdapterProfile);
      final connection = MockConnection();
      return await mockProfile.createProtocol(connection, isDebugMode: isDebugMode);
    }
    
    // Get the profile to try first
    AdapterProfile primaryProfile;
    AdapterProfile fallbackProfile;
    
    // Always set the cheap adapter as the fallback profile for reliability
    try {
      fallbackProfile = _profiles.firstWhere((p) => p.profileId == 'cheap_elm327');
    } catch (e) {
      _logger.severe('Could not find cheap_elm327 fallback profile: $e');
      // Create a default fallback profile if none exists
      fallbackProfile = CheapElm327Profile();
    }
    
    // If a manual profile is selected, use it as primary
    if (_manualProfileSelected && _lastUsedProfileId != null) {
      final profile = getProfile(_lastUsedProfileId!);
      if (profile != null) {
        _logger.info('Using manually selected profile: ${profile.adapterName}');
        primaryProfile = profile;
      } else {
        // Fallback to auto-detection if manual profile not found
        primaryProfile = await resolveProfileForDevice(deviceId, isDebugMode: isDebugMode);
      }
    } else {
      // Auto-detect the profile
      primaryProfile = await resolveProfileForDevice(deviceId, isDebugMode: isDebugMode);
    }
    
    // Check for dynamic configuration for this device
    AdapterConfig? dynamicConfig = _dynamicConfigCache[deviceId];
    
    // If we have a dynamic configuration, use it with the primary profile
    if (dynamicConfig != null) {
      _logger.info('Using dynamically adjusted configuration for device: $deviceId');
      
      // Create a connection
      final connection = BluetoothConnection(deviceId, isDebugMode: isDebugMode);
      final connected = await connection.connect();
      
      if (connected) {
        // Create a protocol with the dynamic configuration
        try {
          return Elm327Protocol(
            connection,
            isDebugMode: isDebugMode,
            adapterProfile: primaryProfile.profileId,
            adapterConfig: dynamicConfig,
            profileManager: this,
            deviceId: deviceId,
          );
        } catch (e) {
          _logger.warning('Failed to create protocol with dynamic configuration: $e');
          // If dynamic configuration fails, continue to normal flow
          await connection.disconnect();
        }
      }
    }
    
    // Try connecting with the primary profile
    final protocol = await _tryConnectWithProfile(primaryProfile, deviceId, isDebugMode: isDebugMode);
    if (protocol != null) {
      return protocol;
    }
    
    // If primary profile failed and it's not the cheap profile,
    // explicitly try the cheap profile as fallback
    if (primaryProfile.profileId != 'cheap_elm327') {
      _logger.info('Primary profile failed, trying cheap_elm327 as fallback');
      final fallbackProtocol = await _tryConnectWithProfile(fallbackProfile, deviceId, isDebugMode: isDebugMode);
      if (fallbackProtocol != null) {
        return fallbackProtocol;
      }
    }
    
    // All profile attempts failed, use the generic implementation with the cheap profile config
    // This is a last resort attempt with the most conservative settings
    _logger.warning('All profiles failed, using fallback implementation with cheap profile config');
    final connection = BluetoothConnection(deviceId, isDebugMode: isDebugMode);
    
    if (await connection.connect()) {
      final cheapConfig = AdapterConfigFactory.createCheapElm327Config();
      return Elm327Protocol(
        connection,
        isDebugMode: isDebugMode,
        adapterProfile: 'cheap_elm327',
        adapterConfig: cheapConfig,
        profileManager: this,
        deviceId: deviceId,
      );
    }
    
    throw Exception('Failed to connect with any profile');
  }
  
  /// Helper method to try connecting with a specific profile
  Future<ObdProtocol?> _tryConnectWithProfile(AdapterProfile profile, String deviceId, {bool isDebugMode = false}) async {
    _logger.info('Trying to connect with profile: ${profile.adapterName}');
    
    final connection = BluetoothConnection(deviceId, isDebugMode: isDebugMode);
    final connected = await connection.connect();
    
    if (connected) {
      _logger.info('Connected with profile: ${profile.adapterName}');
      
      try {
        // Create protocol with the profile
        return await profile.createProtocol(
          connection,
          isDebugMode: isDebugMode,
          profileManager: this,
          deviceId: deviceId,
        );
      } catch (e) {
        _logger.warning('Error creating protocol with ${profile.adapterName}: $e');
        await connection.disconnect();
        return null;
      }
    } else {
      _logger.warning('Failed to connect with profile: ${profile.adapterName}');
      return null;
    }
  }
  
  /// NEW: Track adapter detection metrics for improving detection over time
  void _trackAdapterMetrics(String deviceId, Map<String, double> results, String selectedProfileId, String classification) {
    // Initialize metrics for this device if not already present
    if (!_adapterMetricsMap.containsKey(deviceId)) {
      _adapterMetricsMap[deviceId] = {
        'detectionCount': 0,
        'lastDetectionTime': DateTime.now().millisecondsSinceEpoch,
        'detectionHistory': <Map<String, dynamic>>[],
        'successfulConnections': 0,
        'failedConnections': 0,
        'profileSuccessMap': <String, int>{},
        'classification': <String, int>{},
      };
    }
    
    final metrics = _adapterMetricsMap[deviceId]!;
    
    // Update basic metrics
    metrics['detectionCount'] = (metrics['detectionCount'] as int) + 1;
    metrics['lastDetectionTime'] = DateTime.now().millisecondsSinceEpoch;
    
    // Track this detection in history (limited to last 10)
    final history = metrics['detectionHistory'] as List<Map<String, dynamic>>;
    history.add({
      'timestamp': DateTime.now().millisecondsSinceEpoch,
      'scores': Map<String, double>.from(results),
      'selectedProfile': selectedProfileId,
      'classification': classification,
    });
    
    // Keep history limited to last 10 entries
    if (history.length > 10) {
      history.removeAt(0);
    }
    
    // Update classification counts
    final classificationMap = metrics['classification'] as Map<String, int>;
    classificationMap[classification] = (classificationMap[classification] ?? 0) + 1;
    
    // Track success rates by profile
    final profileSuccessMap = metrics['profileSuccessMap'] as Map<String, int>;
    profileSuccessMap[selectedProfileId] = (profileSuccessMap[selectedProfileId] ?? 0) + 1;
    
    _logger.info('Updated adapter metrics for device: $deviceId (detection #${metrics['detectionCount']})');
    
    // Analyze metrics for potential improvements
    _analyzeMetricsForImprovements(deviceId);
  }
  
  /// NEW: Analyze adapter metrics to suggest potential improvements
  void _analyzeMetricsForImprovements(String deviceId) {
    if (!_adapterMetricsMap.containsKey(deviceId)) {
      return;
    }
    
    final metrics = _adapterMetricsMap[deviceId]!;
    final detectionCount = metrics['detectionCount'] as int;
    
    // Only analyze if we have enough data
    if (detectionCount < 3) {
      return;
    }
    
    final history = metrics['detectionHistory'] as List<Map<String, dynamic>>;
    final classificationMap = metrics['classification'] as Map<String, int>;
    
    // Check for classification consistency
    final classifications = classificationMap.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    if (classifications.isNotEmpty) {
      final mostCommon = classifications.first;
      final mostCommonPercentage = mostCommon.value / detectionCount;
      
      // If classification is consistent, we might want to optimize thresholds
      if (mostCommonPercentage > 0.7) {
        _logger.info('Device $deviceId consistently classified as ${mostCommon.key} '
                    '(${(mostCommonPercentage * 100).toStringAsFixed(1)}% of detections)');
        
        // Look for score patterns
        if (history.length >= 3) {
          // Calculate average scores for each profile
          final avgScores = <String, double>{};
          
          for (final entry in history) {
            final scores = entry['scores'] as Map<String, double>;
            scores.forEach((profile, score) {
              if (!avgScores.containsKey(profile)) {
                avgScores[profile] = 0;
              }
              avgScores[profile] = avgScores[profile]! + score;
            });
          }
          
          // Calculate averages
          avgScores.forEach((profile, total) {
            avgScores[profile] = total / history.length;
          });
          
          _logger.info('Average detection scores for device $deviceId: $avgScores');
          
          // Look for potential threshold adjustments
          final premiumAvg = avgScores['premium_elm327'] ?? 0;
          final cheapAvg = avgScores['cheap_elm327'] ?? 0;
          
          if (mostCommon.key.contains('Premium') && premiumAvg < 0.7) {
            _logger.info('Device consistently classified as Premium but with low scores. '
                        'Consider adjusting premium detection thresholds.');
          } else if (mostCommon.key.contains('Cheap') && cheapAvg < 0.5) {
            _logger.info('Device consistently classified as Cheap but with low scores. '
                        'Consider adjusting cheap adapter detection thresholds.');
          }
        }
      } else if (mostCommonPercentage < 0.5) {
        _logger.warning('Device $deviceId has inconsistent classification patterns. '
                      'This may indicate a non-standard adapter or detection issues.');
      }
    }
  }
  
  /// NEW: Get adapter metrics summary for a device
  Map<String, dynamic> getAdapterMetricsSummary(String deviceId) {
    if (!_adapterMetricsMap.containsKey(deviceId)) {
      return {'deviceId': deviceId, 'message': 'No metrics available for this device'};
    }
    
    final metrics = _adapterMetricsMap[deviceId]!;
    final detectionHistory = metrics['detectionHistory'] as List<Map<String, dynamic>>;
    final classifications = metrics['classification'] as Map<String, int>;
    
    // Calculate the most common classification
    String? mostCommonClassification;
    int highestCount = 0;
    
    classifications.forEach((classification, count) {
      if (count > highestCount) {
        highestCount = count;
        mostCommonClassification = classification;
      }
    });
    
    // Calculate success rate
    final successfulConnections = metrics['successfulConnections'] as int;
    final failedConnections = metrics['failedConnections'] as int;
    final totalConnections = successfulConnections + failedConnections;
    final successRate = totalConnections > 0 
        ? successfulConnections / totalConnections 
        : 0.0;
    
    // Create a summary
    return {
      'deviceId': deviceId,
      'detectionCount': metrics['detectionCount'],
      'mostRecentDetection': DateTime.fromMillisecondsSinceEpoch(
          metrics['lastDetectionTime'] as int
      ).toString(),
      'mostCommonClassification': mostCommonClassification,
      'successRate': '${(successRate * 100).toStringAsFixed(1)}%',
      'totalConnections': totalConnections,
      'recentDetections': detectionHistory.map((h) => {
        'timestamp': DateTime.fromMillisecondsSinceEpoch(h['timestamp'] as int).toString(),
        'selectedProfile': h['selectedProfile'],
        'classification': h['classification'],
      }).toList(),
    };
  }
  
  /// NEW: Reset adapter metrics for a device
  void resetAdapterMetrics(String deviceId) {
    _adapterMetricsMap.remove(deviceId);
    _logger.info('Reset adapter metrics for device: $deviceId');
  }
  
  /// Get runtime statistics for a device and profile
  ///
  /// This can be used for diagnostics and troubleshooting
  Map<String, dynamic>? getRuntimeStatistics(String deviceId, String profileId) {
    return _configValidator.getRuntimeStatistics(deviceId, profileId);
  }
  
  /// Check if a configuration update is safe for the given profile
  ///
  /// This prevents modification of critical parameters for cheap adapters
  bool isSafeConfigUpdate(String profileId, Map<String, dynamic> updates) {
    return _configValidator.isSafeConfigUpdate(profileId, updates);
  }
} 

################################################################################
FILE: lib/obd_lib/helpers/obd_command_helpers.dart
################################################################################

import '../obd_service.dart';

/// Helper methods for sending custom commands to OBD adapters
class ObdCommandHelpers {
  /// Send a custom command to the OBD adapter
  /// 
  /// This is a helper method that bypasses the ObdService and uses the protocol directly
  /// Returns the raw response string from the adapter
  static Future<String> sendCustomCommand(ObdService service, String command) async {
    if (!service.isConnected) {
      return 'Not connected';
    }
    
    try {
      // Since we can't use service._protocol directly (it's private),
      // we'll use the requestPid method and manually construct a response
      final data = await service.requestPid(command);
      if (data != null) {
        return "${data.name}: ${data.value} ${data.unit}";
      } else {
        return 'No response or invalid command';
      }
    } catch (e) {
      return 'Error: $e';
    }
  }
} 

################################################################################
FILE: lib/obd_lib/interfaces/obd_protocol.dart
################################################################################

import 'dart:async';
import '../models/obd_data.dart';
import '../models/obd_command.dart';
import 'obd_connection.dart';

/// Abstract interface for OBD-II protocol handlers
abstract class ObdProtocol {
  /// The underlying connection used by this protocol
  ObdConnection get connection;
  
  /// Whether the protocol is initialized and ready to communicate
  bool get isInitialized;
  
  /// Whether the protocol is currently connected to a device
  bool get isConnected;
  
  /// Whether the protocol is currently connecting to a device
  bool get isConnecting;
  
  /// The latest error message, if any occurred
  String? get errorMessage;
  
  /// Stream of raw response data from the OBD adapter
  Stream<String> get dataStream;
  
  /// Stream of parsed OBD data
  Stream<ObdData> get obdDataStream;
  
  /// Initialize the protocol
  /// 
  /// This method should be called after establishing a connection.
  /// Returns true if initialization was successful.
  Future<bool> initialize();
  
  /// Send a raw command to the OBD adapter
  /// 
  /// Returns the raw response from the OBD adapter.
  Future<String> sendCommand(String command);
  
  /// Send an OBD command to the OBD adapter
  /// 
  /// Returns the raw response from the OBD adapter.
  Future<String> sendObdCommand(ObdCommand command);
  
  /// Request data for a specific PID
  /// 
  /// Returns the parsed OBD data.
  Future<ObdData?> requestPid(String pid);
  
  /// Request data for a list of PIDs
  /// 
  /// Returns a map of PID to parsed OBD data.
  Future<Map<String, ObdData>> requestPids(List<String> pids);
  
  /// Dispose of any resources used by the protocol
  void dispose();
} 

################################################################################
FILE: lib/obd_lib/interfaces/obd_connection.dart
################################################################################

import 'dart:async';

/// Abstract interface for OBD-II connections
abstract class ObdConnection {
  /// Stream of incoming data from the connection
  Stream<String> get dataStream;
  
  /// Whether the connection is active
  bool get isConnected;
  
  /// Connects to the specified OBD-II device
  Future<bool> connect();
  
  /// Disconnects from the OBD-II device
  Future<void> disconnect();
  
  /// Sends a command to the OBD-II device
  Future<void> sendCommand(String command);
  
  /// Disposes of the connection resources
  Future<void> dispose();
} 

################################################################################
FILE: lib/firebase/firebase_options.dart
################################################################################

// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      throw UnsupportedError(
        'DefaultFirebaseOptions have not been configured for web - '
        'you can reconfigure this by running the FlutterFire CLI again.',
      );
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for windows - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyA2srMzBWLTKXJOsCRbWPis64C6VotRHgE',
    appId: '1:969096771444:android:418d203ce0b0032b0ede21',
    messagingSenderId: '969096771444',
    projectId: 'going50',
    storageBucket: 'going50.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyCkeojTsC9vltwjk2sDpCUYGx_siW6dTs0',
    appId: '1:969096771444:ios:889b299f2eabc6620ede21',
    messagingSenderId: '969096771444',
    projectId: 'going50',
    storageBucket: 'going50.firebasestorage.app',
    iosBundleId: 'com.example.going50',
  );
}


################################################################################
FILE: lib/firebase/firebase_initializer.dart
################################################################################

import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart';
import 'package:logging/logging.dart';
import 'package:going50/services/service_locator.dart';
import 'package:going50/firebase/firebase_options.dart';

/// FirebaseInitializer handles the initialization of Firebase services
///
/// This class is responsible for:
/// - Initializing Firebase Core
/// - Setting up Crashlytics
/// - Implementing feature flags for Firebase features
class FirebaseInitializer {
  static final _log = Logger('FirebaseInitializer');
  static bool _isInitialized = false;
  
  /// Flag to determine if Firebase is enabled
  static bool get isFirebaseEnabled => _isInitialized;
  
  /// Initialize Firebase
  static Future<bool> initializeFirebase() async {
    if (_isInitialized) {
      _log.info('Firebase already initialized');
      return true;
    }
    
    try {
      _log.info('Initializing Firebase');
      
      // Try to initialize with options
      try {
        // Initialize Firebase with default options
        await Firebase.initializeApp(
          options: DefaultFirebaseOptions.currentPlatform,
        );
      } catch (optionsError) {
        _log.warning('Failed to initialize Firebase with options: $optionsError');
        _log.info('Attempting to initialize Firebase without options');
        
        // Fall back to initialize without options
        // This will work if the app was registered with the default app name
        await Firebase.initializeApp();
      }
      
      // Configure Crashlytics
      if (!kDebugMode) {
        // Enable Crashlytics only in release mode
        await FirebaseCrashlytics.instance.setCrashlyticsCollectionEnabled(true);
        
        // Pass all uncaught errors to Crashlytics
        FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;
        
        _log.info('Crashlytics enabled');
      } else {
        await FirebaseCrashlytics.instance.setCrashlyticsCollectionEnabled(false);
        _log.info('Crashlytics disabled in debug mode');
      }
      
      _isInitialized = true;
      _log.info('Firebase initialized successfully');
      
      // Register Firebase services in service locator
      // Note: setupServiceLocator is already called in main.dart before this
      // This will just ensure the Firebase services are registered
      await _registerFirebaseServices();
      
      return true;
    } catch (e) {
      _log.severe('Failed to initialize Firebase: $e');
      _isInitialized = false;
      return false;
    }
  }
  
  /// Register Firebase services in the service locator
  static Future<void> _registerFirebaseServices() async {
    try {
      // This will trigger the _registerFirebaseServices method in service_locator.dart
      await setupServiceLocator();
    } catch (e) {
      _log.warning('Error registering Firebase services: $e');
    }
  }
  
  /// Check if Firebase authentication is available
  static Future<bool> isAuthenticationAvailable() async {
    if (!_isInitialized) {
      return false;
    }
    
    try {
      // Check if Firebase is initialized
      return Firebase.apps.isNotEmpty;
    } catch (e) {
      _log.warning('Error checking Firebase authentication availability: $e');
      return false;
    }
  }
  
  /// Disable Firebase (for testing or user opt-out)
  static Future<void> disableFirebase() async {
    _log.info('Disabling Firebase functionality');
    _isInitialized = false;
  }
} 

################################################################################
FILE: lib/data_lib/integration_summary.md
################################################################################

# going50 Data Model Integration Summary

## Overview

The data model extensions have been successfully integrated into the going50 eco-driving application to support:

1. **Enhanced Privacy Controls** - Granular privacy settings for different data types
2. **Social Features** - User connections, content sharing, and social interactions
3. **User Preferences & Personalization** - Adaptive feedback based on effectiveness
4. **Gamification** - Challenges, streaks, leaderboards, and other engagement mechanics
5. **External Platform Integration** - Support for ride-sharing and other third-party integrations

## Implementation Details

### Core Models

New data models were created in the `core_models` folder:

- **`data_privacy_settings.dart`** - Granular privacy controls for data types
- **`social_models.dart`** - Social connections, interactions, and shared content
- **`user_preferences.dart`** - User preferences and feedback effectiveness
- **`gamification_models.dart`** - Challenges, streaks, and leaderboards
- **`external_integration.dart`** - External platform integration and sync status

### Database Schema

The database schema was extended in `database_service.dart`:

- Schema version updated from 1 to 2
- Added 12 new tables with appropriate relationships
- Implemented migration strategy to add new tables
- Added initialization logic for default data

### Data Storage Manager

The `DataStorageManager` was extended with:

- Privacy setting initialization and verification
- Methods for saving and retrieving new model types
- Privacy-aware operation handling
- Challenge and social feature management

## Migration Process

The migration strategy ensures existing installations will be smoothly upgraded:

1. When app starts, schema version check triggers migration
2. Migration creates all new tables
3. Default privacy settings are created for existing users
4. Default system challenges are created
5. Foreign key constraints are enforced to maintain data integrity

## Future Considerations

Additional work may be needed for:

1. **User Interface** - Creating UI components for new features
2. **Algorithms** - Implementing personalization and recommendation engines
3. **Cloud Integration** - Extending sync functionality to new data types
4. **Services** - Creating service layer for social and challenge features
5. **Analytics** - Supporting privacy-aware analytics based on user preferences

## Testing

The integration has been tested and verified:

- Database migration successfully upgrades from version 1 to 2
- Default privacy settings are created for existing users
- Linter issues have been resolved
- The app runs successfully with the new data model 

################################################################################
FILE: lib/data_lib/database_service.dart
################################################################################

import 'dart:async';
import 'dart:io';
import 'dart:convert';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'package:logging/logging.dart';
import 'package:going50/core_models/user_profile.dart';
import 'package:uuid/uuid.dart';

// Models
import 'package:going50/core_models/trip.dart';
import 'package:going50/core_models/combined_driving_data.dart';
import 'package:going50/core_models/driver_performance_metrics.dart';
import 'package:going50/core_models/driving_event.dart';
import 'package:going50/core_models/data_privacy_settings.dart';
import 'package:going50/core_models/social_models.dart';
import 'package:going50/core_models/gamification_models.dart';

part 'database_service.g.dart';

// Tables
class TripsTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  DateTimeColumn get startTime => dateTime()();
  DateTimeColumn get endTime => dateTime().nullable()();
  RealColumn get distanceKm => real().nullable()();
  RealColumn get averageSpeedKmh => real().nullable()();
  RealColumn get maxSpeedKmh => real().nullable()();
  RealColumn get fuelUsedL => real().nullable()();
  IntColumn get idlingEvents => integer().nullable()();
  IntColumn get aggressiveAccelerationEvents => integer().nullable()();
  IntColumn get hardBrakingEvents => integer().nullable()();
  IntColumn get excessiveSpeedEvents => integer().nullable()();
  IntColumn get stopEvents => integer().nullable()();
  RealColumn get averageRPM => real().nullable()();
  BoolColumn get isCompleted => boolean().withDefault(const Constant(false))();
  IntColumn get ecoScore => integer().nullable()(); // Overall eco-score for the trip
  TextColumn get routeDataJson => text().nullable()(); // Simplified storage of route as GeoJSON
  TextColumn get userId => text().nullable()(); // Link to user profile
  
  @override
  Set<Column> get primaryKey => {id};
}

class TripDataPointsTable extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get tripId => text().references(TripsTable, #id)();
  DateTimeColumn get timestamp => dateTime()();
  RealColumn get latitude => real().nullable()();
  RealColumn get longitude => real().nullable()();
  RealColumn get speed => real().nullable()(); // km/h
  RealColumn get acceleration => real().nullable()(); // m/s^2
  RealColumn get rpm => real().nullable()();
  RealColumn get throttlePosition => real().nullable()(); // percentage
  RealColumn get engineLoad => real().nullable()(); // percentage
  RealColumn get fuelRate => real().nullable()(); // L/h
  TextColumn get rawDataJson => text().nullable()(); // All other data as JSON
}

class DrivingEventsTable extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get tripId => text().references(TripsTable, #id)();
  DateTimeColumn get timestamp => dateTime()();
  TextColumn get eventType => text()(); // e.g., 'hard_braking', 'aggressive_acceleration'
  RealColumn get severity => real().withDefault(const Constant(1.0))(); // 0.0 to 1.0
  RealColumn get latitude => real().nullable()();
  RealColumn get longitude => real().nullable()();
  TextColumn get detailsJson => text().nullable()(); // Additional event details as JSON
}

class UserProfilesTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  TextColumn get name => text().nullable()();
  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get lastUpdatedAt => dateTime()();
  BoolColumn get isPublic => boolean().withDefault(const Constant(false))();
  BoolColumn get allowDataUpload => boolean().withDefault(const Constant(false))();
  TextColumn get preferencesJson => text().nullable()(); // User preferences as JSON
  TextColumn get firebaseId => text().nullable()(); // Firebase Auth UID
  TextColumn get email => text().nullable()(); // User email from Firebase Auth
  
  @override
  Set<Column> get primaryKey => {id};
}

class PerformanceMetricsTable extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get userId => text().references(UserProfilesTable, #id)();
  DateTimeColumn get generatedAt => dateTime()();
  DateTimeColumn get periodStart => dateTime()();
  DateTimeColumn get periodEnd => dateTime()();
  IntColumn get totalTrips => integer()();
  RealColumn get totalDistanceKm => real()();
  RealColumn get totalDrivingTimeMinutes => real()();
  RealColumn get averageSpeedKmh => real()();
  RealColumn get estimatedFuelSavingsPercent => real().nullable()();
  RealColumn get estimatedCO2ReductionKg => real().nullable()();
  IntColumn get calmDrivingScore => integer().nullable()();
  IntColumn get speedOptimizationScore => integer().nullable()();
  IntColumn get idlingScore => integer().nullable()();
  IntColumn get shortDistanceScore => integer().nullable()();
  IntColumn get rpmManagementScore => integer().nullable()();
  IntColumn get stopManagementScore => integer().nullable()();
  IntColumn get followDistanceScore => integer().nullable()();
  IntColumn get overallScore => integer()();
  TextColumn get improvementTipsJson => text().nullable()(); // Tips as JSON array
}

class BadgesTable extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get userId => text().references(UserProfilesTable, #id)();
  TextColumn get badgeType => text()(); // e.g., 'eco_master', 'smooth_driver'
  DateTimeColumn get earnedDate => dateTime()();
  IntColumn get level => integer().withDefault(const Constant(1))(); // Badge level
  TextColumn get metadataJson => text().nullable()(); // Additional badge data
}

// New tables for data model extensions

class DataPrivacySettingsTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  TextColumn get userId => text().references(UserProfilesTable, #id)();
  TextColumn get dataType => text()(); // 'trips', 'location', 'driving_events', etc.
  BoolColumn get allowLocalStorage => boolean().withDefault(const Constant(true))();
  BoolColumn get allowCloudSync => boolean().withDefault(const Constant(false))();
  BoolColumn get allowSharing => boolean().withDefault(const Constant(false))();
  BoolColumn get allowAnonymizedAnalytics => boolean().withDefault(const Constant(true))();
  
  @override
  Set<Column> get primaryKey => {id};
}

class SocialConnectionsTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  TextColumn get userId => text().references(UserProfilesTable, #id)();
  TextColumn get connectedUserId => text().references(UserProfilesTable, #id)();
  TextColumn get connectionType => text()(); // 'friend', 'following'
  DateTimeColumn get connectedSince => dateTime()();
  BoolColumn get isMutual => boolean().withDefault(const Constant(false))();
  
  @override
  Set<Column> get primaryKey => {id};
}

class SocialInteractionsTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  TextColumn get userId => text().references(UserProfilesTable, #id)();
  TextColumn get contentType => text()(); // 'trip', 'achievement', 'milestone'
  TextColumn get contentId => text()(); // ID of the related content
  TextColumn get interactionType => text()(); // 'like', 'comment', 'share'
  TextColumn get content => text().nullable()(); // For comments, etc.
  DateTimeColumn get timestamp => dateTime()();
  
  @override
  Set<Column> get primaryKey => {id};
}

class FriendRequestsTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  TextColumn get fromUserId => text().references(UserProfilesTable, #id)();
  TextColumn get toUserId => text().references(UserProfilesTable, #id)();
  DateTimeColumn get requestedAt => dateTime()();
  TextColumn get status => text()(); // 'pending', 'accepted', 'rejected', 'cancelled'
  
  @override
  Set<Column> get primaryKey => {id};
}

class UserBlocksTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  TextColumn get userId => text().references(UserProfilesTable, #id)();
  TextColumn get blockedUserId => text().references(UserProfilesTable, #id)();
  DateTimeColumn get blockedAt => dateTime()();
  
  @override
  Set<Column> get primaryKey => {id};
}

class SharedContentTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  TextColumn get userId => text().references(UserProfilesTable, #id)();
  TextColumn get contentType => text()(); // 'trip', 'achievement', 'ecoScore'
  TextColumn get contentId => text()(); // ID of the shared content
  TextColumn get shareType => text()(); // 'public', 'friends', 'external'
  TextColumn get externalPlatform => text().nullable()(); // If external, where it was shared
  TextColumn get shareUrl => text().nullable()(); // Public URL if generated
  DateTimeColumn get sharedAt => dateTime()();
  BoolColumn get isActive => boolean().withDefault(const Constant(true))();
  
  @override
  Set<Column> get primaryKey => {id};
}

class UserPreferencesTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  TextColumn get userId => text().references(UserProfilesTable, #id)();
  TextColumn get preferenceCategory => text()(); // 'feedback', 'gamification', 'ui', etc.
  TextColumn get preferenceName => text()();
  TextColumn get preferenceValue => text()(); // JSON-encoded value
  DateTimeColumn get updatedAt => dateTime()();
  
  @override
  Set<Column> get primaryKey => {id};
}

class FeedbackEffectivenessTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  TextColumn get userId => text().references(UserProfilesTable, #id)();
  TextColumn get feedbackType => text()(); // 'gentle_reminder', 'direct_instruction', 'positive_reinforcement'
  TextColumn get drivingBehaviorType => text()(); // 'acceleration', 'speed', 'idling', etc.
  IntColumn get timesDelivered => integer().withDefault(const Constant(0))();
  IntColumn get timesBehaviorImproved => integer().withDefault(const Constant(0))();
  RealColumn get effectivenessRatio => real().withDefault(const Constant(0.0))();
  DateTimeColumn get lastUpdated => dateTime()();
  
  @override
  Set<Column> get primaryKey => {id};
}

class ChallengesTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  TextColumn get title => text()();
  TextColumn get description => text()();
  TextColumn get type => text()(); // 'daily', 'weekly', 'achievement'
  IntColumn get targetValue => integer()();
  TextColumn get metricType => text()(); // 'calmDriving', 'idling', etc.
  BoolColumn get isSystem => boolean().withDefault(const Constant(true))();
  TextColumn get creatorId => text().nullable().references(UserProfilesTable, #id)(); // If user-created
  BoolColumn get isActive => boolean().withDefault(const Constant(true))();
  IntColumn get difficultyLevel => integer().withDefault(const Constant(1))(); // 1-5
  TextColumn get iconName => text().nullable()();
  TextColumn get rewardType => text().nullable()(); // Points, badge, etc.
  IntColumn get rewardValue => integer().withDefault(const Constant(0))();
  
  @override
  Set<Column> get primaryKey => {id};
}

class UserChallengesTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  TextColumn get userId => text().references(UserProfilesTable, #id)();
  TextColumn get challengeId => text().references(ChallengesTable, #id)();
  DateTimeColumn get startedAt => dateTime()();
  DateTimeColumn get completedAt => dateTime().nullable()();
  IntColumn get progress => integer().withDefault(const Constant(0))();
  BoolColumn get isCompleted => boolean().withDefault(const Constant(false))();
  BoolColumn get rewardClaimed => boolean().withDefault(const Constant(false))();
  
  @override
  Set<Column> get primaryKey => {id};
}

class StreaksTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  TextColumn get userId => text().references(UserProfilesTable, #id)();
  TextColumn get streakType => text()(); // 'daily_drive', 'eco_score', etc.
  IntColumn get currentCount => integer().withDefault(const Constant(0))();
  IntColumn get bestCount => integer().withDefault(const Constant(0))();
  DateTimeColumn get lastRecorded => dateTime()();
  DateTimeColumn get nextDue => dateTime()();
  BoolColumn get isActive => boolean().withDefault(const Constant(true))();
  
  @override
  Set<Column> get primaryKey => {id};
}

class LeaderboardEntriesTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  TextColumn get leaderboardType => text()(); // 'global', 'regional', 'friends'
  TextColumn get timeframe => text()(); // 'daily', 'weekly', 'monthly', 'alltime'
  TextColumn get userId => text().references(UserProfilesTable, #id)();
  TextColumn get regionCode => text().nullable()(); // Optional region
  IntColumn get rank => integer()();
  IntColumn get score => integer()();
  DateTimeColumn get recordedAt => dateTime()();
  IntColumn get daysRetained => integer().withDefault(const Constant(0))();
  
  @override
  Set<Column> get primaryKey => {id};
}

class ExternalIntegrationsTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  TextColumn get userId => text().references(UserProfilesTable, #id)();
  TextColumn get platformType => text()(); // 'uber', 'lyft', 'applecarplay', etc.
  TextColumn get externalId => text().nullable()();
  TextColumn get integrationStatus => text()(); // 'active', 'pending', 'revoked'
  DateTimeColumn get connectedAt => dateTime()();
  DateTimeColumn get lastSyncAt => dateTime().nullable()();
  TextColumn get accessToken => text().nullable()(); // Encrypted if needed
  TextColumn get refreshToken => text().nullable()(); // Encrypted if needed
  TextColumn get integrationDataJson => text().nullable()(); // Platform-specific settings
  
  @override
  Set<Column> get primaryKey => {id};
}

class SyncStatusTable extends Table {
  TextColumn get id => text().withLength(min: 36, max: 36)();
  TextColumn get userId => text().references(UserProfilesTable, #id)();
  TextColumn get entityType => text()(); // 'trip', 'badge', 'challenge', etc.
  TextColumn get entityId => text()();
  TextColumn get targetPlatform => text().nullable()(); // If syncing to specific external platform
  TextColumn get syncStatus => text()(); // 'pending', 'synced', 'failed'
  DateTimeColumn get lastAttemptAt => dateTime().nullable()();
  IntColumn get retryCount => integer().withDefault(const Constant(0))();
  TextColumn get errorMessage => text().nullable()();
  
  @override
  Set<Column> get primaryKey => {id};
}

@DriftDatabase(tables: [
  TripsTable, 
  TripDataPointsTable, 
  DrivingEventsTable, 
  UserProfilesTable,
  PerformanceMetricsTable,
  BadgesTable,
  // New tables
  DataPrivacySettingsTable,
  SocialConnectionsTable,
  SocialInteractionsTable,
  FriendRequestsTable,
  UserBlocksTable,
  SharedContentTable,
  UserPreferencesTable,
  FeedbackEffectivenessTable,
  ChallengesTable,
  UserChallengesTable,
  StreaksTable,
  LeaderboardEntriesTable,
  ExternalIntegrationsTable,
  SyncStatusTable
])
class AppDatabase extends _$AppDatabase {
  final Logger _logger = Logger('AppDatabase');

  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 3; // Incremented for Firebase fields
  
  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) {
        return m.createAll();
      },
      onUpgrade: (Migrator m, int from, int to) async {
        _logger.info('Upgrading database from version $from to $to');
        
        if (from == 1) {
          // Add new tables when upgrading from version 1
          await m.createTable(dataPrivacySettingsTable);
          await m.createTable(socialConnectionsTable);
          await m.createTable(socialInteractionsTable);
          await m.createTable(friendRequestsTable);
          await m.createTable(userBlocksTable);
          await m.createTable(sharedContentTable);
          await m.createTable(userPreferencesTable);
          await m.createTable(feedbackEffectivenessTable);
          await m.createTable(challengesTable);
          await m.createTable(userChallengesTable);
          await m.createTable(streaksTable);
          await m.createTable(leaderboardEntriesTable);
          await m.createTable(externalIntegrationsTable);
          await m.createTable(syncStatusTable);
        }
        
        if (from < 3) {
          // Add Firebase fields to UserProfilesTable
          await m.addColumn(userProfilesTable, userProfilesTable.firebaseId as GeneratedColumn<Object>);
          await m.addColumn(userProfilesTable, userProfilesTable.email as GeneratedColumn<Object>);
        }
      },
      beforeOpen: (details) async {
        // Run validation or data consistency checks before opening the DB
        _logger.info('Opening database version ${details.versionNow}');
        
        // Verify foreign key constraints are enforced
        await customStatement('PRAGMA foreign_keys = ON');
        
        // Optional: Add default data when database is first created
        if (details.wasCreated) {
          _logger.info('Database was created, adding default data...');
          // Add default challenges, etc.
          await batch((batch) {
            // Example of adding default system challenges
            batch.insert(challengesTable, ChallengesTableCompanion.insert(
              id: '00000000-0000-4000-a000-000000000001', // UUID format
              title: 'Eco-Driving Novice',
              description: 'Maintain an eco-score above 70 for 5 consecutive trips',
              type: 'achievement',
              targetValue: 5,
              metricType: 'eco_score',
            ));
            
            batch.insert(challengesTable, ChallengesTableCompanion.insert(
              id: '00000000-0000-4000-a000-000000000002', // UUID format
              title: 'Smooth Operator',
              description: 'Complete a trip with zero aggressive acceleration events',
              type: 'daily',
              targetValue: 1,
              metricType: 'smooth_driving',
            ));
          });
        }
      },
    );
  }
  
  // Trip related methods
  Future<int> saveTrip(Trip trip) async {
    return into(tripsTable).insert(
      TripsTableCompanion.insert(
        id: trip.id,
        startTime: trip.startTime,
        endTime: Value(trip.endTime),
        distanceKm: Value(trip.distanceKm),
        averageSpeedKmh: Value(trip.averageSpeedKmh),
        maxSpeedKmh: Value(trip.maxSpeedKmh),
        fuelUsedL: Value(trip.fuelUsedL),
        idlingEvents: Value(trip.idlingEvents),
        aggressiveAccelerationEvents: Value(trip.aggressiveAccelerationEvents),
        hardBrakingEvents: Value(trip.hardBrakingEvents),
        excessiveSpeedEvents: Value(trip.excessiveSpeedEvents),
        stopEvents: Value(trip.stopEvents),
        averageRPM: Value(trip.averageRPM),
        isCompleted: Value(trip.isCompleted),
      ),
      mode: InsertMode.insertOrReplace,
    );
  }
  
  Stream<List<Trip>> watchAllTrips() {
    return (select(tripsTable)..orderBy([(t) => OrderingTerm.desc(t.startTime)]))
      .watch()
      .map((rows) => rows.map(_mapToTrip).toList());
  }
  
  Future<List<Trip>> getAllTrips() {
    return (select(tripsTable)..orderBy([(t) => OrderingTerm.desc(t.startTime)]))
      .get()
      .then((rows) => rows.map(_mapToTrip).toList());
  }
  
  Trip _mapToTrip(TripsTableData data) {
    return Trip(
      id: data.id,
      startTime: data.startTime,
      endTime: data.endTime,
      distanceKm: data.distanceKm,
      averageSpeedKmh: data.averageSpeedKmh,
      maxSpeedKmh: data.maxSpeedKmh,
      fuelUsedL: data.fuelUsedL,
      idlingEvents: data.idlingEvents,
      aggressiveAccelerationEvents: data.aggressiveAccelerationEvents,
      hardBrakingEvents: data.hardBrakingEvents,
      excessiveSpeedEvents: data.excessiveSpeedEvents,
      stopEvents: data.stopEvents,
      averageRPM: data.averageRPM,
      isCompleted: data.isCompleted,
    );
  }
  
  // Trip data points methods
  Future<int> saveTripDataPoint(String tripId, CombinedDrivingData dataPoint) async {
    // Get speed value - ensure it's double or null
    double? speedValue = dataPoint.obdData?.vehicleSpeed?.toDouble() ?? 
                        dataPoint.sensorData?.gpsSpeed;
    
    // Get acceleration value - ensure it's double or null
    double? accelValue = dataPoint.calculatedAcceleration ?? 
                        dataPoint.sensorData?.accelerationX;
    
    // RPM value - ensure it's double or null
    double? rpmValue = dataPoint.obdData?.rpm?.toDouble();
    
    // Throttle position - ensure it's double or null
    double? throttleValue = dataPoint.obdData?.throttlePosition;
    
    // Engine load - ensure it's double or null
    double? engineLoadValue = dataPoint.obdData?.engineLoad;
    
    // Fuel rate - ensure it's double or null
    double? fuelRateValue = dataPoint.obdData?.fuelRate;
    
    return into(tripDataPointsTable).insert(
      TripDataPointsTableCompanion.insert(
        tripId: tripId,
        timestamp: dataPoint.timestamp,
        latitude: Value(dataPoint.sensorData?.latitude),
        longitude: Value(dataPoint.sensorData?.longitude),
        speed: Value(speedValue),
        acceleration: Value(accelValue),
        rpm: Value(rpmValue),
        throttlePosition: Value(throttleValue),
        engineLoad: Value(engineLoadValue),
        fuelRate: Value(fuelRateValue),
        rawDataJson: Value(dataPoint.toJson().toString()),
      ),
    );
  }
  
  // Driving events methods
  Future<int> saveDrivingEvent(String tripId, DrivingEvent event) async {
    return into(drivingEventsTable).insert(
      DrivingEventsTableCompanion.insert(
        tripId: tripId,
        timestamp: event.timestamp,
        eventType: event.eventType,
        severity: Value(event.severity),
        latitude: Value(event.latitude),
        longitude: Value(event.longitude),
        detailsJson: Value(event.toJson().toString()),
      ),
    );
  }
  
  // User profile methods
  Future<void> saveUserProfile(String userId, String name, bool isPublic, bool allowDataUpload) async {
    final now = DateTime.now();
    
    // Use a transaction to ensure data consistency
    await transaction(() async {
      // First check if user already exists
      final existingUser = await (select(userProfilesTable)
        ..where((t) => t.id.equals(userId)))
        .getSingleOrNull();
        
      if (existingUser != null) {
        // Update existing user
        await (update(userProfilesTable)..where((t) => t.id.equals(userId)))
          .write(UserProfilesTableCompanion(
            name: Value(name),
            lastUpdatedAt: Value(now),
            isPublic: Value(isPublic),
            allowDataUpload: Value(allowDataUpload),
          ));
      } else {
        // Insert new user
        await into(userProfilesTable).insert(
          UserProfilesTableCompanion.insert(
            id: userId,
            name: Value(name),
            createdAt: now,
            lastUpdatedAt: now,
            isPublic: Value(isPublic),
            allowDataUpload: Value(allowDataUpload),
          ),
          mode: InsertMode.insertOrReplace,
        );
      }
    });
  }
  
  /// Get a user profile by ID
  Future<UserProfile?> getUserProfileById(String userId) async {
    final query = select(userProfilesTable)
      ..where((t) => t.id.equals(userId));
    
    final result = await query.getSingleOrNull();
    
    if (result == null) {
      return null;
    }
    
    return UserProfile(
      id: result.id,
      name: result.name ?? 'Anonymous',
      createdAt: result.createdAt,
      lastUpdatedAt: result.lastUpdatedAt,
      isPublic: result.isPublic,
      allowDataUpload: result.allowDataUpload,
      preferences: result.preferencesJson != null ? jsonDecode(result.preferencesJson!) : null,
    );
  }
  
  // Badge-related methods
  
  /// Save a badge for a user
  Future<void> saveBadge(
    String userId, 
    String badgeType, 
    DateTime earnedDate, 
    int level, 
    String? metadataJson
  ) async {
    // Use a transaction to ensure data consistency
    await transaction(() async {
      // Check if the badge already exists
      final existingBadge = await (select(badgesTable)
        ..where((t) => t.userId.equals(userId) & t.badgeType.equals(badgeType)))
        .getSingleOrNull();
        
      if (existingBadge != null) {
        // Only update if the new level is higher
        if (level > existingBadge.level) {
          await (update(badgesTable)
            ..where((t) => t.userId.equals(userId) & t.badgeType.equals(badgeType)))
            .write(BadgesTableCompanion(
              level: Value(level),
              earnedDate: Value(earnedDate),
              metadataJson: Value(metadataJson),
            ));
        }
      } else {
        // Insert new badge
        await into(badgesTable).insert(
          BadgesTableCompanion.insert(
            userId: userId,
            badgeType: badgeType,
            earnedDate: earnedDate,
            level: Value(level),
            metadataJson: Value(metadataJson),
          ),
        );
      }
    });
  }
  
  /// Get all badges for a user
  Future<List<BadgesTableData>> getUserBadges(String userId) async {
    final query = select(badgesTable)
      ..where((t) => t.userId.equals(userId))
      ..orderBy([(t) => OrderingTerm(expression: t.earnedDate, mode: OrderingMode.desc)]);
    
    return await query.get();
  }
  
  // Performance metrics methods
  Future<int> savePerformanceMetrics(DriverPerformanceMetrics metrics, String userId) async {
    return into(performanceMetricsTable).insert(
      PerformanceMetricsTableCompanion.insert(
        userId: userId,
        generatedAt: metrics.generatedAt,
        periodStart: metrics.periodStart,
        periodEnd: metrics.periodEnd,
        totalTrips: metrics.totalTrips,
        totalDistanceKm: metrics.totalDistanceKm,
        totalDrivingTimeMinutes: metrics.totalDrivingTimeMinutes,
        averageSpeedKmh: metrics.averageSpeedKmh,
        estimatedFuelSavingsPercent: Value(metrics.estimatedFuelSavingsL),
        estimatedCO2ReductionKg: Value(metrics.estimatedCO2ReductionKg),
        calmDrivingScore: Value(metrics.calmDrivingScore),
        speedOptimizationScore: Value(metrics.speedOptimizationScore),
        idlingScore: Value(metrics.idlingScore),
        shortDistanceScore: Value(metrics.shortDistanceScore),
        rpmManagementScore: Value(metrics.rpmManagementScore),
        stopManagementScore: Value(metrics.stopManagementScore),
        followDistanceScore: Value(metrics.followDistanceScore),
        overallScore: metrics.overallEcoScore,
        improvementTipsJson: Value(metrics.improvementRecommendations.toString()),
      ),
    );
  }
  
  /// Update trip with end details
  Future<void> updateTripWithEndDetails(
    String tripId, {
    double? distanceKm,
    double? averageSpeedKmh,
    double? maxSpeedKmh,
    double? fuelUsedL,
    int? idlingEvents,
    int? aggressiveAccelerationEvents,
    int? hardBrakingEvents,
    int? excessiveSpeedEvents,
    int? stopEvents,
    double? averageRPM,
    int? ecoScore,
  }) async {
    // Create a companion object with all the values to update
    final updateValues = TripsTableCompanion(
      endTime: Value(DateTime.now()),
      isCompleted: const Value(true),
      distanceKm: distanceKm != null ? Value(distanceKm) : const Value.absent(),
      averageSpeedKmh: averageSpeedKmh != null ? Value(averageSpeedKmh) : const Value.absent(),
      maxSpeedKmh: maxSpeedKmh != null ? Value(maxSpeedKmh) : const Value.absent(),
      fuelUsedL: fuelUsedL != null ? Value(fuelUsedL) : const Value.absent(),
      idlingEvents: idlingEvents != null ? Value(idlingEvents) : const Value.absent(),
      aggressiveAccelerationEvents: aggressiveAccelerationEvents != null ? Value(aggressiveAccelerationEvents) : const Value.absent(),
      hardBrakingEvents: hardBrakingEvents != null ? Value(hardBrakingEvents) : const Value.absent(),
      excessiveSpeedEvents: excessiveSpeedEvents != null ? Value(excessiveSpeedEvents) : const Value.absent(),
      stopEvents: stopEvents != null ? Value(stopEvents) : const Value.absent(),
      averageRPM: averageRPM != null ? Value(averageRPM) : const Value.absent(),
      ecoScore: ecoScore != null ? Value(ecoScore) : const Value.absent(),
    );
    
    // Perform the update by ID
    await (update(tripsTable)..where((t) => t.id.equals(tripId))).write(updateValues);
    
    _logger.info('Trip $tripId marked as completed');
  }
  
  // New methods for data privacy settings
  Future<int> saveDataPrivacySettings(DataPrivacySettings settings) async {
    return into(dataPrivacySettingsTable).insert(
      DataPrivacySettingsTableCompanion.insert(
        id: settings.id,
        userId: settings.userId,
        dataType: settings.dataType,
        allowLocalStorage: Value(settings.allowLocalStorage),
        allowCloudSync: Value(settings.allowCloudSync),
        allowSharing: Value(settings.allowSharing),
        allowAnonymizedAnalytics: Value(settings.allowAnonymizedAnalytics),
      ),
      mode: InsertMode.insertOrReplace,
    );
  }
  
  Future<List<DataPrivacySettings>> getDataPrivacySettingsForUser(String userId) async {
    final query = select(dataPrivacySettingsTable)
      ..where((t) => t.userId.equals(userId));
    
    final results = await query.get();
    
    return results.map((row) => DataPrivacySettings(
      id: row.id,
      userId: row.userId,
      dataType: row.dataType,
      allowLocalStorage: row.allowLocalStorage,
      allowCloudSync: row.allowCloudSync,
      allowSharing: row.allowSharing,
      allowAnonymizedAnalytics: row.allowAnonymizedAnalytics,
    )).toList();
  }
  
  // New methods for social features
  Future<int> saveSocialConnection(SocialConnection connection) async {
    return into(socialConnectionsTable).insert(
      SocialConnectionsTableCompanion.insert(
        id: connection.id,
        userId: connection.userId,
        connectedUserId: connection.connectedUserId,
        connectionType: connection.connectionType,
        connectedSince: connection.connectedSince,
        isMutual: Value(connection.isMutual),
      ),
      mode: InsertMode.insertOrReplace,
    );
  }
  
  Future<List<SocialConnection>> getSocialConnectionsForUser(String userId) async {
    final query = select(socialConnectionsTable)
      ..where((t) => t.userId.equals(userId));
    
    final results = await query.get();
    
    return results.map((row) => SocialConnection(
      id: row.id,
      userId: row.userId,
      connectedUserId: row.connectedUserId,
      connectionType: row.connectionType,
      connectedSince: row.connectedSince,
      isMutual: row.isMutual,
    )).toList();
  }
  
  // New methods for challenges
  Future<int> saveChallenge(Challenge challenge) async {
    return into(challengesTable).insert(
      ChallengesTableCompanion.insert(
        id: challenge.id,
        title: challenge.title,
        description: challenge.description,
        type: challenge.type,
        targetValue: challenge.targetValue,
        metricType: challenge.metricType,
        isSystem: Value(challenge.isSystem),
        creatorId: Value(challenge.creatorId),
        isActive: Value(challenge.isActive),
        difficultyLevel: Value(challenge.difficultyLevel),
        iconName: Value(challenge.iconName),
        rewardType: Value(challenge.rewardType),
        rewardValue: Value(challenge.rewardValue),
      ),
      mode: InsertMode.insertOrReplace,
    );
  }
  
  Future<List<Challenge>> getAllChallenges() async {
    final query = select(challengesTable)
      ..where((t) => t.isActive.equals(true));
    
    final results = await query.get();
    
    return results.map((row) => Challenge(
      id: row.id,
      title: row.title,
      description: row.description,
      type: row.type,
      targetValue: row.targetValue,
      metricType: row.metricType,
      isSystem: row.isSystem,
      creatorId: row.creatorId,
      isActive: row.isActive,
      difficultyLevel: row.difficultyLevel,
      iconName: row.iconName,
      rewardType: row.rewardType,
      rewardValue: row.rewardValue,
    )).toList();
  }
  
  // New methods for user challenges
  Future<int> saveUserChallenge(UserChallenge userChallenge) async {
    return into(userChallengesTable).insert(
      UserChallengesTableCompanion.insert(
        id: userChallenge.id,
        userId: userChallenge.userId,
        challengeId: userChallenge.challengeId,
        startedAt: userChallenge.startedAt,
        completedAt: Value(userChallenge.completedAt),
        progress: Value(userChallenge.progress),
        isCompleted: Value(userChallenge.isCompleted),
        rewardClaimed: Value(userChallenge.rewardClaimed),
      ),
      mode: InsertMode.insertOrReplace,
    );
  }
  
  // Delete a user challenge
  Future<int> deleteUserChallenge(String userChallengeId) async {
    final query = delete(userChallengesTable)
      ..where((t) => t.id.equals(userChallengeId));
    
    return await query.go();
  }
  
  Future<List<UserChallenge>> getUserChallengesForUser(String userId) async {
    final query = select(userChallengesTable)
      ..where((t) => t.userId.equals(userId));
    
    final results = await query.get();
    
    return results.map((row) => UserChallenge(
      id: row.id,
      userId: row.userId,
      challengeId: row.challengeId,
      startedAt: row.startedAt,
      completedAt: row.completedAt,
      progress: row.progress,
      isCompleted: row.isCompleted,
      rewardClaimed: row.rewardClaimed,
    )).toList();
  }
  
  // Friend request methods
  Future<int> saveFriendRequest(String id, String fromUserId, String toUserId, DateTime requestedAt, String status) async {
    return into(friendRequestsTable).insert(
      FriendRequestsTableCompanion.insert(
        id: id,
        fromUserId: fromUserId,
        toUserId: toUserId,
        requestedAt: requestedAt,
        status: status,
      ),
      mode: InsertMode.insertOrReplace,
    );
  }
  
  Future<List<String>> getReceivedFriendRequests(String userId) async {
    final query = select(friendRequestsTable)
      ..where((t) => t.toUserId.equals(userId) & t.status.equals('pending'));
    
    final results = await query.get();
    
    return results.map((row) => row.fromUserId).toList();
  }
  
  Future<List<String>> getSentFriendRequests(String userId) async {
    final query = select(friendRequestsTable)
      ..where((t) => t.fromUserId.equals(userId) & t.status.equals('pending'));
    
    final results = await query.get();
    
    return results.map((row) => row.toUserId).toList();
  }
  
  Future<int> updateFriendRequestStatus(String fromUserId, String toUserId, String status) async {
    final query = update(friendRequestsTable)
      ..where((t) => t.fromUserId.equals(fromUserId) & t.toUserId.equals(toUserId));
      
    return query.write(FriendRequestsTableCompanion(
      status: Value(status),
    ));
  }
  
  Future<int> deleteFriendRequest(String fromUserId, String toUserId) async {
    final query = delete(friendRequestsTable)
      ..where((t) => t.fromUserId.equals(fromUserId) & t.toUserId.equals(toUserId));
      
    return query.go();
  }
  
  // Social connection management
  Future<void> removeSocialConnection(String userId, String connectedUserId, String connectionType) async {
    final query = delete(socialConnectionsTable)
      ..where((t) => t.userId.equals(userId) & 
                      t.connectedUserId.equals(connectedUserId) &
                      t.connectionType.equals(connectionType));
                      
    await query.go();
  }
  
  // User blocks methods
  Future<int> saveUserBlock(String id, String userId, String blockedUserId, DateTime blockedAt) async {
    return into(userBlocksTable).insert(
      UserBlocksTableCompanion.insert(
        id: id,
        userId: userId,
        blockedUserId: blockedUserId,
        blockedAt: blockedAt,
      ),
      mode: InsertMode.insertOrReplace,
    );
  }
  
  Future<void> removeUserBlock(String userId, String blockedUserId) async {
    final query = delete(userBlocksTable)
      ..where((t) => t.userId.equals(userId) & t.blockedUserId.equals(blockedUserId));
      
    await query.go();
  }
  
  Future<bool> isUserBlocked(String userId, String blockedUserId) async {
    final query = select(userBlocksTable)
      ..where((t) => t.userId.equals(userId) & t.blockedUserId.equals(blockedUserId));
    
    final results = await query.get();
    return results.isNotEmpty;
  }
  
  Future<List<String>> getBlockedUsers(String userId) async {
    final query = select(userBlocksTable)
      ..where((t) => t.userId.equals(userId));
    
    final results = await query.get();
    return results.map((row) => row.blockedUserId).toList();
  }
  
  // Leaderboard methods
  Future<int> saveLeaderboardEntry(LeaderboardEntry entry) async {
    return into(leaderboardEntriesTable).insert(
      LeaderboardEntriesTableCompanion.insert(
        id: entry.id,
        leaderboardType: entry.leaderboardType,
        timeframe: entry.timeframe,
        userId: entry.userId,
        regionCode: Value(entry.regionCode),
        rank: entry.rank,
        score: entry.score,
        recordedAt: entry.recordedAt,
        daysRetained: Value(entry.daysRetained),
      ),
      mode: InsertMode.insertOrReplace,
    );
  }
  
  Future<List<LeaderboardEntry>> getLeaderboardEntries(String leaderboardType, String timeframe, {String? regionCode, int limit = 100, int offset = 0}) async {
    var query = select(leaderboardEntriesTable)
      ..where((t) => t.leaderboardType.equals(leaderboardType) & t.timeframe.equals(timeframe))
      ..orderBy([(t) => OrderingTerm.asc(t.rank)])
      ..limit(limit, offset: offset);
      
    if (regionCode != null) {
      query = select(leaderboardEntriesTable)
        ..where((t) => t.leaderboardType.equals(leaderboardType) & 
                        t.timeframe.equals(timeframe) &
                        t.regionCode.equals(regionCode))
        ..orderBy([(t) => OrderingTerm.asc(t.rank)])
        ..limit(limit, offset: offset);
    }
    
    final results = await query.get();
    
    return results.map((row) => LeaderboardEntry(
      id: row.id,
      leaderboardType: row.leaderboardType,
      timeframe: row.timeframe,
      userId: row.userId,
      regionCode: row.regionCode,
      rank: row.rank,
      score: row.score,
      recordedAt: row.recordedAt,
      daysRetained: row.daysRetained,
    )).toList();
  }
  
  Future<LeaderboardEntry?> getUserLeaderboardEntry(String userId, String leaderboardType, String timeframe, {String? regionCode}) async {
    var query = select(leaderboardEntriesTable)
      ..where((t) => t.userId.equals(userId) & 
                      t.leaderboardType.equals(leaderboardType) & 
                      t.timeframe.equals(timeframe));
                      
    if (regionCode != null) {
      query = select(leaderboardEntriesTable)
        ..where((t) => t.userId.equals(userId) & 
                        t.leaderboardType.equals(leaderboardType) & 
                        t.timeframe.equals(timeframe) &
                        t.regionCode.equals(regionCode));
    }
    
    final results = await query.get();
    
    if (results.isEmpty) {
      return null;
    }
    
    final row = results.first;
    return LeaderboardEntry(
      id: row.id,
      leaderboardType: row.leaderboardType,
      timeframe: row.timeframe,
      userId: row.userId,
      regionCode: row.regionCode,
      rank: row.rank,
      score: row.score,
      recordedAt: row.recordedAt,
      daysRetained: row.daysRetained,
    );
  }
  
  // Shared content methods
  Future<int> saveSharedContent(SharedContent content) async {
    return into(sharedContentTable).insert(
      SharedContentTableCompanion.insert(
        id: content.id,
        userId: content.userId,
        contentType: content.contentType,
        contentId: content.contentId,
        shareType: content.shareType,
        externalPlatform: Value(content.externalPlatform),
        shareUrl: Value(content.shareUrl),
        sharedAt: content.sharedAt,
        isActive: Value(content.isActive),
      ),
      mode: InsertMode.insertOrReplace,
    );
  }
  
  Future<List<SharedContent>> getSharedContentForUser(String userId) async {
    final query = select(sharedContentTable)
      ..where((t) => t.userId.equals(userId) & t.isActive.equals(true))
      ..orderBy([(t) => OrderingTerm.desc(t.sharedAt)]);
      
    final results = await query.get();
    
    return results.map((row) => SharedContent(
      id: row.id,
      userId: row.userId,
      contentType: row.contentType,
      contentId: row.contentId,
      shareType: row.shareType,
      externalPlatform: row.externalPlatform,
      shareUrl: row.shareUrl,
      sharedAt: row.sharedAt,
      isActive: row.isActive,
    )).toList();
  }
  
  // User search method
  Future<List<UserProfile>> searchUserProfiles(String query) async {
    // Case-insensitive search for users by name, limit to 20 results
    final results = await customSelect(
      'SELECT * FROM user_profiles_table WHERE name LIKE ? LIMIT 20',
      variables: [Variable('%$query%')],
      readsFrom: {userProfilesTable},
    ).get();
    
    return results.map((row) {
      final data = userProfilesTable.map(row.data);
      return UserProfile(
        id: data.id,
        name: data.name ?? '',
        createdAt: data.createdAt,
        lastUpdatedAt: data.lastUpdatedAt,
        isPublic: data.isPublic,
        allowDataUpload: data.allowDataUpload,
      );
    }).toList();
  }
  
  // Data deletion methods
  
  /// Delete all trips for a user
  Future<int> deleteUserTrips(String userId) async {
    final query = delete(tripsTable)
      ..where((t) => t.userId.equals(userId));
    
    return await query.go();
  }
  
  /// Delete all driving events for a user
  Future<int> deleteUserDrivingEvents(String userId) async {
    // First get all trips for this user
    final userTrips = await (select(tripsTable)..where((t) => t.userId.equals(userId))).get();
    
    // If no trips, nothing to delete
    if (userTrips.isEmpty) {
      return 0;
    }
    
    // Get all trip IDs
    final tripIds = userTrips.map((t) => t.id).toList();
    
    // Delete all driving events associated with these trips
    int deletedCount = 0;
    for (final tripId in tripIds) {
      final query = delete(drivingEventsTable)
        ..where((t) => t.tripId.equals(tripId));
      
      deletedCount += await query.go();
    }
    
    return deletedCount;
  }
  
  /// Delete all performance metrics for a user
  Future<int> deleteUserPerformanceMetrics(String userId) async {
    final query = delete(performanceMetricsTable)
      ..where((t) => t.userId.equals(userId));
    
    return await query.go();
  }
  
  /// Delete all badges for a user
  Future<int> deleteUserBadges(String userId) async {
    final query = delete(badgesTable)
      ..where((t) => t.userId.equals(userId));
    
    return await query.go();
  }
  
  /// Delete all privacy settings for a user
  Future<int> deleteUserDataPrivacySettings(String userId) async {
    final query = delete(dataPrivacySettingsTable)
      ..where((t) => t.userId.equals(userId));
    
    return await query.go();
  }
  
  /// Delete all social connections for a user
  Future<int> deleteUserSocialConnections(String userId) async {
    final query = delete(socialConnectionsTable)
      ..where((t) => t.userId.equals(userId));
    
    return await query.go();
  }
  
  /// Delete all social interactions for a user
  Future<int> deleteUserSocialInteractions(String userId) async {
    final query = delete(socialInteractionsTable)
      ..where((t) => t.userId.equals(userId));
    
    return await query.go();
  }
  
  /// Delete all friend requests for a user
  Future<int> deleteUserFriendRequests(String userId) async {
    // Delete requests sent by user
    final query1 = delete(friendRequestsTable)
      ..where((t) => t.fromUserId.equals(userId));
    
    // Delete requests received by user
    final query2 = delete(friendRequestsTable)
      ..where((t) => t.toUserId.equals(userId));
    
    final count1 = await query1.go();
    final count2 = await query2.go();
    
    return count1 + count2;
  }
  
  /// Delete all user blocks by a user
  Future<int> deleteUserBlocks(String userId) async {
    final query = delete(userBlocksTable)
      ..where((t) => t.userId.equals(userId));
    
    return await query.go();
  }
  
  /// Delete all shared content for a user
  Future<int> deleteUserSharedContent(String userId) async {
    final query = delete(sharedContentTable)
      ..where((t) => t.userId.equals(userId));
    
    return await query.go();
  }
  
  /// Delete all user preferences
  Future<int> deleteUserPreferences(String userId) async {
    final query = delete(userPreferencesTable)
      ..where((t) => t.userId.equals(userId));
    
    return await query.go();
  }
  
  /// Delete all user challenges
  Future<int> deleteUserChallenges(String userId) async {
    final query = delete(userChallengesTable)
      ..where((t) => t.userId.equals(userId));
    
    return await query.go();
  }
  
  /// Delete all streaks for a user
  Future<int> deleteUserStreaks(String userId) async {
    final query = delete(streaksTable)
      ..where((t) => t.userId.equals(userId));
    
    return await query.go();
  }
  
  /// Delete all leaderboard entries for a user
  Future<int> deleteUserLeaderboardEntries(String userId) async {
    final query = delete(leaderboardEntriesTable)
      ..where((t) => t.userId.equals(userId));
    
    return await query.go();
  }
  
  /// Delete all external integrations for a user
  Future<int> deleteUserExternalIntegrations(String userId) async {
    final query = delete(externalIntegrationsTable)
      ..where((t) => t.userId.equals(userId));
    
    return await query.go();
  }
  
  /// Retrieves a user profile by their Firebase ID
  Future<UserProfile?> getUserProfileByFirebaseId(String firebaseId) async {
    _logger.info('Querying user profile by Firebase ID: $firebaseId');
    try {
      final query = select(userProfilesTable)
        ..where((t) => t.firebaseId.equals(firebaseId));
      final result = await query.getSingleOrNull();
      
      if (result != null) {
        _logger.info('Found user profile for Firebase ID: $firebaseId');
        
        // Create user profile from result
        return UserProfile(
          id: result.id,
          name: result.name ?? 'Anonymous',
          createdAt: result.createdAt,
          lastUpdatedAt: result.lastUpdatedAt,
          isPublic: result.isPublic,
          allowDataUpload: result.allowDataUpload,
          preferences: result.preferencesJson != null ? 
              jsonDecode(result.preferencesJson!) as Map<String, dynamic> : null,
          firebaseId: result.firebaseId,
          email: result.email,
        );
      } else {
        _logger.info('No user profile found for Firebase ID: $firebaseId');
        return null;
      }
    } catch (e) {
      _logger.severe('Error retrieving user profile by Firebase ID: $e');
      return null;
    }
  }

  /// Updates an existing user profile
  Future<bool> updateUserProfile(UserProfile profile) async {
    _logger.info('Updating user profile with ID: ${profile.id}');
    try {
      // Update user profile in a transaction
      await transaction(() async {
        // Update main profile data
        await (update(userProfilesTable)..where((t) => t.id.equals(profile.id))).write(
          UserProfilesTableCompanion(
            name: Value(profile.name),
            lastUpdatedAt: Value(DateTime.now()),
            isPublic: Value(profile.isPublic),
            allowDataUpload: Value(profile.allowDataUpload),
            preferencesJson: profile.preferences != null ? 
                Value(jsonEncode(profile.preferences)) : const Value.absent(),
            firebaseId: profile.firebaseId != null ? 
                Value(profile.firebaseId!) : const Value.absent(),
            email: profile.email != null ? 
                Value(profile.email!) : const Value.absent(),
          ),
        );
      });
      return true;
    } catch (e) {
      _logger.severe('Error updating user profile: $e');
      return false;
    }
  }

  /// Inserts a new user profile
  Future<UserProfile?> insertUserProfile({
    required String name,
    required bool isPublic,
    required bool allowDataUpload,
    required String firebaseId,
    required String email,
    Map<String, dynamic>? preferences,
  }) async {
    _logger.info('Inserting new user profile with Firebase ID: $firebaseId');
    final userId = const Uuid().v4();
    final now = DateTime.now();
    
    try {
      // Insert the user profile
      await into(userProfilesTable).insert(
        UserProfilesTableCompanion.insert(
          id: userId,
          name: Value(name),
          createdAt: now,
          lastUpdatedAt: now,
          isPublic: Value(isPublic),
          allowDataUpload: Value(allowDataUpload),
          preferencesJson: preferences != null ? 
              Value(jsonEncode(preferences)) : const Value.absent(),
          firebaseId: Value(firebaseId),
          email: Value(email),
        ),
      );

      // Return the created user profile
      return UserProfile(
        id: userId,
        name: name,
        createdAt: now,
        lastUpdatedAt: now,
        isPublic: isPublic,
        allowDataUpload: allowDataUpload,
        preferences: preferences,
        firebaseId: firebaseId,
        email: email,
      );
    } catch (e) {
      _logger.severe('Error inserting user profile: $e');
      return null;
    }
  }
  
  /// Close the database connection
  @override
  Future<void> close() async {
    return executor.close();
  }

  @override
  Iterable<TableInfo<Table, Object?>> get allTables => [
    tripsTable,
    tripDataPointsTable,
    drivingEventsTable,
    userProfilesTable,
    dataPrivacySettingsTable,
    socialConnectionsTable,
    socialInteractionsTable,
    friendRequestsTable,
    userBlocksTable,
    sharedContentTable,
    performanceMetricsTable,
    badgesTable,
    userPreferencesTable,
    feedbackEffectivenessTable,
    challengesTable,
    userChallengesTable,
    streaksTable,
    leaderboardEntriesTable,
    externalIntegrationsTable,
    syncStatusTable
  ];
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'going50_db.sqlite'));
    return NativeDatabase(file);
  });
} 


################################################################################
FILE: lib/data_lib/data_storage_manager.dart
################################################################################

import 'dart:convert';
import 'dart:io';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:path_provider/path_provider.dart';
import 'package:uuid/uuid.dart';
import 'package:logging/logging.dart';

// Core models
import 'package:going50/core_models/trip.dart';
import 'package:going50/core_models/combined_driving_data.dart';
import 'package:going50/core_models/driver_performance_metrics.dart';
import 'package:going50/core_models/driving_event.dart';
import 'package:going50/core_models/data_privacy_settings.dart';
import 'package:going50/core_models/social_models.dart';
import 'package:going50/core_models/gamification_models.dart';
import 'package:going50/core_models/user_profile.dart';

// Local imports
import 'package:going50/data_lib/database_service.dart';

/// DataStorageManager handles all data persistence operations for the application.
/// 
/// It serves as a facade over the local database, shared preferences, and 
/// (optionally) cloud storage services. It orchestrates data flow between these
/// storage systems based on user preferences and data privacy settings.
class DataStorageManager {
  final Logger _logger = Logger('DataStorageManager');
  final AppDatabase _database;
  final Uuid _uuid = const Uuid();
  
  // Singleton pattern
  static final DataStorageManager _instance = DataStorageManager._internal();
  factory DataStorageManager() => _instance;
  
  // User profile state
  String? _currentUserId;
  bool _isInitialized = false;
  
  // Settings that control data synchronization
  bool _allowCloudSync = false;
  bool _isPublicProfile = false;
  
  // Added to prevent multiple concurrent initialization
  static Future<void>? _initializationFuture;
  
  DataStorageManager._internal() : _database = AppDatabase();
  
  /// Initialize the storage manager and ensure user profile exists
  Future<void> initialize() async {
    // If already initialized, return immediately
    if (_isInitialized) return;
    
    // If initialization is in progress, wait for it to complete
    if (_initializationFuture != null) {
      await _initializationFuture;
      return;
    }
    
    // Create a new initialization future
    _initializationFuture = _doInitialize();
    
    // Wait for initialization to complete
    await _initializationFuture;
    
    // Reset the initialization future
    _initializationFuture = null;
  }
  
  /// The actual initialization function
  Future<void> _doInitialize() async {
    try {
      _logger.info('Starting DataStorageManager initialization');
      
      // Ensure we have a user profile
      await _loadOrCreateUserProfile();
      
      // Verify user was saved by checking again
      final userProfile = await _database.getUserProfileById(_currentUserId!);
      if (userProfile == null) {
        throw Exception('Failed to create or verify user profile after attempts');
      }
      
      // Add a small delay to ensure user profile is saved to database
      await Future.delayed(Duration(milliseconds: 200));
      
      // Initialize default privacy settings
      await _ensureDefaultPrivacySettings();
      
      _isInitialized = true;
      _logger.info('DataStorageManager initialized successfully');
    } catch (e) {
      _logger.severe('Failed to initialize DataStorageManager: $e');
      // Reset initialization status so it can be attempted again
      _isInitialized = false;
      rethrow;
    }
  }
  
  /// Load existing user profile or create a new one if none exists
  Future<void> _loadOrCreateUserProfile() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      _currentUserId = prefs.getString('user_id');
      
      // If no user ID exists, create a new user profile
      if (_currentUserId == null) {
        _currentUserId = _uuid.v4();
        await prefs.setString('user_id', _currentUserId!);
        
        _logger.info('Generated new user ID: $_currentUserId, creating profile');
        
        // Create default user profile in database with retry logic
        int attempts = 0;
        const maxAttempts = 3;
        UserProfile? userProfile;
        
        while (userProfile == null && attempts < maxAttempts) {
          attempts++;
          _logger.info('Attempting to create user profile (attempt $attempts)');
          
          userProfile = await saveUserProfile(
            _currentUserId!, 
            'Default User', 
            false, // isPublic 
            false, // allowDataUpload
          );
          
          if (userProfile == null) {
            _logger.warning('Failed to create user profile on attempt $attempts');
            await Future.delayed(Duration(milliseconds: 100 * attempts));
          }
        }
        
        if (userProfile == null) {
          throw Exception('Failed to create new user profile after $maxAttempts attempts');
        }
        
        _logger.info('Created new user profile with ID: $_currentUserId');
      } else {
        _logger.info('Found existing user ID in preferences: $_currentUserId');
        
        // Verify the user exists in the database
        final existingUser = await _database.getUserProfileById(_currentUserId!);
        
        if (existingUser == null) {
          _logger.warning('User ID exists in preferences but not in database. Recreating user profile.');
          
          // Create user profile in database with retry logic
          int attempts = 0;
          const maxAttempts = 3;
          UserProfile? userProfile;
          
          while (userProfile == null && attempts < maxAttempts) {
            attempts++;
            _logger.info('Attempting to recreate missing user profile (attempt $attempts)');
            
            userProfile = await saveUserProfile(
              _currentUserId!, 
              'Default User', 
              false, // isPublic 
              false, // allowDataUpload
            );
            
            if (userProfile == null) {
              _logger.warning('Failed to recreate user profile on attempt $attempts');
              await Future.delayed(Duration(milliseconds: 100 * attempts));
            }
          }
          
          if (userProfile == null) {
            throw Exception('Failed to recreate missing user profile after $maxAttempts attempts');
          }
          
          _logger.info('Recreated user profile with ID: $_currentUserId');
        } else {
          _logger.info('Loaded existing user profile with ID: $_currentUserId');
        }
      }
      
      // Load sync preferences
      _allowCloudSync = prefs.getBool('allow_cloud_sync') ?? false;
      _isPublicProfile = prefs.getBool('is_public_profile') ?? false;
      
    } catch (e) {
      _logger.severe('Error loading user profile: $e');
      rethrow;
    }
  }
  
  /// Ensure default privacy settings exist for the user
  Future<void> _ensureDefaultPrivacySettings() async {
    if (_currentUserId == null) return;
    
    try {
      // First verify the user exists in the database to avoid foreign key issues
      final userProfile = await _database.getUserProfileById(_currentUserId!);
      if (userProfile == null) {
        _logger.warning('Cannot create privacy settings: User $_currentUserId does not exist in database');
        return;
      }
      
      final settings = await _database.getDataPrivacySettingsForUser(_currentUserId!);
      
      // If no settings exist, create default ones
      if (settings.isEmpty) {
        _logger.info('No privacy settings found for user $_currentUserId, creating defaults');
        
        final dataTypes = ['trips', 'location', 'driving_events', 'performance_metrics'];
        int successCount = 0;
        
        for (final dataType in dataTypes) {
          try {
            final settingId = _uuid.v4();
            _logger.info('Creating privacy setting for $dataType with ID $settingId');
            
            await _database.saveDataPrivacySettings(
              DataPrivacySettings(
                id: settingId, 
                userId: _currentUserId!, 
                dataType: dataType,
              ),
            );
            
            // Verify the setting was saved
            final updatedSettings = await _database.getDataPrivacySettingsForUser(_currentUserId!);
            if (updatedSettings.any((s) => s.dataType == dataType)) {
              successCount++;
              _logger.info('Privacy setting for $dataType created successfully');
            } else {
              _logger.warning('Failed to verify privacy setting for $dataType was created');
            }
          } catch (e) {
            _logger.warning('Error creating privacy setting for $dataType: $e');
          }
        }
        
        _logger.info('Created $successCount/${dataTypes.length} default privacy settings for user $_currentUserId');
      } else {
        _logger.info('Found ${settings.length} existing privacy settings for user $_currentUserId');
      }
    } catch (e) {
      _logger.warning('Error ensuring default privacy settings: $e');
      // Don't rethrow to avoid crashing the app initialization
    }
  }
  
  /// Start a new trip recording
  Future<Trip> startNewTrip() async {
    if (!_isInitialized) await initialize();
    
    final now = DateTime.now();
    final tripId = _uuid.v4();
    
    // Create the trip with the current user ID
    final trip = Trip(
      id: tripId,
      startTime: now,
      isCompleted: false,
      userId: _currentUserId, // Set the user ID to associate trip with current user
    );
    
    await _database.saveTrip(trip);
    _logger.info('Started new trip with ID: $tripId for user: $_currentUserId');
    
    return trip;
  }
  
  /// End an ongoing trip
  Future<Trip> endTrip(String tripId, {
    double? distanceKm,
    double? averageSpeedKmh,
    double? maxSpeedKmh,
    double? fuelUsedL,
    int? idlingEvents,
    int? aggressiveAccelerationEvents,
    int? hardBrakingEvents,
    int? excessiveSpeedEvents,
    int? stopEvents,
    double? averageRPM,
    int? ecoScore,
  }) async {
    if (!_isInitialized) await initialize();
    
    try {
      // Get the existing trip
      final trips = await _database.getAllTrips();
      final existingTrip = trips.firstWhere((t) => t.id == tripId);
      
      // Update in the database directly
      await _database.updateTripWithEndDetails(
        tripId,
        distanceKm: distanceKm,
        averageSpeedKmh: averageSpeedKmh,
        maxSpeedKmh: maxSpeedKmh,
        fuelUsedL: fuelUsedL,
        idlingEvents: idlingEvents,
        aggressiveAccelerationEvents: aggressiveAccelerationEvents,
        hardBrakingEvents: hardBrakingEvents,
        excessiveSpeedEvents: excessiveSpeedEvents,
        stopEvents: stopEvents,
        averageRPM: averageRPM,
        ecoScore: ecoScore,
      );
      
      // Create the updated trip object to return
      final updatedTrip = existingTrip.copyWith(
        endTime: DateTime.now(),
        distanceKm: distanceKm,
        averageSpeedKmh: averageSpeedKmh,
        maxSpeedKmh: maxSpeedKmh,
        fuelUsedL: fuelUsedL,
        idlingEvents: idlingEvents,
        aggressiveAccelerationEvents: aggressiveAccelerationEvents,
        hardBrakingEvents: hardBrakingEvents,
        excessiveSpeedEvents: excessiveSpeedEvents,
        stopEvents: stopEvents,
        averageRPM: averageRPM,
        isCompleted: true,
      );
      
      _logger.info('Ended trip with ID: $tripId');
      
      // If cloud sync is enabled, sync this trip data
      if (_allowCloudSync) {
        _syncTripToCloud(updatedTrip);
      }
      
      return updatedTrip;
    } catch (e) {
      _logger.severe('Error ending trip $tripId: $e');
      rethrow;
    }
  }
  
  /// Save a data point during a trip
  Future<void> saveTripDataPoint(String tripId, CombinedDrivingData dataPoint) async {
    if (!_isInitialized) await initialize();
    
    try {
      await _database.saveTripDataPoint(tripId, dataPoint);
    } catch (e) {
      _logger.warning('Error saving trip data point: $e');
    }
  }
  
  /// Save a driving event during a trip
  Future<void> saveDrivingEvent(String tripId, DrivingEvent event) async {
    if (!_isInitialized) await initialize();
    
    try {
      await _database.saveDrivingEvent(tripId, event);
    } catch (e) {
      _logger.warning('Error saving driving event: $e');
    }
  }
  
  /// Save driver performance metrics
  Future<void> savePerformanceMetrics(DriverPerformanceMetrics metrics) async {
    if (!_isInitialized) await initialize();
    
    try {
      await _database.savePerformanceMetrics(metrics, _currentUserId!);
      
      // Sync metrics to cloud if enabled
      if (_allowCloudSync && _isPublicProfile) {
        _syncMetricsToCloud(metrics);
      }
    } catch (e) {
      _logger.warning('Error saving performance metrics: $e');
    }
  }
  
  /// Get all trips for the current user
  Future<List<Trip>> getAllTrips() async {
    if (!_isInitialized) await initialize();
    return _database.getAllTrips();
  }
  
  /// Stream of trips that updates in real-time
  Stream<List<Trip>> watchTrips() {
    return _database.watchAllTrips();
  }
  
  /// Update user profile settings
  Future<void> updateUserSettings({
    String? name,
    bool? isPublicProfile,
    bool? allowCloudSync,
  }) async {
    if (!_isInitialized) await initialize();
    
    try {
      final prefs = await SharedPreferences.getInstance();
      
      // Update cloud sync preference
      if (allowCloudSync != null) {
        _allowCloudSync = allowCloudSync;
        await prefs.setBool('allow_cloud_sync', allowCloudSync);
      }
      
      // Update public profile preference
      if (isPublicProfile != null) {
        _isPublicProfile = isPublicProfile;
        await prefs.setBool('is_public_profile', isPublicProfile);
      }
      
      // Update user profile in database
      await _database.saveUserProfile(
        _currentUserId!, 
        name ?? 'Default User', 
        _isPublicProfile, 
        _allowCloudSync,
      );
      
      _logger.info('Updated user settings: public=$_isPublicProfile, sync=$_allowCloudSync');
    } catch (e) {
      _logger.severe('Error updating user settings: $e');
      rethrow;
    }
  }
  
  /// Get a user profile by ID
  Future<UserProfile?> getUserProfileById(String userId) async {
    if (!_isInitialized) await initialize();
    
    try {
      return await _database.getUserProfileById(userId);
    } catch (e) {
      _logger.warning('Error retrieving user profile for ID $userId: $e');
      return null;
    }
  }
  
  /// Save a user profile with the given properties
  Future<UserProfile?> saveUserProfile(String userId, String name, bool isPublic, bool allowDataUpload) async {
    // Don't call initialize here to avoid recursive initialization
    
    try {
      _logger.info('Attempting to save user profile: $userId');
      
      // Add retry logic to ensure the profile is saved
      UserProfile? savedUser;
      int attempts = 0;
      const maxAttempts = 3;
      
      while (savedUser == null && attempts < maxAttempts) {
        attempts++;
        
        // Save the user profile
        await _database.saveUserProfile(userId, name, isPublic, allowDataUpload);
        
        // Verify the user was saved by retrieving it
        savedUser = await _database.getUserProfileById(userId);
        
        if (savedUser != null) {
          _logger.info('User profile saved successfully: $userId (attempt $attempts)');
        } else {
          _logger.warning('User profile not saved on attempt $attempts, retrying...');
          // Small delay before retrying
          await Future.delayed(Duration(milliseconds: 50 * attempts));
        }
      }
      
      if (savedUser == null) {
        _logger.severe('Failed to save user profile after $maxAttempts attempts: $userId');
        return null;
      }
      
      // Update local state
      if (userId == _currentUserId) {
        _isPublicProfile = isPublic;
        
        // Update shared preferences
        final prefs = await SharedPreferences.getInstance();
        await prefs.setBool('is_public_profile', isPublic);
      }
      
      return savedUser;
    } catch (e) {
      _logger.severe('Error saving user profile: $e');
      return null;
    }
  }
  
  /// Export trip data to a JSON file
  Future<File> exportTripData(String tripId) async {
    if (!_isInitialized) await initialize();
    
    try {
      // Get the trip
      final trips = await _database.getAllTrips();
      final trip = trips.firstWhere((t) => t.id == tripId);
      
      // Create a JSON representation
      final tripJson = trip.toJson();
      
      // Create a file in the documents directory
      final dir = await getApplicationDocumentsDirectory();
      final fileName = 'trip_${tripId.substring(0, 8)}_${trip.startTime.toIso8601String().substring(0, 10)}.json';
      final file = File('${dir.path}/$fileName');
      
      // Write the JSON to the file
      await file.writeAsString(jsonEncode(tripJson));
      
      _logger.info('Exported trip data to file: $fileName');
      return file;
    } catch (e) {
      _logger.severe('Error exporting trip data: $e');
      rethrow;
    }
  }
  
  /// Export all user data (for backup, data portability, etc.)
  Future<File> exportAllUserData() async {
    if (!_isInitialized) await initialize();
    
    try {
      // Get all trips
      final trips = await _database.getAllTrips();
      
      // Create a JSON representation
      final dataJson = {
        'userId': _currentUserId,
        'exportDate': DateTime.now().toIso8601String(),
        'trips': trips.map((t) => t.toJson()).toList(),
      };
      
      // Create a file in the documents directory
      final dir = await getApplicationDocumentsDirectory();
      final fileName = 'going50_data_export_${DateTime.now().toIso8601String().substring(0, 10)}.json';
      final file = File('${dir.path}/$fileName');
      
      // Write the JSON to the file
      await file.writeAsString(jsonEncode(dataJson));
      
      _logger.info('Exported all user data to file: $fileName');
      return file;
    } catch (e) {
      _logger.severe('Error exporting all user data: $e');
      rethrow;
    }
  }
  
  /// Sync trip data to cloud (placeholder for cloud implementation)
  void _syncTripToCloud(Trip trip) {
    // This would be implemented when cloud services are integrated
    _logger.info('Syncing trip ${trip.id} to cloud (not implemented)');
  }
  
  /// Sync metrics to cloud (placeholder for cloud implementation)
  void _syncMetricsToCloud(DriverPerformanceMetrics metrics) {
    // This would be implemented when cloud services are integrated
    _logger.info('Syncing performance metrics to cloud (not implemented)');
  }
  
  /// Close the database when the app is shutting down
  Future<void> dispose() async {
    await _database.close();
    _logger.info('DataStorageManager disposed');
  }
  
  /// Get a specific trip by ID
  Future<Trip?> getTrip(String tripId) async {
    if (!_isInitialized) await initialize();
    
    try {
      final trips = await _database.getAllTrips();
      return trips.firstWhere((t) => t.id == tripId);
    } catch (e) {
      _logger.warning('Trip not found with ID: $tripId');
      return null;
    }
  }
  
  /// Save data privacy settings
  Future<void> saveDataPrivacySettings(DataPrivacySettings settings) async {
    if (!_isInitialized) await initialize();
    
    try {
      await _database.saveDataPrivacySettings(settings);
      _logger.info('Saved data privacy settings for type: ${settings.dataType}');
    } catch (e) {
      _logger.warning('Error saving data privacy settings: $e');
      rethrow;
    }
  }
  
  /// Get data privacy settings for the current user
  Future<List<DataPrivacySettings>> getDataPrivacySettings() async {
    if (!_isInitialized) await initialize();
    
    try {
      return await _database.getDataPrivacySettingsForUser(_currentUserId!);
    } catch (e) {
      _logger.warning('Error retrieving data privacy settings: $e');
      rethrow;
    }
  }
  
  /// Get data privacy setting for a specific data type
  Future<DataPrivacySettings?> getDataPrivacySettingForType(String dataType) async {
    if (!_isInitialized) await initialize();
    
    try {
      final settings = await _database.getDataPrivacySettingsForUser(_currentUserId!);
      return settings.firstWhere(
        (s) => s.dataType == dataType,
        orElse: () => DataPrivacySettings(
          id: _uuid.v4(),
          userId: _currentUserId!,
          dataType: dataType,
        ),
      );
    } catch (e) {
      _logger.warning('Error retrieving data privacy setting for type $dataType: $e');
      return null;
    }
  }
  
  /// Check if a specific operation is allowed for a data type
  Future<bool> isOperationAllowed(String dataType, String operation) async {
    if (!_isInitialized) await initialize();
    
    try {
      final setting = await getDataPrivacySettingForType(dataType);
      if (setting == null) return false;
      
      switch (operation) {
        case 'local_storage':
          return setting.allowLocalStorage;
        case 'cloud_sync':
          return setting.allowCloudSync;
        case 'sharing':
          return setting.allowSharing;
        case 'analytics':
          return setting.allowAnonymizedAnalytics;
        default:
          return false;
      }
    } catch (e) {
      _logger.warning('Error checking operation permission: $e');
      return false;
    }
  }
  
  /// Save a challenge
  Future<void> saveChallenge(Challenge challenge) async {
    if (!_isInitialized) await initialize();
    
    try {
      await _database.saveChallenge(challenge);
      _logger.info('Saved challenge: ${challenge.title}');
    } catch (e) {
      _logger.warning('Error saving challenge: $e');
      rethrow;
    }
  }
  
  /// Get all available challenges
  Future<List<Challenge>> getAllChallenges() async {
    if (!_isInitialized) await initialize();
    
    try {
      return await _database.getAllChallenges();
    } catch (e) {
      _logger.warning('Error retrieving challenges: $e');
      return [];
    }
  }
  
  /// Save user's progress on a challenge
  Future<void> saveUserChallenge(UserChallenge userChallenge) async {
    if (!_isInitialized) await initialize();
    
    try {
      await _database.saveUserChallenge(userChallenge);
      _logger.info('Updated user challenge progress: ${userChallenge.challengeId}');
    } catch (e) {
      _logger.warning('Error saving user challenge: $e');
      rethrow;
    }
  }
  
  /// Get all challenges for the current user
  Future<List<UserChallenge>> getUserChallenges() async {
    if (!_isInitialized) await initialize();
    
    try {
      return await _database.getUserChallengesForUser(_currentUserId!);
    } catch (e) {
      _logger.warning('Error retrieving user challenges: $e');
      return [];
    }
  }
  
  /// Delete a user challenge
  Future<bool> deleteUserChallenge(String userChallengeId) async {
    if (!_isInitialized) await initialize();
    
    try {
      await _database.deleteUserChallenge(userChallengeId);
      _logger.info('Deleted user challenge: $userChallengeId');
      return true;
    } catch (e) {
      _logger.warning('Error deleting user challenge: $e');
      return false;
    }
  }
  
  /// Save a social connection
  Future<void> saveSocialConnection(SocialConnection connection) async {
    if (!_isInitialized) await initialize();
    
    try {
      await _database.saveSocialConnection(connection);
      _logger.info('Saved social connection to user: ${connection.connectedUserId}');
    } catch (e) {
      _logger.warning('Error saving social connection: $e');
      rethrow;
    }
  }
  
  /// Get all social connections for the current user
  Future<List<SocialConnection>> getSocialConnections() async {
    if (!_isInitialized) await initialize();
    
    try {
      return await _database.getSocialConnectionsForUser(_currentUserId!);
    } catch (e) {
      _logger.warning('Error retrieving social connections: $e');
      return [];
    }
  }
  
  /// Get friend IDs for a user
  Future<List<String>> getFriendIds(String userId) async {
    if (!_isInitialized) await initialize();
    
    try {
      final connections = await _database.getSocialConnectionsForUser(userId);
      return connections
          .where((connection) => connection.connectionType == 'friend')
          .map((connection) => connection.connectedUserId)
          .toList();
    } catch (e) {
      _logger.warning('Error retrieving friend IDs: $e');
      return [];
    }
  }
  
  /// Get received friend requests
  Future<List<String>> getReceivedFriendRequests(String userId) async {
    if (!_isInitialized) await initialize();
    
    try {
      return await _database.getReceivedFriendRequests(userId);
    } catch (e) {
      _logger.warning('Error retrieving received friend requests: $e');
      return [];
    }
  }
  
  /// Get sent friend requests
  Future<List<String>> getSentFriendRequests(String userId) async {
    if (!_isInitialized) await initialize();
    
    try {
      return await _database.getSentFriendRequests(userId);
    } catch (e) {
      _logger.warning('Error retrieving sent friend requests: $e');
      return [];
    }
  }
  
  /// Send a friend request
  Future<bool> sendFriendRequest(String fromUserId, String toUserId) async {
    if (!_isInitialized) await initialize();
    
    try {
      // Create a unique ID for this request
      final requestId = const Uuid().v4();
      
      // Save the request
      await _database.saveFriendRequest(
        requestId,
        fromUserId,
        toUserId,
        DateTime.now(),
        'pending'
      );
      
      return true;
    } catch (e) {
      _logger.warning('Error sending friend request: $e');
      return false;
    }
  }
  
  /// Accept a friend request
  Future<bool> acceptFriendRequest(String toUserId, String fromUserId) async {
    if (!_isInitialized) await initialize();
    
    try {
      // Update request status
      await _database.updateFriendRequestStatus(fromUserId, toUserId, 'accepted');
      
      // Create social connections in both directions
      final connectionId1 = const Uuid().v4();
      final connectionId2 = const Uuid().v4();
      final now = DateTime.now();
      
      // Create a connection from requester to accepter
      await _database.saveSocialConnection(
        SocialConnection(
          id: connectionId1,
          userId: fromUserId,
          connectedUserId: toUserId,
          connectionType: 'friend',
          connectedSince: now,
          isMutual: true,
        )
      );
      
      // Create a connection from accepter to requester
      await _database.saveSocialConnection(
        SocialConnection(
          id: connectionId2,
          userId: toUserId,
          connectedUserId: fromUserId,
          connectionType: 'friend',
          connectedSince: now,
          isMutual: true,
        )
      );
      
      return true;
    } catch (e) {
      _logger.warning('Error accepting friend request: $e');
      return false;
    }
  }
  
  /// Reject a friend request
  Future<bool> rejectFriendRequest(String toUserId, String fromUserId) async {
    if (!_isInitialized) await initialize();
    
    try {
      // Update request status
      await _database.updateFriendRequestStatus(fromUserId, toUserId, 'rejected');
      return true;
    } catch (e) {
      _logger.warning('Error rejecting friend request: $e');
      return false;
    }
  }
  
  /// Cancel a pending friend request
  Future<bool> cancelFriendRequest(String fromUserId, String toUserId) async {
    if (!_isInitialized) await initialize();
    
    try {
      // Update request status
      await _database.updateFriendRequestStatus(fromUserId, toUserId, 'cancelled');
      return true;
    } catch (e) {
      _logger.warning('Error cancelling friend request: $e');
      return false;
    }
  }
  
  /// Remove a friend connection between two users
  Future<bool> removeFriend(String userId1, String userId2) async {
    if (!_isInitialized) await initialize();
    
    try {
      // Remove connection in both directions
      await _database.removeSocialConnection(userId1, userId2, 'friend');
      await _database.removeSocialConnection(userId2, userId1, 'friend');
      return true;
    } catch (e) {
      _logger.warning('Error removing friend connection: $e');
      return false;
    }
  }
  
  /// Block a user
  Future<bool> blockUser(String userId, String blockedUserId) async {
    if (!_isInitialized) await initialize();
    
    try {
      // Create a block record
      final blockId = const Uuid().v4();
      await _database.saveUserBlock(blockId, userId, blockedUserId, DateTime.now());
      return true;
    } catch (e) {
      _logger.warning('Error blocking user: $e');
      return false;
    }
  }
  
  /// Unblock a user
  Future<bool> unblockUser(String userId, String blockedUserId) async {
    if (!_isInitialized) await initialize();
    
    try {
      await _database.removeUserBlock(userId, blockedUserId);
      return true;
    } catch (e) {
      _logger.warning('Error unblocking user: $e');
      return false;
    }
  }
  
  /// Check if a user is blocked
  Future<bool> isUserBlocked(String userId, String blockedUserId) async {
    if (!_isInitialized) await initialize();
    
    try {
      return await _database.isUserBlocked(userId, blockedUserId);
    } catch (e) {
      _logger.warning('Error checking if user is blocked: $e');
      return false;
    }
  }
  
  /// Get list of blocked users
  Future<List<String>> getBlockedUsers(String userId) async {
    if (!_isInitialized) await initialize();
    
    try {
      return await _database.getBlockedUsers(userId);
    } catch (e) {
      _logger.warning('Error getting blocked users: $e');
      return [];
    }
  }
  
  /// Save a leaderboard entry
  Future<bool> saveLeaderboardEntry(LeaderboardEntry entry) async {
    if (!_isInitialized) await initialize();
    
    try {
      await _database.saveLeaderboardEntry(entry);
      return true;
    } catch (e) {
      _logger.warning('Error saving leaderboard entry: $e');
      return false;
    }
  }
  
  /// Get leaderboard entries for a specific type and timeframe
  Future<List<LeaderboardEntry>> getLeaderboardEntries(String leaderboardType, String timeframe, 
    {String? regionCode, int limit = 100, int offset = 0}) async {
    if (!_isInitialized) await initialize();
    
    try {
      return await _database.getLeaderboardEntries(
        leaderboardType, 
        timeframe, 
        regionCode: regionCode, 
        limit: limit, 
        offset: offset
      );
    } catch (e) {
      _logger.warning('Error retrieving leaderboard entries: $e');
      return [];
    }
  }
  
  /// Get a user's ranking in a leaderboard
  Future<LeaderboardEntry?> getUserLeaderboardEntry(String userId, String leaderboardType, String timeframe, 
    {String? regionCode}) async {
    if (!_isInitialized) await initialize();
    
    try {
      return await _database.getUserLeaderboardEntry(
        userId, 
        leaderboardType, 
        timeframe, 
        regionCode: regionCode
      );
    } catch (e) {
      _logger.warning('Error retrieving user leaderboard entry: $e');
      return null;
    }
  }
  
  /// Save shared content
  Future<String?> saveSharedContent(SharedContent content) async {
    if (!_isInitialized) await initialize();
    
    try {
      await _database.saveSharedContent(content);
      return content.id;
    } catch (e) {
      _logger.warning('Error saving shared content: $e');
      return null;
    }
  }
  
  /// Get shared content for a user
  Future<List<SharedContent>> getSharedContentForUser(String userId) async {
    if (!_isInitialized) await initialize();
    
    try {
      return await _database.getSharedContentForUser(userId);
    } catch (e) {
      _logger.warning('Error retrieving shared content: $e');
      return [];
    }
  }
  
  /// Search for users by name
  Future<List<UserProfile>> searchUserProfiles(String query) async {
    if (!_isInitialized) await initialize();
    
    try {
      return await _database.searchUserProfiles(query);
    } catch (e) {
      _logger.warning('Error searching user profiles: $e');
      return [];
    }
  }
  
  /// Check if an operation is allowed based on user's privacy settings
  Future<bool> checkPrivacyPermission(String dataType, String operation) async {
    if (!_isInitialized) await initialize();
    
    try {
      // For data privacy-aware operations:
      // 1. Check if the operation is allowed for this data type
      final isAllowed = await isOperationAllowed(dataType, operation);
      
      // 2. If not allowed, log and return false
      if (!isAllowed) {
        _logger.info('Operation $operation not allowed for data type $dataType due to privacy settings');
        return false;
      }
      
      return true;
    } catch (e) {
      _logger.warning('Error checking privacy permission: $e');
      return false;
    }
  }
  
  /// Get metrics for a specific user that aren't covered by PerformanceMetrics
  Future<Map<String, dynamic>?> getUserMetrics(String userId) async {
    try {
      // Ensure we're initialized
      if (!_isInitialized) await initialize();
      
      // Query for metrics like trip count, fuel saved, CO2 reduced, etc.
      final trips = await _database.getAllTrips();
      
      // Filter trips for this user
      final userTrips = trips.where((trip) => 
        trip.userId == userId && 
        trip.isCompleted == true).toList();
      
      // Calculate metrics
      final tripCount = userTrips.length;
      
      // Calculate fuel saved (simplified calculation)
      // Assumes 10% better fuel efficiency compared to average driving
      double fuelSaved = 0.0;
      for (final trip in userTrips) {
        if (trip.fuelUsedL != null && trip.distanceKm != null) {
          // Assuming average car uses 7.5L/100km
          final averageFuelUsed = (trip.distanceKm! * 7.5) / 100;
          final actualFuelUsed = trip.fuelUsedL!;
          fuelSaved += (averageFuelUsed - actualFuelUsed).clamp(0, double.infinity);
        }
      }
      
      // Calculate CO2 reduction (2.31 kg CO2 per liter of fuel)
      final co2Reduced = fuelSaved * 2.31;
      
      // Calculate best driving streak (consecutive days with at least one trip)
      int bestDrivingStreak = _calculateBestDrivingStreak(userTrips);
      
      // Return all metrics
      return {
        'tripCount': tripCount,
        'fuelSaved': fuelSaved,
        'co2Reduced': co2Reduced,
        'bestDrivingStreak': bestDrivingStreak,
      };
    } catch (e) {
      _logger.severe('Error getting user metrics: $e');
      return null;
    }
  }
  
  /// Calculate the best driving streak (consecutive days with completed trips)
  int _calculateBestDrivingStreak(List<Trip> trips) {
    if (trips.isEmpty) return 0;
    
    // Sort trips by start time
    trips.sort((a, b) => a.startTime.compareTo(b.startTime));
    
    // Group trips by day
    final Map<String, List<Trip>> tripsByDay = {};
    for (final trip in trips) {
      final dateString = _formatDateKey(trip.startTime);
      tripsByDay[dateString] = [...(tripsByDay[dateString] ?? []), trip];
    }
    
    // Convert to a sorted list of dates
    final tripDates = tripsByDay.keys.toList()..sort();
    if (tripDates.isEmpty) return 0;
    
    // Calculate streaks
    int currentStreak = 1;
    int bestStreak = 1;
    
    for (int i = 1; i < tripDates.length; i++) {
      final previousDate = DateTime.parse(tripDates[i-1]);
      final currentDate = DateTime.parse(tripDates[i]);
      
      // Check if dates are consecutive
      final difference = currentDate.difference(previousDate).inDays;
      
      if (difference == 1) {
        // Consecutive day, increment streak
        currentStreak++;
        // Update best streak if current is better
        if (currentStreak > bestStreak) {
          bestStreak = currentStreak;
        }
      } else {
        // Streak broken, reset counter
        currentStreak = 1;
      }
    }
    
    return bestStreak;
  }
  
  /// Format a DateTime to a consistent string key for grouping by day
  String _formatDateKey(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }
  
  /// Save a badge for a user
  Future<Map<String, dynamic>?> saveBadge(Map<String, dynamic> badge) async {
    try {
      // Ensure we're initialized
      if (!_isInitialized) {
        _logger.info('DataStorageManager not initialized, initializing before saving badge');
        await initialize();
      }
      
      // Extract values from the badge map
      final userId = badge['userId'] as String;
      final badgeType = badge['badgeType'] as String;
      final earnedDate = badge['earnedDate'] as DateTime;
      final level = badge['level'] as int;
      final metadataJson = badge['metadataJson'] as String?;
      
      _logger.info('Saving badge $badgeType level $level for user $userId');
      
      // Verify user exists in database before trying to save badge (to avoid foreign key issues)
      final userExists = await _database.getUserProfileById(userId) != null;
      if (!userExists) {
        _logger.severe('Cannot save badge: User $userId does not exist in database');
        return null;
      }
      
      // Save to database with retry logic
      int attempts = 0;
      const maxAttempts = 3;
      bool saveSuccess = false;
      
      while (!saveSuccess && attempts < maxAttempts) {
        attempts++;
        try {
          _logger.info('Attempting to save badge $badgeType (attempt $attempts)');
          
          await _database.saveBadge(
            userId,
            badgeType,
            earnedDate,
            level,
            metadataJson,
          );
          
          // Verify the badge was saved
          final userBadges = await _database.getUserBadges(userId);
          final badgeExists = userBadges.any((b) => b.badgeType == badgeType);
          
          if (badgeExists) {
            _logger.info('Badge $badgeType successfully saved for user $userId');
            saveSuccess = true;
          } else {
            _logger.warning('Badge $badgeType not found after save attempt');
            await Future.delayed(Duration(milliseconds: 100 * attempts));
          }
        } catch (e) {
          _logger.warning('Error saving badge on attempt $attempts: $e');
          await Future.delayed(Duration(milliseconds: 100 * attempts));
        }
      }
      
      if (!saveSuccess) {
        _logger.severe('Failed to save badge $badgeType after $maxAttempts attempts');
        return null;
      }
      
      // Return the saved badge
      return badge;
    } catch (e) {
      _logger.severe('Error saving badge: $e');
      return null;
    }
  }
  
  /// Get all badges for a user
  Future<List<Map<String, dynamic>>> getUserBadges(String userId) async {
    try {
      // Ensure we're initialized
      if (!_isInitialized) {
        _logger.info('DataStorageManager not initialized, initializing before getting badges');
        await initialize();
      }
      
      _logger.info('Getting badges from database for user $userId');
      
      // Get badges from database
      final badges = await _database.getUserBadges(userId);
      _logger.info('Retrieved ${badges.length} badges from database for user $userId');
      
      // If badges is empty, log it
      if (badges.isEmpty) {
        _logger.info('No badges found in database for user $userId');
      } else {
        // Log all badge types for debugging
        final badgeTypes = badges.map((b) => b.badgeType).toList();
        _logger.info('Badge types for user $userId: ${badgeTypes.join(', ')}');
      }
      
      // Convert to Maps
      final mappedBadges = badges.map((badge) => {
        'userId': badge.userId,
        'badgeType': badge.badgeType,
        'earnedDate': badge.earnedDate,
        'level': badge.level,
        'metadataJson': badge.metadataJson,
      }).toList();
      
      return mappedBadges;
    } catch (e) {
      _logger.severe('Error getting user badges: $e');
      return [];
    }
  }
  
  /// Delete all data for a user
  Future<void> deleteUserData(String userId) async {
    if (!_isInitialized) await initialize();
    
    try {
      _logger.info('Deleting all data for user: $userId');
      
      // Delete all user-related data from tables - with try/catch for each operation
      // to handle cases where tables might not exist yet
      
      // Core data tables - these should always exist
      try {
        await _database.deleteUserTrips(userId);
        _logger.info('Deleted user trips');
      } catch (e) {
        _logger.warning('Error deleting user trips: $e');
      }
      
      try {
        await _database.deleteUserDrivingEvents(userId);
        _logger.info('Deleted user driving events');
      } catch (e) {
        _logger.warning('Error deleting user driving events: $e');
      }
      
      try {
        await _database.deleteUserPerformanceMetrics(userId);
        _logger.info('Deleted user performance metrics');
      } catch (e) {
        _logger.warning('Error deleting user performance metrics: $e');
      }
      
      try {
        await _database.deleteUserBadges(userId);
        _logger.info('Deleted user badges');
      } catch (e) {
        _logger.warning('Error deleting user badges: $e');
      }
      
      try {
        await _database.deleteUserDataPrivacySettings(userId);
        _logger.info('Deleted user privacy settings');
      } catch (e) {
        _logger.warning('Error deleting user privacy settings: $e');
      }
      
      // Social features - these might not exist yet
      try {
        await _database.deleteUserSocialConnections(userId);
        _logger.info('Deleted user social connections');
      } catch (e) {
        _logger.warning('Error deleting user social connections: $e');
      }
      
      try {
        await _database.deleteUserSocialInteractions(userId);
        _logger.info('Deleted user social interactions');
      } catch (e) {
        _logger.warning('Error deleting user social interactions: $e');
      }
      
      try {
        await _database.deleteUserFriendRequests(userId);
        _logger.info('Deleted user friend requests');
      } catch (e) {
        _logger.warning('Error deleting user friend requests: $e');
      }
      
      try {
        await _database.deleteUserBlocks(userId);
        _logger.info('Deleted user blocks');
      } catch (e) {
        _logger.warning('Error deleting user blocks: $e');
      }
      
      try {
        await _database.deleteUserSharedContent(userId);
        _logger.info('Deleted user shared content');
      } catch (e) {
        _logger.warning('Error deleting user shared content: $e');
      }
      
      // Gamification - these might not exist yet
      try {
        await _database.deleteUserPreferences(userId);
        _logger.info('Deleted user preferences');
      } catch (e) {
        _logger.warning('Error deleting user preferences: $e');
      }
      
      try {
        await _database.deleteUserChallenges(userId);
        _logger.info('Deleted user challenges');
      } catch (e) {
        _logger.warning('Error deleting user challenges: $e');
      }
      
      try {
        await _database.deleteUserStreaks(userId);
        _logger.info('Deleted user streaks');
      } catch (e) {
        _logger.warning('Error deleting user streaks: $e');
      }
      
      try {
        await _database.deleteUserLeaderboardEntries(userId);
        _logger.info('Deleted user leaderboard entries');
      } catch (e) {
        _logger.warning('Error deleting user leaderboard entries: $e');
      }
      
      try {
        await _database.deleteUserExternalIntegrations(userId);
        _logger.info('Deleted user external integrations');
      } catch (e) {
        _logger.warning('Error deleting user external integrations: $e');
      }
      
      // Reset shared preferences
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('user_id');
      await prefs.remove('is_anonymous');
      await prefs.remove('allow_cloud_sync');
      await prefs.remove('is_public_profile');
      await prefs.remove('preferences_json');
      
      // Optional: Consider clearing cached files
      try {
        final appDir = await getApplicationDocumentsDirectory();
        final userDir = Directory('${appDir.path}/$userId');
        if (await userDir.exists()) {
          await userDir.delete(recursive: true);
          _logger.info('Deleted user directory: ${userDir.path}');
        }
      } catch (e) {
        _logger.warning('Could not delete user directory: $e');
      }
      
      // Reset internal state
      _currentUserId = null;
      _allowCloudSync = false;
      _isPublicProfile = false;
      
      _logger.info('Successfully deleted all data for user: $userId');
    } catch (e) {
      _logger.severe('Error deleting user data: $e');
      rethrow;
    }
  }
  
  /// Delete basic user data (simplified version of deleteUserData)
  /// This is a more targeted method that only deletes core data tables
  /// with timeout protection to prevent hanging
  Future<void> deleteBasicUserData(String userId) async {
    if (!_isInitialized) await initialize();
    
    try {
      _logger.info('Deleting basic user data for: $userId');
      
      // Use individual futures with timeouts for critical tables
      // to prevent any one operation from hanging the whole process
      
      // Core tables
      await _deleteTableWithTimeout(_database.deleteUserTrips, userId, 'trips');
      await _deleteTableWithTimeout(_database.deleteUserDrivingEvents, userId, 'driving events');
      await _deleteTableWithTimeout(_database.deleteUserPerformanceMetrics, userId, 'performance metrics');
      await _deleteTableWithTimeout(_database.deleteUserBadges, userId, 'badges');
      await _deleteTableWithTimeout(_database.deleteUserDataPrivacySettings, userId, 'privacy settings');
      
      // Reset shared preferences
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('user_id');
      await prefs.remove('is_anonymous');
      await prefs.remove('allow_cloud_sync');
      await prefs.remove('is_public_profile');
      await prefs.remove('preferences_json');
      
      // Reset internal state
      _currentUserId = null;
      _allowCloudSync = false;
      _isPublicProfile = false;
      
      _logger.info('Successfully deleted basic user data for: $userId');
    } catch (e) {
      _logger.severe('Error deleting basic user data: $e');
      rethrow;
    }
  }
  
  /// Helper to delete table data with timeout protection
  Future<void> _deleteTableWithTimeout(
    Future<int> Function(String) deleteFunction, 
    String userId, 
    String tableName
  ) async {
    try {
      // Set a timeout for each delete operation to prevent hanging
      final result = await deleteFunction(userId)
          .timeout(const Duration(seconds: 3), onTimeout: () {
        _logger.warning('Timeout deleting $tableName for user $userId');
        return 0; // Return 0 rows deleted on timeout
      });
      
      _logger.info('Deleted $result $tableName records for user $userId');
    } catch (e) {
      // Log but don't rethrow to allow other tables to be processed
      _logger.warning('Error deleting $tableName: $e');
    }
  }
  
  /// Get user profile by Firebase ID
  Future<UserProfile?> getUserProfileByFirebaseId(String firebaseId) async {
    try {
      await initialize();
      
      // Get profile from database
      final userProfile = await _database.getUserProfileByFirebaseId(firebaseId);
      
      if (userProfile != null) {
        _logger.info('Found user profile by Firebase ID: $firebaseId');
      } else {
        _logger.info('No user profile found for Firebase ID: $firebaseId');
      }
      
      return userProfile;
    } catch (e) {
      _logger.severe('Error getting user profile by Firebase ID: $e');
      return null;
    }
  }
  
  /// Update an existing user profile with a Firebase ID
  Future<UserProfile?> updateUserProfileFirebaseId(String userId, String firebaseId) async {
    try {
      await initialize();
      
      // Get existing profile
      final existingProfile = await _database.getUserProfileById(userId);
      
      if (existingProfile == null) {
        _logger.warning('Cannot update Firebase ID: User profile not found for ID: $userId');
        return null;
      }
      
      // Create updated profile
      final updatedProfile = existingProfile.copyWith(
        firebaseId: firebaseId,
        lastUpdatedAt: DateTime.now(),
      );
      
      // Save to database
      await _database.updateUserProfile(updatedProfile);
      
      _logger.info('Updated Firebase ID for user: $userId');
      return updatedProfile;
    } catch (e) {
      _logger.severe('Error updating Firebase ID for user profile: $e');
      return null;
    }
  }
  
  /// Update user profile with extended information
  Future<UserProfile?> updateUserProfile(
    String userId, 
    String name, {
    bool? isPublic,
    bool? allowDataUpload, 
    String? email,
    String? firebaseId,
  }) async {
    try {
      await initialize();
      
      // Get existing profile
      final existingProfile = await _database.getUserProfileById(userId);
      
      if (existingProfile == null) {
        _logger.warning('Cannot update profile: User profile not found for ID: $userId');
        return null;
      }
      
      // Create updated profile
      final updatedProfile = existingProfile.copyWith(
        name: name,
        isPublic: isPublic,
        allowDataUpload: allowDataUpload,
        email: email,
        firebaseId: firebaseId,
        lastUpdatedAt: DateTime.now(),
      );
      
      // Save to database
      await _database.updateUserProfile(updatedProfile);
      
      _logger.info('Updated profile for user: $userId');
      return updatedProfile;
    } catch (e) {
      _logger.severe('Error updating user profile: $e');
      return null;
    }
  }
  
  /// Save a new user profile with extended information including Firebase details
  Future<UserProfile?> saveUserProfileWithFirebase(
    String userId, 
    String name, 
    bool isPublic, 
    bool allowDataUpload, {
    String? email,
    String? firebaseId,
  }) async {
    try {
      await initialize();
      
      if (firebaseId != null && email != null) {
        // Use the insertUserProfile method if we have Firebase auth details
        return await _database.insertUserProfile(
          name: name,
          isPublic: isPublic,
          allowDataUpload: allowDataUpload,
          firebaseId: firebaseId,
          email: email,
        );
      } else {
        // For non-Firebase users, use the older method
        final now = DateTime.now();
        
        // Create the profile
        final userProfile = UserProfile(
          id: userId,
          name: name,
          createdAt: now,
          lastUpdatedAt: now,
          isPublic: isPublic,
          allowDataUpload: allowDataUpload,
          email: email,
          firebaseId: firebaseId,
        );
        
        // Save to database using existing method for backward compatibility
        await _database.saveUserProfile(userId, name, isPublic, allowDataUpload);
        
        _logger.info('Created new user profile with ID: $userId');
        return userProfile;
      }
    } catch (e) {
      _logger.severe('Error saving user profile: $e');
      return null;
    }
  }
} 

################################################################################
FILE: lib/behavior_classifier_lib/behavior_classifier_lib.dart
################################################################################

// Interfaces
export 'interfaces/behavior_detector.dart';

// Detectors
export 'detectors/calm_driving_detector.dart';
export 'detectors/speed_optimization_detector.dart';
export 'detectors/idling_detector.dart';
export 'detectors/short_distance_detector.dart';
export 'detectors/rpm_management_detector.dart';
export 'detectors/stop_management_detector.dart';
export 'detectors/follow_distance_detector.dart';

// Managers
export 'managers/eco_driving_manager.dart'; 

################################################################################
FILE: lib/behavior_classifier_lib/managers/eco_driving_manager.dart
################################################################################

import 'dart:collection';

import 'package:going50/core_models/combined_driving_data.dart';
import 'package:going50/behavior_classifier_lib/interfaces/behavior_detector.dart';
import 'package:going50/behavior_classifier_lib/detectors/calm_driving_detector.dart';
import 'package:going50/behavior_classifier_lib/detectors/speed_optimization_detector.dart';
import 'package:going50/behavior_classifier_lib/detectors/idling_detector.dart';
import 'package:going50/behavior_classifier_lib/detectors/short_distance_detector.dart';
import 'package:going50/behavior_classifier_lib/detectors/rpm_management_detector.dart';
import 'package:going50/behavior_classifier_lib/detectors/stop_management_detector.dart';
import 'package:going50/behavior_classifier_lib/detectors/follow_distance_detector.dart';

/// Manages all eco-driving detectors
class EcoDrivingManager {
  final List<BehaviorDetector> detectors;
  final int historyWindowSize;
  final Queue<CombinedDrivingData> dataQueue = Queue();
  
  EcoDrivingManager({
    List<BehaviorDetector>? detectors,
    this.historyWindowSize = 60, // Default to 1 minute of data (assuming 1 sample per second)
  }) : detectors = detectors ?? [
    CalmDrivingDetector(),
    SpeedOptimizationDetector(),
    IdlingDetector(),
    ShortDistanceDetector(),
    RPMManagementDetector(),
    StopManagementDetector(),
    FollowDistanceDetector(),
  ];
  
  /// Add new data point and analyze
  void addDataPoint(CombinedDrivingData dataPoint) {
    // Add to queue
    dataQueue.add(dataPoint);
    
    // Remove oldest if queue is too large
    while (dataQueue.length > historyWindowSize) {
      dataQueue.removeFirst();
    }
  }
  
  /// Analyze current data and return results from all detectors
  Map<String, BehaviorDetectionResult> analyzeAll() {
    Map<String, BehaviorDetectionResult> results = {};
    List<CombinedDrivingData> dataPoints = dataQueue.toList();
    
    // Run each detector
    results['calmDriving'] = detectors[0].detectBehavior(dataPoints);
    results['speedOptimization'] = detectors[1].detectBehavior(dataPoints);
    results['idling'] = detectors[2].detectBehavior(dataPoints);
    results['shortDistance'] = detectors[3].detectBehavior(dataPoints);
    results['rpmManagement'] = detectors[4].detectBehavior(dataPoints);
    results['stopManagement'] = detectors[5].detectBehavior(dataPoints);
    results['followDistance'] = detectors[6].detectBehavior(dataPoints);
    
    return results;
  }
  
  /// Calculate overall eco-driving score (0-100)
  double calculateOverallScore() {
    Map<String, BehaviorDetectionResult> results = analyzeAll();
    
    // If no data, return 0
    if (dataQueue.isEmpty) return 0.0;
    
    // Define weights for each behavior (sum should be 1.0)
    Map<String, double> weights = {
      'calmDriving': 0.25,        // 25% - Very important
      'speedOptimization': 0.2,   // 20% - Important
      'idling': 0.1,              // 10% - Lower but still important
      'shortDistance': 0.1,       // 10% - Lower but still important
      'rpmManagement': 0.15,      // 15% - Moderately important
      'stopManagement': 0.1,      // 10% - Lower but still important
      'followDistance': 0.1,      // 10% - Lower but still important
    };
    
    double weightedSum = 0.0;
    double totalWeight = 0.0;
    
    // Calculate weighted score
    results.forEach((key, result) {
      double weight = weights[key] ?? 0.0;
      
      // Adjust weight by confidence
      double adjustedWeight = weight * result.confidence;
      totalWeight += adjustedWeight;
      
      // Add to weighted sum (invert severity since lower severity = better score)
      double score = result.detected ? 100.0 * (1.0 - (result.severity ?? 0.0)) : 100.0;
      weightedSum += score * adjustedWeight;
    });
    
    // Return weighted average (or 0 if no weights)
    return totalWeight > 0.0 ? weightedSum / totalWeight : 0.0;
  }
  
  /// Get detailed analysis with scores for each category
  Map<String, dynamic> getDetailedAnalysis() {
    Map<String, BehaviorDetectionResult> results = analyzeAll();
    double overallScore = calculateOverallScore();
    
    Map<String, dynamic> detailedScores = {};
    
    // Calculate individual scores
    results.forEach((key, result) {
      double score = result.detected ? 100.0 * (1.0 - (result.severity ?? 0.0)) : 100.0;
      
      detailedScores[key] = {
        'score': score,
        'confidence': result.confidence,
        'message': result.message,
        'details': result.additionalData,
      };
    });
    
    return {
      'overallScore': overallScore,
      'detailedScores': detailedScores,
      'dataPointsAnalyzed': dataQueue.length,
      'timeRange': dataQueue.isNotEmpty 
          ? '${dataQueue.first.timestamp.toIso8601String()} to ${dataQueue.last.timestamp.toIso8601String()}'
          : 'No data',
    };
  }
  
  /// Clear all stored data
  void clearData() {
    dataQueue.clear();
  }
} 

################################################################################
FILE: lib/behavior_classifier_lib/detectors/follow_distance_detector.dart
################################################################################

import 'dart:math';

import 'package:going50/core_models/combined_driving_data.dart';
import 'package:going50/behavior_classifier_lib/interfaces/behavior_detector.dart';

/// Detects unsafe following distance
class FollowDistanceDetector extends BehaviorDetector {
  final double minSafeFollowTimeSeconds; // Minimum safe following distance in seconds
  final double brakeDetectionThreshold; // m/s², threshold for significant braking
  
  FollowDistanceDetector({
    this.minSafeFollowTimeSeconds = 2.0, // 2 seconds minimum following distance
    this.brakeDetectionThreshold = 3.0, // 3 m/s² = moderate braking
  });
  
  @override
  int get minimumDataPoints => 30; // Need sufficient data to evaluate following patterns
  
  @override
  List<String> get requiredDataFields => [
    'obdData.vehicleSpeed',
    'sensorData.accelerationX',
    'sensorData.accelerationY',
    'sensorData.accelerationZ',
  ];
  
  @override
  BehaviorDetectionResult detectBehavior(List<CombinedDrivingData> dataPoints) {
    if (dataPoints.isEmpty) {
      return BehaviorDetectionResult(
        detected: false,
        confidence: 0.0,
        message: 'No data available for following distance analysis',
      );
    }
    
    // Calculate confidence based on available data
    double confidence = calculateConfidence(dataPoints);
    
    // Following distance can't be directly measured without radar/camera data
    // We'll use a proxy: sudden braking events, which often occur when following too closely
    
    // If we don't have the car's radar/distance sensor data (most cars won't expose this),
    // we significantly reduce confidence
    bool hasRadarData = dataPoints.any((d) => d.estimatedFollowDistance != null);
    
    if (!hasRadarData) {
      // Significantly reduce confidence since we're using a proxy
      confidence *= 0.4;
    }
    
    // Sort data points by timestamp
    dataPoints.sort((a, b) => a.timestamp.compareTo(b.timestamp));
    
    int suddenBrakingEvents = 0;
    List<DateTime> brakingEventTimes = [];
    
    // Look for sudden deceleration events
    for (int i = 1; i < dataPoints.length; i++) {
      double? prevSpeed = _getSpeed(dataPoints[i-1]);
      double? currentSpeed = _getSpeed(dataPoints[i]);
      
      if (prevSpeed == null || currentSpeed == null) continue;
      
      // Time difference in seconds
      double timeDiff = dataPoints[i].timestamp.difference(dataPoints[i-1].timestamp).inMilliseconds / 1000;
      if (timeDiff <= 0) continue;
      
      // Calculate deceleration in m/s²
      // Convert km/h to m/s by multiplying by 1000/3600
      double deceleration = ((prevSpeed - currentSpeed) * 1000 / 3600) / timeDiff;
      
      // Check for sudden braking (high deceleration)
      if (deceleration > brakeDetectionThreshold) {
        // Verify with accelerometer data if available
        bool confirmedWithAccelerometer = false;
        
        if (dataPoints[i].sensorData?.accelerationX != null) {
          // Forward deceleration is typically negative in the X direction
          // (assuming phone is mounted with screen facing driver and top pointing forward)
          double? accelX = dataPoints[i].sensorData?.accelerationX;
          if (accelX != null && accelX < -brakeDetectionThreshold) {
            confirmedWithAccelerometer = true;
          }
        }
        
        // If we have accelerometer data but it doesn't confirm braking, skip this event
        if (dataPoints[i].sensorData?.accelerationX != null && !confirmedWithAccelerometer) {
          continue;
        }
        
        suddenBrakingEvents++;
        brakingEventTimes.add(dataPoints[i].timestamp);
      }
    }
    
    // Check for clusters of braking events (indicating stop-and-go traffic)
    // which would reduce confidence since braking is expected in such conditions
    List<List<DateTime>> brakingClusters = _identifyBrakingClusters(brakingEventTimes);
    int clusteredEvents = brakingClusters.fold(0, (sum, cluster) => sum + cluster.length);
    
    // Calculate what percentage of braking events were part of clusters
    double clusterPercentage = suddenBrakingEvents > 0 
        ? clusteredEvents / suddenBrakingEvents 
        : 0.0;
    
    // Reduce confidence if many braking events are clustered (likely traffic)
    confidence *= (1.0 - clusterPercentage * 0.5);
    
    // Calculate trip distance and time
    double? totalDistanceKm = _calculateTripDistance(dataPoints);
    Duration totalTime = dataPoints.isEmpty 
        ? Duration.zero 
        : dataPoints.last.timestamp.difference(dataPoints.first.timestamp);
    
    // Calculate braking events per km and per minute
    double eventsPerKm = totalDistanceKm != null && totalDistanceKm > 0
        ? suddenBrakingEvents / totalDistanceKm
        : 0;
    
    double eventsPerMinute = totalTime.inMinutes > 0
        ? suddenBrakingEvents / (totalTime.inMinutes)
        : 0;
    
    // Determine severity based on braking frequency
    double severity = min(eventsPerKm, 1.0); // Over 1 event/km is maximum severity
    
    // Frequent sudden braking (proxy for close following) detected if more than 0.5 events per km
    bool isDetected = eventsPerKm > 0.5;
    
    return BehaviorDetectionResult(
      detected: isDetected,
      confidence: confidence,
      severity: severity,
      message: isDetected
          ? 'Frequent hard braking detected: may indicate following too closely'
          : 'Following distance appears adequate based on braking patterns',
      additionalData: {
        'suddenBrakingEvents': suddenBrakingEvents,
        'brakingEventsPerKm': eventsPerKm,
        'brakingEventsPerMinute': eventsPerMinute,
        'brakingClusters': brakingClusters.length,
        'totalDistanceKm': totalDistanceKm,
        'confidenceNote': hasRadarData 
            ? 'Based on direct distance measurements' 
            : 'Inferred from braking patterns (lower confidence)',
      },
    );
  }
  
  // Helper to get speed from best available source
  double? _getSpeed(CombinedDrivingData data) {
    return data.obdData?.vehicleSpeed ?? data.sensorData?.gpsSpeed;
  }
  
  // Identify clusters of braking events (likely indicating traffic)
  List<List<DateTime>> _identifyBrakingClusters(List<DateTime> eventTimes) {
    if (eventTimes.isEmpty) return [];
    
    List<List<DateTime>> clusters = [];
    List<DateTime> currentCluster = [eventTimes.first];
    
    for (int i = 1; i < eventTimes.length; i++) {
      // If this event is close to the previous one (within 30 seconds),
      // add it to the current cluster
      if (eventTimes[i].difference(eventTimes[i-1]).inSeconds < 30) {
        currentCluster.add(eventTimes[i]);
      } else {
        // Otherwise, start a new cluster
        if (currentCluster.length > 1) {
          clusters.add(List.from(currentCluster));
        }
        currentCluster = [eventTimes[i]];
      }
    }
    
    // Add the last cluster if it has more than one event
    if (currentCluster.length > 1) {
      clusters.add(currentCluster);
    }
    
    return clusters;
  }
  
  // Calculate trip distance using GPS coordinates if available
  double? _calculateTripDistance(List<CombinedDrivingData> dataPoints) {
    double totalDistance = 0.0;
    
    // Use GPS coordinates if available
    bool hasGpsData = false;
    for (int i = 1; i < dataPoints.length; i++) {
      double? lat1 = dataPoints[i-1].sensorData?.latitude;
      double? lon1 = dataPoints[i-1].sensorData?.longitude;
      double? lat2 = dataPoints[i].sensorData?.latitude;
      double? lon2 = dataPoints[i].sensorData?.longitude;
      
      if (lat1 != null && lon1 != null && lat2 != null && lon2 != null) {
        totalDistance += _calculateHaversineDistance(lat1, lon1, lat2, lon2);
        hasGpsData = true;
      }
    }
    
    // If no GPS data, try to use speed data to estimate distance
    if (!hasGpsData) {
      totalDistance = 0.0;
      for (int i = 1; i < dataPoints.length; i++) {
        double? speed = _getSpeed(dataPoints[i-1]);
        if (speed != null) {
          // Convert speed from km/h to km/s
          double speedKmS = speed / 3600;
          // Time difference in seconds
          double timeDiff = dataPoints[i].timestamp.difference(dataPoints[i-1].timestamp).inMilliseconds / 1000;
          // Distance = speed * time
          totalDistance += speedKmS * timeDiff;
        } else {
          // If we don't have speed data, we can't calculate distance
          return null;
        }
      }
    }
    
    return totalDistance;
  }
  
  // Calculate haversine distance between two points
  double _calculateHaversineDistance(double lat1, double lon1, double lat2, double lon2) {
    const double earthRadius = 6371; // km
    
    // Convert to radians
    double dLat = _toRadians(lat2 - lat1);
    double dLon = _toRadians(lon2 - lon1);
    
    double a = sin(dLat / 2) * sin(dLat / 2) +
               cos(_toRadians(lat1)) * cos(_toRadians(lat2)) *
               sin(dLon / 2) * sin(dLon / 2);
    
    double c = 2 * atan2(sqrt(a), sqrt(1 - a));
    
    return earthRadius * c;
  }
  
  double _toRadians(double degrees) {
    return degrees * pi / 180;
  }
} 

################################################################################
FILE: lib/behavior_classifier_lib/detectors/short_distance_detector.dart
################################################################################

import 'dart:math';

import 'package:going50/core_models/combined_driving_data.dart';
import 'package:going50/behavior_classifier_lib/interfaces/behavior_detector.dart';

/// Detects short trips that are inefficient
class ShortDistanceDetector extends BehaviorDetector {
  final double shortTripThresholdKm; // Threshold for short trip classification
  final double engineWarmupTimeMinutes; // Estimated time for engine to warm up
  
  ShortDistanceDetector({
    this.shortTripThresholdKm = 3.0, // Trips under 3 km considered short
    this.engineWarmupTimeMinutes = 5.0, // Engine needs ~5 min to warm up
  });
  
  @override
  int get minimumDataPoints => 5; // Need enough data points to determine trip characteristics
  
  @override
  List<String> get requiredDataFields => [
    'obdData.vehicleSpeed',
    'obdData.engineTemp',
    'sensorData.gpsSpeed',
    'sensorData.latitude',
    'sensorData.longitude',
  ];
  
  @override
  BehaviorDetectionResult detectBehavior(List<CombinedDrivingData> dataPoints) {
    if (dataPoints.isEmpty) {
      return BehaviorDetectionResult(
        detected: false,
        confidence: 0.0,
        message: 'No data available for trip analysis',
      );
    }
    
    // Calculate confidence based on available data
    double confidence = calculateConfidence(dataPoints);
    
    // Sort data points by timestamp
    dataPoints.sort((a, b) => a.timestamp.compareTo(b.timestamp));
    
    // Analyze the trip
    double? distanceKm = _calculateTripDistance(dataPoints);
    Duration tripDuration = dataPoints.last.timestamp.difference(dataPoints.first.timestamp);
    
    // Get engine temperature data if available
    double? startTemp = _getEngineTemp(dataPoints.first);
    double? endTemp = _getEngineTemp(dataPoints.last);
    bool coldStart = startTemp != null && startTemp < 60; // Example threshold for cold engine
    
    // If we can't calculate distance, try using time as a proxy
    if (distanceKm == null) {
      // Lower confidence since we're estimating
      confidence *= 0.7;
      
      // Estimate distance based on time and assumed average speed
      double avgSpeed = 30.0; // km/h, conservative urban average
      distanceKm = tripDuration.inSeconds * (avgSpeed / 3600);
    }
    
    // Determine severity based on how short the trip is and if it was a cold start
    double distanceFactor = distanceKm < shortTripThresholdKm 
        ? 1.0 - (distanceKm / shortTripThresholdKm) 
        : 0.0;
    
    // Cold starts are worse for short trips
    double severity = distanceFactor;
    if (coldStart) {
      severity = min(severity * 1.5, 1.0);
    }
    
    // Short trip detected if distance is under threshold
    bool isShortTrip = distanceKm < shortTripThresholdKm;
    
    return BehaviorDetectionResult(
      detected: isShortTrip,
      confidence: confidence,
      severity: severity,
      message: isShortTrip
          ? 'Short trip detected: ${distanceKm.toStringAsFixed(1)} km${coldStart ? ' with cold engine' : ''}'
          : 'Trip length is efficient: ${distanceKm.toStringAsFixed(1)} km',
      additionalData: {
        'distanceKm': distanceKm,
        'durationMinutes': tripDuration.inMinutes,
        'coldStart': coldStart,
        'startTemperature': startTemp,
        'endTemperature': endTemp,
      },
    );
  }
  
  // Helper to get engine temperature
  double? _getEngineTemp(CombinedDrivingData data) {
    return data.obdData?.engineTemp;
  }
  
  // Calculate trip distance using GPS coordinates if available
  double? _calculateTripDistance(List<CombinedDrivingData> dataPoints) {
    double totalDistance = 0.0;
    
    // Use GPS coordinates if available
    bool hasGpsData = false;
    for (int i = 1; i < dataPoints.length; i++) {
      double? lat1 = dataPoints[i-1].sensorData?.latitude;
      double? lon1 = dataPoints[i-1].sensorData?.longitude;
      double? lat2 = dataPoints[i].sensorData?.latitude;
      double? lon2 = dataPoints[i].sensorData?.longitude;
      
      if (lat1 != null && lon1 != null && lat2 != null && lon2 != null) {
        totalDistance += _calculateHaversineDistance(lat1, lon1, lat2, lon2);
        hasGpsData = true;
      }
    }
    
    // If no GPS data, try to use speed data to estimate distance
    if (!hasGpsData) {
      totalDistance = 0.0;
      for (int i = 1; i < dataPoints.length; i++) {
        double? speed = _getSpeed(dataPoints[i-1]);
        if (speed != null) {
          // Convert speed from km/h to km/s
          double speedKmS = speed / 3600;
          // Time difference in seconds
          double timeDiff = dataPoints[i].timestamp.difference(dataPoints[i-1].timestamp).inMilliseconds / 1000;
          // Distance = speed * time
          totalDistance += speedKmS * timeDiff;
        } else {
          // If we don't have speed data, we can't calculate distance
          return null;
        }
      }
    }
    
    return totalDistance;
  }
  
  // Calculate haversine distance between two points
  double _calculateHaversineDistance(double lat1, double lon1, double lat2, double lon2) {
    const double earthRadius = 6371; // km
    
    // Convert to radians
    double dLat = _toRadians(lat2 - lat1);
    double dLon = _toRadians(lon2 - lon1);
    
    double a = sin(dLat / 2) * sin(dLat / 2) +
               cos(_toRadians(lat1)) * cos(_toRadians(lat2)) *
               sin(dLon / 2) * sin(dLon / 2);
    
    double c = 2 * atan2(sqrt(a), sqrt(1 - a));
    
    return earthRadius * c;
  }
  
  double _toRadians(double degrees) {
    return degrees * pi / 180;
  }
  
  // Helper to get speed from best available source
  double? _getSpeed(CombinedDrivingData data) {
    return data.obdData?.vehicleSpeed ?? data.sensorData?.gpsSpeed;
  }
} 

################################################################################
FILE: lib/behavior_classifier_lib/detectors/calm_driving_detector.dart
################################################################################

import 'dart:math';

import 'package:going50/core_models/combined_driving_data.dart';
import 'package:going50/behavior_classifier_lib/interfaces/behavior_detector.dart';

/// Detects aggressive acceleration and braking patterns
class CalmDrivingDetector extends BehaviorDetector {
  final double accelerationThreshold; // km/h/s threshold for aggressive acceleration
  final double brakingThreshold; // km/h/s threshold for aggressive braking
  final double slopeAdjustmentFactor; // How much to adjust thresholds for slope
  
  CalmDrivingDetector({
    this.accelerationThreshold = 5.0, // 5 km/h/s as per research
    this.brakingThreshold = 5.0,      // 5 km/h/s
    this.slopeAdjustmentFactor = 0.5, // increase threshold by 0.5 km/h/s per % slope
  });
  
  @override
  int get minimumDataPoints => 5; // Need several data points to detect acceleration patterns
  
  @override
  List<String> get requiredDataFields => [
    'obdData.vehicleSpeed',
    'sensorData.accelerationX',
    'sensorData.accelerationY',
    'sensorData.accelerationZ',
    'contextData.slope',
  ];
  
  @override
  double calculateConfidence(List<CombinedDrivingData> dataPoints) {
    // Base confidence starts at 0.3 (minimum)
    double confidence = 0.3;
    
    // Check if we have enough data points
    if (dataPoints.length < minimumDataPoints) {
      return confidence * (dataPoints.length / minimumDataPoints);
    }
    
    // Count how many required fields are present
    int availableFields = 0;
    int totalRequiredFields = requiredDataFields.length;
    
    for (String field in requiredDataFields) {
      bool hasField = _checkFieldAvailability(dataPoints.first, field);
      if (hasField) availableFields++;
    }
    
    // Calculate confidence based on field availability (0.3-1.0 range)
    return 0.3 + 0.7 * (availableFields / totalRequiredFields);
  }
  
  /// Helper to check if a field is available in the data
  bool _checkFieldAvailability(CombinedDrivingData data, String fieldPath) {
    List<String> parts = fieldPath.split('.');
    
    if (parts[0] == 'obdData') {
      if (data.obdData == null) return false;
      
      switch (parts[1]) {
        case 'vehicleSpeed': return data.obdData!.vehicleSpeed != null;
        case 'rpm': return data.obdData!.rpm != null;
        case 'throttlePosition': return data.obdData!.throttlePosition != null;
        case 'engineRunning': return data.obdData!.engineRunning != null;
        // Add additional OBD fields as needed
        default: return false;
      }
    } else if (parts[0] == 'sensorData') {
      if (data.sensorData == null) return false;
      
      switch (parts[1]) {
        case 'gpsSpeed': return data.sensorData!.gpsSpeed != null;
        case 'accelerationX': return data.sensorData!.accelerationX != null;
        case 'accelerationY': return data.sensorData!.accelerationY != null;
        case 'accelerationZ': return data.sensorData!.accelerationZ != null;
        // Add additional sensor fields as needed
        default: return false;
      }
    } else if (parts[0] == 'contextData') {
      if (data.contextData == null) return false;
      
      switch (parts[1]) {
        case 'speedLimit': return data.contextData!.speedLimit != null;
        case 'slope': return data.contextData!.slope != null;
        case 'isTrafficJam': return data.contextData!.isTrafficJam != null;
        // Add additional context fields as needed
        default: return false;
      }
    }
    
    return false;
  }
  
  @override
  BehaviorDetectionResult detectBehavior(List<CombinedDrivingData> dataPoints) {
    if (dataPoints.length < 2) {
      return BehaviorDetectionResult(
        detected: false,
        confidence: 0.1,
        message: 'Insufficient data points to calculate acceleration',
      );
    }
    
    // Calculate confidence based on available data
    double confidence = calculateConfidence(dataPoints);
    
    // Track aggressive events
    int aggressiveAccelerations = 0;
    int aggressiveBrakings = 0;
    List<double> accelerationValues = [];
    
    // Sort data points by timestamp to ensure correct sequence
    dataPoints.sort((a, b) => a.timestamp.compareTo(b.timestamp));
    
    // Calculate acceleration between consecutive data points
    for (int i = 1; i < dataPoints.length; i++) {
      double? prevSpeed = _getSpeed(dataPoints[i-1]);
      double? currentSpeed = _getSpeed(dataPoints[i]);
      
      if (prevSpeed == null || currentSpeed == null) continue;
      
      // Time difference in seconds
      double timeDiff = dataPoints[i].timestamp.difference(dataPoints[i-1].timestamp).inMilliseconds / 1000;
      if (timeDiff <= 0) continue;
      
      // Calculate acceleration in km/h/s
      double acceleration = (currentSpeed - prevSpeed) / timeDiff;
      accelerationValues.add(acceleration);
      
      // Adjust threshold based on slope if available
      double adjustedAccelThreshold = accelerationThreshold;
      double adjustedBrakingThreshold = brakingThreshold;
      
      if (dataPoints[i].contextData?.slope != null) {
        double slope = dataPoints[i].contextData!.slope!;
        adjustedAccelThreshold += slope * slopeAdjustmentFactor;
        adjustedBrakingThreshold -= slope * slopeAdjustmentFactor;
      }
      
      // Check for aggressive acceleration
      if (acceleration > adjustedAccelThreshold && prevSpeed > 30) { // Above 30 km/h as per research
        aggressiveAccelerations++;
      }
      
      // Check for aggressive braking (negative acceleration)
      if (acceleration < -adjustedBrakingThreshold) {
        aggressiveBrakings++;
      }
    }
    
    // Calculate the percentage of aggressive events
    int totalEvents = dataPoints.length - 1;
    double aggressivePercentage = (aggressiveAccelerations + aggressiveBrakings) / totalEvents;
    
    // Determine severity - higher percentage means higher severity
    double severity = min(aggressivePercentage * 3, 1.0); // Scale it to 0-1 range
    
    // Aggressive driving is detected if severity exceeds 0.2 (i.e., >6.7% of events are aggressive)
    bool isAggressive = severity > 0.2;
    
    return BehaviorDetectionResult(
      detected: isAggressive,
      confidence: confidence,
      severity: severity,
      message: isAggressive 
          ? 'Aggressive driving detected: ${(severity * 100).toStringAsFixed(1)}% aggressive events'
          : 'Calm driving pattern detected',
      additionalData: {
        'aggressiveAccelerations': aggressiveAccelerations,
        'aggressiveBrakings': aggressiveBrakings,
        'totalEvents': totalEvents,
        'accelerationValues': accelerationValues,
      },
    );
  }
  
  // Helper to get speed from best available source
  double? _getSpeed(CombinedDrivingData data) {
    return data.obdData?.vehicleSpeed ?? data.sensorData?.gpsSpeed;
  }
} 

################################################################################
FILE: lib/behavior_classifier_lib/detectors/idling_detector.dart
################################################################################

import 'dart:math';

import 'package:going50/core_models/combined_driving_data.dart';
import 'package:going50/behavior_classifier_lib/interfaces/behavior_detector.dart';

/// Detects engine idling behavior
class IdlingDetector extends BehaviorDetector {
  final int idlingThresholdSeconds; // Seconds of idling to be considered wasteful
  final double maxSpeedForIdling; // km/h, maximum speed to be considered idling
  
  IdlingDetector({
    this.idlingThresholdSeconds = 30, // 30 seconds as per research
    this.maxSpeedForIdling = 1.0, // 1 km/h to account for GPS/speed reading fluctuations
  });
  
  @override
  int get minimumDataPoints => 5; // Need several consecutive points to detect idling
  
  @override
  List<String> get requiredDataFields => [
    'obdData.engineRunning',
    'obdData.vehicleSpeed',
    'obdData.rpm',
    'sensorData.gpsSpeed',
  ];
  
  @override
  BehaviorDetectionResult detectBehavior(List<CombinedDrivingData> dataPoints) {
    if (dataPoints.isEmpty) {
      return BehaviorDetectionResult(
        detected: false,
        confidence: 0.0,
        message: 'No data available for idling analysis',
      );
    }
    
    // Calculate confidence based on available data
    double confidence = calculateConfidence(dataPoints);
    
    // Sort data points by timestamp
    dataPoints.sort((a, b) => a.timestamp.compareTo(b.timestamp));
    
    List<IdlingEvent> idlingEvents = [];
    DateTime? idlingStartTime;
    CombinedDrivingData? idlingStartData;
    
    for (int i = 0; i < dataPoints.length; i++) {
      var data = dataPoints[i];
      
      // Check if engine is running and speed is near zero
      bool isIdling = _isIdlingState(data);
      
      if (isIdling) {
        // Start tracking a new idling event
        if (idlingStartTime == null) {
          idlingStartTime = data.timestamp;
          idlingStartData = data;
        }
      } else {
        // End the current idling event if one was in progress
        if (idlingStartTime != null) {
          Duration idlingDuration = data.timestamp.difference(idlingStartTime);
          
          // Only record if duration exceeds threshold
          if (idlingDuration.inSeconds >= idlingThresholdSeconds) {
            idlingEvents.add(IdlingEvent(
              startTime: idlingStartTime,
              endTime: data.timestamp,
              duration: idlingDuration,
              temperature: idlingStartData?.obdData?.engineTemp,
            ));
          }
          
          // Reset tracking
          idlingStartTime = null;
          idlingStartData = null;
        }
      }
    }
    
    // Check for an ongoing idling event at the end of the data
    if (idlingStartTime != null) {
      var lastData = dataPoints.last;
      Duration idlingDuration = lastData.timestamp.difference(idlingStartTime);
      
      if (idlingDuration.inSeconds >= idlingThresholdSeconds) {
        idlingEvents.add(IdlingEvent(
          startTime: idlingStartTime,
          endTime: lastData.timestamp,
          duration: idlingDuration,
          temperature: idlingStartData?.obdData?.engineTemp,
        ));
      }
    }
    
    // Calculate total idling time and data collection time
    Duration totalIdlingTime = Duration.zero;
    for (var event in idlingEvents) {
      totalIdlingTime += event.duration;
    }
    
    Duration totalTime = dataPoints.isEmpty 
        ? Duration.zero 
        : dataPoints.last.timestamp.difference(dataPoints.first.timestamp);
    
    // Calculate idling percentage
    double idlingPercentage = totalTime.inSeconds > 0 
        ? totalIdlingTime.inSeconds / totalTime.inSeconds 
        : 0.0;
    
    // Determine severity based on idling percentage
    double severity = min(idlingPercentage * 5, 1.0); // Scale up to make small percentages more significant
    
    // Excessive idling detected if there's at least one event over threshold
    bool isDetected = idlingEvents.isNotEmpty;
    
    return BehaviorDetectionResult(
      detected: isDetected,
      confidence: confidence,
      severity: severity,
      message: isDetected
          ? '${idlingEvents.length} idling events detected totaling ${_formatDuration(totalIdlingTime)}'
          : 'No excessive idling detected',
      additionalData: {
        'idlingEvents': idlingEvents.map((e) => {
          'startTime': e.startTime.toIso8601String(),
          'endTime': e.endTime.toIso8601String(),
          'durationSeconds': e.duration.inSeconds,
          'engineTemp': e.temperature,
        }).toList(),
        'totalIdlingTimeSeconds': totalIdlingTime.inSeconds,
        'idlingPercentage': idlingPercentage,
      },
    );
  }
  
  // Helper to format duration in mm:ss
  String _formatDuration(Duration duration) {
    int minutes = duration.inMinutes;
    int seconds = duration.inSeconds % 60;
    return '$minutes:${seconds.toString().padLeft(2, '0')}';
  }
  
  // Helper to determine if the current state is idling
  bool _isIdlingState(CombinedDrivingData data) {
    // Best case: OBD data with engine status and speed
    if (data.obdData?.engineRunning == true) {
      double? speed = data.obdData?.vehicleSpeed;
      if (speed != null && speed <= maxSpeedForIdling) {
        return true;
      }
    }
    
    // Alternative: Check RPM and speed
    if (data.obdData?.rpm != null && data.obdData!.rpm! > 0) {
      double? speed = data.obdData?.vehicleSpeed ?? data.sensorData?.gpsSpeed;
      if (speed != null && speed <= maxSpeedForIdling) {
        return true;
      }
    }
    
    // Fallback: Use GPS speed only
    if (data.obdData == null && data.sensorData?.gpsSpeed != null) {
      // This is less reliable, we need to infer engine state
      if (data.sensorData!.gpsSpeed! <= maxSpeedForIdling) {
        // Try to infer if engine is running using accelerometer vibration
        if (data.sensorData?.accelerationX != null && 
            data.sensorData?.accelerationY != null && 
            data.sensorData?.accelerationZ != null) {
          
          double vibration = _calculateVibration(
            data.sensorData!.accelerationX!,
            data.sensorData!.accelerationY!,
            data.sensorData!.accelerationZ!
          );
          
          // Threshold determined experimentally - vehicle vibrations cause small accelerometer fluctuations
          return vibration > 0.05;
        }
      }
    }
    
    return false;
  }
  
  // Calculate vibration magnitude from accelerometer data
  double _calculateVibration(double x, double y, double z) {
    return sqrt(x*x + y*y + z*z);
  }
}

/// Helper class for idling events
class IdlingEvent {
  final DateTime startTime;
  final DateTime endTime;
  final Duration duration;
  final double? temperature; // Engine temperature if available
  
  IdlingEvent({
    required this.startTime,
    required this.endTime,
    required this.duration,
    this.temperature,
  });
} 

################################################################################
FILE: lib/behavior_classifier_lib/detectors/speed_optimization_detector.dart
################################################################################

import 'dart:math';

import 'package:going50/core_models/combined_driving_data.dart';
import 'package:going50/behavior_classifier_lib/interfaces/behavior_detector.dart';

/// Detects if speed is within optimal range for fuel efficiency
class SpeedOptimizationDetector extends BehaviorDetector {
  final double minOptimalSpeed; // km/h
  final double maxOptimalSpeed; // km/h
  final double minSpeedThreshold; // Only evaluate when above this speed
  
  SpeedOptimizationDetector({
    this.minOptimalSpeed = 50.0, // 50-75 km/h optimal range as per research
    this.maxOptimalSpeed = 75.0,
    this.minSpeedThreshold = 20.0, // Don't evaluate below 20 km/h (city traffic)
  });
  
  @override
  int get minimumDataPoints => 10; // Need sufficient data to evaluate speed patterns
  
  @override
  List<String> get requiredDataFields => [
    'obdData.vehicleSpeed',
    'sensorData.gpsSpeed',
    'contextData.speedLimit',
    'contextData.roadType',
  ];
  
  @override
  BehaviorDetectionResult detectBehavior(List<CombinedDrivingData> dataPoints) {
    if (dataPoints.isEmpty) {
      return BehaviorDetectionResult(
        detected: false,
        confidence: 0.0,
        message: 'No data available for speed analysis',
      );
    }
    
    // Calculate confidence based on available data
    double confidence = calculateConfidence(dataPoints);
    
    int totalPoints = 0;
    int optimalPoints = 0;
    int highSpeedPoints = 0;
    double? maxSpeed;
    double? avgSpeed;
    
    // Calculate sum for average
    double speedSum = 0;
    int speedCount = 0;
    
    // Analyze each data point
    for (var data in dataPoints) {
      double? speed = _getSpeed(data);
      if (speed == null) continue;
      
      // Track max speed
      if (maxSpeed == null || speed > maxSpeed) {
        maxSpeed = speed;
      }
      
      // Add to average calculation
      speedSum += speed;
      speedCount++;
      
      // Skip evaluation for very low speeds (likely in city traffic, stopping)
      if (speed < minSpeedThreshold) continue;
      
      totalPoints++;
      
      // Check if within optimal range
      if (speed >= minOptimalSpeed && speed <= maxOptimalSpeed) {
        optimalPoints++;
      }
      
      // Check for excessive speed (over 80 km/h as per research)
      if (speed > 80) {
        highSpeedPoints++;
      }
    }
    
    // Calculate average speed
    if (speedCount > 0) {
      avgSpeed = speedSum / speedCount;
    }
    
    // Calculate deviation from optimal range
    double severity = 0.0;
    if (totalPoints > 0) {
      double optimalPercentage = optimalPoints / totalPoints;
      double highSpeedPercentage = highSpeedPoints / totalPoints;
      
      // Severity is inverse of optimal percentage + penalty for high speed
      severity = (1.0 - optimalPercentage) * 0.7 + highSpeedPercentage * 0.3;
      severity = min(severity, 1.0);
    }
    
    // Determine if speed is optimal based on severity
    bool isOptimal = severity < 0.3; // Less than 30% deviation is considered optimal
    
    return BehaviorDetectionResult(
      detected: isOptimal,
      confidence: confidence,
      severity: severity,
      message: isOptimal 
          ? 'Speed management is optimal: ${(100 - severity * 100).toStringAsFixed(1)}% within efficient range'
          : 'Speed management needs improvement: only ${((1.0 - severity) * 100).toStringAsFixed(1)}% within efficient range',
      additionalData: {
        'maxSpeed': maxSpeed,
        'avgSpeed': avgSpeed,
        'optimalPercentage': totalPoints > 0 ? optimalPoints / totalPoints : 0,
        'highSpeedPercentage': totalPoints > 0 ? highSpeedPoints / totalPoints : 0,
      },
    );
  }
  
  // Helper to get speed from best available source
  double? _getSpeed(CombinedDrivingData data) {
    return data.obdData?.vehicleSpeed ?? data.sensorData?.gpsSpeed;
  }
} 

################################################################################
FILE: lib/behavior_classifier_lib/detectors/rpm_management_detector.dart
################################################################################

import 'dart:math';

import 'package:going50/core_models/combined_driving_data.dart';
import 'package:going50/behavior_classifier_lib/interfaces/behavior_detector.dart';

/// Detects high RPM driving patterns
class RPMManagementDetector extends BehaviorDetector {
  final Map<int, int> gearRPMThresholds; // Map of gear position to RPM threshold
  final int defaultRPMThreshold; // Default threshold for unknown gear
  final double speedRPMRatioThreshold; // Threshold for RPM/speed ratio
  
  RPMManagementDetector({
    Map<int, int>? gearRPMThresholds,
    this.defaultRPMThreshold = 2500, // Conservative default for all gears
    this.speedRPMRatioThreshold = 70.0, // RPM per km/h threshold
  }) : gearRPMThresholds = gearRPMThresholds ?? {
    1: 3000, // 1st gear
    2: 2700, // 2nd gear
    3: 2500, // 3rd gear
    4: 2300, // 4th gear
    5: 2000, // 5th gear
    6: 1800, // 6th gear
  };
  
  @override
  int get minimumDataPoints => 20; // Need sufficient data to evaluate RPM patterns
  
  @override
  List<String> get requiredDataFields => [
    'obdData.rpm',
    'obdData.vehicleSpeed',
    'obdData.gearPosition',
    'contextData.transmissionType',
  ];
  
  @override
  BehaviorDetectionResult detectBehavior(List<CombinedDrivingData> dataPoints) {
    if (dataPoints.isEmpty) {
      return BehaviorDetectionResult(
        detected: false,
        confidence: 0.0,
        message: 'No data available for RPM analysis',
      );
    }
    
    // Calculate confidence based on available data
    double confidence = calculateConfidence(dataPoints);
    
    // If we don't have RPM data, we can't do this analysis
    bool hasRPMData = dataPoints.any((data) => data.obdData?.rpm != null);
    if (!hasRPMData) {
      return BehaviorDetectionResult(
        detected: false,
        confidence: 0.1,
        message: 'No RPM data available for analysis',
      );
    }
    
    // Check if transmission is automatic (less relevant for automatic)
    String? transmissionType;
    for (var data in dataPoints) {
      if (data.contextData?.transmissionType != null) {
        transmissionType = data.contextData!.transmissionType;
        break;
      }
    }
    
    // If automatic, reduce confidence as RPM management is less driver-controlled
    if (transmissionType?.toLowerCase() == 'automatic') {
      confidence *= 0.6;
    }
    
    int totalPoints = 0;
    int highRPMPoints = 0;
    Map<int, int> totalPointsByGear = {};
    Map<int, int> highRPMPointsByGear = {};
    
    // Track max and average RPM
    int? maxRPM;
    double rpmSum = 0;
    int rpmCount = 0;
    
    // Analyze each data point
    for (var data in dataPoints) {
      int? rpm = data.obdData?.rpm;
      double? speed = data.obdData?.vehicleSpeed;
      int? gear = data.obdData?.gearPosition;
      
      if (rpm == null) continue;
      
      // Track max RPM
      if (maxRPM == null || rpm > maxRPM) {
        maxRPM = rpm;
      }
      
      // Add to average calculation
      rpmSum += rpm;
      rpmCount++;
      
      // Skip if speed is very low (likely idling, stopping)
      if (speed == null || speed < 5) continue;
      
      totalPoints++;
      
      // Use gear-specific threshold if gear is known
      int rpmThreshold;
      if (gear != null && gearRPMThresholds.containsKey(gear)) {
        rpmThreshold = gearRPMThresholds[gear]!;
        
        // Track by gear for detailed analysis
        totalPointsByGear[gear] = (totalPointsByGear[gear] ?? 0) + 1;
        if (rpm > rpmThreshold) {
          highRPMPointsByGear[gear] = (highRPMPointsByGear[gear] ?? 0) + 1;
        }
      } else {
        // Use RPM/speed ratio if gear is unknown
        double rpmPerSpeed = rpm / speed;
        if (rpmPerSpeed > speedRPMRatioThreshold) {
          highRPMPoints++;
        }
        
        // Also use default threshold as backup
        rpmThreshold = defaultRPMThreshold;
      }
      
      // Check if RPM is higher than threshold
      if (rpm > rpmThreshold) {
        highRPMPoints++;
      }
    }
    
    // Calculate average RPM
    double? avgRPM = rpmCount > 0 ? rpmSum / rpmCount : null;
    
    // Calculate percentage of time spent at high RPM
    double highRPMPercentage = totalPoints > 0 ? highRPMPoints / totalPoints : 0;
    
    // Determine severity (0-1 range)
    double severity = min(highRPMPercentage * 2, 1.0); // Scale up to make small percentages more significant
    
    // High RPM driving detected if more than 20% of time is at high RPM
    bool isDetected = highRPMPercentage > 0.2;
    
    return BehaviorDetectionResult(
      detected: isDetected,
      confidence: confidence,
      severity: severity,
      message: isDetected
          ? 'High RPM driving detected: ${(highRPMPercentage * 100).toStringAsFixed(1)}% of driving time'
          : 'RPM management is good: ${(highRPMPercentage * 100).toStringAsFixed(1)}% high RPM',
      additionalData: {
        'highRPMPercentage': highRPMPercentage,
        'maxRPM': maxRPM,
        'averageRPM': avgRPM,
        'totalPointsByGear': totalPointsByGear,
        'highRPMPointsByGear': highRPMPointsByGear,
        'transmissionType': transmissionType,
      },
    );
  }
} 

################################################################################
FILE: lib/behavior_classifier_lib/detectors/stop_management_detector.dart
################################################################################

import 'dart:math';

import 'package:going50/core_models/combined_driving_data.dart';
import 'package:going50/behavior_classifier_lib/interfaces/behavior_detector.dart';

/// Detects frequent stops and starts
class StopManagementDetector extends BehaviorDetector {
  final double stopSpeedThreshold; // km/h, speed below which is considered a stop
  final double minDistanceBetweenStopsKm; // Minimum distance between stops to be considered separate stops
  
  StopManagementDetector({
    this.stopSpeedThreshold = 3.0, // 3 km/h threshold for a stop
    this.minDistanceBetweenStopsKm = 0.5, // 500m minimum between stops
  });
  
  @override
  int get minimumDataPoints => 20; // Need sufficient data to evaluate stop patterns
  
  @override
  List<String> get requiredDataFields => [
    'obdData.vehicleSpeed',
    'sensorData.gpsSpeed',
    'sensorData.latitude',
    'sensorData.longitude',
  ];
  
  @override
  BehaviorDetectionResult detectBehavior(List<CombinedDrivingData> dataPoints) {
    if (dataPoints.isEmpty) {
      return BehaviorDetectionResult(
        detected: false,
        confidence: 0.0,
        message: 'No data available for stop pattern analysis',
      );
    }
    
    // Calculate confidence based on available data
    double confidence = calculateConfidence(dataPoints);
    
    // Sort data points by timestamp
    dataPoints.sort((a, b) => a.timestamp.compareTo(b.timestamp));
    
    List<StopEvent> stopEvents = [];
    bool inStopState = false;
    CombinedDrivingData? stopStartData;
    
    // Identify all stops in the data
    for (int i = 0; i < dataPoints.length; i++) {
      var data = dataPoints[i];
      double? speed = _getSpeed(data);
      
      if (speed == null) continue;
      
      bool isStopped = speed < stopSpeedThreshold;
      
      // Transition from moving to stopped
      if (!inStopState && isStopped) {
        inStopState = true;
        stopStartData = data;
      }
      // Transition from stopped to moving
      else if (inStopState && !isStopped) {
        if (stopStartData != null) {
          stopEvents.add(StopEvent(
            startTime: stopStartData.timestamp,
            endTime: data.timestamp,
            duration: data.timestamp.difference(stopStartData.timestamp),
            latitude: data.sensorData?.latitude,
            longitude: data.sensorData?.longitude,
          ));
        }
        
        inStopState = false;
        stopStartData = null;
      }
    }
    
    // Check for an ongoing stop at the end of the data
    if (inStopState && stopStartData != null) {
      var lastData = dataPoints.last;
      stopEvents.add(StopEvent(
        startTime: stopStartData.timestamp,
        endTime: lastData.timestamp,
        duration: lastData.timestamp.difference(stopStartData.timestamp),
        latitude: lastData.sensorData?.latitude,
        longitude: lastData.sensorData?.longitude,
      ));
    }
    
    // Filter out very brief stops (less than 3 seconds) as they might be data noise
    stopEvents = stopEvents.where((event) => event.duration.inSeconds >= 3).toList();
    
    // Calculate trip distance and time
    double? totalDistanceKm = _calculateTripDistance(dataPoints);
    Duration totalTime = dataPoints.isEmpty 
        ? Duration.zero 
        : dataPoints.last.timestamp.difference(dataPoints.first.timestamp);
    
    // Calculate stops per km and stops per minute
    double stopsPerKm = totalDistanceKm != null && totalDistanceKm > 0
        ? stopEvents.length / totalDistanceKm
        : 0;
    
    double stopsPerMinute = totalTime.inMinutes > 0
        ? stopEvents.length / (totalTime.inMinutes)
        : 0;
    
    // Determine severity based on stop frequency
    // Stops per km is more relevant for eco-driving
    double severity = min(stopsPerKm / 2, 1.0); // Over 2 stops/km is maximum severity
    
    // Frequent stops detected if more than 1 stop per km
    bool isDetected = stopsPerKm > 1.0;
    
    return BehaviorDetectionResult(
      detected: isDetected,
      confidence: confidence,
      severity: severity,
      message: isDetected
          ? 'Frequent stops detected: ${stopsPerKm.toStringAsFixed(1)} stops per km'
          : 'Stop frequency is acceptable: ${stopsPerKm.toStringAsFixed(1)} stops per km',
      additionalData: {
        'totalStops': stopEvents.length,
        'stopsPerKm': stopsPerKm,
        'stopsPerMinute': stopsPerMinute,
        'totalDistanceKm': totalDistanceKm,
        'totalTimeMinutes': totalTime.inMinutes,
      },
    );
  }
  
  // Helper to get speed from best available source
  double? _getSpeed(CombinedDrivingData data) {
    return data.obdData?.vehicleSpeed ?? data.sensorData?.gpsSpeed;
  }
  
  // Calculate trip distance using GPS coordinates if available
  double? _calculateTripDistance(List<CombinedDrivingData> dataPoints) {
    double totalDistance = 0.0;
    
    // Use GPS coordinates if available
    bool hasGpsData = false;
    for (int i = 1; i < dataPoints.length; i++) {
      double? lat1 = dataPoints[i-1].sensorData?.latitude;
      double? lon1 = dataPoints[i-1].sensorData?.longitude;
      double? lat2 = dataPoints[i].sensorData?.latitude;
      double? lon2 = dataPoints[i].sensorData?.longitude;
      
      if (lat1 != null && lon1 != null && lat2 != null && lon2 != null) {
        totalDistance += _calculateHaversineDistance(lat1, lon1, lat2, lon2);
        hasGpsData = true;
      }
    }
    
    // If no GPS data, try to use speed data to estimate distance
    if (!hasGpsData) {
      totalDistance = 0.0;
      for (int i = 1; i < dataPoints.length; i++) {
        double? speed = _getSpeed(dataPoints[i-1]);
        if (speed != null) {
          // Convert speed from km/h to km/s
          double speedKmS = speed / 3600;
          // Time difference in seconds
          double timeDiff = dataPoints[i].timestamp.difference(dataPoints[i-1].timestamp).inMilliseconds / 1000;
          // Distance = speed * time
          totalDistance += speedKmS * timeDiff;
        } else {
          // If we don't have speed data, we can't calculate distance
          return null;
        }
      }
    }
    
    return totalDistance;
  }
  
  // Calculate haversine distance between two points
  double _calculateHaversineDistance(double lat1, double lon1, double lat2, double lon2) {
    const double earthRadius = 6371; // km
    
    // Convert to radians
    double dLat = _toRadians(lat2 - lat1);
    double dLon = _toRadians(lon2 - lon1);
    
    double a = sin(dLat / 2) * sin(dLat / 2) +
               cos(_toRadians(lat1)) * cos(_toRadians(lat2)) *
               sin(dLon / 2) * sin(dLon / 2);
    
    double c = 2 * atan2(sqrt(a), sqrt(1 - a));
    
    return earthRadius * c;
  }
  
  double _toRadians(double degrees) {
    return degrees * pi / 180;
  }
}

/// Helper class for stop events
class StopEvent {
  final DateTime startTime;
  final DateTime endTime;
  final Duration duration;
  final double? latitude;
  final double? longitude;
  
  StopEvent({
    required this.startTime,
    required this.endTime,
    required this.duration,
    this.latitude,
    this.longitude,
  });
} 

################################################################################
FILE: lib/behavior_classifier_lib/interfaces/behavior_detector.dart
################################################################################

import 'package:going50/core_models/combined_driving_data.dart';

/// Base abstract class for all behavior detectors
abstract class BehaviorDetector {
  /// Analyzes data to detect eco-driving behavior
  /// Returns a BehaviorDetectionResult with detection status and confidence
  BehaviorDetectionResult detectBehavior(List<CombinedDrivingData> dataPoints);
  
  /// Returns the minimum required data points for reliable detection
  int get minimumDataPoints;
  
  /// Returns the list of required data fields for optimal detection
  List<String> get requiredDataFields;
  
  /// Calculate confidence score based on available data
  double calculateConfidence(List<CombinedDrivingData> dataPoints) {
    // Base confidence starts at 0.3 (minimum)
    double confidence = 0.3;
    
    // Check if we have enough data points
    if (dataPoints.length < minimumDataPoints) {
      return confidence * (dataPoints.length / minimumDataPoints);
    }
    
    // Count how many required fields are present
    int availableFields = 0;
    int totalRequiredFields = requiredDataFields.length;
    
    for (String field in requiredDataFields) {
      bool hasField = _checkFieldAvailability(dataPoints.first, field);
      if (hasField) availableFields++;
    }
    
    // Calculate confidence based on field availability (0.3-1.0 range)
    return 0.3 + 0.7 * (availableFields / totalRequiredFields);
  }
  
  /// Helper to check if a field is available in the data
  bool _checkFieldAvailability(CombinedDrivingData data, String fieldPath) {
    List<String> parts = fieldPath.split('.');
    
    if (parts[0] == 'obdData') {
      if (data.obdData == null) return false;
      
      switch (parts[1]) {
        case 'vehicleSpeed': return data.obdData!.vehicleSpeed != null;
        case 'rpm': return data.obdData!.rpm != null;
        case 'throttlePosition': return data.obdData!.throttlePosition != null;
        case 'engineRunning': return data.obdData!.engineRunning != null;
        // Add additional OBD fields as needed
        default: return false;
      }
    } else if (parts[0] == 'sensorData') {
      if (data.sensorData == null) return false;
      
      switch (parts[1]) {
        case 'gpsSpeed': return data.sensorData!.gpsSpeed != null;
        case 'accelerationX': return data.sensorData!.accelerationX != null;
        case 'accelerationY': return data.sensorData!.accelerationY != null;
        case 'accelerationZ': return data.sensorData!.accelerationZ != null;
        // Add additional sensor fields as needed
        default: return false;
      }
    } else if (parts[0] == 'contextData') {
      if (data.contextData == null) return false;
      
      switch (parts[1]) {
        case 'speedLimit': return data.contextData!.speedLimit != null;
        case 'slope': return data.contextData!.slope != null;
        case 'isTrafficJam': return data.contextData!.isTrafficJam != null;
        // Add additional context fields as needed
        default: return false;
      }
    }
    
    return false;
  }
}

/// Result of a behavior detection operation
class BehaviorDetectionResult {
  final bool detected;
  final double confidence; // 0.0 to 1.0
  final double? severity; // 0.0 to 1.0, how severe the behavior is
  final String? message;
  final Map<String, dynamic>? additionalData;
  final int occurrences; // Number of times the behavior was detected
  
  BehaviorDetectionResult({
    required this.detected,
    required this.confidence,
    this.severity,
    this.message,
    this.additionalData,
    this.occurrences = 0,
  });
  
  @override
  String toString() {
    return 'Detected: $detected, Confidence: ${(confidence * 100).toStringAsFixed(1)}%, ${severity != null ? 'Severity: ${(severity! * 100).toStringAsFixed(1)}%, ' : ''}Occurrences: $occurrences, ${message != null ? 'Message: $message' : ''}';
  }
} 

################################################################################
FILE: lib/presentation/providers/social_provider.dart
################################################################################

import 'package:flutter/foundation.dart';
import 'package:going50/core_models/user_profile.dart';
import 'package:going50/services/social/social_service.dart';
import 'package:going50/services/social/leaderboard_service.dart';
import 'package:going50/services/social/sharing_service.dart';

/// Provider for social features
///
/// This provider is responsible for:
/// - Managing connections between users
/// - Providing leaderboard functionality
/// - Handling content sharing
class SocialProvider extends ChangeNotifier {
  // Dependencies
  final SocialService _socialService;
  final LeaderboardService _leaderboardService;
  final SharingService _sharingService;
  
  // State
  List<UserProfile> _friends = [];
  List<Map<String, dynamic>> _leaderboardEntries = [];
  bool _isLoading = false;
  String? _errorMessage;
  
  // Public getters
  
  /// List of friends
  List<UserProfile> get friends => _friends;
  
  /// Current leaderboard entries
  List<Map<String, dynamic>> get leaderboardEntries => _leaderboardEntries;
  
  /// Whether data is currently being loaded
  bool get isLoading => _isLoading;
  
  /// Error message, if any
  String? get errorMessage => _errorMessage;
  
  /// Selected leaderboard type ('global', 'regional', 'friends')
  String _leaderboardType = 'global';
  String get leaderboardType => _leaderboardType;
  
  /// Selected leaderboard timeframe ('daily', 'weekly', 'monthly', 'alltime')
  String _timeframe = 'weekly';
  String get timeframe => _timeframe;
  
  /// Constructor
  SocialProvider(this._socialService, this._leaderboardService, this._sharingService) {
    _initialize();
  }
  
  /// Initialize the provider
  void _initialize() {
    _setLoading(true);
    
    // Subscribe to social service events
    _socialService.socialEventStream.listen(_handleSocialEvent);
    _socialService.friendsStream.listen(_handleFriendsUpdate);
    
    // Load initial data
    _loadInitialData();
  }
  
  /// Load initial data 
  Future<void> _loadInitialData() async {
    try {
      // Load friends
      _friends = _socialService.friends;
      
      // Load leaderboard data
      await _refreshLeaderboard();
      
      notifyListeners();
    } catch (e) {
      _setError('Failed to load social data: $e');
    } finally {
      _setLoading(false);
    }
  }
  
  /// Handle social event
  void _handleSocialEvent(Map<String, dynamic> event) {
    final eventType = event['type'] as String;
    
    switch (eventType) {
      case 'friend_added':
      case 'friend_removed':
      case 'request_accepted':
        // Refresh friends list
        _friends = _socialService.friends;
        notifyListeners();
        break;
        
      case 'content_shared':
      case 'content_shared_external':
        // Nothing to do here, just informational
        break;
        
      default:
        // Unknown event
        break;
    }
  }
  
  /// Handle friends update
  void _handleFriendsUpdate(List<UserProfile> friends) {
    _friends = friends;
    notifyListeners();
  }
  
  /// Set the leaderboard type
  Future<void> setLeaderboardType(String type) async {
    if (_leaderboardType != type) {
      _leaderboardType = type;
      await _refreshLeaderboard();
      notifyListeners();
    }
  }
  
  /// Set the leaderboard timeframe
  Future<void> setTimeframe(String timeframe) async {
    if (_timeframe != timeframe) {
      _timeframe = timeframe;
      await _refreshLeaderboard();
      notifyListeners();
    }
  }
  
  /// Refresh leaderboard data
  Future<void> _refreshLeaderboard() async {
    _setLoading(true);
    
    try {
      _leaderboardEntries = await _leaderboardService.getLeaderboard(
        type: _leaderboardType,
        timeframe: _timeframe,
      );
    } catch (e) {
      _setError('Failed to load leaderboard: $e');
    } finally {
      _setLoading(false);
    }
  }
  
  /// Filter leaderboard by friend status
  List<Map<String, dynamic>> getFilteredLeaderboard({bool friendsOnly = false}) {
    if (!friendsOnly) return _leaderboardEntries;
    
    return _leaderboardEntries.where((entry) => 
      entry['isFriend'] == true
    ).toList();
  }
  
  /// Share trip or achievement
  Future<bool> shareContent({
    required String contentType, 
    required String contentId,
    required String shareType
  }) async {
    _setLoading(true);
    
    try {
      // Get current user ID (in a real implementation, this would come from a user service)
      const userId = 'current_user_id';
      
      final result = await _sharingService.shareContent(
        userId: userId,
        contentType: contentType,
        contentId: contentId,
        shareType: shareType,
      );
      
      // Return success
      return result != null;
    } catch (e) {
      _setError('Failed to share content: $e');
      return false;
    } finally {
      _setLoading(false);
    }
  }
  
  /// Get details for a specific friend
  UserProfile? getFriendById(String friendId) {
    try {
      return _friends.firstWhere((friend) => friend.id == friendId);
    } catch (e) {
      // Friend not found
      return null;
    }
  }
  
  /// Add a new friend
  Future<bool> addFriend(String userId) async {
    _setLoading(true);
    
    try {
      final success = await _socialService.sendFriendRequest(userId);
      
      if (success) {
        // No need to update friends list yet, as this is just a request
        notifyListeners();
      }
      
      return success;
    } catch (e) {
      _setError('Failed to add friend: $e');
      return false;
    } finally {
      _setLoading(false);
    }
  }
  
  /// Remove a friend
  Future<bool> removeFriend(String friendId) async {
    _setLoading(true);
    
    try {
      final success = await _socialService.removeFriend(friendId);
      
      if (success) {
        // Friends list should get updated via the stream listener
        // but to be safe, update it directly too
        _friends.removeWhere((friend) => friend.id == friendId);
        notifyListeners();
      }
      
      return success;
    } catch (e) {
      _setError('Failed to remove friend: $e');
      return false;
    } finally {
      _setLoading(false);
    }
  }
  
  /// Set loading state
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }
  
  /// Set error message
  void _setError(String message) {
    _errorMessage = message;
    notifyListeners();
  }
} 

################################################################################
FILE: lib/presentation/providers/user_provider.dart
################################################################################

import 'package:flutter/foundation.dart';
import 'package:going50/core_models/user_profile.dart';
import 'package:going50/services/user/user_service.dart';
import 'package:going50/services/user/preferences_service.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Provider for user profile state
///
/// This provider is responsible for:
/// - Managing user profile information
/// - Handling user preferences
/// - Managing privacy settings
class UserProvider extends ChangeNotifier {
  // Dependencies
  final UserService _userService;
  final PreferencesService _preferencesService;
  
  // State
  UserProfile? _userProfile;
  bool _isAnonymous = true;
  bool _isLoading = false;
  String? _errorMessage;
  Map<String, Map<String, dynamic>> _preferences = {};
  
  // Public getters
  
  /// The current user profile, if any
  UserProfile? get userProfile => _userProfile;
  
  /// Whether the user is anonymous (not logged in)
  bool get isAnonymous => _isAnonymous;
  
  /// Whether data is currently being loaded
  bool get isLoading => _isLoading;
  
  /// Error message, if any
  String? get errorMessage => _errorMessage;
  
  /// User preferences
  Map<String, Map<String, dynamic>> get preferences => _preferences;
  
  /// Constructor
  UserProvider(this._userService, this._preferencesService) {
    _loadUserProfile();
    
    // Listen for user profile changes
    _userService.userProfileStream.listen((profile) {
      if (profile != null) {
        _userProfile = profile;
        _isAnonymous = _userService.isAnonymous;
        notifyListeners();
      }
    });
    
    // Listen for preference changes
    _preferencesService.preferencesStream.listen((prefs) {
      _preferences = prefs;
      notifyListeners();
    });
  }
  
  /// Load the user profile from storage
  Future<void> _loadUserProfile() async {
    _setLoading(true);
    
    try {
      await _userService.initialize();
      
      _userProfile = _userService.currentUser;
      _isAnonymous = _userService.isAnonymous;
      
      // Initialize preferences service with current user ID
      if (_userProfile != null) {
        await _preferencesService.initialize(_userProfile!.id);
        _preferences = _preferencesService.getAllPreferences();
      }
      
      notifyListeners();
    } catch (e) {
      _setError('Failed to load user profile: $e');
    } finally {
      _setLoading(false);
    }
  }
  
  /// Get a specific preference
  dynamic getPreference(String category, String key) {
    return _preferencesService.getPreference(category, key);
  }
  
  /// Get all preferences for a category
  Map<String, dynamic>? getPreferenceCategory(String category) {
    return _preferencesService.getCategory(category);
  }
  
  /// Update a user preference
  Future<void> updatePreference(String category, String key, dynamic value) async {
    _setLoading(true);
    
    try {
      await _preferencesService.setPreference(category, key, value);
      // No need to update local preferences here as we're listening to the preferences stream
    } catch (e) {
      _setError('Failed to update preference: $e');
    } finally {
      _setLoading(false);
    }
  }
  
  /// Reset preferences for a category to defaults
  Future<void> resetCategoryPreferences(String category) async {
    _setLoading(true);
    
    try {
      await _preferencesService.resetCategory(category);
      // No need to update local preferences here as we're listening to the preferences stream
    } catch (e) {
      _setError('Failed to reset preferences: $e');
    } finally {
      _setLoading(false);
    }
  }
  
  /// Reset all preferences to defaults
  Future<void> resetAllPreferences() async {
    _setLoading(true);
    
    try {
      await _preferencesService.resetAllPreferences();
      // No need to update local preferences here as we're listening to the preferences stream
    } catch (e) {
      _setError('Failed to reset preferences: $e');
    } finally {
      _setLoading(false);
    }
  }
  
  /// Register a user (convert anonymous to registered)
  Future<void> registerUser({
    required String name,
    required bool isPublic,
    required bool allowDataUpload,
  }) async {
    _setLoading(true);
    
    try {
      await _userService.registerUser(
        name: name,
        isPublic: isPublic,
        allowDataUpload: allowDataUpload,
      );
      
      _userProfile = _userService.currentUser;
      _isAnonymous = _userService.isAnonymous;
      
      notifyListeners();
    } catch (e) {
      _setError('Failed to register user: $e');
    } finally {
      _setLoading(false);
    }
  }
  
  /// Update user profile
  Future<void> updateProfile({String? name, bool? isPublic, bool? allowDataUpload}) async {
    if (_userProfile == null) return;
    
    _setLoading(true);
    
    try {
      await _userService.updateProfile(
        name: name,
        isPublic: isPublic,
        allowDataUpload: allowDataUpload,
      );
      
      _userProfile = _userService.currentUser;
      
      notifyListeners();
    } catch (e) {
      _setError('Failed to update profile: $e');
    } finally {
      _setLoading(false);
    }
  }
  
  /// Set loading state
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }
  
  /// Set error message
  void _setError(String message) {
    _errorMessage = message;
    notifyListeners();
  }
  
  /// Reset user state - used when data is deleted
  Future<void> resetUser() async {
    _setLoading(true);
    try {
      // Clear local state first
      _userProfile = null;
      _isAnonymous = true;
      _preferences = {};
      _errorMessage = null;
      
      // Reset preferences service
      await _preferencesService.resetAllPreferences();
      
      // Clear shared preferences to ensure complete reset
      final prefs = await SharedPreferences.getInstance();
      
      // Clear all user-related preferences 
      await prefs.remove('user_id');
      await prefs.remove('is_anonymous');
      await prefs.remove('preferences_json');
      await prefs.remove('last_login');
      await prefs.remove('auth_token');
      
      // Add a small delay to ensure all state is cleared
      await Future.delayed(Duration(milliseconds: 200));
      
      // Create a new anonymous user
      try {
        await _userService.createAnonymousUser();
        
        // Update local state with the new user
        _userProfile = _userService.currentUser;
        _isAnonymous = _userService.isAnonymous;
      } catch (e) {
        // Even if this fails, we want to continue with reset
        print('Error creating anonymous user: $e');
      }
      
      notifyListeners();
    } catch (e) {
      _setError('Failed to reset user state: $e');
    } finally {
      _setLoading(false);
      notifyListeners(); // Notify again to ensure UI updates
    }
  }
} 

################################################################################
FILE: lib/presentation/providers/driving_provider.dart
################################################################################

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:going50/core_models/combined_driving_data.dart';
import 'package:going50/core_models/driving_event.dart';
import 'package:going50/core_models/trip.dart';
import 'package:going50/obd_lib/models/bluetooth_device.dart';
import 'package:going50/services/driving/driving_service.dart';

/// Provider for driving-related state and actions
///
/// This provider exposes the state of the DrivingService to the UI
/// and provides methods to interact with it.
class DrivingProvider extends ChangeNotifier {
  final DrivingService _drivingService;
  
  // Subscription management
  StreamSubscription<DrivingEvent>? _eventSubscription;
  StreamSubscription<double>? _ecoScoreSubscription;
  
  // State
  double _currentEcoScore = 0.0;
  List<DrivingEvent> _recentEvents = [];
  bool _preferOBD = true; // Default to preferring OBD connection if available
  
  /// Constructor
  DrivingProvider(this._drivingService) {
    _subscribeToStreams();
    
    // Listen for changes in the driving service
    _drivingService.addListener(() {
      notifyListeners();
    });
  }
  
  // Public getters that expose state from the driving service
  
  /// Current driving status (notReady, ready, recording, error)
  DrivingStatus get drivingStatus => _drivingService.drivingStatus;
  
  /// Whether a trip is currently being recorded
  bool get isRecording => _drivingService.drivingStatus == DrivingStatus.recording;
  
  /// Whether the app is currently collecting data
  bool get isCollecting => _drivingService.isCollecting;
  
  /// Whether an OBD device is connected
  bool get isObdConnected => _drivingService.isObdConnected;
  
  /// The current trip, if any
  Trip? get currentTrip => _drivingService.currentTrip;
  
  /// The current eco-score (0-100)
  double get currentEcoScore => _currentEcoScore;
  
  /// Recent driving events
  List<DrivingEvent> get recentEvents => _recentEvents;
  
  /// Any error message from the driving service
  String? get errorMessage => _drivingService.errorMessage;
  
  /// Whether the user prefers to use OBD when available
  bool get preferOBD => _preferOBD;
  
  // Public methods that delegate to the driving service
  
  /// Start a new trip
  Future<bool> startTrip({bool skipPermissionChecks = false}) async {
    final success = await _drivingService.startTrip(skipPermissionChecks: skipPermissionChecks) != null;
    return success;
  }
  
  /// End the current trip
  Future<bool> endTrip() async {
    final success = await _drivingService.endTrip() != null;
    return success;
  }
  
  /// Scan for OBD devices
  Stream<List<BluetoothDevice>> scanForObdDevices() {
    _drivingService.startScanningForDevices();
    return _drivingService.deviceStream;
  }
  
  /// Stop scanning for OBD devices
  void stopScanningForDevices() {
    _drivingService.stopScanningForDevices();
  }
  
  /// Connect to an OBD device
  Future<bool> connectToObdDevice(String deviceId) async {
    return await _drivingService.connectToObdDevice(deviceId);
  }
  
  /// Disconnect from the OBD device
  Future<void> disconnectObdDevice() async {
    await _drivingService.disconnectFromObdDevice();
  }
  
  /// Set whether the user prefers to use OBD when available
  void setPreferOBD(bool prefer) {
    _preferOBD = prefer;
    // TODO: Store this preference in persistent storage when user service is implemented
    notifyListeners();
  }
  
  /// Get the trip history
  Future<List<Trip>> getTrips({int limit = 10, int offset = 0}) async {
    return await _drivingService.getTrips(limit: limit, offset: offset);
  }
  
  /// Get a specific trip by ID
  Future<Trip?> getTrip(String tripId) async {
    return await _drivingService.getTrip(tripId);
  }
  
  /// Get the latest combined driving data
  Future<CombinedDrivingData?> getLatestDrivingData() async {
    // We need to access the data stream and get the latest value
    final dataStream = _drivingService.dataStream;
    try {
      return await dataStream.first;
    } catch (e) {
      return null;
    }
  }
  
  /// Force update notification (for debugging purposes)
  void forceUpdate() {
    notifyListeners();
  }
  
  /// Force reinitialize all services (for troubleshooting)
  Future<bool> forceReinitializeServices() async {
    return await _drivingService.forceReinitializeServices();
  }
  
  /// Subscribe to streams from the driving service
  void _subscribeToStreams() {
    // Subscribe to driving events
    _eventSubscription = _drivingService.drivingEventStream.listen((event) {
      _recentEvents = [event, ..._recentEvents];
      if (_recentEvents.length > 10) {
        _recentEvents = _recentEvents.sublist(0, 10);
      }
      notifyListeners();
    });
    
    // Subscribe to eco-score updates
    _ecoScoreSubscription = _drivingService.ecoScoreStream.listen((score) {
      _currentEcoScore = score;
      notifyListeners();
    });
  }
  
  @override
  void dispose() {
    // Cancel subscriptions
    _eventSubscription?.cancel();
    _ecoScoreSubscription?.cancel();
    
    // Remove listener from driving service
    _drivingService.removeListener(() {});
    
    super.dispose();
  }
} 

################################################################################
FILE: lib/presentation/providers/insights_provider.dart
################################################################################

import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';  // Added for DateTimeRange
import 'package:going50/core_models/trip.dart';
import 'package:going50/core_models/driver_performance_metrics.dart';
import 'package:going50/services/driving/driving_service.dart';
import 'package:going50/services/driving/performance_metrics_service.dart';
import 'package:intl/intl.dart';
import 'dart:math' as math;

/// Provider for insights and historical data
///
/// This provider is responsible for:
/// - Loading and caching trip history data
/// - Managing performance metrics
/// - Providing access to historical driving data for visualization
class InsightsProvider extends ChangeNotifier {
  final DrivingService _drivingService;
  final PerformanceMetricsService _metricsService;
  
  // State
  List<Trip> _recentTrips = [];
  Trip? _selectedTrip;
  bool _isLoading = false;
  String? _errorMessage;
  
  // Time period for metrics analysis
  String _selectedTimeFrame = 'week'; // 'day', 'week', 'month', 'year'
  
  // Cache for performance metrics
  DriverPerformanceMetrics? _currentMetrics;
  Map<String, List<double>> _ecoScoreTrends = {};
  final Map<String, double> _fuelSavings = {};
  final Map<String, double> _co2Reduction = {};
  final Map<String, double> _moneySavings = {};

  // Cache for performance metrics service results
  final Map<String, PerformanceMetrics> _performanceMetricsCache = {};
  
  /// Constructor
  InsightsProvider(this._drivingService, this._metricsService) {
    _loadRecentTrips();
    _loadPerformanceMetrics();
  }
  
  // Public getters
  
  /// List of recent trips, sorted by start time descending
  List<Trip> get recentTrips => _recentTrips;
  
  /// Currently selected trip for detailed view
  Trip? get selectedTrip => _selectedTrip;
  
  /// Whether data is currently being loaded
  bool get isLoading => _isLoading;
  
  /// Error message, if any
  String? get errorMessage => _errorMessage;
  
  /// Currently selected time frame for analysis
  String get selectedTimeFrame => _selectedTimeFrame;
  
  /// Current performance metrics
  DriverPerformanceMetrics? get currentMetrics => _currentMetrics;
  
  /// Get eco-score trend data for the current time period
  List<double> get ecoScoreTrend => _ecoScoreTrends[_selectedTimeFrame] ?? [];
  
  /// Get fuel savings for the current time period
  double get fuelSavings => _fuelSavings[_selectedTimeFrame] ?? 0.0;
  
  /// Get CO2 reduction for the current time period
  double get co2Reduction => _co2Reduction[_selectedTimeFrame] ?? 0.0;
  
  /// Get money savings for the current time period
  double get moneySavings => _moneySavings[_selectedTimeFrame] ?? 0.0;
  
  /// Get time period description
  String get timePeriodDescription {
    switch (_selectedTimeFrame) {
      case 'day':
        return 'Today';
      case 'week':
        return 'This Week';
      case 'month':
        return 'This Month';
      case 'year':
        return 'This Year';
      default:
        return 'All Time';
    }
  }
  
  /// Get behavior scores for current time period
  Map<String, int> get behaviorScores {
    if (_currentMetrics == null) {
      return {};
    }
    
    return {
      'calm_driving': _currentMetrics!.calmDrivingScore,
      'speed_optimization': _currentMetrics!.speedOptimizationScore,
      'idle_management': _currentMetrics!.idlingScore,
      'trip_planning': _currentMetrics!.shortDistanceScore,
      'rpm_efficiency': _currentMetrics!.rpmManagementScore,
      'stop_management': _currentMetrics!.stopManagementScore,
      'following_distance': _currentMetrics!.followDistanceScore,
    };
  }
  
  /// Load recent trips
  Future<void> _loadRecentTrips() async {
    _setLoading(true);
    _clearError();
    
    try {
      final trips = await _drivingService.getTrips(limit: 50);
      _recentTrips = trips;
      notifyListeners();
    } catch (e) {
      _setError('Failed to load trips: $e');
    } finally {
      _setLoading(false);
    }
  }
  
  /// Load performance metrics for all time periods
  Future<void> _loadPerformanceMetrics() async {
    _setLoading(true);
    _clearError();
    
    try {
      // Load metrics for current time period
      await _loadMetricsForPeriod(_selectedTimeFrame);
      
      // Load trends
      await _loadTrends();
      
      notifyListeners();
    } catch (e) {
      _setError('Failed to load performance metrics: $e');
    } finally {
      _setLoading(false);
    }
  }
  
  /// Load metrics for a specific time period
  Future<void> _loadMetricsForPeriod(String period) async {
    try {
      // Get performance metrics from the service
      PerformanceMetrics metrics;
      
      // Check if we have cached metrics
      if (_performanceMetricsCache.containsKey(period)) {
        metrics = _performanceMetricsCache[period]!;
      } else {
        // Get metrics from the service based on the time period
        switch (period) {
          case 'day':
            metrics = await _metricsService.getDailyMetrics(DateTime.now());
            break;
          case 'week':
            metrics = await _metricsService.getWeeklyMetrics(DateTime.now());
            break;
          case 'month':
            metrics = await _metricsService.getMonthlyMetrics(DateTime.now());
            break;
          case 'year':
            metrics = await _metricsService.getYearlyMetrics(DateTime.now());
            break;
          default:
            // Default to weekly metrics
            metrics = await _metricsService.getWeeklyMetrics(DateTime.now());
        }
        
        // Cache the metrics
        _performanceMetricsCache[period] = metrics;
      }
      
      // Convert PerformanceMetrics to DriverPerformanceMetrics
      _currentMetrics = _convertToDriverPerformanceMetrics(metrics, period);
      
      // Update savings calculations based on the performance metrics
      final projectionData = _metricsService.calculateProjectedSavings(
        metrics, 
        period == 'day' ? 1 : period == 'week' ? 4 : period == 'month' ? 12 : 52
      );
      
      _fuelSavings[period] = projectionData['fuelSavingsL'] ?? 0.0;
      _moneySavings[period] = projectionData['moneySavingsUSD'] ?? 0.0;
      _co2Reduction[period] = projectionData['co2SavingsKg'] ?? 0.0;
      
    } catch (e) {
      _setError('Failed to load metrics for $period: $e');
      
      // Fall back to mock metrics if there's an error
      _currentMetrics = _generateMockMetrics(period);
      _calculateSavings(period);
    }
  }
  
  /// Convert PerformanceMetrics to DriverPerformanceMetrics
  DriverPerformanceMetrics _convertToDriverPerformanceMetrics(
    PerformanceMetrics metrics,
    String period
  ) {
    // Extract improvement tips from JSON
    List<String> improvementTips = [];
    try {
      final tipsData = jsonDecode(metrics.improvementTipsJson);
      if (tipsData['tips'] != null) {
        for (var tip in tipsData['tips']) {
          improvementTips.add('${tip['area']}: ${tip['tip']} ${tip['benefit']}');
        }
      }
    } catch (e) {
      improvementTips = ['Try to drive more efficiently to improve your eco-score.'];
    }
    
    return DriverPerformanceMetrics(
      generatedAt: metrics.generatedAt,
      periodStart: metrics.periodStart,
      periodEnd: metrics.periodEnd,
      totalTrips: metrics.totalTrips,
      totalDistanceKm: metrics.totalDistanceKm,
      totalDrivingTimeMinutes: metrics.totalDrivingTimeMinutes,
      averageSpeedKmh: metrics.totalDrivingTimeMinutes > 0 
        ? (metrics.totalDistanceKm / metrics.totalDrivingTimeMinutes) * 60 
        : 0,
      estimatedFuelSavingsL: _fuelSavings[period],
      estimatedCO2ReductionKg: _co2Reduction[period],
      calmDrivingScore: metrics.calmDrivingScore.round(),
      speedOptimizationScore: metrics.speedOptimizationScore.round(),
      idlingScore: metrics.idlingScore.round(),
      shortDistanceScore: 70, // Not directly tracked in PerformanceMetrics
      rpmManagementScore: metrics.steadySpeedScore.round(),
      stopManagementScore: 75, // Not directly tracked in PerformanceMetrics
      followDistanceScore: 80, // Not directly tracked in PerformanceMetrics
      overallEcoScore: metrics.overallScore.round(),
      improvementRecommendations: improvementTips,
    );
  }
  
  /// Load trend data for charts
  Future<void> _loadTrends() async {
    try {
      // Load trend data from the metrics service
      // For each time period, we need a different interval and date range
      
      final now = DateTime.now();
      
      // Daily trend (hourly intervals for the current day)
      final startOfDay = DateTime(now.year, now.month, now.day);
      final dayTrend = await _metricsService.getTrendData(
        'overallScore',
        startOfDay,
        now,
        interval: 'daily',
      );
      
      // Weekly trend (daily intervals for the current week)
      final startOfWeek = now.subtract(Duration(days: now.weekday - 1));
      final weekTrend = await _metricsService.getTrendData(
        'overallScore',
        startOfWeek,
        now,
        interval: 'daily',
      );
      
      // Monthly trend (weekly intervals for the current month)
      final startOfMonth = DateTime(now.year, now.month, 1);
      final monthTrend = await _metricsService.getTrendData(
        'overallScore',
        startOfMonth,
        now,
        interval: 'weekly',
      );
      
      // Yearly trend (monthly intervals for the current year)
      final startOfYear = DateTime(now.year, 1, 1);
      final yearTrend = await _metricsService.getTrendData(
        'overallScore',
        startOfYear,
        now,
        interval: 'monthly',
      );
      
      // Convert trend data to lists
      _ecoScoreTrends = {
        'day': _convertTrendMapToList(dayTrend),
        'week': _convertTrendMapToList(weekTrend),
        'month': _convertTrendMapToList(monthTrend),
        'year': _convertTrendMapToList(yearTrend),
      };
    } catch (e) {
      // Fall back to generated trends if there's an error
      _ecoScoreTrends = {
        'day': _generateHourlyTrend(),
        'week': _generateDailyTrend(),
        'month': _generateWeeklyTrend(),
        'year': _generateMonthlyTrend(),
      };
    }
  }
  
  /// Convert trend map to list
  List<double> _convertTrendMapToList(Map<DateTime, double> trendMap) {
    // Sort the dates
    final sortedDates = trendMap.keys.toList()..sort();
    
    // Create list of values in order
    return sortedDates.map((date) => trendMap[date] ?? 0.0).toList();
  }
  
  /// Calculate savings for the given period (legacy method, used as fallback)
  void _calculateSavings(String period) {
    if (_currentMetrics == null) return;
    
    // Fuel savings (L)
    final fuelSavings = _currentMetrics!.estimatedFuelSavingsL ?? 0.0;
    _fuelSavings[period] = fuelSavings;
    
    // CO2 reduction (kg)
    final co2Reduction = _currentMetrics!.estimatedCO2ReductionKg ?? 0.0;
    _co2Reduction[period] = co2Reduction;
    
    // Money savings ($) - assuming $1.50 per liter
    final moneySavings = fuelSavings * 1.50;
    _moneySavings[period] = moneySavings;
  }
  
  /// Get date range for the given period
  DateTimeRange _getDateRangeForPeriod(String period) {
    final now = DateTime.now();
    
    switch (period) {
      case 'day':
        final start = DateTime(now.year, now.month, now.day);
        return DateTimeRange(start: start, end: now);
      
      case 'week':
        // Start of week (assuming Sunday is the first day)
        final daysToSubtract = now.weekday % 7;
        final start = DateTime(now.year, now.month, now.day - daysToSubtract);
        return DateTimeRange(start: start, end: now);
      
      case 'month':
        final start = DateTime(now.year, now.month, 1);
        return DateTimeRange(start: start, end: now);
      
      case 'year':
        final start = DateTime(now.year, 1, 1);
        return DateTimeRange(start: start, end: now);
      
      default:
        // All time - using a far past date
        final start = DateTime(2020, 1, 1);
        return DateTimeRange(start: start, end: now);
    }
  }
  
  /// Generate mock metrics for a period (used as fallback if services fail)
  DriverPerformanceMetrics _generateMockMetrics(String period) {
    final dateRange = _getDateRangeForPeriod(period);
    
    // Create metrics with random scores
    final random = DateTime.now().millisecondsSinceEpoch % 100;
    final baseScore = 60 + (random % 25); // Base score between 60-84
    
    return DriverPerformanceMetrics(
      generatedAt: DateTime.now(),
      periodStart: dateRange.start,
      periodEnd: dateRange.end,
      totalTrips: period == 'day' ? 1 : (period == 'week' ? 5 : (period == 'month' ? 18 : 220)),
      totalDistanceKm: period == 'day' ? 25.0 : (period == 'week' ? 125.0 : (period == 'month' ? 480.0 : 5800.0)),
      totalDrivingTimeMinutes: period == 'day' ? 45.0 : (period == 'week' ? 210.0 : (period == 'month' ? 840.0 : 9600.0)),
      averageSpeedKmh: 35.0,
      estimatedFuelSavingsL: period == 'day' ? 0.8 : (period == 'week' ? 4.2 : (period == 'month' ? 16.5 : 196.0)),
      estimatedCO2ReductionKg: period == 'day' ? 1.9 : (period == 'week' ? 9.8 : (period == 'month' ? 38.5 : 458.0)),
      calmDrivingScore: baseScore + (random % 15 - 7),
      speedOptimizationScore: baseScore + (random % 18 - 9),
      idlingScore: baseScore + (random % 12 - 6),
      shortDistanceScore: baseScore + (random % 10 - 5),
      rpmManagementScore: baseScore + (random % 20 - 10),
      stopManagementScore: baseScore + (random % 16 - 8),
      followDistanceScore: baseScore + (random % 14 - 7),
      overallEcoScore: baseScore,
      improvementRecommendations: [
        'Reduce aggressive acceleration to improve your calm driving score',
        'Avoid excessive idling to save fuel and reduce emissions',
        'Maintain a consistent speed on highways to optimize fuel efficiency',
      ],
    );
  }
  
  // The following methods filter trips and generate mock trend data
  // We keep them as fallbacks for when the service is unavailable

  /// Filter trips by date range
  List<Trip> filterTripsByDateRange(DateTime start, DateTime end) {
    return _recentTrips.where((trip) {
      return trip.startTime.isAfter(start) && 
             (trip.endTime?.isBefore(end) ?? false);
    }).toList();
  }
  
  /// Generate hourly trend data for the day view (fallback)
  List<double> _generateHourlyTrend() {
    // Create fixed mock data to avoid type conversion issues
    final baseValue = 65.0 + (DateTime.now().hour % 10);
    List<double> trend = [];
    
    for (int i = 0; i < 24; i++) {
      if (i <= DateTime.now().hour) {
        // Only include hours up to the current hour
        final variation = math.sin(i / 24 * math.pi * 2) * 10;
        trend.add(baseValue + variation);
      }
    }
    
    return trend;
  }
  
  /// Generate daily trend data for the week view (fallback)
  List<double> _generateDailyTrend() {
    // Create fixed mock data to avoid type conversion issues
    return [
      65.0, 68.0, 72.0, 70.0, 75.0, 78.0, 80.0
    ].sublist(0, math.min(7, DateTime.now().weekday + 1));
  }
  
  /// Generate weekly trend data for the month view (fallback)
  List<double> _generateWeeklyTrend() {
    // Create fixed mock data to avoid type conversion issues
    final weekOfMonth = (DateTime.now().day / 7).ceil();
    return [
      67.0, 70.0, 73.0, 75.0, 78.0
    ].sublist(0, math.min(5, weekOfMonth));
  }
  
  /// Generate monthly trend data for the year view (fallback)
  List<double> _generateMonthlyTrend() {
    // Create fixed mock data to avoid type conversion issues
    return [
      65.0, 67.0, 70.0, 72.0, 68.0, 70.0, 75.0, 78.0, 80.0, 82.0, 84.0, 85.0
    ].sublist(0, DateTime.now().month);
  }
  
  /// Refresh insights data
  Future<void> refreshInsights() async {
    // Clear caches
    _performanceMetricsCache.clear();
    
    await _loadRecentTrips();
    await _loadPerformanceMetrics();
  }
  
  /// Set the time frame for analysis
  Future<void> setTimeFrame(String timeFrame) async {
    if (_selectedTimeFrame != timeFrame) {
      _selectedTimeFrame = timeFrame;
      _setLoading(true);
      
      try {
        await _loadMetricsForPeriod(timeFrame);
      } catch (e) {
        _setError('Failed to load metrics for $timeFrame: $e');
      } finally {
        _setLoading(false);
      }
      
      notifyListeners();
    }
  }
  
  // Helper methods to set loading state and errors
  
  void _setLoading(bool isLoading) {
    _isLoading = isLoading;
    notifyListeners();
  }
  
  void _setError(String message) {
    _errorMessage = message;
    notifyListeners();
  }
  
  void _clearError() {
    _errorMessage = null;
  }
  
  /// Refresh trip data
  Future<void> refreshTrips() async {
    await _loadRecentTrips();
  }
  
  /// Load more trips (pagination)
  Future<void> loadMoreTrips() async {
    if (_isLoading) return;
    
    _setLoading(true);
    _clearError();
    
    try {
      final moreTrips = await _drivingService.getTrips(
        limit: 20,
        offset: _recentTrips.length,
      );
      
      if (moreTrips.isNotEmpty) {
        _recentTrips = [..._recentTrips, ...moreTrips];
        notifyListeners();
      }
    } catch (e) {
      _setError('Failed to load more trips: $e');
    } finally {
      _setLoading(false);
    }
  }
  
  /// Select a trip for detailed view
  Future<void> selectTrip(String tripId) async {
    _setLoading(true);
    _clearError();
    
    try {
      final trip = await _drivingService.getTrip(tripId);
      _selectedTrip = trip;
      notifyListeners();
    } catch (e) {
      _setError('Failed to load trip details: $e');
    } finally {
      _setLoading(false);
    }
  }
  
  /// Clear the selected trip
  void clearSelectedTrip() {
    _selectedTrip = null;
    notifyListeners();
  }
  
  /// Search trips by keyword
  List<Trip> searchTrips(String query) {
    if (query.isEmpty) return _recentTrips;
    
    final lowercaseQuery = query.toLowerCase();
    
    return _recentTrips.where((trip) {
      final date = DateFormat.yMMMd().format(trip.startTime);
      final time = DateFormat.jm().format(trip.startTime);
      
      return date.toLowerCase().contains(lowercaseQuery) ||
             time.toLowerCase().contains(lowercaseQuery) ||
             (trip.distanceKm?.toString() ?? '').contains(lowercaseQuery);
    }).toList();
  }
} 

################################################################################
FILE: lib/presentation/screens/insights/trip_detail_screen.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import 'package:going50/core_models/trip.dart';
import 'package:going50/presentation/providers/insights_provider.dart';
import 'package:going50/presentation/screens/insights/components/trip_map_section.dart';
import 'package:going50/presentation/screens/insights/components/trip_metrics_section.dart';
import 'package:going50/presentation/screens/insights/components/trip_timeline_section.dart';

/// A screen that displays detailed information about a specific trip.
///
/// This screen shows:
/// - Map visualization of the trip route (if location permitted)
/// - Detailed metrics with tabs for different categories
/// - Timeline of driving events
class TripDetailScreen extends StatefulWidget {
  /// The ID of the trip to display
  final String tripId;
  
  /// Constructor
  const TripDetailScreen({
    super.key,
    required this.tripId,
  });

  @override
  State<TripDetailScreen> createState() => _TripDetailScreenState();
}

class _TripDetailScreenState extends State<TripDetailScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  
  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
    
    // Load the trip data when the screen initializes
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadTripData();
    });
  }
  
  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }
  
  /// Load the trip data from the provider
  Future<void> _loadTripData() async {
    final insightsProvider = Provider.of<InsightsProvider>(context, listen: false);
    await insightsProvider.selectTrip(widget.tripId);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Trip Details'),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => Navigator.of(context).pop(),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.share),
            onPressed: () {
              // TODO: Implement sharing functionality
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Sharing coming soon!'))
              );
            },
          ),
        ],
      ),
      body: Consumer<InsightsProvider>(
        builder: (context, insightsProvider, child) {
          if (insightsProvider.isLoading) {
            return const Center(
              child: CircularProgressIndicator(),
            );
          }
          
          if (insightsProvider.errorMessage != null) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(
                    Icons.error_outline,
                    size: 64,
                    color: Colors.red,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'Error loading trip details',
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    insightsProvider.errorMessage ?? 'Unknown error',
                    textAlign: TextAlign.center,
                    style: Theme.of(context).textTheme.bodyMedium,
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    onPressed: () => _loadTripData(),
                    child: const Text('Try Again'),
                  ),
                ],
              ),
            );
          }
          
          if (insightsProvider.selectedTrip == null) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(
                    Icons.not_listed_location,
                    size: 64,
                    color: Colors.grey,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'Trip not found',
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'The requested trip could not be found',
                    textAlign: TextAlign.center,
                    style: Theme.of(context).textTheme.bodyMedium,
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Go Back'),
                  ),
                ],
              ),
            );
          }
          
          final trip = insightsProvider.selectedTrip!;
          
          return Column(
            children: [
              // Trip header with basic info
              _buildTripHeader(trip),
              
              // Tab bar
              Container(
                color: Theme.of(context).primaryColor.withOpacity(0.1),
                child: TabBar(
                  controller: _tabController,
                  labelColor: Theme.of(context).primaryColor,
                  unselectedLabelColor: Colors.grey,
                  indicatorColor: Theme.of(context).primaryColor,
                  tabs: const [
                    Tab(text: 'Overview'),
                    Tab(text: 'Metrics'),
                    Tab(text: 'Timeline'),
                  ],
                ),
              ),
              
              // Tab content
              Expanded(
                child: TabBarView(
                  controller: _tabController,
                  children: [
                    // Overview tab with map
                    SingleChildScrollView(
                      child: Column(
                        children: [
                          // Map visualization
                          TripMapSection(trip: trip),
                          
                          // Summary metrics
                          Padding(
                            padding: const EdgeInsets.all(16.0),
                            child: _buildSummaryMetrics(trip),
                          ),
                        ],
                      ),
                    ),
                    
                    // Detailed metrics tab
                    TripMetricsSection(trip: trip),
                    
                    // Timeline tab
                    TripTimelineSection(trip: trip),
                  ],
                ),
              ),
            ],
          );
        },
      ),
    );
  }
  
  /// Build the trip header with basic information
  Widget _buildTripHeader(Trip trip) {
    // Format the date and time
    final dateFormatter = DateFormat('E, MMM d, yyyy');
    final timeFormatter = DateFormat('h:mm a');
    final date = dateFormatter.format(trip.startTime);
    final startTime = timeFormatter.format(trip.startTime);
    final endTime = trip.endTime != null ? timeFormatter.format(trip.endTime!) : 'N/A';
    
    // Calculate duration
    final duration = trip.endTime != null 
      ? _formatDuration(trip.endTime!.difference(trip.startTime))
      : 'Unknown';
    
    // Calculate eco-score - using a placeholder calculation
    final ecoScore = _calculateEcoScore(trip);
    
    return Container(
      padding: const EdgeInsets.all(16.0),
      decoration: BoxDecoration(
        color: Theme.of(context).primaryColor,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        children: [
          Row(
            children: [
              // Date and time
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      date,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        color: Colors.white,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      '$startTime - $endTime',
                      style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Colors.white.withOpacity(0.9),
                      ),
                    ),
                  ],
                ),
              ),
              
              // Eco-score
              Container(
                width: 60,
                height: 60,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: Colors.white,
                  border: Border.all(
                    color: _getScoreColor(ecoScore),
                    width: 3,
                  ),
                ),
                child: Center(
                  child: Text(
                    ecoScore.toStringAsFixed(0),
                    style: Theme.of(context).textTheme.titleLarge?.copyWith(
                      color: _getScoreColor(ecoScore),
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
            ],
          ),
          
          const SizedBox(height: 16),
          
          // Trip stats
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: [
              _buildStatItem(
                context, 
                '${trip.distanceKm?.toStringAsFixed(1) ?? 'N/A'} km',
                'Distance',
                Icons.map,
              ),
              _buildStatItem(
                context, 
                '${trip.averageSpeedKmh?.toStringAsFixed(1) ?? 'N/A'} km/h',
                'Avg Speed',
                Icons.speed,
              ),
              _buildStatItem(
                context, 
                duration,
                'Duration',
                Icons.timer,
              ),
            ],
          ),
        ],
      ),
    );
  }
  
  /// Build a summary metrics card
  Widget _buildSummaryMetrics(Trip trip) {
    // Calculate fuel used and savings
    final fuelUsed = trip.fuelUsedL ?? 0.0;
    final fuelSavings = fuelUsed * 0.1; // Assuming 10% savings from eco-driving
    
    // Calculate CO2 emissions and reduction (2.3kg per liter of fuel)
    final co2Reduction = fuelSavings * 2.3;
    
    // Calculate money saved (assuming $1.50 per liter)
    final moneySaved = fuelSavings * 1.50;
    
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Eco-Driving Impact',
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            
            // Savings grid
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                _buildSavingItem(
                  context,
                  '${fuelSavings.toStringAsFixed(2)} L',
                  'Fuel Saved',
                  Icons.local_gas_station,
                  Colors.green,
                ),
                _buildSavingItem(
                  context,
                  '${co2Reduction.toStringAsFixed(2)} kg',
                  'CO₂ Reduction',
                  Icons.eco,
                  Colors.teal,
                ),
                _buildSavingItem(
                  context,
                  '\$${moneySaved.toStringAsFixed(2)}',
                  'Money Saved',
                  Icons.attach_money,
                  Colors.amber,
                ),
              ],
            ),
            
            const SizedBox(height: 16),
            const Divider(),
            const SizedBox(height: 8),
            
            // Event summary
            Text(
              'Driving Events',
              style: Theme.of(context).textTheme.titleSmall?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            
            // Event counts
            _buildEventRow(context, 
              'Aggressive Acceleration', 
              trip.aggressiveAccelerationEvents ?? 0, 
              Icons.trending_up
            ),
            _buildEventRow(context, 
              'Hard Braking', 
              trip.hardBrakingEvents ?? 0, 
              Icons.trending_down
            ),
            _buildEventRow(context, 
              'Excessive Idling', 
              trip.idlingEvents ?? 0, 
              Icons.timer_off
            ),
            _buildEventRow(context, 
              'Speed Violations', 
              trip.excessiveSpeedEvents ?? 0, 
              Icons.speed
            ),
          ],
        ),
      ),
    );
  }
  
  /// Build a stat item for the header
  Widget _buildStatItem(BuildContext context, String value, String label, IconData icon) {
    return Column(
      children: [
        Icon(
          icon,
          color: Colors.white70,
          size: 18,
        ),
        const SizedBox(height: 4),
        Text(
          value,
          style: Theme.of(context).textTheme.titleMedium?.copyWith(
            color: Colors.white,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 2),
        Text(
          label,
          style: Theme.of(context).textTheme.bodySmall?.copyWith(
            color: Colors.white70,
          ),
        ),
      ],
    );
  }
  
  /// Build a saving item for the impact section
  Widget _buildSavingItem(BuildContext context, String value, String label, IconData icon, Color color) {
    return Column(
      children: [
        Icon(
          icon,
          color: color,
          size: 24,
        ),
        const SizedBox(height: 8),
        Text(
          value,
          style: Theme.of(context).textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 4),
        Text(
          label,
          style: Theme.of(context).textTheme.bodySmall?.copyWith(
            color: Colors.grey.shade600,
          ),
        ),
      ],
    );
  }
  
  /// Build an event row for the event summary
  Widget _buildEventRow(BuildContext context, String label, int count, IconData icon) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        children: [
          Icon(
            icon,
            size: 16,
            color: count > 0 ? Colors.orange : Colors.green,
          ),
          const SizedBox(width: 8),
          Text(label),
          const Spacer(),
          Text(
            count.toString(),
            style: TextStyle(
              fontWeight: FontWeight.bold,
              color: count > 0 ? Colors.orange : Colors.green,
            ),
          ),
        ],
      ),
    );
  }
  
  /// Format a duration to a readable string
  String _formatDuration(Duration duration) {
    int minutes = duration.inMinutes;
    int hours = minutes ~/ 60;
    minutes = minutes % 60;
    
    if (hours > 0) {
      return '$hours h ${minutes.toString().padLeft(2, '0')} min';
    } else {
      return '$minutes min';
    }
  }
  
  /// Calculate eco-score from trip data
  double _calculateEcoScore(Trip trip) {
    // Base score
    double score = 75.0;
    
    // Deduct points for events
    if (trip.aggressiveAccelerationEvents != null && trip.aggressiveAccelerationEvents! > 0) {
      score -= trip.aggressiveAccelerationEvents! * 3;
    }
    
    if (trip.hardBrakingEvents != null && trip.hardBrakingEvents! > 0) {
      score -= trip.hardBrakingEvents! * 4;
    }
    
    if (trip.idlingEvents != null && trip.idlingEvents! > 0) {
      score -= trip.idlingEvents! * 2;
    }
    
    if (trip.excessiveSpeedEvents != null && trip.excessiveSpeedEvents! > 0) {
      score -= trip.excessiveSpeedEvents! * 3;
    }
    
    // Ensure score stays within 0-100 range
    return score.clamp(0.0, 100.0);
  }
  
  /// Get color based on score value
  Color _getScoreColor(double score) {
    if (score >= 80) {
      return Colors.green;
    } else if (score >= 60) {
      return Colors.amber;
    } else {
      return Colors.red;
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/insights/insights_screen.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:going50/presentation/providers/insights_provider.dart';
import 'package:going50/presentation/widgets/common/layout/section_container.dart';
import 'package:going50/presentation/screens/insights/components/time_period_selector.dart';
import 'package:going50/presentation/widgets/common/charts/line_chart.dart';
import 'package:going50/presentation/screens/insights/components/savings_summary_card.dart';
import 'package:going50/presentation/widgets/common/charts/radar_chart.dart';
import 'package:going50/presentation/widgets/common/charts/eco_score_gauge.dart';
import 'package:going50/core/constants/route_constants.dart';
import 'package:fl_chart/fl_chart.dart';

/// InsightsScreen is the main screen for the Insights tab.
///
/// This screen provides access to trip history and driving analytics,
/// showing eco-driving performance metrics and trends.
class InsightsScreen extends StatefulWidget {
  const InsightsScreen({super.key});

  @override
  State<InsightsScreen> createState() => _InsightsScreenState();
}

class _InsightsScreenState extends State<InsightsScreen> {
  @override
  void initState() {
    super.initState();
    // Initial data loading is handled in the provider constructor
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Insights'),
        centerTitle: true,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () {
              _refreshInsights();
            },
            tooltip: 'Refresh insights',
          ),
        ],
      ),
      body: Consumer<InsightsProvider>(
        builder: (context, insightsProvider, child) {
          if (insightsProvider.isLoading) {
            return const Center(
              child: CircularProgressIndicator(),
            );
          }

          if (insightsProvider.errorMessage != null) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(
                    Icons.error_outline,
                    size: 64,
                    color: Colors.red,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'Error loading insights',
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    insightsProvider.errorMessage!,
                    textAlign: TextAlign.center,
                    style: Theme.of(context).textTheme.bodyMedium,
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    onPressed: _refreshInsights,
                    child: const Text('Try Again'),
                  ),
                ],
              ),
            );
          }

          // Generate labels for the eco-score trend chart
          final trendLabels = _generateTrendLabels(insightsProvider.selectedTimeFrame);
          
          // Convert trend data to FlSpot for AppLineChart
          final trendSpots = _convertTrendDataToFlSpots(insightsProvider.ecoScoreTrend);

          return RefreshIndicator(
            onRefresh: () => insightsProvider.refreshInsights(),
            child: SingleChildScrollView(
              physics: const AlwaysScrollableScrollPhysics(),
              padding: const EdgeInsets.fromLTRB(16, 0, 16, 32),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Time period selector
                  Align(
                    alignment: Alignment.center,
                    child: Padding(
                      padding: const EdgeInsets.symmetric(vertical: 16.0),
                      child: TimePeriodSelector(
                        selected: insightsProvider.selectedTimeFrame,
                        onSelect: (timeFrame) {
                          insightsProvider.setTimeFrame(timeFrame);
                        },
                      ),
                    ),
                  ),
                  
                  // Eco-Score Overview
                  SectionContainer(
                    title: 'Your Eco-Score',
                    child: Column(
                      children: [
                        Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            EcoScoreGauge(
                              score: (insightsProvider.currentMetrics?.overallEcoScore ?? 0).toDouble(),
                              size: 140,
                              showLabel: true,
                              showScore: true,
                            ),
                          ],
                        ),
                        const SizedBox(height: 16),
                        AppLineChart(
                          dataPoints: [trendSpots],
                          xLabels: trendLabels,
                          height: 150,
                          title: 'Trend',
                          showGrid: true,
                          showFill: true,
                          minY: 0,
                          maxY: 100,
                        ),
                      ],
                    ),
                  ),
                  
                  const SizedBox(height: 16),
                  
                  // Savings Summary
                  SavingsSummaryCard(
                    fuelSavingsL: insightsProvider.fuelSavings,
                    moneySavings: insightsProvider.moneySavings,
                    co2ReductionKg: insightsProvider.co2Reduction,
                    timePeriod: insightsProvider.timePeriodDescription,
                  ),
                  
                  const SizedBox(height: 24),
                  
                  // Driving Behaviors Radar Chart
                  SectionContainer(
                    title: 'Driving Behaviors',
                    child: Column(
                      children: [
                        Padding(
                          padding: const EdgeInsets.symmetric(vertical: 16.0),
                          child: AppRadarChart(
                            data: _convertBehaviorScoresToDoubles(insightsProvider.behaviorScores),
                            size: 250,
                            maxValue: 100,
                            rings: 4,
                          ),
                        ),
                        if (insightsProvider.currentMetrics != null)
                          Padding(
                            padding: const EdgeInsets.only(top: 8.0),
                            child: _buildRecommendations(
                              context,
                              insightsProvider.currentMetrics!.improvementRecommendations,
                            ),
                          ),
                      ],
                    ),
                  ),
                  
                  const SizedBox(height: 24),
                  
                  // View Trip History Button
                  Center(
                    child: OutlinedButton.icon(
                      onPressed: () {
                        Navigator.of(context).pushNamed(InsightsRoutes.tripHistory);
                      },
                      icon: const Icon(Icons.history),
                      label: const Text('View Trip History'),
                      style: OutlinedButton.styleFrom(
                        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }
  
  /// Refresh insights data
  Future<void> _refreshInsights() async {
    await Provider.of<InsightsProvider>(context, listen: false).refreshInsights();
  }
  
  /// Generate labels for the eco-score trend chart based on the selected time frame
  List<String> _generateTrendLabels(String timeFrame) {
    switch (timeFrame) {
      case 'day':
        return ['12am', '6am', '12pm', '6pm'];
      case 'week':
        return ['Sun', 'Mon', 'Wed', 'Fri'];
      case 'month':
        return ['Week 1', 'Week 2', 'Week 3', 'Week 4'];
      case 'year':
        return ['Jan', 'Apr', 'Jul', 'Oct'];
      default:
        return [];
    }
  }
  
  /// Convert the behavior scores from int to double
  Map<String, double> _convertBehaviorScoresToDoubles(Map<String, int> behaviorScores) {
    return behaviorScores.map((key, value) => MapEntry(key, value.toDouble()));
  }
  
  /// Convert trend data to FlSpot for use with AppLineChart
  List<FlSpot> _convertTrendDataToFlSpots(List<double> trendData) {
    return List.generate(trendData.length, (index) => 
      FlSpot(index.toDouble(), trendData[index]));
  }
  
  /// Build a recommendations list
  Widget _buildRecommendations(BuildContext context, List<String> recommendations) {
    final theme = Theme.of(context);
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(bottom: 8.0, left: 4.0),
          child: Text(
            'Recommendations',
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
        ...recommendations.map((recommendation) {
          return Padding(
            padding: const EdgeInsets.only(bottom: 8.0),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Icon(
                  Icons.tips_and_updates,
                  size: 18,
                  color: Colors.amber,
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    recommendation,
                    style: theme.textTheme.bodyMedium,
                  ),
                ),
              ],
            ),
          );
        }),
      ],
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/insights/trip_history_screen.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import 'package:going50/core/constants/route_constants.dart';
import 'package:going50/core_models/trip.dart';
import 'package:going50/presentation/providers/insights_provider.dart';
import 'package:going50/presentation/screens/insights/components/search_filter_bar.dart';
import 'package:going50/presentation/screens/insights/components/trip_list_item.dart';
import 'package:going50/presentation/screens/insights/components/filter_sheet.dart';

/// The Trip History Screen allows users to browse and search past trips.
///
/// Includes:
/// - Search functionality
/// - Filtering options
/// - Sorting controls
/// - Grouped trip list by date
class TripHistoryScreen extends StatefulWidget {
  /// Constructor
  const TripHistoryScreen({super.key});

  @override
  State<TripHistoryScreen> createState() => _TripHistoryScreenState();
}

class _TripHistoryScreenState extends State<TripHistoryScreen> {
  // Search and filter state
  String _searchQuery = '';
  DateTimeRange? _dateRange;
  RangeValues _ecoScoreRange = const RangeValues(0, 100);
  RangeValues _distanceRange = const RangeValues(0, 100);
  List<String> _selectedEventTypes = [];
  
  // Sorting state
  String _sortBy = 'date'; // 'date', 'score', 'distance'
  bool _sortAscending = false;
  
  // Scroll controller for infinite scrolling
  final ScrollController _scrollController = ScrollController();
  
  @override
  void initState() {
    super.initState();
    
    // Load initial trips
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _refreshTrips();
    });
    
    // Set up scroll listener for infinite scrolling
    _scrollController.addListener(_scrollListener);
  }
  
  @override
  void dispose() {
    _scrollController.removeListener(_scrollListener);
    _scrollController.dispose();
    super.dispose();
  }
  
  /// Listen for scroll events to implement infinite scrolling
  void _scrollListener() {
    if (_scrollController.position.pixels >= _scrollController.position.maxScrollExtent - 200) {
      // When we're near the bottom, load more trips
      _loadMoreTrips();
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Trip History'),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => Navigator.of(context).pop(),
        ),
      ),
      body: Column(
        children: [
          // Search and filter bar
          SearchFilterBar(
            onSearch: _handleSearch,
            onFilterPressed: _showFilterSheet,
            searchQuery: _searchQuery,
          ),
          
          // Sorting controls
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 8, 16, 8),
            child: Row(
              children: [
                Text(
                  'Sort by:',
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
                const SizedBox(width: 8),
                _buildSortDropdown(),
                const SizedBox(width: 16),
                IconButton(
                  icon: Icon(_sortAscending ? Icons.arrow_upward : Icons.arrow_downward),
                  onPressed: _toggleSortOrder,
                  tooltip: _sortAscending ? 'Ascending' : 'Descending',
                  iconSize: 20,
                ),
                const Spacer(),
                if (_hasActiveFilters())
                  TextButton.icon(
                    icon: const Icon(Icons.filter_alt_off, size: 18),
                    label: const Text('Clear Filters'),
                    onPressed: _clearFilters,
                    style: TextButton.styleFrom(
                      padding: const EdgeInsets.symmetric(horizontal: 8),
                    ),
                  ),
              ],
            ),
          ),
          
          // Trip list
          Expanded(
            child: Consumer<InsightsProvider>(
              builder: (context, insightsProvider, child) {
                if (insightsProvider.isLoading && insightsProvider.recentTrips.isEmpty) {
                  return const Center(
                    child: CircularProgressIndicator(),
                  );
                }
                
                if (insightsProvider.errorMessage != null && insightsProvider.recentTrips.isEmpty) {
                  return Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        const Icon(
                          Icons.error_outline,
                          size: 64,
                          color: Colors.red,
                        ),
                        const SizedBox(height: 16),
                        Text(
                          'Error loading trips',
                          style: Theme.of(context).textTheme.titleLarge,
                        ),
                        const SizedBox(height: 8),
                        Text(
                          insightsProvider.errorMessage ?? 'Unknown error',
                          textAlign: TextAlign.center,
                          style: Theme.of(context).textTheme.bodyMedium,
                        ),
                        const SizedBox(height: 24),
                        ElevatedButton(
                          onPressed: _refreshTrips,
                          child: const Text('Try Again'),
                        ),
                      ],
                    ),
                  );
                }
                
                // Apply filters and search to the trips
                final filteredTrips = _getFilteredTrips(insightsProvider.recentTrips);
                
                if (filteredTrips.isEmpty) {
                  return Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        const Icon(
                          Icons.search_off,
                          size: 64,
                          color: Colors.grey,
                        ),
                        const SizedBox(height: 16),
                        Text(
                          'No trips found',
                          style: Theme.of(context).textTheme.titleLarge,
                        ),
                        const SizedBox(height: 8),
                        Text(
                          _searchQuery.isNotEmpty
                              ? 'Try different search terms'
                              : _hasActiveFilters()
                                  ? 'Try different filter settings'
                                  : 'No trips recorded yet',
                          textAlign: TextAlign.center,
                          style: Theme.of(context).textTheme.bodyMedium,
                        ),
                        const SizedBox(height: 24),
                        if (_hasActiveFilters() || _searchQuery.isNotEmpty)
                          ElevatedButton(
                            onPressed: _clearFilters,
                            child: const Text('Clear Filters'),
                          ),
                      ],
                    ),
                  );
                }
                
                // Group trips by date for display
                final groupedTrips = _groupTripsByDate(filteredTrips);
                
                return RefreshIndicator(
                  onRefresh: _refreshTrips,
                  child: ListView.builder(
                    controller: _scrollController,
                    itemCount: groupedTrips.length + (insightsProvider.isLoading ? 1 : 0),
                    itemBuilder: (context, index) {
                      // Show loading indicator at the bottom when loading more
                      if (insightsProvider.isLoading && index == groupedTrips.length) {
                        return const Padding(
                          padding: EdgeInsets.all(16.0),
                          child: Center(child: CircularProgressIndicator()),
                        );
                      }
                      
                      final dateGroup = groupedTrips[index];
                      return Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          // Date header
                          Padding(
                            padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                            child: Text(
                              dateGroup.key,
                              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ),
                          // Trip items
                          ...dateGroup.trips.map((trip) => TripListItem(
                            trip: trip,
                            onTap: () => _navigateToTripDetail(trip.id),
                          )),
                        ],
                      );
                    },
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
  
  /// Build the sort dropdown button
  Widget _buildSortDropdown() {
    return DropdownButton<String>(
      value: _sortBy,
      onChanged: (value) {
        if (value != null) {
          setState(() {
            _sortBy = value;
          });
        }
      },
      items: const [
        DropdownMenuItem(
          value: 'date',
          child: Text('Date'),
        ),
        DropdownMenuItem(
          value: 'score',
          child: Text('Eco-Score'),
        ),
        DropdownMenuItem(
          value: 'distance',
          child: Text('Distance'),
        ),
      ],
      isDense: true,
      underline: const SizedBox(),
    );
  }
  
  /// Toggle between ascending and descending sort order
  void _toggleSortOrder() {
    setState(() {
      _sortAscending = !_sortAscending;
    });
  }
  
  /// Handle search query changes
  void _handleSearch(String query) {
    setState(() {
      _searchQuery = query;
    });
  }
  
  /// Show the filter sheet
  void _showFilterSheet() {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return DraggableScrollableSheet(
          initialChildSize: 0.7,
          maxChildSize: 0.9,
          minChildSize: 0.5,
          builder: (context, scrollController) {
            return SingleChildScrollView(
              controller: scrollController,
              child: FilterSheet(
                initialDateRange: _dateRange,
                initialEcoScoreRange: _ecoScoreRange,
                initialDistanceRange: _distanceRange,
                initialSelectedEventTypes: _selectedEventTypes,
                onApply: (dateRange, ecoScoreRange, distanceRange, selectedEventTypes) {
                  setState(() {
                    _dateRange = dateRange;
                    _ecoScoreRange = ecoScoreRange;
                    _distanceRange = distanceRange;
                    _selectedEventTypes = selectedEventTypes;
                  });
                },
              ),
            );
          },
        );
      },
    );
  }
  
  /// Check if any filters are active
  bool _hasActiveFilters() {
    return _dateRange != null || 
           _ecoScoreRange.start > 0 || 
           _ecoScoreRange.end < 100 ||
           _distanceRange.start > 0 || 
           _distanceRange.end < 100 ||
           _selectedEventTypes.isNotEmpty;
  }
  
  /// Clear all filters
  void _clearFilters() {
    setState(() {
      _searchQuery = '';
      _dateRange = null;
      _ecoScoreRange = const RangeValues(0, 100);
      _distanceRange = const RangeValues(0, 100);
      _selectedEventTypes = [];
    });
  }
  
  /// Apply filters, search, and sorting to trips
  List<Trip> _getFilteredTrips(List<Trip> trips) {
    // Apply date range filter
    List<Trip> filteredTrips = trips;
    
    if (_dateRange != null) {
      filteredTrips = filteredTrips.where((trip) {
        return trip.startTime.isAfter(_dateRange!.start) && 
               trip.startTime.isBefore(_dateRange!.end.add(const Duration(days: 1)));
      }).toList();
    }
    
    // Apply eco-score filter (simulated as we don't have direct access to eco-score)
    if (_ecoScoreRange.start > 0 || _ecoScoreRange.end < 100) {
      filteredTrips = filteredTrips.where((trip) {
        // Simple eco-score calculation for filtering
        final calculatedScore = _calculateEcoScore(trip);
        return calculatedScore >= _ecoScoreRange.start && 
               calculatedScore <= _ecoScoreRange.end;
      }).toList();
    }
    
    // Apply distance filter
    if (_distanceRange.start > 0 || _distanceRange.end < 100) {
      filteredTrips = filteredTrips.where((trip) {
        final distance = trip.distanceKm ?? 0;
        return distance >= _distanceRange.start && 
               distance <= _distanceRange.end;
      }).toList();
    }
    
    // Apply event type filters
    if (_selectedEventTypes.isNotEmpty) {
      filteredTrips = filteredTrips.where((trip) {
        for (final eventType in _selectedEventTypes) {
          switch (eventType) {
            case 'aggressive_acceleration':
              if ((trip.aggressiveAccelerationEvents ?? 0) > 0) return true;
              break;
            case 'hard_braking':
              if ((trip.hardBrakingEvents ?? 0) > 0) return true;
              break;
            case 'idling':
              if ((trip.idlingEvents ?? 0) > 0) return true;
              break;
            case 'excessive_speed':
              if ((trip.excessiveSpeedEvents ?? 0) > 0) return true;
              break;
          }
        }
        return false;
      }).toList();
    }
    
    // Apply search
    if (_searchQuery.isNotEmpty) {
      final searchLower = _searchQuery.toLowerCase();
      filteredTrips = filteredTrips.where((trip) {
        // Search in date/time
        final dateTime = DateFormat('MMM d, yyyy h:mm a').format(trip.startTime).toLowerCase();
        if (dateTime.contains(searchLower)) return true;
        
        // Could expand search to include other trip attributes in the future
        
        return false;
      }).toList();
    }
    
    // Apply sorting
    filteredTrips.sort((a, b) {
      switch (_sortBy) {
        case 'date':
          return _sortAscending 
              ? a.startTime.compareTo(b.startTime)
              : b.startTime.compareTo(a.startTime);
        case 'score':
          final scoreA = _calculateEcoScore(a);
          final scoreB = _calculateEcoScore(b);
          return _sortAscending 
              ? scoreA.compareTo(scoreB)
              : scoreB.compareTo(scoreA);
        case 'distance':
          final distanceA = a.distanceKm ?? 0;
          final distanceB = b.distanceKm ?? 0;
          return _sortAscending 
              ? distanceA.compareTo(distanceB)
              : distanceB.compareTo(distanceA);
        default:
          return _sortAscending 
              ? a.startTime.compareTo(b.startTime)
              : b.startTime.compareTo(a.startTime);
      }
    });
    
    return filteredTrips;
  }
  
  /// Group trips by date for display
  List<TripDateGroup> _groupTripsByDate(List<Trip> trips) {
    // Map to store trips by date string
    final groupMap = <String, List<Trip>>{};
    final dateFormat = DateFormat('EEEE, MMMM d, yyyy');
    
    // Group trips by date
    for (final trip in trips) {
      final dateString = dateFormat.format(trip.startTime);
      if (!groupMap.containsKey(dateString)) {
        groupMap[dateString] = [];
      }
      groupMap[dateString]!.add(trip);
    }
    
    // Convert to list of date groups
    return groupMap.entries.map((entry) {
      return TripDateGroup(key: entry.key, trips: entry.value);
    }).toList();
  }
  
  /// Navigate to trip detail screen
  void _navigateToTripDetail(String tripId) async {
    await Provider.of<InsightsProvider>(context, listen: false).selectTrip(tripId);
    if (!mounted) return;
    Navigator.of(context).pushNamed(InsightsRoutes.tripDetail, arguments: tripId);
  }
  
  /// Refresh trips from provider
  Future<void> _refreshTrips() async {
    await Provider.of<InsightsProvider>(context, listen: false).refreshTrips();
  }
  
  /// Load more trips for infinite scrolling
  Future<void> _loadMoreTrips() async {
    final provider = Provider.of<InsightsProvider>(context, listen: false);
    if (!provider.isLoading) {
      await provider.loadMoreTrips();
    }
  }
  
  /// Calculate eco-score from trip data for filtering and sorting
  /// Ideally this would come directly from the Trip object
  double _calculateEcoScore(Trip trip) {
    // Base score
    double score = 75.0;
    
    // Deduct points for events
    if (trip.aggressiveAccelerationEvents != null && trip.aggressiveAccelerationEvents! > 0) {
      score -= trip.aggressiveAccelerationEvents! * 3;
    }
    
    if (trip.hardBrakingEvents != null && trip.hardBrakingEvents! > 0) {
      score -= trip.hardBrakingEvents! * 4;
    }
    
    if (trip.idlingEvents != null && trip.idlingEvents! > 0) {
      score -= trip.idlingEvents! * 2;
    }
    
    if (trip.excessiveSpeedEvents != null && trip.excessiveSpeedEvents! > 0) {
      score -= trip.excessiveSpeedEvents! * 3;
    }
    
    // Ensure score stays within 0-100 range
    return score.clamp(0.0, 100.0);
  }
}

/// Helper class to represent a group of trips by date
class TripDateGroup {
  final String key;
  final List<Trip> trips;
  
  TripDateGroup({
    required this.key,
    required this.trips,
  });
} 

################################################################################
FILE: lib/presentation/screens/insights/components/eco_score_trend_chart.dart
################################################################################

import 'package:flutter/material.dart';

/// A widget that displays the eco-score trend over time
///
/// This simple chart shows eco-score values over time as a line chart
/// with smooth animations and an area fill beneath the line.
class EcoScoreTrendChart extends StatefulWidget {
  /// List of eco-score data points
  final List<double> scores;
  
  /// Labels for the X-axis (optional)
  final List<String>? labels;
  
  /// Title of the chart (optional)
  final String? title;
  
  /// Height of the chart
  final double height;

  /// Constructor
  const EcoScoreTrendChart({
    super.key,
    required this.scores,
    this.labels,
    this.title,
    this.height = 200,
  });

  @override
  State<EcoScoreTrendChart> createState() => _EcoScoreTrendChartState();
}

class _EcoScoreTrendChartState extends State<EcoScoreTrendChart> 
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1200),
    );
    _animation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    );
    _animationController.forward();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final scores = widget.scores;
    
    if (scores.isEmpty) {
      return SizedBox(
        height: widget.height,
        child: Center(
          child: Text(
            'No eco-score data available',
            style: theme.textTheme.bodyMedium,
          ),
        ),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (widget.title != null)
          Padding(
            padding: const EdgeInsets.only(bottom: 16.0, left: 8.0),
            child: Text(
              widget.title!,
              style: theme.textTheme.titleMedium,
            ),
          ),
        SizedBox(
          height: widget.height,
          child: AnimatedBuilder(
            animation: _animation,
              builder: (context, child) {
                return CustomPaint(
                  size: Size.infinite,
                  painter: _ChartPainter(
                    scores: scores,
                    animation: _animation.value,
                    lineColor: theme.colorScheme.primary,
                    fillColor: theme.colorScheme.primary.withAlpha(51), // ~20% opacity
                  ),
                );
              },
            ),
          ),
        if (widget.labels != null)
          Padding(
            padding: const EdgeInsets.only(top: 8.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: widget.labels!.map((label) => 
                Text(
                  label,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                )
              ).toList(),
            ),
          ),
      ],
    );
  }
}

/// Custom painter for the chart
class _ChartPainter extends CustomPainter {
  final List<double> scores;
  final double animation;
  final Color lineColor;
  final Color fillColor;
  
  _ChartPainter({
    required this.scores,
    required this.animation,
    required this.lineColor,
    required this.fillColor,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    if (scores.isEmpty) return;
    
    final height = size.height;
    final width = size.width;
    
    // Calculate step width
    final stepX = width / (scores.length - 1);
    
    // Find min and max scores for scaling
    final maxScore = 100.0; // Eco-score is typically 0-100
    final minScore = 0.0;
    final range = maxScore - minScore;
    
    // Create path for the line
    final path = Path();
    final fillPath = Path();
    
    // Start the fill path at the bottom-left
    fillPath.moveTo(0, height);
    
    // First point
    final firstY = height - (scores.first - minScore) / range * height * animation;
    path.moveTo(0, firstY);
    fillPath.lineTo(0, firstY);
    
    // Add points to both paths
    for (var i = 1; i < scores.length; i++) {
      final x = stepX * i;
      final y = height - (scores[i] - minScore) / range * height * animation;
      
      if (i < scores.length - 1) {
        // Use Bezier curve for smoother line
        final nextX = stepX * (i + 1);
        final nextY = height - (scores[i + 1] - minScore) / range * height * animation;
        
        final controlX1 = x + (nextX - x) / 3;
        final controlY1 = y;
        final controlX2 = x + 2 * (nextX - x) / 3;
        final controlY2 = nextY;
        
        path.cubicTo(controlX1, controlY1, controlX2, controlY2, nextX, nextY);
        fillPath.cubicTo(controlX1, controlY1, controlX2, controlY2, nextX, nextY);
     } else {
        path.lineTo(x, y);
        fillPath.lineTo(x, y);
     }
   }
   
    // Complete the fill path
    fillPath.lineTo(width, height);
    fillPath.lineTo(0, height);
    fillPath.close();
    
    // Draw fill
    final fillPaint = Paint()
      ..color = fillColor
      ..style = PaintingStyle.fill;
    canvas.drawPath(fillPath, fillPaint);
    
    // Draw line
    final linePaint = Paint()
      ..color = lineColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.5
      ..strokeCap = StrokeCap.round;
    canvas.drawPath(path, linePaint);
    
    // Draw data points
    final pointPaint = Paint()
      ..color = lineColor
      ..style = PaintingStyle.fill;
    
    // Draw points only if we have a small number of them (to avoid clutter)
    if (scores.length <= 10) {
      for (var i = 0; i < scores.length; i++) {
        final x = stepX * i;
        final y = height - (scores[i] - minScore) / range * height * animation;
        canvas.drawCircle(Offset(x, y), 4, pointPaint);
      }
    }
  }
  
  @override
  bool shouldRepaint(covariant _ChartPainter oldDelegate) {
    return oldDelegate.animation != animation || 
           oldDelegate.scores != scores || 
           oldDelegate.lineColor != lineColor ||
           oldDelegate.fillColor != fillColor;
  }
} 

################################################################################
FILE: lib/presentation/screens/insights/components/trip_timeline_section.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:going50/core_models/trip.dart';
import 'package:going50/core_models/driving_event.dart';

/// Component that displays a chronological timeline of driving events during a trip.
///
/// This component shows:
/// - A vertical timeline of significant events
/// - Icons and descriptions for each event
/// - Timestamps showing when events occurred
class TripTimelineSection extends StatelessWidget {
  /// The trip to display the timeline for
  final Trip trip;

  /// Constructor
  const TripTimelineSection({
    super.key,
    required this.trip,
  });

  @override
  Widget build(BuildContext context) {
    // In a real implementation, we would fetch the actual events for this trip
    // For now, we'll create sample events based on the trip data
    final events = _generateSampleEvents();
    
    return events.isEmpty
        ? _buildEmptyState(context)
        : _buildTimeline(context, events);
  }
  
  /// Build the timeline view with events
  Widget _buildTimeline(BuildContext context, List<DrivingEvent> events) {
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: events.length + 2, // +2 for start and end events
      itemBuilder: (context, index) {
        if (index == 0) {
          // Start of trip
          return _buildTimelineItem(
            context,
            'Trip Started',
            _formatTime(trip.startTime),
            Icons.play_circle,
            Colors.green,
            isFirst: true,
            isLast: false,
          );
        } else if (index == events.length + 1) {
          // End of trip
          return _buildTimelineItem(
            context,
            'Trip Ended',
            _formatTime(trip.endTime ?? trip.startTime.add(const Duration(minutes: 30))),
            Icons.stop_circle,
            Colors.red,
            isFirst: false,
            isLast: true,
            details: 'Total Distance: ${trip.distanceKm?.toStringAsFixed(1) ?? "N/A"} km',
          );
        } else {
          // Driving event
          final event = events[index - 1];
          
          String eventTitle;
          String details;
          IconData icon;
          Color color;
          
          switch (event.eventType) {
            case 'idling':
              eventTitle = 'Excessive Idling';
              details = 'Engine idling for ${_formatDuration(_calculateIdlingDuration(event.severity))}';
              icon = Icons.timer_off;
              color = Colors.amber;
              break;
            case 'aggressive_acceleration':
              eventTitle = 'Aggressive Acceleration';
              details = 'Acceleration rate: ${(event.magnitude ?? 0.0).toStringAsFixed(1)} m/s²';
              icon = Icons.trending_up;
              color = Colors.orange;
              break;
            case 'hard_braking':
              eventTitle = 'Hard Braking';
              details = 'Deceleration rate: ${(event.magnitude ?? 0.0).toStringAsFixed(1)} m/s²';
              icon = Icons.trending_down;
              color = Colors.red;
              break;
            case 'excessive_speed':
              eventTitle = 'Excessive Speed';
              details = 'Speed: ${(event.magnitude ?? 0.0).toStringAsFixed(1)} km/h';
              icon = Icons.speed;
              color = Colors.deepOrange;
              break;
            default:
              eventTitle = 'Driving Event';
              details = 'Unspecified event';
              icon = Icons.warning;
              color = Colors.grey;
          }
          
          return _buildTimelineItem(
            context,
            eventTitle,
            _formatTime(event.timestamp),
            icon,
            color,
            isFirst: false,
            isLast: false,
            details: details,
            severity: event.severity,
          );
        }
      },
    );
  }
  
  /// Build an empty state when no events are available
  Widget _buildEmptyState(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(
            Icons.timeline,
            size: 64,
            color: Colors.grey,
          ),
          const SizedBox(height: 16),
          Text(
            'No events to display',
            style: Theme.of(context).textTheme.titleLarge,
          ),
          const SizedBox(height: 8),
          Text(
            'Event data is not available for this trip',
            textAlign: TextAlign.center,
            style: Theme.of(context).textTheme.bodyMedium,
          ),
          const SizedBox(height: 24),
          ElevatedButton.icon(
            onPressed: () {
              // This would refresh the timeline data in a real implementation
            },
            icon: const Icon(Icons.refresh),
            label: const Text('Refresh'),
          ),
        ],
      ),
    );
  }
  
  /// Build a timeline item
  Widget _buildTimelineItem(
    BuildContext context,
    String title,
    String time,
    IconData icon,
    Color color, {
    required bool isFirst,
    required bool isLast,
    String? details,
    double? severity,
  }) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Timeline line and dot
        SizedBox(
          width: 40,
          child: Column(
            children: [
              // Top line (hidden for first item)
              if (!isFirst)
                Container(
                  width: 2,
                  height: 20,
                  color: Colors.grey.shade300,
                ),
              
              // Timeline dot
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  color: color.withOpacity(0.2),
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: color,
                    width: 2,
                  ),
                ),
                child: Icon(
                  icon,
                  size: 14,
                  color: color,
                ),
              ),
              
              // Bottom line (hidden for last item)
              if (!isLast)
                Padding(
                  padding: const EdgeInsets.only(bottom: 16.0),
                  child: Container(
                    width: 2,
                    height: 60,
                    color: Colors.grey.shade300,
                  ),
                ),
            ],
          ),
        ),
        
        // Content
        Expanded(
          child: Padding(
            padding: EdgeInsets.only(bottom: isLast ? 0 : 16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Time
                Text(
                  time,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Colors.grey.shade600,
                  ),
                ),
                
                // Title and severity
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        title,
                        style: Theme.of(context).textTheme.titleSmall?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                    if (severity != null)
                      _buildSeverityIndicator(severity),
                  ],
                ),
                
                // Details if available
                if (details != null)
                  Padding(
                    padding: const EdgeInsets.only(top: 4.0),
                    child: Text(
                      details,
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  ),
                
                // Location badge (for demonstration)
                if (!isFirst && !isLast)
                  Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Row(
                      children: [
                        Icon(
                          Icons.location_on,
                          size: 14,
                          color: Colors.grey.shade600,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          'Location unavailable',
                          style: Theme.of(context).textTheme.bodySmall?.copyWith(
                            color: Colors.grey.shade600,
                            fontStyle: FontStyle.italic,
                          ),
                        ),
                      ],
                    ),
                  ),
              ],
            ),
          ),
        ),
      ],
    );
  }
  
  /// Build a severity indicator
  Widget _buildSeverityIndicator(double severity) {
    Color color;
    String label;
    
    if (severity >= 0.7) {
      color = Colors.red;
      label = 'High';
    } else if (severity >= 0.4) {
      color = Colors.orange;
      label = 'Medium';
    } else {
      color = Colors.yellow;
      label = 'Low';
    }
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: color,
          width: 1,
        ),
      ),
      child: Text(
        label,
        style: TextStyle(
          color: color,
          fontSize: 12,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
  
  /// Format a timestamp to a readable time string
  String _formatTime(DateTime time) {
    return DateFormat('h:mm a').format(time);
  }
  
  /// Format a duration in minutes to a readable string
  String _formatDuration(Duration duration) {
    final minutes = duration.inMinutes;
    final seconds = duration.inSeconds % 60;
    
    if (minutes > 0) {
      return '$minutes min ${seconds.toString().padLeft(2, '0')} sec';
    } else {
      return '${seconds.toString()} sec';
    }
  }
  
  /// Calculate idling duration based on severity
  Duration _calculateIdlingDuration(double severity) {
    // Simply create a duration based on severity (0-1 scale)
    // In a real app, this would come from actual measurements
    final seconds = (30 + severity * 90).round(); // 30s to 2min range
    return Duration(seconds: seconds);
  }
  
  /// Generate sample driving events based on the trip data
  List<DrivingEvent> _generateSampleEvents() {
    final events = <DrivingEvent>[];
    final random = DateTime.now().millisecondsSinceEpoch;
    
    // Only generate events if the trip has event counts
    if (trip.aggressiveAccelerationEvents == null && 
        trip.hardBrakingEvents == null &&
        trip.idlingEvents == null &&
        trip.excessiveSpeedEvents == null) {
      return [];
    }
    
    // Calculate the trip duration
    final tripDuration = trip.endTime != null 
        ? trip.endTime!.difference(trip.startTime) 
        : const Duration(minutes: 30);
    
    // Helper function to create random timestamp within trip duration
    DateTime randomTimestamp() {
      final randomMinutes = (random % tripDuration.inMinutes).toInt();
      return trip.startTime.add(Duration(minutes: randomMinutes));
    }
    
    // Add aggressive acceleration events
    for (int i = 0; i < (trip.aggressiveAccelerationEvents ?? 0); i++) {
      events.add(DrivingEvent(
        id: 'acc_$i',
        tripId: trip.id,
        timestamp: randomTimestamp(),
        eventType: 'aggressive_acceleration',
        severity: 0.5 + (random % 5) / 10, // 0.5-0.9 range
        magnitude: 3.0 + (random % 30) / 10, // 3.0-6.0 m/s² range
      ));
    }
    
    // Add hard braking events
    for (int i = 0; i < (trip.hardBrakingEvents ?? 0); i++) {
      events.add(DrivingEvent(
        id: 'brk_$i',
        tripId: trip.id,
        timestamp: randomTimestamp(),
        eventType: 'hard_braking',
        severity: 0.5 + (random % 5) / 10, // 0.5-0.9 range
        magnitude: 3.0 + (random % 40) / 10, // 3.0-7.0 m/s² range
      ));
    }
    
    // Add idling events
    for (int i = 0; i < (trip.idlingEvents ?? 0); i++) {
      events.add(DrivingEvent(
        id: 'idl_$i',
        tripId: trip.id,
        timestamp: randomTimestamp(),
        eventType: 'idling',
        severity: 0.3 + (random % 7) / 10, // 0.3-0.9 range
      ));
    }
    
    // Add excessive speed events
    for (int i = 0; i < (trip.excessiveSpeedEvents ?? 0); i++) {
      events.add(DrivingEvent(
        id: 'spd_$i',
        tripId: trip.id,
        timestamp: randomTimestamp(),
        eventType: 'excessive_speed',
        severity: 0.4 + (random % 6) / 10, // 0.4-0.9 range
        magnitude: 110 + (random % 40), // 110-150 km/h range
      ));
    }
    
    // Sort by timestamp
    events.sort((a, b) => a.timestamp.compareTo(b.timestamp));
    
    return events;
  }
} 

################################################################################
FILE: lib/presentation/screens/insights/components/search_filter_bar.dart
################################################################################

import 'package:flutter/material.dart';

/// A search and filter bar for the trip history screen.
///
/// Includes a search field with icon and a filter button that opens the filter sheet.
class SearchFilterBar extends StatefulWidget {
  /// Callback when the search query changes
  final Function(String) onSearch;

  /// Callback when the filter button is pressed
  final VoidCallback onFilterPressed;

  /// Current search query
  final String searchQuery;

  /// Constructor
  const SearchFilterBar({
    super.key,
    required this.onSearch,
    required this.onFilterPressed,
    this.searchQuery = '',
  });

  @override
  State<SearchFilterBar> createState() => _SearchFilterBarState();
}

class _SearchFilterBarState extends State<SearchFilterBar> {
  late TextEditingController _searchController;

  @override
  void initState() {
    super.initState();
    _searchController = TextEditingController(text: widget.searchQuery);
  }

  @override
  void didUpdateWidget(SearchFilterBar oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.searchQuery != oldWidget.searchQuery) {
      _searchController.text = widget.searchQuery;
    }
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
      child: Row(
        children: [
          // Search field
          Expanded(
            child: Container(
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.surfaceContainerHighest,
                borderRadius: BorderRadius.circular(24.0),
              ),
              child: TextField(
                controller: _searchController,
                decoration: InputDecoration(
                  hintText: 'Search trips...',
                  prefixIcon: const Icon(Icons.search),
                  border: InputBorder.none,
                  contentPadding: const EdgeInsets.symmetric(
                    vertical: 12.0,
                    horizontal: 16.0,
                  ),
                  suffixIcon: _searchController.text.isNotEmpty
                      ? IconButton(
                          icon: const Icon(Icons.clear),
                          onPressed: () {
                            _searchController.clear();
                            widget.onSearch('');
                          },
                        )
                      : null,
                ),
                onChanged: widget.onSearch,
                textInputAction: TextInputAction.search,
              ),
            ),
          ),
          
          // Filter button
          const SizedBox(width: 8.0),
          Container(
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.surfaceContainerHighest,
              borderRadius: BorderRadius.circular(24.0),
            ),
            child: IconButton(
              icon: const Icon(Icons.filter_list),
              tooltip: 'Filter',
              onPressed: widget.onFilterPressed,
            ),
          ),
        ],
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/insights/components/filter_sheet.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:going50/core/theme/app_colors.dart';

/// A modal bottom sheet for filtering trips.
///
/// Includes:
/// - Date range picker
/// - Eco-score range slider
/// - Distance range slider
/// - Event type checkboxes
/// - Apply/Reset buttons
class FilterSheet extends StatefulWidget {
  /// Initial date range for filtering
  final DateTimeRange? initialDateRange;
  
  /// Initial eco-score range for filtering (0-100)
  final RangeValues? initialEcoScoreRange;
  
  /// Initial distance range for filtering (in km)
  final RangeValues? initialDistanceRange;
  
  /// Initial selected event types
  final List<String>? initialSelectedEventTypes;
  
  /// Callback when filter is applied
  final Function(
    DateTimeRange? dateRange,
    RangeValues ecoScoreRange,
    RangeValues distanceRange,
    List<String> selectedEventTypes,
  ) onApply;
  
  /// Constructor
  const FilterSheet({
    super.key,
    this.initialDateRange,
    this.initialEcoScoreRange,
    this.initialDistanceRange,
    this.initialSelectedEventTypes,
    required this.onApply,
  });

  @override
  State<FilterSheet> createState() => _FilterSheetState();
}

class _FilterSheetState extends State<FilterSheet> {
  late DateTimeRange? _dateRange;
  late RangeValues _ecoScoreRange;
  late RangeValues _distanceRange;
  late List<String> _selectedEventTypes;
  
  final List<Map<String, dynamic>> _eventTypes = [
    {'id': 'aggressive_acceleration', 'label': 'Aggressive Acceleration', 'icon': Icons.speed},
    {'id': 'hard_braking', 'label': 'Hard Braking', 'icon': Icons.warning},
    {'id': 'idling', 'label': 'Idling', 'icon': Icons.timer_off},
    {'id': 'excessive_speed', 'label': 'Excessive Speed', 'icon': Icons.shutter_speed},
  ];
  
  // Formatters
  final DateFormat _dateFormat = DateFormat('MMM d, yyyy');
  
  @override
  void initState() {
    super.initState();
    _dateRange = widget.initialDateRange;
    _ecoScoreRange = widget.initialEcoScoreRange ?? const RangeValues(0, 100);
    _distanceRange = widget.initialDistanceRange ?? const RangeValues(0, 100);
    _selectedEventTypes = widget.initialSelectedEventTypes?.toList() ?? [];
  }
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Container(
      padding: const EdgeInsets.fromLTRB(24, 16, 24, 24),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(24),
          topRight: Radius.circular(24),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header with title and close button
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                'Filter Trips',
                style: theme.textTheme.titleLarge?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              IconButton(
                icon: const Icon(Icons.close),
                onPressed: () => Navigator.of(context).pop(),
              ),
            ],
          ),
          
          const SizedBox(height: 16),
          
          // Date range picker
          Text(
            'Date Range',
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          InkWell(
            onTap: _selectDateRange,
            borderRadius: BorderRadius.circular(12),
            child: Container(
              padding: const EdgeInsets.symmetric(
                horizontal: 16,
                vertical: 12,
              ),
              decoration: BoxDecoration(
                border: Border.all(
                  color: theme.colorScheme.outline,
                ),
                borderRadius: BorderRadius.circular(12),
              ),
              child: Row(
                children: [
                  const Icon(Icons.calendar_today),
                  const SizedBox(width: 12),
                  Text(
                    _dateRange != null
                        ? '${_dateFormat.format(_dateRange!.start)} - ${_dateFormat.format(_dateRange!.end)}'
                        : 'All time',
                    style: theme.textTheme.bodyMedium,
                  ),
                  const Spacer(),
                  if (_dateRange != null)
                    IconButton(
                      icon: const Icon(Icons.clear),
                      onPressed: () {
                        setState(() {
                          _dateRange = null;
                        });
                      },
                      iconSize: 20,
                      padding: EdgeInsets.zero,
                      constraints: const BoxConstraints(),
                    ),
                ],
              ),
            ),
          ),
          
          const SizedBox(height: 24),
          
          // Eco-score range slider
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                'Eco-Score',
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              Text(
                '${_ecoScoreRange.start.round()}-${_ecoScoreRange.end.round()}',
                style: theme.textTheme.bodyMedium,
              ),
            ],
          ),
          SliderTheme(
            data: SliderTheme.of(context).copyWith(
              trackHeight: 4,
              rangeThumbShape: const RoundRangeSliderThumbShape(
                enabledThumbRadius: 10,
              ),
            ),
            child: RangeSlider(
              values: _ecoScoreRange,
              min: 0,
              max: 100,
              divisions: 20,
              labels: RangeLabels(
                _ecoScoreRange.start.round().toString(),
                _ecoScoreRange.end.round().toString(),
              ),
              onChanged: (values) {
                setState(() {
                  _ecoScoreRange = values;
                });
              },
            ),
          ),
          
          const SizedBox(height: 16),
          
          // Distance range slider
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                'Distance (km)',
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              Text(
                '${_distanceRange.start.round()}-${_distanceRange.end.round()}',
                style: theme.textTheme.bodyMedium,
              ),
            ],
          ),
          SliderTheme(
            data: SliderTheme.of(context).copyWith(
              trackHeight: 4,
              rangeThumbShape: const RoundRangeSliderThumbShape(
                enabledThumbRadius: 10,
              ),
            ),
            child: RangeSlider(
              values: _distanceRange,
              min: 0,
              max: 100,
              divisions: 20,
              labels: RangeLabels(
                _distanceRange.start.round().toString(),
                _distanceRange.end.round().toString(),
              ),
              onChanged: (values) {
                setState(() {
                  _distanceRange = values;
                });
              },
            ),
          ),
          
          const SizedBox(height: 16),
          
          // Event type checkboxes
          Text(
            'Event Types',
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: _eventTypes.map((eventType) {
              final id = eventType['id'] as String;
              final label = eventType['label'] as String;
              final icon = eventType['icon'] as IconData;
              final isSelected = _selectedEventTypes.contains(id);
              
              return FilterChip(
                label: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      icon,
                      size: 16,
                      color: isSelected ? Colors.white : AppColors.textSecondary,
                    ),
                    const SizedBox(width: 8),
                    Text(label),
                  ],
                ),
                selected: isSelected,
                onSelected: (selected) {
                  setState(() {
                    if (selected) {
                      _selectedEventTypes.add(id);
                    } else {
                      _selectedEventTypes.remove(id);
                    }
                  });
                },
                checkmarkColor: Colors.white,
                selectedColor: AppColors.primary,
                backgroundColor: theme.colorScheme.surfaceContainerHighest,
              );
            }).toList(),
          ),
          
          const SizedBox(height: 24),
          
          // Action buttons
          Row(
            children: [
              // Reset button
              OutlinedButton(
                onPressed: _resetFilters,
                child: const Text('Reset'),
              ),
              const SizedBox(width: 12),
              // Apply button
              Expanded(
                child: ElevatedButton(
                  onPressed: () {
                    widget.onApply(
                      _dateRange,
                      _ecoScoreRange,
                      _distanceRange,
                      _selectedEventTypes,
                    );
                    Navigator.of(context).pop();
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppColors.primary,
                    foregroundColor: Colors.white,
                  ),
                  child: const Text('Apply Filters'),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
  
  /// Reset all filters to their default values
  void _resetFilters() {
    setState(() {
      _dateRange = null;
      _ecoScoreRange = const RangeValues(0, 100);
      _distanceRange = const RangeValues(0, 100);
      _selectedEventTypes = [];
    });
  }
  
  /// Open the date range picker dialog
  Future<void> _selectDateRange() async {
    final initialDateRange = _dateRange ?? DateTimeRange(
      start: DateTime.now().subtract(const Duration(days: 30)),
      end: DateTime.now(),
    );
    
    final newDateRange = await showDateRangePicker(
      context: context,
      initialDateRange: initialDateRange,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
      builder: (context, child) {
        return Theme(
          data: ThemeData.light().copyWith(
            colorScheme: const ColorScheme.light(
              primary: AppColors.primary,
              onPrimary: Colors.white,
              surface: Colors.white,
              onSurface: Colors.black,
            ),
          ),
          child: child!,
        );
      },
    );
    
    if (newDateRange != null) {
      setState(() {
        _dateRange = newDateRange;
      });
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/insights/components/trip_metrics_section.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:going50/core_models/trip.dart';

/// Component that displays detailed metrics about a trip with multiple tabs.
///
/// This component shows various metrics grouped by category:
/// - Performance: Speed, RPM, acceleration
/// - Efficiency: Fuel consumption, eco-score breakdown
/// - Behavior: Driving events and recommendations
class TripMetricsSection extends StatefulWidget {
  /// The trip to display metrics for
  final Trip trip;

  /// Constructor
  const TripMetricsSection({
    super.key,
    required this.trip,
  });

  @override
  State<TripMetricsSection> createState() => _TripMetricsSectionState();
}

class _TripMetricsSectionState extends State<TripMetricsSection> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  
  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
  }
  
  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // Metrics tab bar
        Container(
          color: Colors.grey.shade200,
          child: TabBar(
            controller: _tabController,
            labelColor: Theme.of(context).primaryColor,
            unselectedLabelColor: Colors.grey,
            indicatorColor: Theme.of(context).primaryColor,
            dividerColor: Colors.transparent,
            tabs: const [
              Tab(text: 'Performance'),
              Tab(text: 'Efficiency'),
              Tab(text: 'Behavior'),
            ],
          ),
        ),
        
        // Metrics tab content
        Expanded(
          child: TabBarView(
            controller: _tabController,
            children: [
              // Performance tab
              _buildPerformanceTab(),
              
              // Efficiency tab
              _buildEfficiencyTab(),
              
              // Behavior tab
              _buildBehaviorTab(),
            ],
          ),
        ),
      ],
    );
  }
  
  /// Build the performance metrics tab
  Widget _buildPerformanceTab() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildSectionTitle('Speed Metrics'),
          const SizedBox(height: 16),
          
          // Speed metrics
          _buildMetricRow(
            'Average Speed',
            '${widget.trip.averageSpeedKmh?.toStringAsFixed(1) ?? 'N/A'} km/h',
            Icons.speed,
          ),
          _buildMetricRow(
            'Maximum Speed',
            '${widget.trip.maxSpeedKmh?.toStringAsFixed(1) ?? 'N/A'} km/h',
            Icons.trending_up,
          ),
          
          const Divider(height: 32),
          _buildSectionTitle('Engine Metrics'),
          const SizedBox(height: 16),
          
          // Engine metrics
          _buildMetricRow(
            'Average RPM',
            '${widget.trip.averageRPM?.toStringAsFixed(0) ?? 'N/A'} rpm',
            Icons.speed,
          ),
          _buildMetricRow(
            'Time in Optimal RPM',
            '76%', // Placeholder value
            Icons.thumb_up,
          ),
          
          // Performance chart - placeholder
          const SizedBox(height: 24),
          Container(
            height: 200,
            width: double.infinity,
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.grey.shade200,
              borderRadius: BorderRadius.circular(8),
            ),
            child: const Center(
              child: Text('Speed/RPM Chart Placeholder'),
            ),
          ),
          
          // Trip stages (start, city, highway, etc.) - placeholder
          const SizedBox(height: 24),
          _buildSectionTitle('Trip Stages'),
          const SizedBox(height: 16),
          
          // Placeholders for trip stages
          _buildTripStage('Urban', 28, Colors.orange),
          _buildTripStage('Highway', 62, Colors.blue),
          _buildTripStage('Traffic', 10, Colors.red),
        ],
      ),
    );
  }
  
  /// Build the efficiency metrics tab
  Widget _buildEfficiencyTab() {
    // Calculate fuel efficiency
    final fuelUsed = widget.trip.fuelUsedL ?? 0.0;
    final distance = widget.trip.distanceKm ?? 0.0;
    final fuelEfficiency = distance > 0 && fuelUsed > 0
        ? distance / fuelUsed
        : 0.0;
    
    // Average values for comparison - these would ideally come from a service
    const avgFuelEfficiency = 12.0; // km/L
    
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildSectionTitle('Fuel Metrics'),
          const SizedBox(height: 16),
          
          // Fuel metrics
          _buildMetricRow(
            'Fuel Used',
            '${fuelUsed.toStringAsFixed(2)} L',
            Icons.local_gas_station,
          ),
          _buildMetricRow(
            'Fuel Efficiency',
            '${fuelEfficiency.toStringAsFixed(1)} km/L',
            Icons.eco,
            isHigherBetter: true,
            comparisonValue: avgFuelEfficiency,
          ),
          _buildMetricRow(
            'CO₂ Emissions',
            '${(fuelUsed * 2.3).toStringAsFixed(1)} kg',
            Icons.cloud,
            isHigherBetter: false,
          ),
          
          const Divider(height: 32),
          _buildSectionTitle('Eco-Score Breakdown'),
          const SizedBox(height: 16),
          
          // Eco-score breakdown - placeholder
          _buildScoreBar('Calm Driving', 72),
          _buildScoreBar('Speed Management', 85),
          _buildScoreBar('Idle Management', 64),
          _buildScoreBar('RPM Efficiency', 78),
          _buildScoreBar('Stop Management', 69),
          
          // Efficiency visualization - placeholder
          const SizedBox(height: 24),
          Container(
            height: 200,
            width: double.infinity,
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.grey.shade200,
              borderRadius: BorderRadius.circular(8),
            ),
            child: const Center(
              child: Text('Efficiency Trends Chart Placeholder'),
            ),
          ),
        ],
      ),
    );
  }
  
  /// Build the behavior metrics tab
  Widget _buildBehaviorTab() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildSectionTitle('Driving Events'),
          const SizedBox(height: 16),
          
          // Driving events summary
          _buildEventMetric(
            'Aggressive Acceleration',
            widget.trip.aggressiveAccelerationEvents ?? 0,
            Icons.trending_up,
            Colors.orange,
          ),
          _buildEventMetric(
            'Hard Braking',
            widget.trip.hardBrakingEvents ?? 0,
            Icons.trending_down,
            Colors.red,
          ),
          _buildEventMetric(
            'Idling Events',
            widget.trip.idlingEvents ?? 0,
            Icons.timer_off,
            Colors.amber,
          ),
          _buildEventMetric(
            'Excessive Speed',
            widget.trip.excessiveSpeedEvents ?? 0,
            Icons.speed,
            Colors.deepOrange,
          ),
          _buildEventMetric(
            'Stop Events',
            widget.trip.stopEvents ?? 0,
            Icons.stop_circle,
            Colors.blue,
          ),
          
          const Divider(height: 32),
          _buildSectionTitle('Improvement Suggestions'),
          const SizedBox(height: 16),
          
          // Improvement suggestions - placeholders
          _buildSuggestionCard(
            'Reduce Aggressive Acceleration',
            'Try to accelerate more gently to improve fuel efficiency and reduce wear on your vehicle.',
            Icons.trending_up,
          ),
          const SizedBox(height: 16),
          _buildSuggestionCard(
            'Minimize Idle Time',
            'Turn off your engine when stopped for more than 30 seconds to save fuel and reduce emissions.',
            Icons.timer_off,
          ),
        ],
      ),
    );
  }
  
  /// Build a section title
  Widget _buildSectionTitle(String title) {
    return Text(
      title,
      style: Theme.of(context).textTheme.titleMedium?.copyWith(
        fontWeight: FontWeight.bold,
      ),
    );
  }
  
  /// Build a metric row with label and value
  Widget _buildMetricRow(
    String label,
    String value,
    IconData icon, {
    bool isHigherBetter = false,
    double? comparisonValue,
  }) {
    // Determine if the value is better than the comparison
    bool isBetter = false;
    bool isWorse = false;
    
    if (comparisonValue != null) {
      final numValue = double.tryParse(value.replaceAll(RegExp(r'[^0-9.]'), '')) ?? 0;
      isBetter = isHigherBetter ? numValue > comparisonValue : numValue < comparisonValue;
      isWorse = isHigherBetter ? numValue < comparisonValue : numValue > comparisonValue;
    }
    
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        children: [
          Icon(
            icon,
            size: 20,
            color: Colors.grey.shade700,
          ),
          const SizedBox(width: 12),
          Text(
            label,
            style: Theme.of(context).textTheme.bodyMedium,
          ),
          const Spacer(),
          Row(
            children: [
              Text(
                value,
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: isBetter ? Colors.green : (isWorse ? Colors.red : null),
                ),
              ),
              if (isBetter || isWorse)
                Padding(
                  padding: const EdgeInsets.only(left: 4.0),
                  child: Icon(
                    isBetter ? Icons.arrow_upward : Icons.arrow_downward,
                    size: 16,
                    color: isBetter ? Colors.green : Colors.red,
                  ),
                ),
            ],
          ),
        ],
      ),
    );
  }
  
  /// Build a score bar for eco-score components
  Widget _buildScoreBar(String label, int score) {
    Color barColor;
    if (score >= 80) {
      barColor = Colors.green;
    } else if (score >= 60) {
      barColor = Colors.amber;
    } else {
      barColor = Colors.red;
    }
    
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                label,
                style: Theme.of(context).textTheme.bodyMedium,
              ),
              Text(
                score.toString(),
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          const SizedBox(height: 4),
          ClipRRect(
            borderRadius: BorderRadius.circular(4),
            child: LinearProgressIndicator(
              value: score / 100,
              backgroundColor: Colors.grey.shade300,
              color: barColor,
              minHeight: 8,
            ),
          ),
        ],
      ),
    );
  }
  
  /// Build an event metric card
  Widget _buildEventMetric(String label, int count, IconData icon, Color color) {
    final isGood = count == 0;
    
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        children: [
          Container(
            width: 36,
            height: 36,
            decoration: BoxDecoration(
              color: isGood ? Colors.green.withOpacity(0.1) : color.withOpacity(0.1),
              borderRadius: BorderRadius.circular(18),
            ),
            child: Icon(
              isGood ? Icons.check_circle : icon,
              color: isGood ? Colors.green : color,
              size: 20,
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  label,
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
                Text(
                  isGood 
                      ? 'No events detected' 
                      : count == 1 
                          ? '1 event detected' 
                          : '$count events detected',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: isGood ? Colors.green : color,
                  ),
                ),
              ],
            ),
          ),
          if (!isGood)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: color.withOpacity(0.1),
                borderRadius: BorderRadius.circular(12),
              ),
              child: Text(
                count.toString(),
                style: TextStyle(
                  color: color,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
        ],
      ),
    );
  }
  
  /// Build a trip stage visualization
  Widget _buildTripStage(String stageName, int percentage, Color color) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                stageName,
                style: Theme.of(context).textTheme.bodyMedium,
              ),
              Text(
                '$percentage%',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          const SizedBox(height: 4),
          ClipRRect(
            borderRadius: BorderRadius.circular(4),
            child: LinearProgressIndicator(
              value: percentage / 100,
              backgroundColor: Colors.grey.shade300,
              color: color,
              minHeight: 8,
            ),
          ),
        ],
      ),
    );
  }
  
  /// Build a suggestion card
  Widget _buildSuggestionCard(String title, String description, IconData icon) {
    return Card(
      elevation: 1,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(
                color: Theme.of(context).primaryColor.withOpacity(0.1),
                borderRadius: BorderRadius.circular(20),
              ),
              child: Icon(
                icon,
                color: Theme.of(context).primaryColor,
                size: 24,
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: Theme.of(context).textTheme.titleSmall?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    description,
                    style: Theme.of(context).textTheme.bodySmall,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/insights/components/time_period_selector.dart
################################################################################

import 'package:flutter/material.dart';

/// A widget that allows users to select a time period for insights data
///
/// This widget displays a row of selectable time period options (day, week, month, year)
/// with the currently selected option highlighted.
class TimePeriodSelector extends StatelessWidget {
  /// The currently selected time period
  final String selected;
  
  /// Callback when a time period is selected
  final Function(String) onSelect;
  
  /// Available time period options
  final List<String> options;
  
  /// Constructor
  const TimePeriodSelector({
    super.key,
    required this.selected,
    required this.onSelect,
    this.options = const ['day', 'week', 'month', 'year'],
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Container(
      height: 40,
      decoration: BoxDecoration(
        color: theme.colorScheme.surfaceContainerHighest.withAlpha(77), // ~30% opacity
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: options.map((option) {
          final isSelected = option == selected;
          
          return GestureDetector(
            onTap: () => onSelect(option),
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              decoration: BoxDecoration(
                color: isSelected ? theme.colorScheme.primaryContainer : Colors.transparent,
                borderRadius: BorderRadius.circular(10),
              ),
              child: Text(
                _getDisplayText(option),
                style: TextStyle(
                  fontSize: 14,
                  fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                  color: isSelected 
                      ? theme.colorScheme.onPrimaryContainer 
                      : theme.colorScheme.onSurfaceVariant,
                ),
              ),
            ),
          );
        }).toList(),
      ),
    );
  }
  
  /// Converts the time period option to a display-friendly format
  String _getDisplayText(String option) {
    switch (option) {
      case 'day':
        return 'Day';
      case 'week':
        return 'Week';
      case 'month':
        return 'Month';
      case 'year':
        return 'Year';
      default:
        return option.substring(0, 1).toUpperCase() + option.substring(1);
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/insights/components/trip_list_item.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/core_models/trip.dart';
import 'package:going50/core/utils/formatter_utils.dart';

/// A list item that displays information about a trip.
///
/// Shows date/time, distance, duration, eco-score and key events.
class TripListItem extends StatelessWidget {
  /// The trip to display
  final Trip trip;
  
  /// Callback when the item is tapped
  final VoidCallback? onTap;
  
  /// Constructor
  const TripListItem({
    super.key,
    required this.trip,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    // Format trip date/time
    final dateTimeFormat = DateFormat('MMM d, yyyy • h:mm a');
    final tripDateTime = dateTimeFormat.format(trip.startTime);
    
    // Format trip duration
    final duration = trip.endTime != null 
        ? trip.endTime!.difference(trip.startTime) 
        : Duration.zero;
    final durationText = FormatterUtils.formatDuration(duration);
    
    // Format trip distance
    final distanceText = trip.distanceKm != null
        ? FormatterUtils.formatDistance(trip.distanceKm!)
        : 'N/A';
    
    // Calculate eco-score (based on events)
    // This would normally come from the trip data, but for now we'll calculate it
    final ecoScore = _calculateEcoScore(trip);
    final ecoScoreColor = AppColors.getEcoScoreColor(ecoScore);
    
    // Get key events for indicators
    final hasAggressiveAcceleration = (trip.aggressiveAccelerationEvents ?? 0) > 0;
    final hasHardBraking = (trip.hardBrakingEvents ?? 0) > 0;
    final hasIdling = (trip.idlingEvents ?? 0) > 0;
    final hasExcessiveSpeed = (trip.excessiveSpeedEvents ?? 0) > 0;
    
    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      elevation: 1,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Date/time and eco-score
              Row(
                children: [
                  Expanded(
                    child: Text(
                      tripDateTime,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                  // Eco-score badge
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 10,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: ecoScoreColor.withOpacity(0.2),
                      borderRadius: BorderRadius.circular(16),
                      border: Border.all(
                        color: ecoScoreColor,
                        width: 1,
                      ),
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(
                          Icons.eco,
                          size: 14,
                          color: ecoScoreColor,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          ecoScore.toInt().toString(),
                          style: theme.textTheme.bodyMedium?.copyWith(
                            fontWeight: FontWeight.bold,
                            color: ecoScoreColor,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: 12),
              
              // Distance and duration
              Row(
                children: [
                  // Distance
                  Expanded(
                    child: Row(
                      children: [
                        const Icon(
                          Icons.route,
                          size: 16,
                          color: AppColors.textSecondary,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          distanceText,
                          style: theme.textTheme.bodyMedium,
                        ),
                      ],
                    ),
                  ),
                  
                  // Duration
                  Expanded(
                    child: Row(
                      children: [
                        const Icon(
                          Icons.timer,
                          size: 16,
                          color: AppColors.textSecondary,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          durationText,
                          style: theme.textTheme.bodyMedium,
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              
              // Event indicators (if any)
              if (hasAggressiveAcceleration || hasHardBraking || hasIdling || hasExcessiveSpeed)
                Padding(
                  padding: const EdgeInsets.only(top: 12),
                  child: Wrap(
                    spacing: 8,
                    runSpacing: 8,
                    children: [
                      if (hasAggressiveAcceleration)
                        _buildEventIndicator(
                          context,
                          'Aggressive Acceleration',
                          Icons.speed,
                          AppColors.warning,
                        ),
                      if (hasHardBraking)
                        _buildEventIndicator(
                          context,
                          'Hard Braking',
                          Icons.warning,
                          AppColors.error,
                        ),
                      if (hasIdling)
                        _buildEventIndicator(
                          context,
                          'Idling',
                          Icons.timer_off,
                          AppColors.warning,
                        ),
                      if (hasExcessiveSpeed)
                        _buildEventIndicator(
                          context,
                          'Excessive Speed',
                          Icons.shutter_speed,
                          AppColors.error,
                        ),
                    ],
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
  
  /// Build an event indicator chip
  Widget _buildEventIndicator(
    BuildContext context,
    String label,
    IconData icon,
    Color color,
  ) {
    return Tooltip(
      message: label,
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: 8,
          vertical: 4,
        ),
        decoration: BoxDecoration(
          color: color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              icon,
              size: 14,
              color: color,
            ),
            const SizedBox(width: 4),
            Text(
              label,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: color,
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  /// Calculate eco-score based on trip data
  /// This is a simplified version that would ideally come from the database
  double _calculateEcoScore(Trip trip) {
    // Base score
    double score = 75.0;
    
    // Deduct points for events
    if (trip.aggressiveAccelerationEvents != null && trip.aggressiveAccelerationEvents! > 0) {
      score -= trip.aggressiveAccelerationEvents! * 3;
    }
    
    if (trip.hardBrakingEvents != null && trip.hardBrakingEvents! > 0) {
      score -= trip.hardBrakingEvents! * 4;
    }
    
    if (trip.idlingEvents != null && trip.idlingEvents! > 0) {
      score -= trip.idlingEvents! * 2;
    }
    
    if (trip.excessiveSpeedEvents != null && trip.excessiveSpeedEvents! > 0) {
      score -= trip.excessiveSpeedEvents! * 3;
    }
    
    // Ensure score stays within 0-100 range
    return score.clamp(0.0, 100.0);
  }
} 

################################################################################
FILE: lib/presentation/screens/insights/components/savings_summary_card.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:going50/core/utils/formatter_utils.dart';

/// A card displaying the estimated savings from eco-driving
///
/// This card shows the estimated savings in fuel, money, and CO2 emissions
/// compared to baseline driving behaviors.
class SavingsSummaryCard extends StatelessWidget {
  /// Estimated fuel savings in liters
  final double fuelSavingsL;
  
  /// Estimated money savings in the user's currency (assumed to be USD for now)
  final double moneySavings;
  
  /// Estimated CO2 reduction in kg
  final double co2ReductionKg;
  
  /// Time period description (e.g., "This Week", "This Month")
  final String timePeriod;
  
  /// Constructor
  const SavingsSummaryCard({
    super.key,
    required this.fuelSavingsL,
    required this.moneySavings,
    required this.co2ReductionKg,
    required this.timePeriod,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(16.0),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: BorderRadius.circular(16.0),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.savings_outlined,
                color: theme.colorScheme.primary,
                size: 20,
              ),
              const SizedBox(width: 8),
              Text(
                'Your Savings $timePeriod',
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              _buildSavingItem(
                context,
                icon: Icons.local_gas_station,
                value: FormatterUtils.formatFuel(fuelSavingsL),
                label: 'Fuel',
                iconColor: Colors.orange,
              ),
              _buildSavingItem(
                context,
                icon: Icons.attach_money,
                value: FormatterUtils.formatCurrency(moneySavings),
                label: 'Money',
                iconColor: Colors.green,
              ),
              _buildSavingItem(
                context,
                icon: Icons.co2,
                value: '${FormatterUtils.formatDistance(co2ReductionKg, includeUnit: false)} kg',
                label: 'CO₂',
                iconColor: Colors.blue,
              ),
            ],
          ),
          const SizedBox(height: 12),
          Text(
            'Based on your eco-driving compared to average driving patterns',
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }
  
  /// Builds a single saving metric item
  Widget _buildSavingItem(
    BuildContext context, {
    required IconData icon,
    required String value,
    required String label,
    required Color iconColor,
  }) {
    final theme = Theme.of(context);
    
    return Expanded(
      child: Column(
        children: [
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: iconColor.withAlpha(51), // ~20% opacity
              shape: BoxShape.circle,
            ),
            child: Icon(
              icon,
              color: iconColor,
              size: 24,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            value,
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            label,
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/insights/components/driving_behaviors_chart.dart
################################################################################

import 'package:flutter/material.dart';
import 'dart:math' as math;

/// A widget that displays a radar chart of driving behaviors
///
/// This chart visualizes various driving behavior scores using a radar chart
/// (also known as a spider or web chart) to show relative strengths and weaknesses.
class DrivingBehaviorsChart extends StatefulWidget {
  /// Map of behavior names to scores (0-100)
  final Map<String, int> behaviorScores;
  
  /// Colors for each behavior (optional)
  final Map<String, Color>? behaviorColors;
  
  /// Size of the chart
  final double size;
  
  /// Constructor
  const DrivingBehaviorsChart({
    super.key,
    required this.behaviorScores,
    this.behaviorColors,
    this.size = 250,
  });

  @override
  State<DrivingBehaviorsChart> createState() => _DrivingBehaviorsChartState();
}

class _DrivingBehaviorsChartState extends State<DrivingBehaviorsChart> 
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    );
    _animation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOutCubic,
    );
    _animationController.forward();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final behaviors = widget.behaviorScores.keys.toList();
    
    // Default color if no specific color is provided
    final defaultColor = theme.colorScheme.primary;
    
    return Column(
      children: [
        SizedBox(
          width: widget.size,
          height: widget.size,
          child: AnimatedBuilder(
            animation: _animation,
            builder: (context, child) {
              return CustomPaint(
                size: Size(widget.size, widget.size),
                painter: _BehaviorChartPainter(
                  behaviorScores: widget.behaviorScores,
                  behaviorColors: widget.behaviorColors,
                  defaultColor: defaultColor,
                  animation: _animation.value,
                  backgroundColor: theme.colorScheme.surfaceContainerHighest.withAlpha(77), // ~30% opacity
                  lineColor: theme.colorScheme.outlineVariant,
                ),
              );
            },
          ),
        ),
        Padding(
          padding: const EdgeInsets.only(top: 16.0),
          child: Wrap(
            alignment: WrapAlignment.center,
            spacing: 16,
            runSpacing: 8,
            children: behaviors.map((behavior) {
              final color = widget.behaviorColors?[behavior] ?? defaultColor;
              
              return Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(
                    width: 12,
                    height: 12,
                    decoration: BoxDecoration(
                      color: color,
                      shape: BoxShape.circle,
                    ),
                  ),
                  const SizedBox(width: 4),
                  Text(
                    _formatBehaviorName(behavior),
                    style: theme.textTheme.bodySmall,
                  ),
                ],
              );
            }).toList(),
          ),
        ),
      ],
    );
  }
  
  /// Format behavior name for display (e.g., "calm_driving" -> "Calm Driving")
  String _formatBehaviorName(String behavior) {
    return behavior
        .split('_')
        .map((word) => word.substring(0, 1).toUpperCase() + word.substring(1))
        .join(' ');
  }
}

/// Custom painter for the behavior chart
class _BehaviorChartPainter extends CustomPainter {
  final Map<String, int> behaviorScores;
  final Map<String, Color>? behaviorColors;
  final Color defaultColor;
  final double animation;
  final Color backgroundColor;
  final Color lineColor;
  
  _BehaviorChartPainter({
    required this.behaviorScores,
    this.behaviorColors,
    required this.defaultColor,
    required this.animation,
    required this.backgroundColor,
    required this.lineColor,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    final center = Offset(size.width / 2, size.height / 2);
    final radius = math.min(size.width, size.height) / 2;
    final behaviors = behaviorScores.keys.toList();
    final count = behaviors.length;
    
    if (count < 3) {
      // Not enough data points for a radar chart
      _drawError(canvas, size, 'Insufficient data');
      return;
    }
    
    // Draw background shape
    _drawBackground(canvas, center, radius, count);
    
    // Draw grid lines and labels
    _drawGrid(canvas, center, radius, count);
    
    // Draw data
    _drawData(canvas, center, radius, behaviors, count);
  }
  
  /// Draw error message when there's not enough data
  void _drawError(Canvas canvas, Size size, String message) {
    final textStyle = TextStyle(
      color: Colors.grey,
      fontSize: 14,
    );
    final textSpan = TextSpan(
      text: message,
      style: textStyle,
    );
    final textPainter = TextPainter(
      text: textSpan,
      textDirection: TextDirection.ltr,
    );
    textPainter.layout(
      minWidth: 0,
      maxWidth: size.width,
    );
    textPainter.paint(
      canvas, 
      Offset((size.width - textPainter.width) / 2, (size.height - textPainter.height) / 2)
    );
  }
  
  /// Draw the background shape
  void _drawBackground(Canvas canvas, Offset center, double radius, int count) {
    final backgroundPaint = Paint()
      ..color = backgroundColor
      ..style = PaintingStyle.fill;
    
    final path = Path();
    
    // Draw the outer polygon
    for (var i = 0; i < count; i++) {
      final angle = 2 * math.pi * i / count - math.pi / 2;
      final point = Offset(
        center.dx + radius * math.cos(angle),
        center.dy + radius * math.sin(angle),
      );
      
      if (i == 0) {
        path.moveTo(point.dx, point.dy);
      } else {
        path.lineTo(point.dx, point.dy);
      }
    }
    
    path.close();
    canvas.drawPath(path, backgroundPaint);
  }
  
  /// Draw grid lines and axes
  void _drawGrid(Canvas canvas, Offset center, double radius, int count) {
    final gridPaint = Paint()
      ..color = lineColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;
    
    // Draw axes
    for (var i = 0; i < count; i++) {
      final angle = 2 * math.pi * i / count - math.pi / 2;
      final point = Offset(
        center.dx + radius * math.cos(angle),
        center.dy + radius * math.sin(angle),
      );
      
      canvas.drawLine(center, point, gridPaint);
    }
    
    // Draw concentric circles for scale
    for (var i = 1; i <= 4; i++) {
      final circlePaint = Paint()
        ..color = lineColor.withAlpha((0.3 * i * 255).toInt())
        ..style = PaintingStyle.stroke
        ..strokeWidth = 0.5;
      
      canvas.drawCircle(
        center,
        radius * i / 4,
        circlePaint,
      );
    }
  }
  
  /// Draw the data shape
  void _drawData(Canvas canvas, Offset center, double radius, List<String> behaviors, int count) {
    final dataPath = Path();
    
    for (var i = 0; i < count; i++) {
      final behavior = behaviors[i];
      final score = behaviorScores[behavior] ?? 0;
      final normalizedScore = score / 100; // Assuming scores are 0-100
      final adjustedRadius = radius * normalizedScore * animation;
      
      final angle = 2 * math.pi * i / count - math.pi / 2;
      final point = Offset(
        center.dx + adjustedRadius * math.cos(angle),
        center.dy + adjustedRadius * math.sin(angle),
      );
      
      if (i == 0) {
        dataPath.moveTo(point.dx, point.dy);
      } else {
        dataPath.lineTo(point.dx, point.dy);
      }
    }
    
    dataPath.close();
    
    // Fill with gradient
    final Color lightColor = defaultColor.withAlpha(179); // ~70% opacity
    final Color darkColor = defaultColor.withAlpha(77);  // ~30% opacity
    
    final gradientPaint = Paint()
      ..shader = RadialGradient(
        colors: [
          lightColor,
          darkColor,
        ],
      ).createShader(Rect.fromCircle(center: center, radius: radius))
      ..style = PaintingStyle.fill;
    
    canvas.drawPath(dataPath, gradientPaint);
    
    // Draw outline
    final outlinePaint = Paint()
      ..color = defaultColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.0;
    
    canvas.drawPath(dataPath, outlinePaint);
    
    // Draw points
    final pointPaint = Paint()
      ..color = defaultColor
      ..style = PaintingStyle.fill;
    
    for (var i = 0; i < count; i++) {
      final behavior = behaviors[i];
      final score = behaviorScores[behavior] ?? 0;
      final normalizedScore = score / 100;
      final adjustedRadius = radius * normalizedScore * animation;
      
      final angle = 2 * math.pi * i / count - math.pi / 2;
      final point = Offset(
        center.dx + adjustedRadius * math.cos(angle),
        center.dy + adjustedRadius * math.sin(angle),
      );
      
      canvas.drawCircle(point, 4, pointPaint);
    }
  }
  
  @override
  bool shouldRepaint(covariant _BehaviorChartPainter oldDelegate) {
    return oldDelegate.animation != animation ||
           oldDelegate.behaviorScores != behaviorScores ||
           oldDelegate.behaviorColors != behaviorColors ||
           oldDelegate.defaultColor != defaultColor ||
           oldDelegate.backgroundColor != backgroundColor ||
           oldDelegate.lineColor != lineColor;
  }
} 

################################################################################
FILE: lib/presentation/screens/insights/components/trip_map_section.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:going50/core_models/trip.dart';

/// Component that displays a map visualization of the trip route.
///
/// In a real implementation, this would use a mapping library like Google Maps.
/// For now, we'll create a placeholder with a simulated route visualization.
class TripMapSection extends StatelessWidget {
  /// The trip to display on the map
  final Trip trip;

  /// Constructor
  const TripMapSection({
    super.key,
    required this.trip,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      height: 200,
      margin: const EdgeInsets.all(16.0),
      decoration: BoxDecoration(
        color: Colors.grey.shade200,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Stack(
        children: [
          // Map placeholder with simulated route
          ClipRRect(
            borderRadius: BorderRadius.circular(12),
            child: Container(
              color: Colors.grey.shade300,
              child: CustomPaint(
                size: const Size(double.infinity, 200),
                painter: _RoutePainter(),
              ),
            ),
          ),
          
          // Map overlay
          Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(
                  Icons.map,
                  size: 36,
                  color: Colors.grey,
                ),
                const SizedBox(height: 8),
                Text(
                  'Route Map',
                  style: Theme.of(context).textTheme.titleMedium,
                ),
                const SizedBox(height: 4),
                Text(
                  'Location data not available',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Colors.grey.shade700,
                  ),
                ),
              ],
            ),
          ),
          
          // Map controls (mockup)
          Positioned(
            right: 8,
            bottom: 8,
            child: Column(
              children: [
                _buildMapButton(Icons.add, () {}),
                const SizedBox(height: 8),
                _buildMapButton(Icons.remove, () {}),
                const SizedBox(height: 8),
                _buildMapButton(Icons.my_location, () {}),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  /// Build a circular map control button
  Widget _buildMapButton(IconData icon, VoidCallback onTap) {
    return Container(
      width: 36,
      height: 36,
      decoration: BoxDecoration(
        color: Colors.white,
        shape: BoxShape.circle,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 2,
            offset: const Offset(0, 1),
          ),
        ],
      ),
      child: IconButton(
        icon: Icon(icon, size: 18),
        onPressed: onTap,
        padding: EdgeInsets.zero,
      ),
    );
  }
}

/// Custom painter to simulate a route on the map
class _RoutePainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.blue.shade500
      ..strokeWidth = 3
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;
    
    // Create a simulated route path
    final path = Path();
    path.moveTo(size.width * 0.2, size.height * 0.8);
    path.quadraticBezierTo(
      size.width * 0.4, size.height * 0.5,
      size.width * 0.6, size.height * 0.7,
    );
    path.quadraticBezierTo(
      size.width * 0.75, size.height * 0.85,
      size.width * 0.85, size.height * 0.3,
    );
    
    canvas.drawPath(path, paint);
    
    // Draw the start point
    final startPointPaint = Paint()
      ..color = Colors.green
      ..style = PaintingStyle.fill;
    canvas.drawCircle(
      Offset(size.width * 0.2, size.height * 0.8),
      6,
      startPointPaint,
    );
    
    // Draw a white border around the start point
    final startBorderPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2;
    canvas.drawCircle(
      Offset(size.width * 0.2, size.height * 0.8),
      6,
      startBorderPaint,
    );
    
    // Draw the end point
    final endPointPaint = Paint()
      ..color = Colors.red
      ..style = PaintingStyle.fill;
    canvas.drawCircle(
      Offset(size.width * 0.85, size.height * 0.3),
      6,
      endPointPaint,
    );
    
    // Draw a white border around the end point
    final endBorderPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2;
    canvas.drawCircle(
      Offset(size.width * 0.85, size.height * 0.3),
      6,
      endBorderPaint,
    );
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
} 

################################################################################
FILE: lib/presentation/screens/profile/settings_screen.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:going50/presentation/providers/user_provider.dart';
import 'package:going50/core/constants/route_constants.dart';
import 'package:going50/presentation/screens/profile/components/settings_section.dart';
import 'package:going50/presentation/screens/profile/components/settings_item.dart';

/// The Settings Screen for the Going50 app.
///
/// This screen displays all app configuration options organized by category.
class SettingsScreen extends StatelessWidget {
  /// Constructor for the settings screen.
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final userProvider = Provider.of<UserProvider>(context);
    final isAnonymous = userProvider.isAnonymous;
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Settings'),
        elevation: 0,
      ),
      body: SafeArea(
        child: ListView(
          children: [
            // Account Section (if signed in)
            if (!isAnonymous) _buildAccountSection(context, userProvider),
            
            // Privacy Section
            _buildPrivacySection(context, userProvider),
            
            // Device Section
            _buildDeviceSection(context, userProvider),
            
            // Preferences Section
            _buildPreferencesSection(context, userProvider),
            
            // About Section
            _buildAboutSection(context, userProvider),
            
            const SizedBox(height: 32),
          ],
        ),
      ),
    );
  }

  /// Builds the account section of settings.
  Widget _buildAccountSection(BuildContext context, UserProvider userProvider) {
    return SettingsSection(
      title: 'ACCOUNT',
      children: [
        SettingsItem(
          title: 'Profile Information',
          subtitle: userProvider.userProfile?.name ?? 'Your profile details',
          icon: Icons.person,
          trailing: const Icon(Icons.arrow_forward_ios, size: 16),
          onTap: () {
            // TODO: Navigate to profile edit screen
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Profile edit not yet implemented'),
              ),
            );
          },
        ),
        SettingsItem(
          title: 'Data Sync',
          subtitle: userProvider.getPreference('privacy', 'allow_data_upload') == true
              ? 'Enabled'
              : 'Disabled',
          icon: Icons.sync,
          trailing: Switch(
            value: userProvider.getPreference('privacy', 'allow_data_upload') == true,
            onChanged: (value) async {
              await userProvider.updatePreference('privacy', 'allow_data_upload', value);
            },
          ),
          onTap: null, // Tapping the row doesn't do anything since we have a switch
        ),
        SettingsItem(
          title: 'Delete Account',
          subtitle: 'Permanently delete your account and all data',
          icon: Icons.delete_forever,
          trailing: const Icon(Icons.arrow_forward_ios, size: 16),
          showDivider: false,
          onTap: () {
            // Show confirmation dialog
            showDialog(
              context: context,
              builder: (context) => AlertDialog(
                title: const Text('Delete Account?'),
                content: const Text(
                  'This will permanently delete your account and all associated data. This action cannot be undone.',
                ),
                actions: [
                  TextButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('CANCEL'),
                  ),
                  TextButton(
                    onPressed: () {
                      Navigator.of(context).pop();
                      // TODO: Implement account deletion
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Account deletion not yet implemented'),
                        ),
                      );
                    },
                    child: const Text('DELETE', style: TextStyle(color: Colors.red)),
                  ),
                ],
              ),
            );
          },
        ),
      ],
    );
  }

  /// Builds the privacy section of settings.
  Widget _buildPrivacySection(BuildContext context, UserProvider userProvider) {
    return SettingsSection(
      title: 'PRIVACY',
      children: [
        SettingsItem(
          title: 'Privacy Settings',
          subtitle: 'Data collection and sharing preferences',
          icon: Icons.privacy_tip,
          trailing: const Icon(Icons.arrow_forward_ios, size: 16),
          onTap: () {
            Navigator.of(context).pushNamed(ProfileRoutes.privacySettings);
          },
        ),
        SettingsItem(
          title: 'Social Visibility',
          subtitle: userProvider.getPreference('privacy', 'share_achievements') == true
              ? 'Public profile'
              : 'Private profile',
          icon: Icons.visibility,
          trailing: Switch(
            value: userProvider.getPreference('privacy', 'share_achievements') == true,
            onChanged: (value) async {
              await userProvider.updatePreference('privacy', 'share_achievements', value);
            },
          ),
          onTap: null,
        ),
        SettingsItem(
          title: 'Data Management',
          subtitle: 'Export or delete your data',
          icon: Icons.storage,
          trailing: const Icon(Icons.arrow_forward_ios, size: 16),
          showDivider: false,
          onTap: () {
            // Navigate to data management screen without scrolling to reset
            Navigator.of(context).pushNamed(
              ProfileRoutes.dataManagement,
              arguments: {'scrollToReset': false},
            );
          },
        ),
      ],
    );
  }

  /// Builds the device section of settings.
  Widget _buildDeviceSection(BuildContext context, UserProvider userProvider) {
    final connectionMode = userProvider.getPreference('connection', 'connection_mode') as String? ?? 'auto';
    
    String connectionModeText;
    switch (connectionMode) {
      case 'auto':
        connectionModeText = 'Automatic (OBD if available)';
        break;
      case 'obd_only':
        connectionModeText = 'OBD device only';
        break;
      case 'phone_only':
        connectionModeText = 'Phone sensors only';
        break;
      default:
        connectionModeText = 'Automatic';
    }
    
    return SettingsSection(
      title: 'DEVICE',
      children: [
        SettingsItem(
          title: 'OBD Connection',
          subtitle: 'Manage connected OBD devices',
          icon: Icons.bluetooth,
          trailing: const Icon(Icons.arrow_forward_ios, size: 16),
          onTap: () {
            Navigator.of(context).pushNamed(ProfileRoutes.deviceConnection);
          },
        ),
        SettingsItem(
          title: 'Connection Mode',
          subtitle: connectionModeText,
          icon: Icons.settings_input_component,
          trailing: const Icon(Icons.arrow_forward_ios, size: 16),
          onTap: () {
            _showConnectionModeDialog(context, userProvider, connectionMode);
          },
        ),
        SettingsItem(
          title: 'Background Operation',
          subtitle: userProvider.getPreference('driving', 'auto_end_trip') == true
              ? 'Enabled'
              : 'Disabled',
          icon: Icons.directions_car,
          trailing: Switch(
            value: userProvider.getPreference('driving', 'auto_end_trip') == true,
            onChanged: (value) async {
              await userProvider.updatePreference('driving', 'auto_end_trip', value);
            },
          ),
          showDivider: false,
          onTap: null,
        ),
      ],
    );
  }

  /// Builds the preferences section of settings.
  Widget _buildPreferencesSection(BuildContext context, UserProvider userProvider) {
    final units = userProvider.getPreference('display', 'units') as String? ?? 'metric';
    
    return SettingsSection(
      title: 'PREFERENCES',
      children: [
        SettingsItem(
          title: 'Notification Settings',
          subtitle: 'Customize app notifications',
          icon: Icons.notifications,
          trailing: const Icon(Icons.arrow_forward_ios, size: 16),
          onTap: () {
            // TODO: Navigate to notification settings
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Notification settings not yet implemented'),
              ),
            );
          },
        ),
        SettingsItem(
          title: 'Display Preferences',
          subtitle: 'Theme and display options',
          icon: Icons.palette,
          trailing: const Icon(Icons.arrow_forward_ios, size: 16),
          onTap: () {
            // TODO: Navigate to display settings
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Display settings not yet implemented'),
              ),
            );
          },
        ),
        SettingsItem(
          title: 'Audio Feedback',
          subtitle: userProvider.getPreference('driving', 'audio_feedback') == true
              ? 'Enabled'
              : 'Disabled',
          icon: Icons.volume_up,
          trailing: Switch(
            value: userProvider.getPreference('driving', 'audio_feedback') == true,
            onChanged: (value) async {
              await userProvider.updatePreference('driving', 'audio_feedback', value);
            },
          ),
          onTap: null,
        ),
        SettingsItem(
          title: 'Measurement Units',
          subtitle: units == 'metric' ? 'Metric (km, L)' : 'Imperial (mi, gal)',
          icon: Icons.straighten,
          trailing: const Icon(Icons.arrow_forward_ios, size: 16),
          onTap: () {
            _showUnitSelectionDialog(context, userProvider, units);
          },
          showDivider: false,
        ),
      ],
    );
  }

  /// Builds the about section of settings.
  Widget _buildAboutSection(BuildContext context, UserProvider userProvider) {
    return SettingsSection(
      title: 'ABOUT',
      children: [
        SettingsItem(
          title: 'App Version',
          subtitle: '1.0.0 (beta)',
          icon: Icons.info,
          onTap: null,
        ),
        SettingsItem(
          title: 'Terms of Service',
          icon: Icons.description,
          trailing: const Icon(Icons.arrow_forward_ios, size: 16),
          onTap: () {
            // TODO: Navigate to terms of service
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Terms of service not yet implemented'),
              ),
            );
          },
        ),
        SettingsItem(
          title: 'Privacy Policy',
          icon: Icons.policy,
          trailing: const Icon(Icons.arrow_forward_ios, size: 16),
          onTap: () {
            // TODO: Navigate to privacy policy
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Privacy policy not yet implemented'),
              ),
            );
          },
        ),
        SettingsItem(
          title: 'Send Feedback',
          icon: Icons.feedback,
          trailing: const Icon(Icons.arrow_forward_ios, size: 16),
          showDivider: false,
          onTap: () {
            // TODO: Navigate to feedback form
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Feedback form not yet implemented'),
              ),
            );
          },
        ),
      ],
    );
  }

  /// Shows a dialog to select connection mode.
  void _showConnectionModeDialog(BuildContext context, UserProvider userProvider, String currentMode) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Connection Mode'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            RadioListTile<String>(
              title: const Text('Automatic'),
              subtitle: const Text('Use OBD if available, fallback to phone sensors'),
              value: 'auto',
              groupValue: currentMode,
              onChanged: (value) async {
                Navigator.of(context).pop();
                await userProvider.updatePreference('connection', 'connection_mode', value);
              },
            ),
            RadioListTile<String>(
              title: const Text('OBD Only'),
              subtitle: const Text('Only use OBD device for data collection'),
              value: 'obd_only',
              groupValue: currentMode,
              onChanged: (value) async {
                Navigator.of(context).pop();
                await userProvider.updatePreference('connection', 'connection_mode', value);
              },
            ),
            RadioListTile<String>(
              title: const Text('Phone Only'),
              subtitle: const Text('Only use phone sensors for data collection'),
              value: 'phone_only',
              groupValue: currentMode,
              onChanged: (value) async {
                Navigator.of(context).pop();
                await userProvider.updatePreference('connection', 'connection_mode', value);
              },
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('CANCEL'),
          ),
        ],
      ),
    );
  }

  /// Shows a dialog to select measurement units.
  void _showUnitSelectionDialog(BuildContext context, UserProvider userProvider, String currentUnits) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Measurement Units'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            RadioListTile<String>(
              title: const Text('Metric'),
              subtitle: const Text('Kilometers, Liters, kg CO₂'),
              value: 'metric',
              groupValue: currentUnits,
              onChanged: (value) async {
                Navigator.of(context).pop();
                await userProvider.updatePreference('display', 'units', value);
              },
            ),
            RadioListTile<String>(
              title: const Text('Imperial'),
              subtitle: const Text('Miles, Gallons, lbs CO₂'),
              value: 'imperial',
              groupValue: currentUnits,
              onChanged: (value) async {
                Navigator.of(context).pop();
                await userProvider.updatePreference('display', 'units', value);
              },
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('CANCEL'),
          ),
        ],
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/profile/data_management_screen.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:going50/presentation/screens/profile/components/data_management_section.dart';
import 'package:provider/provider.dart';
import 'package:going50/presentation/providers/user_provider.dart';
import 'package:going50/services/service_locator.dart';
import 'package:going50/services/user/privacy_service.dart';
import 'package:going50/core/theme/app_colors.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:going50/core/constants/route_constants.dart';
import 'package:going50/data_lib/data_storage_manager.dart';
import 'package:flutter/services.dart';

/// DataManagementScreen provides a comprehensive interface for managing user data
/// 
/// Features:
/// - Local data deletion
/// - Data export
/// - Data usage statistics
/// - Privacy settings access
class DataManagementScreen extends StatefulWidget {
  /// Whether to automatically scroll to the data reset section
  final bool scrollToReset;
  
  const DataManagementScreen({
    Key? key, 
    this.scrollToReset = false,
  }) : super(key: key);

  @override
  State<DataManagementScreen> createState() => _DataManagementScreenState();
}

class _DataManagementScreenState extends State<DataManagementScreen> {
  final PrivacyService _privacyService = serviceLocator<PrivacyService>();
  bool _isLoading = false;
  
  // Scroll controller for managing scroll position
  final ScrollController _scrollController = ScrollController();
  
  // Reference to data controls section
  final GlobalKey _dataControlsKey = GlobalKey();
  
  // Flag to track if we've already scrolled
  bool _hasScrolled = false;

  @override
  void initState() {
    super.initState();
    _loadPrivacySettings();
    
    // Add post-frame callback to scroll to the data controls section if needed
    if (widget.scrollToReset) {
      // Add a slightly longer delay to ensure rendering is complete
      Future.delayed(const Duration(milliseconds: 300), () {
        if (mounted && !_hasScrolled) {
          _scrollToDataControls();
        }
      });
    }
  }
  
  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  /// Scrolls to the data controls section with animation
  void _scrollToDataControls() {
    // Scroll to a specific position from the top that will likely show the reset button
    // This is more reliable than trying to calculate exact positions
    final double targetPosition = MediaQuery.of(context).size.height * 0.95;
    
    _scrollController.animateTo(
      targetPosition,
      duration: const Duration(milliseconds: 800),
      curve: Curves.easeInOut,
    ).then((_) {
      // After the first scroll, set up a delayed second scroll to fine-tune position
      // This handles cases where content height changes during the first scroll
      Future.delayed(const Duration(milliseconds: 100), () {
        if (mounted) {
          _scrollController.animateTo(
            _scrollController.position.maxScrollExtent - 200, // Show the reset button with some context above it
            duration: const Duration(milliseconds: 400),
            curve: Curves.easeOut,
          );
          _hasScrolled = true;
        }
      });
    });
  }

  Future<void> _loadPrivacySettings() async {
    setState(() {
      _isLoading = true;
    });

    try {
      await _privacyService.initialize();
    } catch (e) {
      // Handle error
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final userProvider = Provider.of<UserProvider>(context);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Local Data Management'),
        elevation: 0,
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : Stack(
              children: [
                SingleChildScrollView(
                  controller: _scrollController,
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Section title and description
                      const Text(
                        'Manage Your Local Data',
                        style: TextStyle(
                          fontSize: 20,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 8),
                      const Text(
                        'Control how your local device data is stored, exported, or deleted. For cloud data management, use the Privacy Settings.',
                        style: TextStyle(
                          fontSize: 14,
                          color: Colors.grey,
                        ),
                      ),
                      const SizedBox(height: 16),
                      
                      // Data Management Section - customize to hide redundant button when already on this screen
                      _buildLocalDataManagementSection(),
                      
                      const SizedBox(height: 24),
                      
                      // Data Storage Details
                      _buildDataStorageCard(context),
                      
                      const SizedBox(height: 24),
                      
                      // Data Control Actions - with key for scrolling
                      Container(
                        key: _dataControlsKey,
                        child: _buildDataControlsCard(context, userProvider),
                      ),
                      
                      // Add extra space at bottom for better scrolling
                      const SizedBox(height: 100),
                    ],
                  ),
                ),
                
                // Show a floating hint button if we're supposed to scroll
                if (widget.scrollToReset && !_hasScrolled)
                  Positioned(
                    bottom: 16,
                    right: 16,
                    child: FloatingActionButton(
                      mini: true,
                      backgroundColor: Theme.of(context).primaryColor,
                      onPressed: _scrollToDataControls,
                      tooltip: 'Reset options below',
                      child: const Icon(Icons.arrow_downward),
                    ),
                  ),
              ],
            ),
    );
  }
  
  /// Build a customized version of the DataManagementSection that doesn't include
  /// the "Manage Local Data" button when already on this screen
  Widget _buildLocalDataManagementSection() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Expanded(
                  child: Text(
                    'Data Management Options',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                // If scrollToReset is true, show a hint to scroll down
                if (widget.scrollToReset)
                  Tooltip(
                    message: 'Reset options below',
                    child: IconButton(
                      icon: const Icon(Icons.arrow_downward),
                      onPressed: _scrollToDataControls,
                      color: Theme.of(context).primaryColor,
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                const Expanded(
                  child: Text(
                    'Export your data or manage cloud data in the Privacy Settings section.',
                    style: TextStyle(fontSize: 14),
                  ),
                ),
                if (widget.scrollToReset)
                  Text(
                    'Scroll down for reset options →',
                    style: TextStyle(
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                      color: Theme.of(context).primaryColor,
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 16),
            _buildExportDataButton(context),
            const SizedBox(height: 16),
            _buildDataRetentionInfo(),
          ],
        ),
      ),
    );
  }
  
  /// Builds the export data button (copied from DataManagementSection)
  Widget _buildExportDataButton(BuildContext context) {
    return OutlinedButton(
      onPressed: () => _handleExportData(context),
      style: OutlinedButton.styleFrom(
        minimumSize: const Size.fromHeight(44),
        side: BorderSide(color: Theme.of(context).primaryColor),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.download, color: Theme.of(context).primaryColor),
          const SizedBox(width: 8),
          Text(
            'EXPORT YOUR DATA',
            style: TextStyle(color: Theme.of(context).primaryColor),
          ),
        ],
      ),
    );
  }
  
  /// Handles the export data action (copied from DataManagementSection)
  void _handleExportData(BuildContext context) {
    // Show a loading indicator during export
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const AlertDialog(
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 16),
            Text('Preparing your data export...'),
          ],
        ),
      ),
    );

    // Simulate export process with a delay
    Future.delayed(const Duration(seconds: 2), () {
      Navigator.of(context).pop(); // Close loading dialog
      
      // Show completion dialog
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Data Export Ready'),
          content: const Text(
            'Your data has been exported successfully. It will be downloaded to your device.',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('OK'),
            ),
          ],
        ),
      );
    });
  }
  
  /// Builds the data retention information section (copied from DataManagementSection)
  Widget _buildDataRetentionInfo() {
    return const Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Data Retention',
          style: TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.bold,
          ),
        ),
        SizedBox(height: 8),
        Text(
          'By default, your data is stored locally on your device. If you enable cloud sync, '
          'your data is also stored in our secure cloud according to our privacy policy.',
          style: TextStyle(fontSize: 12, color: Colors.grey),
        ),
        SizedBox(height: 8),
        Text(
          'Local data is retained until you delete it manually. Cloud data is retained as long as '
          'you have an active account.',
          style: TextStyle(fontSize: 12, color: Colors.grey),
        ),
      ],
    );
  }
  
  /// Build a card showing data storage details
  Widget _buildDataStorageCard(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Expanded(
                  child: Text(
                    'Data Storage Location',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                // If scrollToReset is true, show a hint to scroll down
                if (widget.scrollToReset)
                  Tooltip(
                    message: 'Reset options below',
                    child: IconButton(
                      icon: const Icon(Icons.arrow_downward),
                      onPressed: _scrollToDataControls,
                      color: Theme.of(context).primaryColor,
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 8),
            const Text(
              'This screen lets you manage data stored on your device. For cloud data management, visit Privacy Settings.',
              style: TextStyle(
                fontSize: 14,
                color: Colors.grey,
              ),
            ),
            const SizedBox(height: 16),
            
            // Data types with storage info
            FutureBuilder<bool>(
              future: _privacyService.isOperationAllowed(
                PrivacyService.dataTypeTrips, 'cloud_sync'
              ),
              builder: (context, snapshot) {
                return _buildDataTypeStorageRow(
                  'Trip Data', 
                  true, 
                  snapshot.data ?? false,
                );
              }
            ),
            const SizedBox(height: 12),
            
            FutureBuilder<bool>(
              future: _privacyService.isOperationAllowed(
                PrivacyService.dataTypeLocation, 'cloud_sync'
              ),
              builder: (context, snapshot) {
                return _buildDataTypeStorageRow(
                  'Location History', 
                  true, 
                  snapshot.data ?? false,
                );
              }
            ),
            const SizedBox(height: 12),
            
            FutureBuilder<bool>(
              future: _privacyService.isOperationAllowed(
                PrivacyService.dataTypePerformanceMetrics, 'cloud_sync'
              ),
              builder: (context, snapshot) {
                return _buildDataTypeStorageRow(
                  'Performance Metrics', 
                  true, 
                  snapshot.data ?? false,
                );
              }
            ),
            const SizedBox(height: 12),
            
            FutureBuilder<bool>(
              future: _privacyService.isOperationAllowed(
                PrivacyService.dataTypeDrivingEvents, 'cloud_sync'
              ),
              builder: (context, snapshot) {
                return _buildDataTypeStorageRow(
                  'Driving Events', 
                  true, 
                  snapshot.data ?? false,
                );
              }
            ),
            
            const SizedBox(height: 16),
            const Divider(),
            const SizedBox(height: 8),
            
            // Note about cloud sync
            const Text(
              'To manage cloud data or change sync settings, visit Privacy Settings. The reset function on this screen only affects local data.',
              style: TextStyle(
                fontSize: 12,
                color: Colors.grey,
                fontStyle: FontStyle.italic,
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  /// Build a row showing storage status for a data type
  Widget _buildDataTypeStorageRow(String dataType, bool isLocal, bool isCloud) {
    return Row(
      children: [
        Expanded(
          flex: 3,
          child: Text(
            dataType,
            style: const TextStyle(
              fontWeight: FontWeight.w500,
            ),
          ),
        ),
        Expanded(
          flex: 2,
          child: Row(
            children: [
              Icon(
                Icons.smartphone,
                size: 16,
                color: isLocal ? AppColors.ecoScoreHigh : Colors.grey,
              ),
              const SizedBox(width: 4),
              Text(
                isLocal ? 'Local' : 'Not Local',
                style: TextStyle(
                  fontSize: 12,
                  color: isLocal ? AppColors.ecoScoreHigh : Colors.grey,
                ),
              ),
            ],
          ),
        ),
        Expanded(
          flex: 2,
          child: Row(
            children: [
              Icon(
                Icons.cloud,
                size: 16,
                color: isCloud ? AppColors.ecoScoreMedium : Colors.grey,
              ),
              const SizedBox(width: 4),
              Text(
                isCloud ? 'Cloud' : 'Not Synced',
                style: TextStyle(
                  fontSize: 12,
                  color: isCloud ? AppColors.ecoScoreMedium : Colors.grey,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
  
  /// Build a card with data control options
  Widget _buildDataControlsCard(BuildContext context, UserProvider userProvider) {
    return Card(
      elevation: widget.scrollToReset ? 4 : 1, // Highlight card if we're scrolling to it
      margin: widget.scrollToReset 
          ? const EdgeInsets.all(4) 
          : null,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: widget.scrollToReset 
            ? BorderSide(color: Theme.of(context).primaryColor, width: 2)
            : BorderSide.none,
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Expanded(
                  child: Text(
                    'Reset Local App Data',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                // Add a hint icon if we're highlighting this section
                if (widget.scrollToReset)
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: Theme.of(context).primaryColor.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(16),
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(
                          Icons.check_circle,
                          color: Theme.of(context).primaryColor,
                          size: 18,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          'Here it is!',
                          style: TextStyle(
                            color: Theme.of(context).primaryColor,
                            fontWeight: FontWeight.bold,
                            fontSize: 12,
                          ),
                        ),
                      ],
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 8),
            const Text(
              'This option will delete all local data and reset the app as if it was newly installed.',
              style: TextStyle(fontSize: 14),
            ),
            const SizedBox(height: 16),
            
            // Reset app button
            OutlinedButton(
              onPressed: () => _showResetConfirmation(context),
              style: OutlinedButton.styleFrom(
                minimumSize: const Size.fromHeight(44),
                side: const BorderSide(color: Colors.red),
              ),
              child: const Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.restore, color: Colors.red),
                  SizedBox(width: 8),
                  Text(
                    'DELETE LOCAL DATA & RESET APP',
                    style: TextStyle(color: Colors.red),
                  ),
                ],
              ),
            ),
            
            const SizedBox(height: 16),
            const Text(
              'This will delete all your local data and reset your user profile. You will be returned to the onboarding flow. This action cannot be undone.',
              style: TextStyle(
                fontSize: 12,
                color: Colors.grey,
              ),
            ),
            const SizedBox(height: 8),
            const Text(
              'Note: This does not affect any data stored on cloud servers. To delete cloud data, use the Cloud Data Management option in Privacy Settings.',
              style: TextStyle(
                fontSize: 12,
                fontStyle: FontStyle.italic,
                color: Colors.grey,
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  /// Show confirmation dialog for resetting the app
  void _showResetConfirmation(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Local Data & Reset App?'),
        content: const Text(
          'This will permanently delete all your local data and reset the app. '
          'Cloud data will not be affected. '
          'You will be returned to the onboarding flow. This action cannot be undone.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('CANCEL'),
          ),
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              _handleResetApp(context);
            },
            child: const Text(
              'DELETE & RESET',
              style: TextStyle(color: Colors.red),
            ),
          ),
        ],
      ),
    );
  }
  
  /// Handle app reset
  void _handleResetApp(BuildContext context) {
    // Show a loading indicator during deletion
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const AlertDialog(
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 16),
            Text('Deleting local data and resetting app...'),
          ],
        ),
      ),
    );

    // Get the user provider
    final userProvider = Provider.of<UserProvider>(context, listen: false);
    
    // Also get direct access to services for complete reset
    final dataStorageManager = serviceLocator<DataStorageManager>();
    
    // Create a timeout to prevent hanging
    bool isCompleted = false;
    
    // Set a timeout to prevent hanging
    Future.delayed(Duration(seconds: 10), () {
      if (!isCompleted && mounted) {
        print("Data deletion operation timed out - forcing completion");
        _completeReset(context);
        isCompleted = true;
      }
    });
    
    // Reset the user state completely with a smaller scope
    Future.microtask(() async {
      try {
        // Get current user ID before resetting
        final userId = userProvider.userProfile?.id;
        
        if (userId != null) {
          // Basic reset: reset preferences and user data
          
          // 1. Clear shared preferences first
          final prefs = await SharedPreferences.getInstance();
          await prefs.clear(); // Clear ALL preferences
          
          // 2. Reset onboarding status explicitly
          await prefs.setBool('onboarding_complete', false);
          
          // 3. Force reset the user provider state
          await userProvider.resetUser();
          
          // 4. Try to delete critical tables only, don't worry about social ones
          try {
            // Delete core user data with individual timeouts
            await dataStorageManager.deleteBasicUserData(userId);
          } catch (e) {
            print("Error during data deletion, continuing with reset: $e");
          }
        }
        
        if (!isCompleted) {
          _completeReset(context);
          isCompleted = true;
        }
      } catch (error) {
        print("Error during reset: $error");
        // Close loading dialog if open
        if (mounted && Navigator.of(context).canPop()) {
          Navigator.of(context).pop();
        }
        
        // Show error dialog
        if (mounted && !isCompleted) {
          showDialog(
            context: context,
            builder: (context) => AlertDialog(
              title: const Text('Error'),
              content: Text(
                'An error occurred while deleting local data: $error\n\nThe app will now exit. Please restart it to complete the reset.',
              ),
              actions: [
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pop();
                    SystemChannels.platform.invokeMethod('SystemNavigator.pop');
                  },
                  child: const Text('EXIT APP'),
                ),
              ],
            ),
          );
          isCompleted = true;
        }
      }
    });
  }
  
  /// Complete the reset process and show final dialog
  void _completeReset(BuildContext context) {
    // Close loading dialog if open
    if (mounted && Navigator.of(context).canPop()) {
      Navigator.of(context).pop();
    }
    
    // Show completion dialog
    if (mounted) {
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => AlertDialog(
          title: const Text('App Reset Complete'),
          content: const Text(
            'Your data has been deleted and the app has been reset. The app will now exit. Please restart it to start fresh.',
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
                // Exit the app to ensure a clean slate
                SystemChannels.platform.invokeMethod('SystemNavigator.pop');
              },
              child: const Text('EXIT APP'),
            ),
          ],
        ),
      );
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/profile/profile_screen.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:going50/presentation/screens/profile/components/profile_header.dart';
import 'package:going50/presentation/screens/profile/components/achievements_grid.dart';
import 'package:going50/presentation/screens/profile/components/statistics_summary.dart';
import 'package:going50/core/constants/route_constants.dart';

/// ProfileScreen is the main screen for the Profile tab.
///
/// This screen displays user achievements and provides access to settings.
class ProfileScreen extends StatelessWidget {
  const ProfileScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Profile'),
        centerTitle: true,
      ),
      body: RefreshIndicator(
        onRefresh: () async {
          // TODO: Implement refresh logic
          await Future.delayed(const Duration(milliseconds: 800));
        },
        child: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 24),
              
              // Profile header with user info and eco-score
              const ProfileHeader(),
              
              const SizedBox(height: 32),
              
              // Achievements section
              _buildSectionTitle(context, 'Achievements'),
              const SizedBox(height: 16),
              const AchievementsGrid(),
              
              const SizedBox(height: 32),
              
              // Statistics section
              _buildSectionTitle(context, 'Statistics'),
              const SizedBox(height: 8),
              const StatisticsSummary(),
              
              const SizedBox(height: 32),
              
              // Action buttons
              Center(
                child: _buildActionButton(
                  context,
                  'Settings',
                  Icons.settings,
                  () {
                    Navigator.of(context).pushNamed(ProfileRoutes.settings);
                  },
                ),
              ),
              
              const SizedBox(height: 16),
              
              Center(
                child: _buildActionButton(
                  context,
                  'Help & Support',
                  Icons.help_outline,
                  () {
                    // TODO: Implement help & support
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text('Help & Support not yet implemented'),
                      ),
                    );
                  },
                ),
              ),
              
              const SizedBox(height: 32),
            ],
          ),
        ),
      ),
    );
  }
  
  /// Builds a section title
  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: Text(
        title,
        style: const TextStyle(
          fontSize: 18,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
  
  /// Builds an action button
  Widget _buildActionButton(
    BuildContext context,
    String label,
    IconData icon,
    VoidCallback onPressed,
  ) {
    return SizedBox(
      width: 280,
      child: ElevatedButton.icon(
        onPressed: onPressed,
        icon: Icon(icon),
        label: Text(label),
        style: ElevatedButton.styleFrom(
          padding: const EdgeInsets.symmetric(vertical: 12),
          backgroundColor: Colors.white,
          foregroundColor: Colors.black87,
          elevation: 1,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/profile/privacy_settings_screen.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:provider/provider.dart';
import 'package:going50/presentation/providers/user_provider.dart';
import 'package:going50/services/user/privacy_service.dart';
import 'package:going50/presentation/screens/profile/components/data_collection_visualization.dart';
import 'package:going50/presentation/screens/profile/components/privacy_toggles.dart';
import 'package:going50/presentation/screens/profile/components/data_management_section.dart';
import 'package:going50/core_models/data_privacy_settings.dart';

/// Privacy Settings Screen allows users to control their data collection and sharing preferences
///
/// This screen provides:
/// - Visual representation of what data is collected and how it's used
/// - Granular toggle controls for different data types
/// - Data management options (export, delete)
/// - Privacy policy information
class PrivacySettingsScreen extends StatefulWidget {
  const PrivacySettingsScreen({Key? key}) : super(key: key);

  @override
  State<PrivacySettingsScreen> createState() => _PrivacySettingsScreenState();
}

class _PrivacySettingsScreenState extends State<PrivacySettingsScreen> {
  bool _isLoading = true; // Start with loading state

  @override
  void initState() {
    super.initState();
    // Initialize privacy settings when the screen is loaded
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _initializePrivacySettings();
    });
  }
  
  /// Initialize privacy settings
  Future<void> _initializePrivacySettings() async {
    try {
      final privacyService = Provider.of<PrivacyService>(context, listen: false);
      await privacyService.initialize();
      
      if (mounted) {
        setState(() => _isLoading = false);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to load privacy settings: $e')),
        );
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final privacyService = Provider.of<PrivacyService>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Privacy Settings'),
        elevation: 0,
      ),
      body: _isLoading 
        ? const Center(child: CircularProgressIndicator())
        : StreamBuilder<Map<String, DataPrivacySettings>>(
            stream: privacyService.privacySettingsStream,
            initialData: privacyService.privacySettings,
            builder: (context, snapshot) {
              return RefreshIndicator(
                onRefresh: () async {
                  // Force refresh of privacy settings
                  setState(() => _isLoading = true);
                  await _initializePrivacySettings();
                },
                child: SingleChildScrollView(
                  physics: const AlwaysScrollableScrollPhysics(),
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Privacy score and visualization section
                      const DataCollectionVisualization(),
                      
                      const SizedBox(height: 24),
                      
                     
                      
                      // Data collection toggles
                      const Text(
                        'Data Collection Controls',
                        style: TextStyle(
                          fontSize: 18, 
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 12),
                      PrivacyToggles(
                        onSettingChanged: (dataType, operation, value) {
                          // Handle privacy setting changes
                          setState(() => _isLoading = true);
                          _updatePrivacySetting(dataType, operation, value).then((_) {
                            // Force screen refresh to update visualization
                            setState(() => _isLoading = false);
                          });
                        },
                      ),
                      
                      const SizedBox(height: 24),
                      
                      // Data management section
                      const DataManagementSection(),
                      
                      const SizedBox(height: 24),
                      
                      // Privacy policy section
                      _buildPrivacyPolicySection(context),
                    ],
                  ),
                ),
              );
            }
          ),
    );
  }
  
  /// Updates a privacy setting for a data type and operation
  Future<void> _updatePrivacySetting(String dataType, String operation, bool value) async {
    try {
      final privacyService = context.read<PrivacyService>();
      
      // Determine which setting to update based on operation
      if (operation == PrivacyService.operationLocalStorage) {
        await privacyService.updatePrivacySetting(
          dataType: dataType,
          allowLocalStorage: value,
        );
      } else if (operation == PrivacyService.operationCloudSync) {
        await privacyService.updatePrivacySetting(
          dataType: dataType,
          allowCloudSync: value,
        );
      } else if (operation == PrivacyService.operationSharing) {
        await privacyService.updatePrivacySetting(
          dataType: dataType,
          allowSharing: value,
        );
      } else if (operation == PrivacyService.operationAnalytics) {
        await privacyService.updatePrivacySetting(
          dataType: dataType,
          allowAnonymizedAnalytics: value,
        );
      }
    } catch (e) {
      // Show error snackbar
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to update setting: $e')),
        );
      }
    }
  }
  
  /// Builds the privacy policy section
  Widget _buildPrivacyPolicySection(BuildContext context) {
    return Card(
      margin: EdgeInsets.zero,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Privacy Policy',
              style: TextStyle(
                fontSize: 18, 
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 12),
            const Text(
              'Going50 respects your privacy and gives you full control over your data. '
              'We collect only the data you allow us to, and use it only in the ways you permit.',
              style: TextStyle(fontSize: 14),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () {
                    // TODO: Navigate to full privacy policy
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Privacy policy coming soon')),
                    );
                  },
                  child: const Text('READ FULL POLICY'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

################################################################################
FILE: lib/presentation/screens/profile/device_connection_screen.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:going50/obd_lib/models/bluetooth_device.dart';
import 'package:going50/presentation/providers/driving_provider.dart';
import 'package:going50/presentation/widgets/common/indicators/status_indicator.dart';
import 'package:going50/presentation/screens/profile/components/device_scanner.dart';
import 'package:going50/presentation/screens/profile/components/connection_manager.dart';
import 'package:going50/presentation/screens/profile/components/adapter_config.dart';

/// A screen for managing OBD device connections and adapter configuration.
class DeviceConnectionScreen extends StatefulWidget {
  /// Constructor
  const DeviceConnectionScreen({super.key});

  @override
  State<DeviceConnectionScreen> createState() => _DeviceConnectionScreenState();
}

class _DeviceConnectionScreenState extends State<DeviceConnectionScreen> {
  String? _errorMessage;
  int _currentStep = 0;
  
  @override
  void initState() {
    super.initState();
    
    // After the first frame is rendered, check if we need to show the scanner
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _setInitialStep();
    });
  }
  
  /// Sets the initial step based on connection status
  void _setInitialStep() {
    final drivingProvider = Provider.of<DrivingProvider>(context, listen: false);
    
    // If not connected, go directly to the scanner step
    if (!drivingProvider.isObdConnected && mounted) {
      setState(() {
        _currentStep = 1; // Device scanner step
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final drivingProvider = Provider.of<DrivingProvider>(context);
    final isConnected = drivingProvider.isObdConnected;

    return Scaffold(
      appBar: AppBar(
        title: const Text('OBD Connection'),
        elevation: 0,
      ),
      body: SafeArea(
        child: _buildContent(context, isConnected),
      ),
    );
  }

  /// Builds the main content of the screen
  Widget _buildContent(BuildContext context, bool isConnected) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Status card
          _buildStatusCard(context, isConnected),
          
          const SizedBox(height: 24),
          
          // Error message
          if (_errorMessage != null) ...[
            StatusIndicator(
              text: _errorMessage!,
              type: StatusType.error,
              icon: Icons.error_outline,
            ),
            const SizedBox(height: 24),
          ],
          
          // Connection steps
          _buildConnectionSteps(context, isConnected),
        ],
      ),
    );
  }

  /// Builds the connection status card
  Widget _buildStatusCard(BuildContext context, bool isConnected) {
    return Card(
      margin: EdgeInsets.zero,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Row(
          children: [
            Icon(
              isConnected ? Icons.bluetooth_connected : Icons.bluetooth_disabled,
              size: 36,
              color: isConnected
                  ? Theme.of(context).colorScheme.primary
                  : Theme.of(context).colorScheme.error,
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    isConnected ? 'Connected' : 'Not Connected',
                    style: Theme.of(context).textTheme.titleLarge?.copyWith(
                      color: isConnected
                          ? Theme.of(context).colorScheme.primary
                          : Theme.of(context).colorScheme.error,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    isConnected
                        ? 'Your OBD adapter is connected and ready to use'
                        : 'Scan for devices below to connect your OBD adapter',
                    style: Theme.of(context).textTheme.bodyMedium,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// Builds the connection steps
  Widget _buildConnectionSteps(BuildContext context, bool isConnected) {
    return Stepper(
      physics: const ClampingScrollPhysics(),
      currentStep: _currentStep,
      controlsBuilder: (context, details) {
        // No controls needed
        return const SizedBox.shrink();
      },
      onStepTapped: (step) {
        setState(() {
          _currentStep = step;
        });
      },
      steps: [
        // Step 1: Connection Status
        Step(
          title: const Text('Connection Status'),
          subtitle: Text(isConnected ? 'Connected' : 'Not Connected'),
          content: ConnectionManager(
            onDisconnected: () {
              setState(() {
                _currentStep = 1; // Go to device scanner step
              });
            },
          ),
          isActive: _currentStep == 0,
          state: _getStepState(0, isConnected),
        ),
        
        // Step 2: Device Scanner
        Step(
          title: const Text('Available Devices'),
          subtitle: const Text('Select a device to connect'),
          content: DeviceScanner(
            onDeviceSelected: (device) {
              _connectToDevice(device);
            },
          ),
          isActive: _currentStep == 1,
          state: _getStepState(1, isConnected),
        ),
        
        // Step 3: Adapter Configuration
        Step(
          title: const Text('Adapter Configuration'),
          subtitle: const Text('Advanced settings'),
          content: const AdapterConfig(),
          isActive: _currentStep == 2,
          state: _getStepState(2, isConnected),
        ),
      ],
    );
  }
  
  /// Gets the appropriate step state based on the step index and connection status
  StepState _getStepState(int stepIndex, bool isConnected) {
    if (stepIndex == 0 && isConnected) {
      return StepState.complete;
    } else if (stepIndex == 1 && !isConnected) {
      return StepState.indexed;
    } else {
      return StepState.indexed;
    }
  }

  /// Connects to the selected OBD device
  Future<void> _connectToDevice(BluetoothDevice device) async {
    final drivingProvider = Provider.of<DrivingProvider>(context, listen: false);
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final theme = Theme.of(context);
    
    setState(() {
      _errorMessage = null;
    });

    try {
      final success = await drivingProvider.connectToObdDevice(device.id);
      
      if (!mounted) return;
      
      if (success) {
        // Go to status step
        setState(() {
          _currentStep = 0;
        });
        
        // Show success snackbar
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text('Connected to ${device.name}'),
            backgroundColor: theme.colorScheme.primary,
          ),
        );
      } else {
        setState(() {
          _errorMessage = 'Failed to connect to device';
        });
      }
    } catch (e) {
      if (!mounted) return;
      
      setState(() {
        _errorMessage = 'Connection error: $e';
      });
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/profile/components/device_scanner.dart
################################################################################

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:going50/obd_lib/models/bluetooth_device.dart';
import 'package:going50/presentation/providers/driving_provider.dart';
import 'package:going50/presentation/widgets/common/indicators/status_indicator.dart';
import 'package:going50/presentation/widgets/common/buttons/primary_button.dart';

/// A widget that scans for OBD Bluetooth devices and displays them in a list.
class DeviceScanner extends StatefulWidget {
  /// Function called when a device is selected
  final Function(BluetoothDevice device) onDeviceSelected;

  /// Constructor
  const DeviceScanner({
    super.key,
    required this.onDeviceSelected,
  });

  @override
  State<DeviceScanner> createState() => _DeviceScannerState();
}

class _DeviceScannerState extends State<DeviceScanner> {
  bool _isScanning = false;
  List<BluetoothDevice> _devices = [];
  StreamSubscription? _scanSubscription;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    // Start scanning when the widget is first initialized
    _startScan();
  }

  @override
  void dispose() {
    // Cancel scan subscription when widget is disposed
    _scanSubscription?.cancel();
    super.dispose();
  }

  /// Start scanning for OBD devices
  void _startScan() {
    final drivingProvider = Provider.of<DrivingProvider>(context, listen: false);
    
    // Cancel any existing scan first
    _stopScan();
    
    setState(() {
      _isScanning = true;
      _errorMessage = null;
      _devices = [];
    });

    try {
      // Subscribe to device stream
      _scanSubscription = drivingProvider.scanForObdDevices().listen(
        (devices) {
          if (mounted) {
            setState(() {
              _devices = devices;
            });
          }
        },
        onError: (error) {
          if (mounted) {
            setState(() {
              _isScanning = false;
              _errorMessage = 'Failed to scan for devices: $error';
            });
          }
        },
        onDone: () {
          if (mounted) {
            setState(() {
              _isScanning = false;
            });
          }
        },
      );

      // Stop scan after 30 seconds if not already stopped
      Future.delayed(const Duration(seconds: 30), () {
        if (mounted && _isScanning) {
          _stopScan();
        }
      });
    } catch (e) {
      if (mounted) {
        setState(() {
          _isScanning = false;
          _errorMessage = 'Failed to scan for devices: $e';
        });
      }
    }
  }

  /// Stop scanning for OBD devices
  void _stopScan() {
    if (!_isScanning) return;
    
    setState(() {
      _isScanning = false;
    });

    // First cancel our subscription to prevent memory leaks
    _scanSubscription?.cancel();
    _scanSubscription = null;
    
    // Then tell the driving provider to stop scanning
    final drivingProvider = Provider.of<DrivingProvider>(context, listen: false);
    drivingProvider.stopScanningForDevices();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Status row
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Available Devices',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            if (_isScanning)
              StatusIndicator(
                text: 'Scanning...',
                type: StatusType.info,
                icon: Icons.search,
              ),
          ],
        ),
        
        const SizedBox(height: 16),
        
        // Error message
        if (_errorMessage != null) ...[
          StatusIndicator(
            text: _errorMessage!,
            type: StatusType.error,
            icon: Icons.error_outline,
          ),
          const SizedBox(height: 16),
        ],
        
        // Device list
        if (_devices.isEmpty && !_isScanning)
          const Padding(
            padding: EdgeInsets.symmetric(vertical: 32),
            child: Center(
              child: Text(
                'No devices found. Make sure your OBD adapter is powered on and in pairing mode.',
                textAlign: TextAlign.center,
              ),
            ),
          )
        else
          Container(
            decoration: BoxDecoration(
              border: Border.all(color: Colors.grey.shade300),
              borderRadius: BorderRadius.circular(8),
            ),
            child: ListView.separated(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: _devices.length,
              separatorBuilder: (context, index) => const Divider(height: 1),
              itemBuilder: (context, index) {
                final device = _devices[index];
                return ListTile(
                  leading: const Icon(Icons.bluetooth),
                  title: Text(device.name.isNotEmpty ? device.name : 'Unknown Device'),
                  subtitle: Text(device.id),
                  trailing: const Icon(Icons.chevron_right),
                  onTap: () {
                    widget.onDeviceSelected(device);
                  },
                );
              },
            ),
          ),
        
        const SizedBox(height: 20),
        
        // Scan button
        Center(
          child: PrimaryButton(
            text: _isScanning ? 'Stop Scan' : 'Scan for Devices',
            icon: _isScanning ? Icons.stop : Icons.search,
            onPressed: _isScanning ? _stopScan : _startScan,
          ),
        ),
      ],
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/profile/components/connection_manager.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:going50/obd_lib/models/bluetooth_device.dart';
import 'package:going50/presentation/providers/driving_provider.dart';
import 'package:going50/presentation/widgets/common/indicators/status_indicator.dart';
import 'package:going50/presentation/widgets/common/buttons/primary_button.dart';

/// A widget that manages the currently connected OBD device
/// and provides options to disconnect or reconnect.
class ConnectionManager extends StatefulWidget {
  /// Called when disconnection is successful
  final VoidCallback onDisconnected;

  /// Constructor
  const ConnectionManager({
    super.key,
    required this.onDisconnected,
  });

  @override
  State<ConnectionManager> createState() => _ConnectionManagerState();
}

class _ConnectionManagerState extends State<ConnectionManager> {
  bool _isDisconnecting = false;
  String? _errorMessage;
  BluetoothDevice? _connectedDevice;

  @override
  void initState() {
    super.initState();
    _updateConnectedDevice();
  }

  /// Updates the connected device information
  void _updateConnectedDevice() {
    final drivingProvider = Provider.of<DrivingProvider>(context, listen: false);
    
    // In a real implementation, we would query the connected device details
    // from the ObdConnectionService. For now, we'll use basic info.
    if (drivingProvider.isObdConnected) {
      setState(() {
        _connectedDevice = BluetoothDevice(
          id: 'unknown', // We don't have direct access to the device ID
          name: 'Connected OBD Device',
          rssi: 0,
        );
      });
    } else {
      setState(() {
        _connectedDevice = null;
      });
    }
  }

  /// Disconnects from the current OBD device
  Future<void> _disconnectDevice() async {
    final drivingProvider = Provider.of<DrivingProvider>(context, listen: false);
    
    setState(() {
      _isDisconnecting = true;
      _errorMessage = null;
    });

    try {
      await drivingProvider.disconnectObdDevice();
      
      setState(() {
        _isDisconnecting = false;
        _connectedDevice = null;
      });
      
      widget.onDisconnected();
    } catch (e) {
      setState(() {
        _isDisconnecting = false;
        _errorMessage = 'Failed to disconnect: $e';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final drivingProvider = Provider.of<DrivingProvider>(context);
    final isConnected = drivingProvider.isObdConnected;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Title
        Text(
          'Connected Device',
          style: Theme.of(context).textTheme.titleLarge,
        ),
        
        const SizedBox(height: 16),
        
        // Status
        if (isConnected && _connectedDevice != null) ...[
          _buildConnectedDeviceCard(),
        ] else ...[
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const StatusIndicator(
                text: 'No device connected',
                type: StatusType.inactive,
                icon: Icons.bluetooth_disabled,
              ),
              const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.secondary.withAlpha(20),
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(
                    color: Theme.of(context).colorScheme.secondary.withAlpha(40),
                  ),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.info_outline,
                      color: Theme.of(context).colorScheme.secondary,
                      size: 20,
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'Go to "Available Devices" below to scan and connect to your OBD adapter',
                        style: Theme.of(context).textTheme.bodyMedium,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ],
        
        // Error message
        if (_errorMessage != null) ...[
          const SizedBox(height: 16),
          StatusIndicator(
            text: _errorMessage!,
            type: StatusType.error,
            icon: Icons.error_outline,
          ),
        ],
      ],
    );
  }

  /// Builds the connected device card
  Widget _buildConnectedDeviceCard() {
    return Container(
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey.shade300),
        borderRadius: BorderRadius.circular(12),
        color: Theme.of(context).colorScheme.surface,
      ),
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Connection status
          Row(
            children: [
              StatusIndicator(
                text: 'Connected',
                type: StatusType.success,
                icon: Icons.bluetooth_connected,
              ),
              const Spacer(),
              if (_isDisconnecting)
                const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2),
                ),
            ],
          ),
          
          const SizedBox(height: 12),
          
          // Device info
          Row(
            children: [
              const Icon(Icons.bluetooth, size: 24),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      _connectedDevice?.name ?? 'Unknown Device',
                      style: Theme.of(context).textTheme.titleMedium,
                    ),
                    const SizedBox(height: 4),
                    Text(
                      _connectedDevice?.id ?? 'Unknown ID',
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Theme.of(context).textTheme.bodySmall?.color?.withAlpha(179),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          
          const SizedBox(height: 16),
          
          // Disconnect button
          PrimaryButton(
            text: 'Disconnect',
            icon: Icons.bluetooth_disabled,
            onPressed: _isDisconnecting ? null : _disconnectDevice,
          ),
        ],
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/profile/components/achievements_grid.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:going50/services/gamification/achievement_service.dart';
import 'package:going50/services/service_locator.dart';
import 'package:going50/services/user/user_service.dart';
import 'package:flutter/foundation.dart';
import 'package:provider/provider.dart';
import 'package:going50/presentation/providers/user_provider.dart';
import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/presentation/widgets/achievements/achievement_celebration.dart';
import 'dart:math' as math;

/// AchievementsGrid displays a grid of earned achievement badges
class AchievementsGrid extends StatefulWidget {
  /// Number of columns to display in the grid
  final int columns;
  
  /// Whether to show a "See All" button
  final bool showSeeAllButton;
  
  /// Callback when "See All" is pressed
  final VoidCallback? onSeeAllPressed;
  
  /// Constructor
  const AchievementsGrid({
    super.key, 
    this.columns = 3,
    this.showSeeAllButton = true,
    this.onSeeAllPressed,
  });

  @override
  State<AchievementsGrid> createState() => _AchievementsGridState();
}

class _AchievementsGridState extends State<AchievementsGrid> with TickerProviderStateMixin {
  final AchievementService _achievementService = serviceLocator<AchievementService>();
  final UserService _userService = serviceLocator<UserService>();
  
  // List to store user badges
  List<Map<String, dynamic>> _badges = [];
  // List to store all badges (earned and unearned) for quick view
  List<Map<String, dynamic>> _quickViewBadges = [];
  bool _isLoading = true;
  String? _errorMessage;
  bool _userInitialized = false; // Track if user is initialized
  
  // Animation controllers
  late AnimationController _shineController;
  Map<String, AnimationController> _unlockControllers = {};
  String? _recentlyUnlockedBadgeId;
  
  @override
  void initState() {
    super.initState();
    
    if (kDebugMode) {
      print('AchievementsGrid: Initializing');
    }
    
    // Initialize shine animation controller
    _shineController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    );
    
    // Initial load with a small delay to ensure services are ready
    Future.delayed(Duration(milliseconds: 500), () {
      if (mounted) {
        if (kDebugMode) {
          print('AchievementsGrid: Loading badges after delay');
        }
        _loadBadges();
      }
    });
    
    // Subscribe to achievement events to update the grid when new badges are earned
    _achievementService.achievementEventStream.listen((event) {
      if (kDebugMode) {
        print('AchievementsGrid: Achievement event received: ${event.badgeType}');
      }
      
      // Show celebration animation for the new badge
      _recentlyUnlockedBadgeId = '${event.badgeType}_${event.level}';
      
      // Force badge cache refresh by clearing the cache
      if (mounted) {
        if (kDebugMode) {
          print('AchievementsGrid: Reloading badges after achievement event');
        }
        
        // Short delay to ensure the badge is saved to the database
        Future.delayed(Duration(milliseconds: 300), () {
          if (mounted) {
            _loadBadges().then((_) {
              // Start celebration animation after badges are loaded
              _startUnlockAnimation(_recentlyUnlockedBadgeId!);
              
              // Show achievement celebration dialog
              _showAchievementCelebration(event);
            });
          }
        });
      }
    });
  }
  
  @override
  void dispose() {
    _shineController.dispose();
    // Dispose all unlock controllers
    for (final controller in _unlockControllers.values) {
      controller.dispose();
    }
    super.dispose();
  }
  
  /// Start unlock animation for a specific badge
  void _startUnlockAnimation(String badgeId) {
    // Create a controller if it doesn't exist
    if (!_unlockControllers.containsKey(badgeId)) {
      _unlockControllers[badgeId] = AnimationController(
        vsync: this,
        duration: const Duration(milliseconds: 1500),
      );
    }
    
    // Reset and start the animation
    _unlockControllers[badgeId]!.reset();
    _unlockControllers[badgeId]!.forward().then((_) {
      // After main animation completes, start shine animation
      _shineController.reset();
      _shineController.forward();
    });
  }
  
  /// Load badges from the achievement service
  Future<void> _loadBadges() async {
    if (_isLoading == false) {
      setState(() {
        _isLoading = true;
      });
    }
    
    try {
      // Get the current user ID from UserService
      final user = _userService.currentUser;
      
      if (user == null) {
        if (kDebugMode) {
          print('AchievementsGrid: No user found, trying to initialize UserService');
        }
        
        // No user found, initialize UserService
        await _userService.initialize();
        final currentUser = _userService.currentUser;
        
        if (currentUser != null && mounted) {
          // Load badges for current user
          final badges = await _achievementService.getUserBadges(currentUser.id);
          
          // Get all available badge types with progress
          final allBadgeTypes = _achievementService.getAvailableBadgeTypes();
          final quickViewBadges = await _prepareQuickViewBadges(currentUser.id, allBadgeTypes, badges);
          
          if (mounted) {
            setState(() {
              _badges = badges;
              _quickViewBadges = quickViewBadges;
              _isLoading = false;
              _errorMessage = null;
              _userInitialized = true;
            });
          }
        } else {
          if (mounted) {
            setState(() {
              _isLoading = false;
              _errorMessage = 'Failed to initialize user';
            });
          }
        }
      } else {
        if (kDebugMode) {
          print('AchievementsGrid: Loading badges for user ${user.id}');
        }
        
        // Load badges for the current user
        final badges = await _achievementService.getUserBadges(user.id);
        
        // Get all available badge types with progress
        final allBadgeTypes = _achievementService.getAvailableBadgeTypes();
        final quickViewBadges = await _prepareQuickViewBadges(user.id, allBadgeTypes, badges);
        
        if (mounted) {
          setState(() {
            _badges = badges;
            _quickViewBadges = quickViewBadges;
            _isLoading = false;
            _errorMessage = null;
            _userInitialized = true;
          });
        }
      }
    } catch (e) {
      if (kDebugMode) {
        print('AchievementsGrid: Error loading badges: $e');
      }
      
      if (mounted) {
        setState(() {
          _isLoading = false;
          _errorMessage = 'Failed to load achievements: $e';
        });
      }
    }
  }

  /// Prepare badges for quick view - a mix of earned and high-progress unearned badges
  Future<List<Map<String, dynamic>>> _prepareQuickViewBadges(
    String userId, 
    List<Map<String, dynamic>> allBadgeTypes,
    List<Map<String, dynamic>> earnedBadges
  ) async {
    final List<Map<String, dynamic>> result = [];
    
    // Get progress for unearned badges
    final progressBadges = <Map<String, dynamic>>[];
    
    // Find unearned badge types
    final earnedTypes = earnedBadges.map((b) => b['badgeType'] as String).toSet();
    final unearnedTypes = allBadgeTypes
        .where((b) => !earnedTypes.contains(b['badgeType']))
        .toList();
    
    // Create a list for all unearned badges - regardless of progress
    final allUnearnedBadges = <Map<String, dynamic>>[];
    
    // Process all unearned badge types
    for (final badgeType in unearnedTypes) {
      final type = badgeType['badgeType'] as String;
      final progress = await _achievementService.getBadgeProgress(userId, type);
      
      final badgeWithProgress = {
        ...badgeType,
        'progress': progress ?? 0.0,
        'earned': false,
      };
      
      // Add to all unearned badges
      allUnearnedBadges.add(badgeWithProgress);
      
      // Also add to progress badges if it has progress
      if (progress != null && progress > 0) {
        progressBadges.add(badgeWithProgress);
      }
    }
    
    // Sort by progress (highest first)
    progressBadges.sort((a, b) => 
      (b['progress'] as double).compareTo(a['progress'] as double)
    );
    
    // Sort all unearned badges by progress (highest first)
    allUnearnedBadges.sort((a, b) => 
      (b['progress'] as double).compareTo(a['progress'] as double)
    );
    
    // Add earned badges first (capped at 3 to ensure at least 3 unearned ones if possible)
    result.addAll(earnedBadges.take(3));
    
    // Add unearned badges with progress first
    if (progressBadges.isNotEmpty) {
      // How many spaces we have left in our 6-item grid
      final spacesLeft = 6 - result.length;
      // Add as many progress badges as we can fit
      result.addAll(progressBadges.take(spacesLeft));
    }
    
    // If we still have space and not enough badges yet, add more unearned badges
    if (result.length < 6) {
      // Add unearned badges that weren't already added (including those without progress)
      final alreadyAddedTypes = result.map((b) => b['badgeType'] as String).toSet();
      final remainingUnearned = allUnearnedBadges
          .where((b) => !alreadyAddedTypes.contains(b['badgeType']))
          .toList();
      
      result.addAll(remainingUnearned.take(6 - result.length));
    }
    
    // If we still have space and not enough badges yet, add more earned badges
    if (result.length < 6 && earnedBadges.length > 3) {
      final alreadyAddedEarnedTypes = result
          .where((b) => b.containsKey('earnedDate') || b['earned'] == true)
          .map((b) => b['badgeType'] as String)
          .toSet();
      
      final remainingEarned = earnedBadges
          .where((b) => !alreadyAddedEarnedTypes.contains(b['badgeType']))
          .toList();
      
      result.addAll(remainingEarned.take(6 - result.length));
    }
    
    // If we have fewer than 6 badges total (earned + unearned), just fill the grid with what we have
    if (result.length < 6 && result.length < (earnedBadges.length + allUnearnedBadges.length)) {
      if (kDebugMode) {
        print('AchievementsGrid: Unable to fill grid with 6 badges. Only ${result.length} available.');
      }
    }
    
    return result;
  }

  @override
  Widget build(BuildContext context) {
    // Show loading indicator while loading
    if (_isLoading) {
      return const Center(
        child: Padding(
          padding: EdgeInsets.all(16.0),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              CircularProgressIndicator(),
              SizedBox(height: 16),
              Text("Loading achievements..."),
            ],
          ),
        ),
      );
    }
    
    // Show error message if there was an error
    if (_errorMessage != null) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                _errorMessage!,
                style: const TextStyle(color: Colors.red),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: _loadBadges,
                child: const Text('Retry'),
              ),
            ],
          ),
        ),
      );
    }
    
    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: GridView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: widget.columns,
              crossAxisSpacing: 16,
              mainAxisSpacing: 16,
            ),
            // Use the mixed quick view badges instead of just earned ones
            itemCount: _quickViewBadges.length > 6 ? 6 : _quickViewBadges.length,
            itemBuilder: (context, index) {
              if (index < _quickViewBadges.length) {
                final badge = _quickViewBadges[index];
                return _buildBadgeItem(context, badge);
              } else {
                return _buildLockedBadge(context);
              }
            },
          ),
        ),
        
        // Always show the "See All" button if we have any badges (earned or in progress)
        if (widget.showSeeAllButton)
          Padding(
            padding: const EdgeInsets.only(top: 16),
            child: TextButton(
              onPressed: widget.onSeeAllPressed ?? () {
                _showAllAchievements(context);
              },
              child: Text(
                // Show the count of all available achievements
                'See All (${_achievementService.getAvailableBadgeTypes().length})',
                style: TextStyle(
                  color: Theme.of(context).primaryColor,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
      ],
    );
  }

  /// Build a badge item
  Widget _buildBadgeItem(BuildContext context, Map<String, dynamic> badge) {
    final bool isEarned = badge.containsKey('earnedDate') || (badge['earned'] == true) || 
        ((badge['progress'] as double?) ?? 0) >= 1.0; // Also check for 100% progress
    final double? progress = badge['progress'] as double?;
    final String badgeType = badge['badgeType'] as String;
    final int level = badge['level'] as int? ?? 1;
    final String badgeId = '${badgeType}_$level';
    
    // Check if this badge was recently unlocked
    final bool isRecentlyUnlocked = _recentlyUnlockedBadgeId == badgeId;
    
    // Create an animation controller for this badge if needed
    if (isRecentlyUnlocked && !_unlockControllers.containsKey(badgeId)) {
      _unlockControllers[badgeId] = AnimationController(
        vsync: this,
        duration: const Duration(milliseconds: 1500),
      )..forward();
    }
    
    return GestureDetector(
      onTap: () => _showBadgeDetails(context, badge),
      child: isRecentlyUnlocked && _unlockControllers.containsKey(badgeId) 
          ? _buildAnimatedBadge(context, badge, _unlockControllers[badgeId]!) 
          : _buildStaticBadge(context, badge),
    );
  }
  
  /// Build an animated badge when unlocked
  Widget _buildAnimatedBadge(BuildContext context, Map<String, dynamic> badge, AnimationController controller) {
    // Create animations
    final scaleAnimation = Tween<double>(begin: 1.0, end: 1.2).animate(
      CurvedAnimation(
        parent: controller,
        curve: Interval(0.0, 0.4, curve: Curves.easeOutBack),
      ),
    );
    
    final pulseAnimation = TweenSequence<double>([
      TweenSequenceItem(tween: Tween<double>(begin: 1.0, end: 1.2), weight: 1),
      TweenSequenceItem(tween: Tween<double>(begin: 1.2, end: 1.0), weight: 1),
    ]).animate(
      CurvedAnimation(
        parent: controller,
        curve: Interval(0.4, 0.7, curve: Curves.easeInOut),
      ),
    );
    
    final rotateAnimation = TweenSequence<double>([
      TweenSequenceItem(tween: Tween<double>(begin: 0, end: 0.08), weight: 1),
      TweenSequenceItem(tween: Tween<double>(begin: 0.08, end: -0.08), weight: 1),
      TweenSequenceItem(tween: Tween<double>(begin: -0.08, end: 0), weight: 1),
    ]).animate(
      CurvedAnimation(
        parent: controller,
        curve: Interval(0.3, 0.6, curve: Curves.easeInOut),
      ),
    );
    
    // Shine animation
    final shineAnimation = Tween<double>(begin: -1.0, end: 2.0).animate(
      CurvedAnimation(
        parent: _shineController,
        curve: Interval(0.0, 1.0, curve: Curves.easeInOut),
      ),
    );
    
    return AnimatedBuilder(
      animation: controller,
      builder: (context, child) {
        return Transform.scale(
          scale: controller.value < 0.4 
              ? scaleAnimation.value 
              : (controller.value < 0.7 ? pulseAnimation.value : 1.0),
          child: Transform.rotate(
            angle: rotateAnimation.value * math.pi,
            child: Stack(
              children: [
                // The badge content
                _buildStaticBadge(context, badge, isAnimating: true),
                
                // Shine effect with separate controller
                if (controller.value > 0.7)
                  AnimatedBuilder(
                    animation: _shineController,
                    builder: (context, _) {
                      return Positioned.fill(
                        child: ClipRRect(
                          borderRadius: BorderRadius.circular(12),
                          child: Transform.rotate(
                            angle: math.pi / 4, // 45 degrees
                            child: Transform.translate(
                              offset: Offset(
                                shineAnimation.value * 200,
                                0,
                              ),
                              child: Container(
                                width: 40,
                                decoration: BoxDecoration(
                                  gradient: LinearGradient(
                                    colors: [
                                      Colors.white.withOpacity(0),
                                      Colors.white.withOpacity(0.5),
                                      Colors.white.withOpacity(0),
                                    ],
                                    stops: const [0.0, 0.5, 1.0],
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ),
                      );
                    },
                  ),
                
                // Initial celebration particles
                if (controller.value < 0.4)
                  ...List.generate(8, (i) {
                    final angle = i * (math.pi / 4); // Evenly spaced around circle
                    final distance = 50 * controller.value; // Gradually move outward
                    final fadeOpacity = 1.0 - controller.value * 2.5; // Fade out
                    
                    return Positioned(
                      left: 50 + math.cos(angle) * distance,
                      top: 50 + math.sin(angle) * distance,
                      child: Opacity(
                        opacity: fadeOpacity > 0 ? fadeOpacity : 0,
                        child: Container(
                          width: 5,
                          height: 5,
                          decoration: BoxDecoration(
                            color: Theme.of(context).primaryColor,
                            shape: BoxShape.circle,
                          ),
                        ),
                      ),
                    );
                  }),
              ],
            ),
          ),
        );
      },
    );
  }
  
  /// Build a static badge (normal display)
  Widget _buildStaticBadge(BuildContext context, Map<String, dynamic> badge, {bool isAnimating = false}) {
    final bool isEarned = badge.containsKey('earnedDate') || (badge['earned'] == true) || 
        ((badge['progress'] as double?) ?? 0) >= 1.0; // Also check for 100% progress
    final double? progress = badge['progress'] as double?;
    
    // Enhanced visual distinction for earned badges - with better contrast
    final borderColor = isEarned 
        ? AppColors.ecoScoreHigh // Gold/green color for earned badges
        : Colors.grey.withOpacity(0.3);
        
    // Lighter background for better contrast with the green text/icon
    final backgroundColor = isEarned 
        ? AppColors.ecoScoreHigh.withOpacity(0.08) // Reduced opacity for better contrast
        : Colors.grey.withOpacity(0.1);
    
    final iconColor = isEarned
        ? AppColors.ecoScoreHigh // Vibrant icon color 
        : Colors.grey.withOpacity(0.7);
        
    final textColor = isEarned
        ? AppColors.ecoScoreHigh // Vibrant text color
        : Colors.grey.withOpacity(0.9);
    
    return Container(
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: borderColor,
          width: isEarned ? 2.5 : 1.0, // Thicker border for earned badges
        ),
        // Add a subtle shadow or glow for earned badges
        boxShadow: isEarned ? [
          BoxShadow(
            color: AppColors.ecoScoreHigh.withOpacity(isAnimating ? 0.4 : 0.2),
            blurRadius: isAnimating ? 10 : 6,
            spreadRadius: isAnimating ? 2 : 1,
          )
        ] : null,
      ),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // Badge icon with conditional styling
          Icon(
            _getBadgeIcon(badge['badgeType'] as String),
            size: 32,
            color: iconColor,
          ),
          
          const SizedBox(height: 8),
          
          // Badge name
          Text(
            badge['name'] as String? ?? 'Badge',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 12,
              fontWeight: isEarned ? FontWeight.bold : FontWeight.normal,
              color: textColor,
            ),
          ),
          
          // Display either progress or completion indicator
          if (!isEarned && progress != null && progress > 0) ...[
            const SizedBox(height: 8),
            SizedBox(
              width: 40,
              height: 4,
              child: ClipRRect(
                borderRadius: BorderRadius.circular(2),
                child: LinearProgressIndicator(
                  value: progress,
                  backgroundColor: Colors.grey.withOpacity(0.2),
                  valueColor: AlwaysStoppedAnimation<Color>(
                    Theme.of(context).primaryColor.withOpacity(0.7),
                  ),
                ),
              ),
            ),
            const SizedBox(height: 4),
            Text(
              '${(progress * 100).toInt()}%',
              style: TextStyle(
                fontSize: 10,
                color: Colors.grey.withOpacity(0.9),
              ),
            ),
          ] else if (isEarned) ...[
            // Show "Completed" indicator for earned badges
            const SizedBox(height: 8),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
              decoration: BoxDecoration(
                color: AppColors.ecoScoreHigh.withOpacity(0.15),
                borderRadius: BorderRadius.circular(8),
                border: Border.all(
                  color: AppColors.ecoScoreHigh.withOpacity(0.3),
                ),
              ),
              child: Text(
                '100%',
                style: TextStyle(
                  fontSize: 10,
                  fontWeight: FontWeight.bold,
                  color: AppColors.ecoScoreHigh,
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  /// Build a locked badge
  Widget _buildLockedBadge(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.grey.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: Colors.grey.withOpacity(0.3),
        ),
      ),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.lock_outline,
            size: 24,
            color: Colors.grey.withOpacity(0.5),
          ),
          const SizedBox(height: 8),
          Text(
            'Locked',
            style: TextStyle(
              fontSize: 12,
              color: Colors.grey.withOpacity(0.7),
            ),
          ),
        ],
      ),
    );
  }
  
  /// Get icon for a badge type
  IconData _getBadgeIcon(String badgeType) {
    switch (badgeType) {
      case 'smooth_driver':
        return Icons.rowing;
      case 'eco_warrior':
        return Icons.eco;
      case 'fuel_saver':
        return Icons.local_gas_station;
      case 'carbon_reducer':
        return Icons.co2;
      case 'road_veteran':
        return Icons.map;
      case 'speed_master':
        return Icons.speed;
      case 'eco_expert':
        return Icons.auto_graph;
      case 'fuel_efficiency':
        return Icons.trending_up;
      case 'consistent_driver':
        return Icons.repeat;
      case 'early_adopter':
        return Icons.star;
      default:
        return Icons.emoji_events;
    }
  }
  
  /// Show all achievements in a dialog
  void _showAllAchievements(BuildContext context) {
    // Get current user ID for loading badge progress
    final userId = _userService.currentUser?.id;
    
    if (userId == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('User not found. Please try again.')),
      );
      return;
    }
    
    showDialog(
      context: context,
      builder: (context) => Dialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        // Make the dialog larger to avoid horizontal squashing
        insetPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 48.0),
        child: Container(
          width: MediaQuery.of(context).size.width * 0.9, // Occupy 90% of screen width
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text(
                    'All Achievements',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close),
                    onPressed: () => Navigator.of(context).pop(),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              // Use less columns in the expanded view for better spacing
              Expanded(
                child: FutureBuilder<List<Map<String, dynamic>>>(
                  future: _buildAllAchievementsList(userId.toString()),
                  builder: (context, snapshot) {
                    if (snapshot.connectionState == ConnectionState.waiting) {
                      return const Center(child: CircularProgressIndicator());
                    }
                    
                    if (snapshot.hasError) {
                      return Center(
                        child: Text('Error loading achievements: ${snapshot.error}'),
                      );
                    }
                    
                    final allBadges = snapshot.data ?? [];
                    
                    return GridView.builder(
                      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                        crossAxisCount: 2, // Reduced from 3 to 2 for better spacing
                        crossAxisSpacing: 16, // Increased from 12 to 16
                        mainAxisSpacing: 16, // Increased from 12 to 16
                        childAspectRatio: 1.0, // Adjusted for better proportions
                      ),
                      itemCount: allBadges.length,
                      itemBuilder: (context, index) {
                        return _buildBadgeItem(context, allBadges[index]);
                      },
                    );
                  },
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  /// Build a list of all achievements (earned and unearned)
  Future<List<Map<String, dynamic>>> _buildAllAchievementsList(String userId) async {
    final List<Map<String, dynamic>> result = [];
    
    // Get all badge types
    final allBadgeTypes = _achievementService.getAvailableBadgeTypes();
    
    // Map of earned badges by type
    final earnedBadgesByType = {
      for (var badge in _badges) 
        badge['badgeType'] as String: badge
    };
    
    // Process each available badge type
    for (final badgeType in allBadgeTypes) {
      final type = badgeType['badgeType'] as String;
      
      // If earned, add the earned badge
      if (earnedBadgesByType.containsKey(type)) {
        result.add(earnedBadgesByType[type]!);
      } else {
        // Otherwise, add unearned badge with progress
        final progress = await _achievementService.getBadgeProgress(userId, type);
        result.add({
          ...badgeType,
          'level': 1, // Default to level 1 for unearned
          'progress': progress ?? 0.0,
          'earned': false,
        });
      }
    }
    
    // Sort with earned badges first, then by progress
    result.sort((a, b) {
      final aEarned = a.containsKey('earnedDate') || (a['earned'] == true);
      final bEarned = b.containsKey('earnedDate') || (b['earned'] == true);
      
      if (aEarned && !bEarned) return -1;
      if (!aEarned && bEarned) return 1;
      
      // Both earned or both unearned - sort by progress
      final aProgress = a['progress'] as double? ?? 0.0;
      final bProgress = b['progress'] as double? ?? 0.0;
      
      return bProgress.compareTo(aProgress);
    });
    
    return result;
  }
  
  /// Show badge details in a dialog
  void _showBadgeDetails(BuildContext context, Map<String, dynamic> badge) {
    // Use the same isEarned logic as in _buildStaticBadge for consistency
    final bool isEarned = badge.containsKey('earnedDate') || (badge['earned'] == true) ||
        ((badge['progress'] as double?) ?? 0) >= 1.0;
    
    showDialog(
      context: context,
      builder: (context) => Dialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(20),
        ),
        child: Container(
          padding: const EdgeInsets.all(20),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(20),
            border: isEarned ? Border.all(
              color: AppColors.ecoScoreHigh.withOpacity(0.7),
              width: 2,
            ) : null,
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              // Badge icon with special styling
              Container(
                width: 100,
                height: 100,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isEarned 
                      ? AppColors.ecoScoreHigh.withOpacity(0.1) // Reduced opacity for better contrast
                      : Colors.grey.withOpacity(0.1),
                  boxShadow: isEarned ? [
                    BoxShadow(
                      color: AppColors.ecoScoreHigh.withOpacity(0.2), // Reduced opacity
                      blurRadius: 12,
                      spreadRadius: 2,
                    )
                  ] : null,
                  border: Border.all(
                    color: isEarned 
                        ? AppColors.ecoScoreHigh.withOpacity(0.7)
                        : Colors.grey.withOpacity(0.3),
                    width: isEarned ? 2 : 1,
                  ),
                ),
                child: Center(
                  child: Icon(
                    _getBadgeIcon(badge['badgeType'] as String),
                    size: 64,
                    color: isEarned 
                        ? AppColors.ecoScoreHigh
                        : Colors.grey.withOpacity(0.7),
                  ),
                ),
              ),
              
              const SizedBox(height: 20),
              
              // Status indicator
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
                decoration: BoxDecoration(
                  color: isEarned
                      ? AppColors.ecoScoreHigh.withOpacity(0.1) // Reduced opacity
                      : Colors.grey.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(20),
                  border: Border.all(
                    color: isEarned
                        ? AppColors.ecoScoreHigh.withOpacity(0.7)
                        : Colors.grey.withOpacity(0.3),
                    width: isEarned ? 2 : 1,
                  ),
                ),
                child: Text(
                  isEarned ? 'ACHIEVED' : 'IN PROGRESS',
                  style: TextStyle(
                    color: isEarned
                        ? AppColors.ecoScoreHigh
                        : Colors.grey.withOpacity(0.9),
                    fontWeight: FontWeight.bold,
                    fontSize: 14,
                  ),
                ),
              ),
              
              const SizedBox(height: 20),
              
              // Badge name
              Text(
                badge['name'] as String,
                style: TextStyle(
                  fontSize: 22,
                  fontWeight: FontWeight.bold,
                  color: isEarned
                      ? Theme.of(context).primaryColor
                      : Theme.of(context).textTheme.titleLarge?.color,
                ),
                textAlign: TextAlign.center,
              ),
              
              const SizedBox(height: 8),
              
              // Badge description
              Text(
                badge['description'] as String? ?? 'No description available',
                style: TextStyle(
                  fontSize: 16,
                  color: Theme.of(context).textTheme.bodyLarge?.color?.withOpacity(0.8),
                ),
                textAlign: TextAlign.center,
              ),
              
              const SizedBox(height: 16),
              
              // Progress indicator for unearned badges
              if (!isEarned && badge.containsKey('progress')) ...[
                const SizedBox(height: 8),
                
                // Progress percentage
                Text(
                  'Progress: ${((badge['progress'] as double) * 100).toInt()}%',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                    color: Theme.of(context).textTheme.bodyLarge?.color,
                  ),
                ),
                
                const SizedBox(height: 8),
                
                // Progress bar
                ClipRRect(
                  borderRadius: BorderRadius.circular(10),
                  child: SizedBox(
                    height: 10,
                    width: double.infinity,
                    child: LinearProgressIndicator(
                      value: badge['progress'] as double,
                      backgroundColor: Colors.grey.withOpacity(0.2),
                      valueColor: AlwaysStoppedAnimation<Color>(
                        Theme.of(context).primaryColor,
                      ),
                    ),
                  ),
                ),
              ],
              
              if (isEarned && badge.containsKey('earnedDate')) ...[
                const SizedBox(height: 16),
                Text(
                  'Earned on: ${_formatEarnedDate(badge['earnedDate'])}',
                  style: TextStyle(
                    fontSize: 14,
                    color: Theme.of(context).textTheme.bodySmall?.color,
                    fontStyle: FontStyle.italic,
                  ),
                ),
              ],
              
              const SizedBox(height: 20),
              
              // Close button
              ElevatedButton(
                onPressed: () => Navigator.of(context).pop(),
                style: ElevatedButton.styleFrom(
                  backgroundColor: isEarned 
                      ? AppColors.ecoScoreHigh
                      : Theme.of(context).primaryColor,
                  foregroundColor: Colors.white,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(20),
                  ),
                ),
                child: const Padding(
                  padding: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  child: Text('Close'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  /// Format earned date for display
  String _formatEarnedDate(dynamic date) {
    if (date == null) return 'Unknown date';
    
    if (date is DateTime) {
      return '${date.day}/${date.month}/${date.year}';
    } else if (date is String) {
      try {
        final parsedDate = DateTime.parse(date);
        return '${parsedDate.day}/${parsedDate.month}/${parsedDate.year}';
      } catch (e) {
        return date; // Return the original string if parsing fails
      }
    }
    
    return 'Unknown date';
  }

  /// Show the achievement celebration dialog
  void _showAchievementCelebration(AchievementEvent event) {
    // Show celebration only if we're visible
    if (mounted && ModalRoute.of(context)?.isCurrent == true) {
      showAchievementCelebration(
        context,
        title: "${event.badgeName} - Level ${event.level}",
        description: event.badgeDescription,
        icon: _getBadgeIcon(event.badgeType),
        onDismiss: () {
          // Nothing special to do on dismiss
        },
      );
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/profile/components/settings_section.dart
################################################################################

import 'package:flutter/material.dart';

/// A settings section component for use in the settings screen.
///
/// This component groups related settings items under a common header.
class SettingsSection extends StatelessWidget {
  /// The title of the settings section.
  final String title;

  /// The list of widgets to display in this section.
  final List<Widget> children;

  /// The margin around the section.
  final EdgeInsets margin;

  /// The background color of the section.
  final Color? backgroundColor;

  /// Whether to show a divider after the section.
  final bool showDivider;

  /// Constructor for the settings section.
  const SettingsSection({
    super.key,
    required this.title,
    required this.children,
    this.margin = const EdgeInsets.only(bottom: 24),
    this.backgroundColor,
    this.showDivider = false,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: margin,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Section header
          Padding(
            padding: const EdgeInsets.only(left: 16, right: 16, bottom: 8, top: 16),
            child: Text(
              title,
              style: Theme.of(context).textTheme.titleSmall?.copyWith(
                    color: Theme.of(context).colorScheme.primary,
                    fontWeight: FontWeight.bold,
                  ),
            ),
          ),
          
          // Section content
          Container(
            decoration: BoxDecoration(
              color: backgroundColor ?? Theme.of(context).cardTheme.color,
              borderRadius: BorderRadius.circular(8),
            ),
            margin: const EdgeInsets.symmetric(horizontal: 16),
            child: Column(
              children: children,
            ),
          ),
          
          // Optional section divider
          if (showDivider)
            const Divider(
              height: 32,
              thickness: 1,
            ),
        ],
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/profile/components/settings_item.dart
################################################################################

import 'package:flutter/material.dart';

/// A settings item component for use in the settings screen.
///
/// This component displays a single settings option with a title,
/// optional subtitle, optional icon, and optional trailing widget.
class SettingsItem extends StatelessWidget {
  /// The title of the settings item.
  final String title;

  /// The optional subtitle/description text.
  final String? subtitle;

  /// The optional leading icon.
  final IconData? icon;

  /// The optional trailing widget (e.g., toggle, arrow).
  final Widget? trailing;

  /// The callback function when the item is tapped.
  final VoidCallback? onTap;

  /// The background color of the settings item.
  final Color? backgroundColor;

  /// Whether to show a divider after this item.
  final bool showDivider;

  /// Constructor for the settings item.
  const SettingsItem({
    super.key,
    required this.title,
    this.subtitle,
    this.icon,
    this.trailing,
    this.onTap,
    this.backgroundColor,
    this.showDivider = true,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        InkWell(
          onTap: onTap,
          child: Container(
            color: backgroundColor,
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
            child: Row(
              children: [
                if (icon != null) ...[
                  Icon(
                    icon,
                    color: Theme.of(context).colorScheme.primary,
                    size: 24,
                  ),
                  const SizedBox(width: 16),
                ],
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        title,
                        style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                              fontWeight: FontWeight.w500,
                            ),
                      ),
                      if (subtitle != null) ...[
                        const SizedBox(height: 4),
                        Text(
                          subtitle!,
                          style: Theme.of(context).textTheme.bodySmall?.copyWith(
                                color: Theme.of(context).textTheme.bodySmall?.color?.withOpacity(0.7),
                              ),
                        ),
                      ],
                    ],
                  ),
                ),
                if (trailing != null) trailing!,
              ],
            ),
          ),
        ),
        if (showDivider)
          const Divider(
            height: 1,
            indent: 16,
            endIndent: 16,
          ),
      ],
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/profile/components/adapter_config.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:going50/services/driving/obd_connection_service.dart';
import 'package:going50/services/service_locator.dart';
import 'package:going50/obd_lib/test/obd_field_test.dart';
import 'package:going50/obd_lib/obd_service.dart';

/// A widget that allows configuration of the OBD adapter settings.
class AdapterConfig extends StatefulWidget {
  /// Constructor
  const AdapterConfig({super.key});

  @override
  State<AdapterConfig> createState() => _AdapterConfigState();
}

class _AdapterConfigState extends State<AdapterConfig> {
  late ObdConnectionService _obdService;
  List<Map<String, String>> _availableProfiles = [];
  String? _selectedProfileId;
  bool _isAutoDetectionEnabled = true;
  bool _isAdapterConnected = false;

  @override
  void initState() {
    super.initState();
    _obdService = serviceLocator<ObdConnectionService>();
    _loadProfiles();
    _checkAdapterConnection();
  }

  /// Loads the available adapter profiles
  void _loadProfiles() {
    try {
      setState(() {
        _availableProfiles = _obdService.getAvailableProfiles();
        // Initially use automatic detection 
        _selectedProfileId = null;
        _isAutoDetectionEnabled = true;
      });
    } catch (e) {
      // Handle error
      debugPrint('Error loading profiles: $e');
    }
  }

  /// Check if an adapter is currently connected
  void _checkAdapterConnection() {
    setState(() {
      _isAdapterConnected = _obdService.isConnected;
    });
  }

  /// Sets the selected adapter profile
  void _setProfile(String? profileId) {
    if (profileId == null) {
      _obdService.enableAutomaticProfileDetection();
      setState(() {
        _selectedProfileId = null;
        _isAutoDetectionEnabled = true;
      });
    } else {
      _obdService.setAdapterProfile(profileId);
      setState(() {
        _selectedProfileId = profileId;
        _isAutoDetectionEnabled = false;
      });
    }
  }

  /// Navigate to adapter test screen
  void _navigateToAdapterTest() {
    final obdService = serviceLocator<ObdService>();
    final deviceId = _obdService.currentDeviceId;
    
    if (deviceId == null || deviceId.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('No adapter connected. Please connect an adapter first.')),
      );
      return;
    }
    
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => ObdFieldTestScreen(
          obdService: obdService,
          deviceId: deviceId,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Title
        Text(
          'Adapter Configuration',
          style: Theme.of(context).textTheme.titleLarge,
        ),
        
        const SizedBox(height: 16),
        
        // Info text
        Text(
          'Configure advanced settings for your OBD adapter. In most cases, automatic detection works best.',
          style: Theme.of(context).textTheme.bodyMedium,
        ),
        
        const SizedBox(height: 24),
        
        // Automatic detection option
        _buildProfileOption(
          context, 
          null, 
          'Automatic Detection (Recommended)',
          'The app will automatically detect and use the best protocol for your adapter.',
        ),
        
        const Divider(height: 32),
        
        // Manual profile selection heading
        Text(
          'Manual Profile Selection',
          style: Theme.of(context).textTheme.titleMedium,
        ),
        
        const SizedBox(height: 12),
        
        // Available profiles
        ..._availableProfiles.map((profile) => _buildProfileOption(
          context,
          profile['id'],
          profile['name'] ?? 'Unknown Profile',
          profile['description'] ?? 'No description available',
        )),
        
        if (_availableProfiles.isEmpty)
          const Padding(
            padding: EdgeInsets.symmetric(vertical: 16),
            child: Text(
              'No profiles available. Connect an OBD device first to see available profiles.',
              style: TextStyle(fontStyle: FontStyle.italic),
            ),
          ),
          
        // Add a divider and test adapter section
        const Divider(height: 32),
        
        // Adapter test section
        Text(
          'Adapter Testing',
          style: Theme.of(context).textTheme.titleMedium,
        ),
        
        const SizedBox(height: 12),
        
        Text(
          'Test your OBD adapter connection quality, performance, and reliability.',
          style: Theme.of(context).textTheme.bodyMedium,
        ),
        
        const SizedBox(height: 16),
        
        ElevatedButton.icon(
          onPressed: _isAdapterConnected ? _navigateToAdapterTest : null,
          icon: const Icon(Icons.speed),
          label: const Text('TEST ADAPTER PERFORMANCE'),
          style: ElevatedButton.styleFrom(
            minimumSize: const Size.fromHeight(44),
          ),
        ),
        
        if (!_isAdapterConnected)
          const Padding(
            padding: EdgeInsets.only(top: 8),
            child: Text(
              'Connect an OBD adapter first to run tests.',
              style: TextStyle(
                fontStyle: FontStyle.italic,
                color: Colors.grey,
                fontSize: 12,
              ),
            ),
          ),
      ],
    );
  }

  /// Builds a profile option card
  Widget _buildProfileOption(
    BuildContext context,
    String? profileId,
    String title,
    String description,
  ) {
    final isSelected = (profileId == null && _isAutoDetectionEnabled) || 
                       (profileId != null && profileId == _selectedProfileId);
    
    return InkWell(
      onTap: () => _setProfile(profileId),
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: isSelected 
                ? Theme.of(context).colorScheme.primary 
                : Colors.grey.shade300,
            width: isSelected ? 2 : 1,
          ),
          color: isSelected 
              ? Theme.of(context).colorScheme.primary.withAlpha(26)
              : Colors.transparent,
        ),
        child: Row(
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: Theme.of(context).textTheme.titleSmall?.copyWith(
                      fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    description,
                    style: Theme.of(context).textTheme.bodySmall,
                  ),
                ],
              ),
            ),
            Radio<String?>(
              value: profileId,
              groupValue: _selectedProfileId,
              onChanged: (value) => _setProfile(value),
              activeColor: Theme.of(context).colorScheme.primary,
            ),
          ],
        ),
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/profile/components/profile_header.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:going50/presentation/providers/user_provider.dart';
import 'package:going50/core_models/user_profile.dart';
import 'package:going50/presentation/providers/insights_provider.dart';

/// ProfileHeader displays the user's profile information and overall eco-driving level
class ProfileHeader extends StatelessWidget {
  /// Constructor
  const ProfileHeader({super.key});

  @override
  Widget build(BuildContext context) {
    final userProvider = Provider.of<UserProvider>(context);
    final insightsProvider = Provider.of<InsightsProvider>(context);
    final UserProfile? profile = userProvider.userProfile;
    
    // Overall eco-score (from insights provider)
    final overallScore = insightsProvider.currentMetrics?.overallEcoScore ?? 0;
    final driverLevel = _getDriverLevelFromScore(overallScore.toDouble());
    
    return Column(
      children: [
        // Avatar
        CircleAvatar(
          radius: 50,
          backgroundColor: Theme.of(context).primaryColor,
          child: Icon(
            profile != null && !userProvider.isAnonymous
                ? Icons.person
                : Icons.person_outline,
            size: 50,
            color: Colors.white,
          ),
        ),
        
        const SizedBox(height: 16),
        
        // User name
        Text(
          profile?.name ?? 'Anonymous User',
          style: const TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
        ),
        
        const SizedBox(height: 8),
        
        // Eco-driver level badge
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
          decoration: BoxDecoration(
            color: Theme.of(context).primaryColor.withOpacity(0.1),
            borderRadius: BorderRadius.circular(16),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                Icons.eco,
                size: 16,
                color: Theme.of(context).primaryColor,
              ),
              const SizedBox(width: 4),
              Text(
                driverLevel,
                style: TextStyle(
                  fontSize: 14,
                  color: Theme.of(context).primaryColor,
                ),
              ),
            ],
          ),
        ),
        
        const SizedBox(height: 16),
        
        // Progress bar for eco-score
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 32),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    'Eco-Driving Score',
                    style: TextStyle(
                      fontSize: 14,
                      color: Colors.grey[600],
                    ),
                  ),
                  Text(
                    '$overallScore',
                    style: TextStyle(
                      fontSize: 14,
                      fontWeight: FontWeight.bold,
                      color: _getColorForScore(overallScore.toDouble()),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 4),
              LinearProgressIndicator(
                value: overallScore / 100,
                backgroundColor: Colors.grey[200],
                valueColor: AlwaysStoppedAnimation<Color>(
                  _getColorForScore(overallScore.toDouble()),
                ),
                minHeight: 8,
                borderRadius: BorderRadius.circular(4),
              ),
            ],
          ),
        ),
        
        const SizedBox(height: 16),
        
        // Total impact statistics
        Container(
          margin: const EdgeInsets.symmetric(horizontal: 16),
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Colors.grey[50],
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: Colors.grey.withOpacity(0.2)),
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: [
              _buildImpactStat(
                context,
                Icons.local_gas_station,
                '${(insightsProvider.fuelSavings).toStringAsFixed(1)} L',
                'Fuel Saved'
              ),
              _buildImpactStat(
                context,
                Icons.co2,
                '${(insightsProvider.co2Reduction).toStringAsFixed(1)} kg',
                'CO₂ Reduced'
              ),
              _buildImpactStat(
                context,
                Icons.attach_money,
                '\$${(insightsProvider.moneySavings).toStringAsFixed(1)}',
                'Money Saved'
              ),
            ],
          ),
        ),
        
        // Edit button (only for non-anonymous users)
        if (!userProvider.isAnonymous)
          Padding(
            padding: const EdgeInsets.only(top: 16),
            child: TextButton.icon(
              onPressed: () {
                // TODO: Navigate to profile edit screen
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Profile editing not yet implemented'),
                  ),
                );
              },
              icon: const Icon(Icons.edit, size: 16),
              label: const Text('Edit Profile'),
              style: TextButton.styleFrom(
                foregroundColor: Theme.of(context).primaryColor,
              ),
            ),
          )
        else
          Padding(
            padding: const EdgeInsets.only(top: 16),
            child: TextButton.icon(
              onPressed: () {
                // TODO: Navigate to account creation
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Account creation not yet implemented'),
                  ),
                );
              },
              icon: const Icon(Icons.person_add, size: 16),
              label: const Text('Create Account'),
              style: TextButton.styleFrom(
                foregroundColor: Theme.of(context).primaryColor,
              ),
            ),
          ),
      ],
    );
  }
  
  /// Builds an impact statistic item
  Widget _buildImpactStat(BuildContext context, IconData icon, String value, String label) {
    return Column(
      children: [
        Icon(
          icon,
          color: Theme.of(context).primaryColor,
          size: 20,
        ),
        const SizedBox(height: 8),
        Text(
          value,
          style: const TextStyle(
            fontWeight: FontWeight.bold,
            fontSize: 14,
          ),
        ),
        const SizedBox(height: 4),
        Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: Colors.grey[600],
          ),
        ),
      ],
    );
  }
  
  /// Returns a user-friendly driver level based on eco-score
  String _getDriverLevelFromScore(double score) {
    if (score < 20) return 'Eco-Driving Beginner';
    if (score < 40) return 'Eco-Driving Novice';
    if (score < 60) return 'Eco-Driving Apprentice';
    if (score < 80) return 'Eco-Driving Pro';
    return 'Eco-Driving Master';
  }
  
  /// Returns an appropriate color based on the eco-score
  Color _getColorForScore(double score) {
    if (score < 40) return Colors.red;
    if (score < 70) return Colors.orange;
    return Colors.green;
  }
} 

################################################################################
FILE: lib/presentation/screens/profile/components/statistics_summary.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:going50/presentation/providers/insights_provider.dart';
import 'package:going50/services/driving/trip_service.dart';
import 'package:going50/services/service_locator.dart';
import 'package:going50/services/user/user_service.dart';

/// StatisticsSummary displays key user statistics and personal records
class StatisticsSummary extends StatelessWidget {
  /// Constructor
  const StatisticsSummary({super.key});

  @override
  Widget build(BuildContext context) {
    final insightsProvider = Provider.of<InsightsProvider>(context);
    final currentMetrics = insightsProvider.currentMetrics;
    
    // Get statistics from the metrics
    final totalTrips = currentMetrics?.totalTrips ?? 0;
    final totalDistance = currentMetrics?.totalDistanceKm ?? 0;
    final totalDrivingTime = currentMetrics?.totalDrivingTimeMinutes ?? 0;
    final fuelSaved = insightsProvider.fuelSavings;
    final moneySaved = insightsProvider.moneySavings;
    final co2Reduced = insightsProvider.co2Reduction;
    
    return Column(
      children: [
        // Key statistics section
        _buildSection(
          context, 
          'Key Statistics',
          [
            _buildStatisticItem(
              context,
              Icons.track_changes,
              totalTrips.toString(),
              'Total Trips'
            ),
            _buildStatisticItem(
              context,
              Icons.route,
              '${totalDistance.toStringAsFixed(1)} km',
              'Distance Driven'
            ),
            _buildStatisticItem(
              context,
              Icons.timer,
              _formatDrivingTime(totalDrivingTime),
              'Driving Time'
            ),
            _buildStatisticItem(
              context,
              Icons.local_gas_station,
              '${fuelSaved.toStringAsFixed(1)} L',
              'Fuel Saved'
            ),
            _buildStatisticItem(
              context,
              Icons.attach_money,
              '\$${moneySaved.toStringAsFixed(1)}',
              'Money Saved'
            ),
            _buildStatisticItem(
              context,
              Icons.co2,
              '${co2Reduced.toStringAsFixed(1)} kg',
              'CO₂ Reduced'
            ),
          ],
        ),
        
        const SizedBox(height: 16),
        
        // Personal records section
        _buildSection(
          context, 
          'Personal Records',
          [
            _buildStatisticItem(
              context,
              Icons.star,
              (currentMetrics?.overallEcoScore ?? 0).toString(),
              'Best Eco-Score'
            ),
            FutureBuilder<double>(
              future: _getLongestTrip(),
              builder: (context, snapshot) {
                final longestTripDistance = snapshot.hasData 
                    ? snapshot.data!
                    : 0.0;
                
                return _buildStatisticItem(
                  context,
                  Icons.social_distance,
                  '${longestTripDistance.toStringAsFixed(1)} km',
                  'Longest Trip'
                );
              },
            ),
            FutureBuilder<String>(
              future: _getBestDrivingStreak(),
              builder: (context, snapshot) {
                final streakText = snapshot.hasData 
                    ? snapshot.data!
                    : '0 days';
                
                return _buildStatisticItem(
                  context,
                  Icons.speed,
                  streakText,
                  'Best Streak'
                );
              },
            ),
          ],
        ),
      ],
    );
  }
  
  /// Builds a section with title and list of statistics
  Widget _buildSection(BuildContext context, String title, List<Widget> items) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Text(
            title,
            style: const TextStyle(
              fontWeight: FontWeight.bold,
              fontSize: 16,
            ),
          ),
        ),
        const SizedBox(height: 8),
        ...items,
      ],
    );
  }
  
  /// Builds a single statistic item with icon, value, and label
  Widget _buildStatisticItem(BuildContext context, IconData icon, String value, String label) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Row(
        children: [
          Icon(
            icon,
            size: 20,
            color: Theme.of(context).primaryColor,
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Text(
              label,
              style: TextStyle(
                fontSize: 14,
                color: Colors.grey[600],
              ),
            ),
          ),
          Text(
            value,
            style: const TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.bold,
            ),
          ),
        ],
      ),
    );
  }
  
  /// Formats driving time into a human-readable string
  String _formatDrivingTime(double minutes) {
    final hours = (minutes / 60).floor();
    final remainingMinutes = (minutes % 60).floor();
    
    if (hours > 0) {
      return '$hours hr ${remainingMinutes > 0 ? '$remainingMinutes min' : ''}';
    } else {
      return '$remainingMinutes min';
    }
  }
  
  /// Gets the longest trip distance based on actual trip data
  Future<double> _getLongestTrip() async {
    // Get the trip service from the service locator
    final tripService = serviceLocator<TripService>();
    final userService = serviceLocator<UserService>();
    
    try {
      // Get the current user ID
      final userId = userService.currentUser?.id;
      if (userId == null) return 0.0;
      
      // Get all trips from the service
      final trips = await tripService.getTripHistory();
      
      // Filter for the current user's completed trips
      final userTrips = trips.where((trip) => 
        trip.userId == userId && 
        trip.isCompleted == true &&
        trip.distanceKm != null).toList();
      
      if (userTrips.isEmpty) return 0.0;
      
      // Find the trip with the maximum distance
      double maxDistance = 0.0;
      for (final trip in userTrips) {
        if (trip.distanceKm != null && trip.distanceKm! > maxDistance) {
          maxDistance = trip.distanceKm!;
        }
      }
      
      return maxDistance;
    } catch (e) {
      // Return 0 on error
      return 0.0;
    }
  }
  
  /// Gets the best driving streak based on streak data
  Future<String> _getBestDrivingStreak() async {
    // Get user service from the service locator
    final userService = serviceLocator<UserService>();
    
    try {
      // Get the current user
      final userId = userService.currentUser?.id;
      if (userId == null) return '0 days';
      
      // Get user metrics which should include best streak
      final userMetrics = await userService.getUserMetrics(userId);
      
      // Get best streak count (or 0 if not available)
      final bestStreakCount = userMetrics?['bestDrivingStreak'] as int? ?? 0;
      
      // Format the streak count
      return '$bestStreakCount days';
    } catch (e) {
      // Return 0 on error
      return '0 days';
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/profile/components/data_collection_visualization.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:going50/services/user/privacy_service.dart';
import 'package:going50/core_models/data_privacy_settings.dart';

/// A visual representation of what data is collected and how it's used
///
/// This component provides:
/// - Visual representation of data types collected
/// - Indication of how each data type is used
/// - Privacy score summary
class DataCollectionVisualization extends StatelessWidget {
  const DataCollectionVisualization({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final privacyService = Provider.of<PrivacyService>(context, listen: false);
    
    return StreamBuilder<Map<String, DataPrivacySettings>>(
      stream: privacyService.privacySettingsStream,
      initialData: privacyService.privacySettings,
      builder: (context, snapshot) {
        final privacySettings = snapshot.data ?? {};
        
        // Calculate privacy score (0-100) based on privacy settings
        // The more restrictive the settings, the higher the score
        final privacyScore = _calculatePrivacyScore(privacySettings);
        
        return Card(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    const Text(
                      'Data Collection Overview',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    _buildPrivacyScoreBadge(privacyScore),
                  ],
                ),
                const SizedBox(height: 16),
                const Text(
                  'This visualization shows what data is collected and how it\'s used.',
                  style: TextStyle(fontSize: 14),
                ),
                const SizedBox(height: 16),
                _buildDataTypeRows(privacySettings),
              ],
            ),
          ),
        );
      }
    );
  }
  
  /// Calculates a privacy score from 0-100 based on privacy settings
  int _calculatePrivacyScore(Map<String, DataPrivacySettings> privacySettings) {
    if (privacySettings.isEmpty) {
      return 50; // Default middle score
    }
    
    int totalOptions = 0;
    int restrictedOptions = 0;
    
    // Count all privacy options and how many are restricted
    privacySettings.forEach((dataType, settings) {
      // Ignore local storage in score as it's required for app functionality
      totalOptions += 3; 
      
      if (settings.allowCloudSync == false) restrictedOptions++;
      if (settings.allowSharing == false) restrictedOptions++;
      if (settings.allowAnonymizedAnalytics == false) restrictedOptions++;
    });
    
    if (totalOptions == 0) return 50;
    
    // Calculate score: 50 (neutral) + up to 50 for restrictions
    return 50 + ((restrictedOptions / totalOptions) * 50).round();
  }
  
  /// Builds the privacy score badge
  Widget _buildPrivacyScoreBadge(int score) {
    // Determine color based on score
    Color color;
    if (score >= 75) {
      color = Colors.green;
    } else if (score >= 50) {
      color = Colors.orange;
    } else {
      color = Colors.red;
    }
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      decoration: BoxDecoration(
        color: color.withOpacity(0.2),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: color),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.shield, size: 16, color: color),
          const SizedBox(width: 4),
          Text(
            '$score',
            style: TextStyle(
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
        ],
      ),
    );
  }
  
  /// Builds rows for each data type
  Widget _buildDataTypeRows(Map<String, DataPrivacySettings> privacySettings) {
    final List<Widget> rows = [];
    
    // Define data types and their descriptions
    final dataTypes = {
      PrivacyService.dataTypeTrips: 'Trip Data',
      PrivacyService.dataTypeLocation: 'Location Data',
      PrivacyService.dataTypeDrivingEvents: 'Driving Events',
      PrivacyService.dataTypePerformanceMetrics: 'Performance Metrics',
    };
    
    dataTypes.forEach((dataType, label) {
      final settings = privacySettings[dataType];
      
      rows.add(
        Padding(
          padding: const EdgeInsets.only(bottom: 12.0),
          child: Row(
            children: [
              Expanded(
                flex: 3,
                child: Text(
                  label,
                  style: const TextStyle(fontWeight: FontWeight.w500),
                ),
              ),
              if (settings != null) ...[
                _buildIndicator(
                  settings.allowLocalStorage, 
                  'Local', 
                  'Stored on your device'
                ),
                const SizedBox(width: 8),
                _buildIndicator(
                  settings.allowCloudSync, 
                  'Cloud', 
                  'Synced to the cloud'
                ),
                const SizedBox(width: 8),
                _buildIndicator(
                  settings.allowSharing, 
                  'Shared', 
                  'Shared with friends'
                ),
                const SizedBox(width: 8),
                _buildIndicator(
                  settings.allowAnonymizedAnalytics, 
                  'Analytics', 
                  'Used for anonymous analytics'
                ),
              ] else ...[
                const Expanded(
                  flex: 7,
                  child: Text('Settings not configured', 
                    style: TextStyle(fontStyle: FontStyle.italic),
                  ),
                ),
              ],
            ],
          ),
        ),
      );
    });
    
    return Column(children: rows);
  }
  
  /// Builds an indicator for a privacy setting
  Widget _buildIndicator(bool isEnabled, String label, String tooltip) {
    return Expanded(
      flex: 2,
      child: Tooltip(
        message: tooltip,
        child: Container(
          padding: const EdgeInsets.symmetric(vertical: 4, horizontal: 6),
          decoration: BoxDecoration(
            color: isEnabled 
                ? Colors.green.withOpacity(0.2) 
                : Colors.grey.withOpacity(0.2),
            borderRadius: BorderRadius.circular(4),
            border: Border.all(
              color: isEnabled ? Colors.green : Colors.grey,
              width: 1,
            ),
          ),
          child: Center(
            child: Text(
              label,
              style: TextStyle(
                fontSize: 10,
                color: isEnabled ? Colors.green.shade800 : Colors.grey.shade700,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ),
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/profile/components/privacy_toggles.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:going50/services/user/privacy_service.dart';
import 'package:going50/core_models/data_privacy_settings.dart';

/// A component that provides toggle controls for different data types and privacy operations
///
/// This widget displays toggles for controlling:
/// - What data is collected
/// - How data is shared
/// - What operations are allowed on the data
class PrivacyToggles extends StatelessWidget {
  /// Callback for when a setting is changed
  final Function(String dataType, String operation, bool value) onSettingChanged;

  const PrivacyToggles({
    Key? key,
    required this.onSettingChanged,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final privacyService = Provider.of<PrivacyService>(context, listen: false);
    
    return StreamBuilder<Map<String, DataPrivacySettings>>(
      stream: privacyService.privacySettingsStream,
      initialData: privacyService.privacySettings,
      builder: (context, snapshot) {
        final settings = snapshot.data ?? {};
        
        return Card(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildDataTypeSection(
                  context, 
                  PrivacyService.dataTypeTrips, 
                  'Trip Data',
                  'Control how your trip information is stored and shared',
                  settings[PrivacyService.dataTypeTrips],
                ),
                const Divider(),
                _buildDataTypeSection(
                  context, 
                  PrivacyService.dataTypeLocation, 
                  'Location Data',
                  'Control how your location information is stored and shared',
                  settings[PrivacyService.dataTypeLocation],
                ),
                const Divider(),
                _buildDataTypeSection(
                  context, 
                  PrivacyService.dataTypeDrivingEvents, 
                  'Driving Events',
                  'Control how specific driving behaviors are recorded and shared',
                  settings[PrivacyService.dataTypeDrivingEvents],
                ),
                const Divider(),
                _buildDataTypeSection(
                  context, 
                  PrivacyService.dataTypePerformanceMetrics, 
                  'Performance Metrics',
                  'Control how your eco-driving performance is analyzed and shared',
                  settings[PrivacyService.dataTypePerformanceMetrics],
                ),
              ],
            ),
          ),
        );
      }
    );
  }
  
  /// Builds a section for controlling a specific data type
  Widget _buildDataTypeSection(
    BuildContext context,
    String dataType,
    String title,
    String description,
    dynamic settings,
  ) {
    final isConfigured = settings != null;
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 4),
        Text(
          description,
          style: const TextStyle(
            fontSize: 12,
            color: Colors.grey,
          ),
        ),
        const SizedBox(height: 12),
        if (isConfigured) ...[
          _buildToggleItem(
            context,
            'Store on Device',
            'Required for app functionality',
            settings.allowLocalStorage,
            (value) => onSettingChanged(dataType, PrivacyService.operationLocalStorage, value),
            isEnabled: false, // Local storage is required, so disable this toggle
          ),
          _buildToggleItem(
            context,
            'Sync to Cloud',
            'Upload data to your account in the cloud',
            settings.allowCloudSync,
            (value) => onSettingChanged(dataType, PrivacyService.operationCloudSync, value),
          ),
          _buildToggleItem(
            context,
            'Share with Friends',
            'Allow friends to see this data',
            settings.allowSharing,
            (value) => onSettingChanged(dataType, PrivacyService.operationSharing, value),
          ),
          _buildToggleItem(
            context,
            'Anonymous Analytics',
            'Contribute to improving the app (no personal data)',
            settings.allowAnonymizedAnalytics,
            (value) => onSettingChanged(dataType, PrivacyService.operationAnalytics, value),
          ),
        ] else ...[
          const Center(
            child: Text(
              'Settings not configured',
              style: TextStyle(
                fontStyle: FontStyle.italic,
                color: Colors.grey,
              ),
            ),
          ),
        ],
      ],
    );
  }
  
  /// Builds a toggle item with label and description
  Widget _buildToggleItem(
    BuildContext context,
    String label,
    String description,
    bool value,
    Function(bool) onChanged, {
    bool isEnabled = true,
  }) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0),
      child: Row(
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  label,
                  style: TextStyle(
                    fontWeight: FontWeight.w500,
                    color: isEnabled ? Colors.black : Colors.grey,
                  ),
                ),
                Text(
                  description,
                  style: TextStyle(
                    fontSize: 12,
                    color: isEnabled ? Colors.grey : Colors.grey.shade400,
                  ),
                ),
              ],
            ),
          ),
          Switch(
            value: value,
            onChanged: isEnabled ? onChanged : null,
            activeColor: Theme.of(context).primaryColor,
          ),
        ],
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/profile/components/data_management_section.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:going50/services/service_locator.dart';
import 'package:going50/services/user/user_service.dart';
import 'package:going50/data_lib/data_storage_manager.dart';
import 'package:provider/provider.dart';
import 'package:going50/presentation/providers/user_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:going50/core/constants/route_constants.dart';

/// A component that provides options for managing user data
///
/// This component offers:
/// - Data export functionality
/// - Cloud data deletion options
/// - Data retention information
class DataManagementSection extends StatelessWidget {
  const DataManagementSection({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Cloud Data Management',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Export or delete your cloud data. Local data can be managed in the Data Management tab.',
              style: TextStyle(fontSize: 14),
            ),
            const SizedBox(height: 16),
            _buildExportDataButton(context),
            const SizedBox(height: 16),
            _buildDeleteCloudDataButton(context),
            const SizedBox(height: 16),
            _buildManageLocalDataButton(context),
            const SizedBox(height: 16),
            _buildDataRetentionInfo(),
          ],
        ),
      ),
    );
  }
  
  /// Builds the export data button
  Widget _buildExportDataButton(BuildContext context) {
    return OutlinedButton(
      onPressed: () => _handleExportData(context),
      style: OutlinedButton.styleFrom(
        minimumSize: const Size.fromHeight(44),
        side: BorderSide(color: Theme.of(context).primaryColor),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.download, color: Theme.of(context).primaryColor),
          const SizedBox(width: 8),
          Text(
            'EXPORT YOUR DATA',
            style: TextStyle(color: Theme.of(context).primaryColor),
          ),
        ],
      ),
    );
  }
  
  /// Builds the delete cloud data button
  Widget _buildDeleteCloudDataButton(BuildContext context) {
    return OutlinedButton(
      onPressed: () => _showDeleteCloudConfirmation(context),
      style: OutlinedButton.styleFrom(
        minimumSize: const Size.fromHeight(44),
        side: const BorderSide(color: Colors.red),
      ),
      child: const Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.cloud_off, color: Colors.red),
          SizedBox(width: 8),
          Text(
            'DELETE ALL CLOUD DATA',
            style: TextStyle(color: Colors.red),
          ),
        ],
      ),
    );
  }
  
  /// Builds the manage local data button
  Widget _buildManageLocalDataButton(BuildContext context) {
    return TextButton(
      onPressed: () => Navigator.of(context).pushNamed(
        ProfileRoutes.dataManagement,
        arguments: {'scrollToReset': true},
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.storage, color: Theme.of(context).primaryColor),
          const SizedBox(width: 8),
          Text(
            'MANAGE LOCAL DATA',
            style: TextStyle(color: Theme.of(context).primaryColor),
          ),
        ],
      ),
    );
  }
  
  /// Builds the data retention information section
  Widget _buildDataRetentionInfo() {
    return const Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Data Retention',
          style: TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.bold,
          ),
        ),
        SizedBox(height: 8),
        Text(
          'By default, your data is stored locally on your device. If you enable cloud sync, '
          'your data is also stored in our secure cloud according to our privacy policy.',
          style: TextStyle(fontSize: 12, color: Colors.grey),
        ),
        SizedBox(height: 8),
        Text(
          'Local data is retained until you delete it manually. Cloud data is retained as long as '
          'you have an active account.',
          style: TextStyle(fontSize: 12, color: Colors.grey),
        ),
      ],
    );
  }
  
  /// Handles the export data action
  void _handleExportData(BuildContext context) {
    // Show a loading indicator during export
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const AlertDialog(
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 16),
            Text('Preparing your data export...'),
          ],
        ),
      ),
    );

    // Simulate export process with a delay
    Future.delayed(const Duration(seconds: 2), () {
      Navigator.of(context).pop(); // Close loading dialog
      
      // Show completion dialog
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Data Export Ready'),
          content: const Text(
            'Your data has been exported successfully. It will be downloaded to your device.',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('OK'),
            ),
          ],
        ),
      );
    });
  }
  
  /// Shows the delete cloud data confirmation dialog
  void _showDeleteCloudConfirmation(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete All Cloud Data?'),
        content: const Text(
          'This will permanently delete all your data stored in our cloud servers. '
          'Your local data will remain intact. This action cannot be undone.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('CANCEL'),
          ),
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              _handleDeleteCloudData(context);
            },
            child: const Text(
              'DELETE',
              style: TextStyle(color: Colors.red),
            ),
          ),
        ],
      ),
    );
  }
  
  /// Handles the delete cloud data action
  void _handleDeleteCloudData(BuildContext context) {
    // Show a loading indicator during deletion
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const AlertDialog(
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 16),
            Text('Deleting your cloud data...'),
          ],
        ),
      ),
    );

    // Get the user provider
    final userProvider = Provider.of<UserProvider>(context, listen: false);
    
    // Simulate cloud data deletion (in a real app, this would delete from cloud servers)
    Future.delayed(const Duration(seconds: 2), () {
      Navigator.of(context).pop(); // Close loading dialog
      
      // Show completion dialog
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Cloud Data Deleted'),
          content: const Text(
            'All your data has been deleted from our cloud servers. Your local data remains unaffected.',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('OK'),
            ),
          ],
        ),
      );
    });
  }
} 

################################################################################
FILE: lib/presentation/screens/community/challenge_detail_screen.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import 'dart:async';

import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/services/gamification/challenge_service.dart';
import 'package:going50/services/service_locator.dart';
import 'package:going50/services/user/user_service.dart';
import 'package:going50/presentation/providers/social_provider.dart';
import 'package:going50/presentation/screens/community/components/challenge_progress_section.dart';
import 'package:going50/presentation/screens/community/components/challenge_leaderboard.dart';

/// ChallengeDetailScreen displays detailed information about a specific challenge.
///
/// This screen includes:
/// - Challenge information (title, description, etc.)
/// - Progress tracking and visualization
/// - Participant leaderboard
/// - Join/leave functionality
class ChallengeDetailScreen extends StatefulWidget {
  /// The unique identifier of the challenge
  final String challengeId;
  
  /// Constructor
  const ChallengeDetailScreen({
    super.key, 
    required this.challengeId,
  });

  @override
  State<ChallengeDetailScreen> createState() => _ChallengeDetailScreenState();
}

class _ChallengeDetailScreenState extends State<ChallengeDetailScreen> {
  final ChallengeService _challengeService = serviceLocator<ChallengeService>();
  bool _isLoading = true;
  String? _errorMessage;
  Map<String, dynamic>? _challengeData;
  bool _isParticipating = false;
  
  // Add the UserService
  final UserService _userService = serviceLocator<UserService>();
  
  // Subscription for challenge state changes
  StreamSubscription? _challengeStateSubscription;

  @override
  void initState() {
    super.initState();
    _loadChallengeData();
    
    // Listen to challenge state changes from the service
    _challengeStateSubscription = _challengeService.challengeStateChangeStream
        .listen(_handleChallengeStateChange);
  }
  
  @override
  void dispose() {
    _challengeStateSubscription?.cancel();
    super.dispose();
  }
  
  /// Handle challenge state changes from the service
  void _handleChallengeStateChange(Map<String, dynamic> event) {
    // Only process events relevant to this challenge
    if (event['challengeId'] == widget.challengeId) {
      _loadChallengeData();
    }
  }
  
  /// Load challenge details from the service
  Future<void> _loadChallengeData() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });
    
    try {
      // Get the current user ID from UserService
      final currentUser = _userService.currentUser;
      if (currentUser == null) {
        setState(() {
          _errorMessage = 'User not found. Please restart the app.';
        });
        return;
      }
      
      final challengeData = await _challengeService.getDetailedChallenge(
        currentUser.id, 
        widget.challengeId,
      );
      
      if (challengeData != null) {
        setState(() {
          _challengeData = challengeData;
          
          // Use explicit isJoined flag if available, fall back to progress check
          _isParticipating = challengeData['isJoined'] ?? false;
        });
      } else {
        setState(() {
          _errorMessage = 'Challenge not found';
        });
      }
    } catch (e) {
      setState(() {
        _errorMessage = 'Failed to load challenge: $e';
      });
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }
  
  /// Join or leave the challenge
  Future<void> _toggleParticipation() async {
    if (_challengeData == null) return;
    
    setState(() {
      _isLoading = true;
    });
    
    try {
      // Get the current user ID from UserService
      final currentUser = _userService.currentUser;
      if (currentUser == null) {
        setState(() {
          _errorMessage = 'User not found. Please restart the app.';
        });
        return;
      }
      
      if (_isParticipating) {
        // Leave the challenge
        final success = await _challengeService.leaveChallenge(
          currentUser.id, 
          widget.challengeId
        );
        
        if (success) {
          // State will be updated via the event listener
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Left ${_challengeData!['title']} challenge'),
            ),
          );
          
          // Navigate back to previous screen
          Navigator.of(context).pop();
          return; // Return early since we've already popped
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to leave challenge'),
              backgroundColor: Colors.red,
            ),
          );
        }
      } else {
        // Join the challenge
        final result = await _challengeService.startChallenge(
          currentUser.id, 
          widget.challengeId
        );
        
        if (result != null) {
          // State will be updated via the event listener
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Joined ${_challengeData!['title']} challenge'),
            ),
          );
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to join challenge'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
      
      // Reload challenge data
      await _loadChallengeData();
    } catch (e) {
      setState(() {
        _errorMessage = 'Failed to update participation: $e';
      });
      
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error: $_errorMessage'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Challenge Details'),
      ),
      body: _isLoading 
          ? const Center(child: CircularProgressIndicator())
          : _errorMessage != null
              ? Center(child: Text('Error: $_errorMessage'))
              : _challengeData == null
                  ? const Center(child: Text('Challenge not found'))
                  : _buildChallengeContent(),
    );
  }
  
  Widget _buildChallengeContent() {
    final data = _challengeData!;
    
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Challenge header section
          _buildChallengeHeader(data),
          
          // Divider
          const Divider(height: 1),
          
          // Progress section
          ChallengeProgressSection(
            progress: data['progress'] ?? 0,
            targetValue: data['targetValue'] ?? 100,
            metricType: data['metricType'] ?? '',
            isCompleted: data['isCompleted'] ?? false,
            timeRemaining: _getTimeRemaining(data),
          ),
          
          // Divider
          const Divider(height: 1),
          
          // Reward section
          _buildRewardSection(data),
          
          // Divider
          const Divider(height: 1),
          
          // Leaderboard section
          ChallengeLeaderboard(
            challengeId: widget.challengeId,
            challengeTitle: data['title'] ?? 'Challenge',
          ),
        ],
      ),
    );
  }
  
  Widget _buildChallengeHeader(Map<String, dynamic> data) {
    final bool isCompleted = data['isCompleted'] ?? false;
    
    return Container(
      padding: const EdgeInsets.all(16),
      color: Colors.white,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: AppColors.primary.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  _getIconData(data['iconName']),
                  color: AppColors.primary,
                  size: 32,
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      data['title'] ?? 'Challenge',
                      style: const TextStyle(
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      _getDifficultyText(data['difficultyLevel']),
                      style: TextStyle(
                        fontSize: 14,
                        color: Colors.grey.shade700,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          Text(
            data['description'] ?? 'No description available',
            style: TextStyle(
              fontSize: 16,
              color: Colors.grey.shade800,
            ),
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              Expanded(
                child: Row(
                  children: [
                    Icon(
                      Icons.people_outline,
                      size: 18,
                      color: Colors.grey.shade700,
                    ),
                    const SizedBox(width: 4),
                    Text(
                      '${data['participantCount'] ?? '120'} participants',
                      style: TextStyle(
                        fontSize: 14,
                        color: Colors.grey.shade700,
                      ),
                    ),
                  ],
                ),
              ),
              ElevatedButton(
                onPressed: isCompleted ? null : _toggleParticipation,
                style: ElevatedButton.styleFrom(
                  backgroundColor: _isParticipating ? Colors.grey.shade200 : AppColors.primary,
                  foregroundColor: _isParticipating ? Colors.grey.shade800 : Colors.white,
                  padding: const EdgeInsets.symmetric(
                    horizontal: 24,
                    vertical: 12,
                  ),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(20),
                  ),
                  elevation: 0,
                ),
                child: Text(
                  isCompleted
                      ? 'Completed'
                      : (_isParticipating ? 'Leave' : 'Join'),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
  
  Widget _buildRewardSection(Map<String, dynamic> data) {
    final String rewardType = data['rewardType'] ?? 'points';
    final int rewardValue = data['rewardValue'] ?? 0;
    
    return Container(
      padding: const EdgeInsets.all(16),
      color: Colors.white,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Reward',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: AppColors.secondary.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  rewardType == 'badge' ? Icons.military_tech : Icons.stars,
                  color: AppColors.secondary,
                  size: 32,
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      rewardType == 'badge' 
                          ? 'Badge: Level $rewardValue' 
                          : '$rewardValue Points',
                      style: TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                        color: AppColors.secondary,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      rewardType == 'badge'
                          ? 'Earn this badge by completing the challenge'
                          : 'Points will be added to your total score',
                      style: TextStyle(
                        fontSize: 14,
                        color: Colors.grey.shade700,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          
          // For completed challenges, add claim button
          if (data['isCompleted'] == true && data['rewardClaimed'] != true)
            Padding(
              padding: const EdgeInsets.only(top: 16),
              child: Center(
                child: ElevatedButton(
                  onPressed: () async {
                    try {
                      // Get the current user ID from UserService
                      final currentUser = _userService.currentUser;
                      if (currentUser == null) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('User not found. Please restart the app.'),
                            backgroundColor: Colors.red,
                          ),
                        );
                        return;
                      }
                      
                      final success = await _challengeService.claimChallengeReward(
                        currentUser.id, 
                        widget.challengeId,
                      );
                      
                      if (success) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text('Claimed reward for ${data['title']}!'),
                            backgroundColor: AppColors.success,
                          ),
                        );
                        
                        // Reload challenge data
                        await _loadChallengeData();
                      } else {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('Failed to claim reward'),
                            backgroundColor: Colors.red,
                          ),
                        );
                      }
                    } catch (e) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text('Error: $e'),
                          backgroundColor: Colors.red,
                        ),
                      );
                    }
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppColors.secondary,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(
                      horizontal: 32,
                      vertical: 12,
                    ),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(20),
                    ),
                  ),
                  child: const Text('Claim Reward'),
                ),
              ),
            ),
          
          // For already claimed rewards
          if (data['isCompleted'] == true && data['rewardClaimed'] == true)
            Padding(
              padding: const EdgeInsets.only(top: 16),
              child: Center(
                child: Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 8,
                  ),
                  decoration: BoxDecoration(
                    color: Colors.grey.shade100,
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(
                        Icons.check_circle,
                        color: AppColors.success,
                        size: 18,
                      ),
                      const SizedBox(width: 8),
                      Text(
                        'Reward Claimed',
                        style: TextStyle(
                          color: AppColors.success,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }
  
  String _getDifficultyText(int? difficultyLevel) {
    switch (difficultyLevel) {
      case 1:
        return 'Easy';
      case 2:
        return 'Moderate';
      case 3:
        return 'Medium';
      case 4:
        return 'Hard';
      case 5:
        return 'Expert';
      default:
        return 'Normal';
    }
  }
  
  String _getTimeRemaining(Map<String, dynamic> data) {
    final String type = data['type'] ?? '';
    if (type == 'daily') {
      return 'Today';
    } else if (type == 'weekly') {
      return 'This week';
    } else if (type == 'achievement') {
      return 'Ongoing';
    } else {
      // For other types or when no specific end date is known
      return '7 days remaining';
    }
  }
  
  IconData _getIconData(String? iconName) {
    switch (iconName) {
      case 'eco':
        return Icons.eco;
      case 'local_gas_station':
        return Icons.local_gas_station;
      case 'speed':
        return Icons.speed;
      case 'cloud':
        return Icons.cloud;
      case 'trending_up':
        return Icons.trending_up;
      case 'location_city':
        return Icons.location_city;
      case 'weekend':
        return Icons.weekend;
      case 'access_time':
        return Icons.access_time;
      case 'mood':
        return Icons.mood;
      case 'timer':
        return Icons.timer;
      case 'repeat':
        return Icons.repeat;
      case 'straighten':
        return Icons.straighten;
      case 'event_available':
        return Icons.event_available;
      case 'directions_car':
        return Icons.directions_car;
      case 'stars':
        return Icons.stars;
      default:
        return Icons.emoji_events;
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/community/friend_profile_screen.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/core_models/user_profile.dart';
import 'package:going50/presentation/providers/social_provider.dart';
import 'package:going50/presentation/providers/insights_provider.dart';
import 'package:going50/services/gamification/achievement_service.dart';
import 'package:going50/services/service_locator.dart';

/// FriendProfileScreen displays another user's eco-driving profile.
///
/// This screen shows:
/// - Basic profile information
/// - Achievement showcase
/// - Driving statistics summary
/// - Interaction options
class FriendProfileScreen extends StatefulWidget {
  /// ID of the friend whose profile to display
  final String friendId;

  /// Constructor
  const FriendProfileScreen({
    super.key,
    required this.friendId,
  });

  @override
  State<FriendProfileScreen> createState() => _FriendProfileScreenState();
}

class _FriendProfileScreenState extends State<FriendProfileScreen> {
  bool _isCompareMode = false;
  
  @override
  Widget build(BuildContext context) {
    final socialProvider = Provider.of<SocialProvider>(context);
    final insightsProvider = Provider.of<InsightsProvider>(context);
    
    // Get friend profile from provider
    final friend = socialProvider.getFriendById(widget.friendId);
    
    if (friend == null) {
      // Handle case where friend is not found
      return Scaffold(
        appBar: AppBar(
          title: const Text('Profile'),
          leading: IconButton(
            icon: const Icon(Icons.arrow_back),
            onPressed: () => Navigator.of(context).pop(),
          ),
        ),
        body: const Center(
          child: Text('Friend not found'),
        ),
      );
    }
    
    return Scaffold(
      appBar: AppBar(
        title: Text(friend.name),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => Navigator.of(context).pop(),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.more_vert),
            onPressed: () => _showMoreOptions(context, friend),
          ),
        ],
      ),
      body: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildProfileHeader(context, friend),
            const Divider(height: 1),
            _buildAchievementShowcase(context, friend),
            const Divider(height: 1),
            _buildStatisticsSummary(context, friend, insightsProvider),
            const Divider(height: 1),
            _buildInteractionSection(context, friend, socialProvider),
          ],
        ),
      ),
    );
  }
  
  /// Builds the profile header section with avatar, name, and basic info
  Widget _buildProfileHeader(BuildContext context, UserProfile friend) {
    // Mock data - in a real app, this would come from a service
    final ecoDriverLevel = 'Eco Explorer';
    final memberSince = friend.createdAt;
    
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              // User avatar
              Container(
                width: 80,
                height: 80,
                decoration: BoxDecoration(
                  color: Colors.grey.shade300,
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: AppColors.primary,
                    width: 2,
                  ),
                ),
                child: Icon(
                  Icons.person,
                  color: Colors.grey.shade700,
                  size: 48,
                ),
              ),
              
              const SizedBox(width: 16),
              
              // User info
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      friend.name,
                      style: const TextStyle(
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Row(
                      children: [
                        const Icon(
                          Icons.eco,
                          size: 16,
                          color: AppColors.primary,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          ecoDriverLevel,
                          style: const TextStyle(
                            fontSize: 14,
                            color: AppColors.primary,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Text(
                      'Member since ${_formatDate(memberSince)}',
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey.shade600,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          
          const SizedBox(height: 16),
          
          // Connection status
          Container(
            padding: const EdgeInsets.symmetric(
              horizontal: 12,
              vertical: 6,
            ),
            decoration: BoxDecoration(
              color: AppColors.primary.withOpacity(0.1),
              borderRadius: BorderRadius.circular(16),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Icon(
                  Icons.check_circle,
                  size: 16,
                  color: AppColors.primary,
                ),
                const SizedBox(width: 4),
                const Text(
                  'Connected',
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.w500,
                    color: AppColors.primary,
                  ),
                ),
              ],
            ),
          ),
          
          const SizedBox(height: 16),
          
          // Impact stats
          Row(
            children: [
              _buildImpactStat(
                'CO₂ Saved',
                '320 kg',
                Icons.cloud_outlined,
              ),
              _buildImpactStat(
                'Fuel Saved',
                '145 L',
                Icons.local_gas_station_outlined,
              ),
              _buildImpactStat(
                'Money Saved',
                '\$186',
                Icons.attach_money,
              ),
            ],
          ),
        ],
      ),
    );
  }
  
  /// Builds a single impact statistic
  Widget _buildImpactStat(String label, String value, IconData icon) {
    return Expanded(
      child: Column(
        children: [
          Icon(
            icon,
            color: AppColors.secondary,
            size: 24,
          ),
          const SizedBox(height: 4),
          Text(
            value,
            style: const TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          Text(
            label,
            style: TextStyle(
              fontSize: 12,
              color: Colors.grey.shade600,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
  
  /// Builds the achievement showcase grid
  Widget _buildAchievementShowcase(BuildContext context, UserProfile friend) {
    final achievementService = serviceLocator<AchievementService>();
    
    return FutureBuilder<List<Map<String, dynamic>>>(
      future: achievementService.getUserBadges(friend.id),
      builder: (context, snapshot) {
        // Handle loading state
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(
            child: Padding(
              padding: EdgeInsets.all(16.0),
              child: CircularProgressIndicator(),
            ),
          );
        }
        
        // Handle error state
        if (snapshot.hasError) {
          return Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              'Could not load achievements: ${snapshot.error}',
              style: const TextStyle(color: Colors.red),
            ),
          );
        }
        
        // Handle empty achievements
        final achievements = snapshot.data ?? [];
        if (achievements.isEmpty) {
          return const Padding(
            padding: EdgeInsets.all(16.0),
            child: Text('No achievements yet'),
          );
        }
        
        // Show badges
        return Container(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text(
                    'Achievements',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  TextButton(
                    onPressed: () {
                      // Show all achievements
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Full achievements view coming soon'),
                          duration: Duration(seconds: 2),
                        ),
                      );
                    },
                    child: const Text('See All'),
                  ),
                ],
              ),
              
              const SizedBox(height: 8),
              
              // Achievements grid
              GridView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 3,
                  childAspectRatio: 0.9,
                  crossAxisSpacing: 12,
                  mainAxisSpacing: 12,
                ),
                itemCount: achievements.length > 5 ? 5 : achievements.length,
                itemBuilder: (context, index) {
                  final achievement = achievements[index];
                  return _buildAchievementBadge(
                    context,
                    achievement['badgeType'] as String,
                    achievement['level'] as int,
                    achievement['name'] as String,
                    achievement['description'] as String,
                  );
                },
              ),
              
              const SizedBox(height: 8),
              
              // Challenge progress
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.grey.shade100,
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: Colors.grey.shade300),
                ),
                child: Row(
                  children: [
                    Container(
                      width: 40,
                      height: 40,
                      decoration: BoxDecoration(
                        color: AppColors.secondary.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: const Icon(
                        Icons.emoji_events_outlined,
                        color: AppColors.secondary,
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          const Text(
                            'Current Challenge',
                            style: TextStyle(
                              fontSize: 14,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            'Eco Week: Maintain 90+ eco-score for 7 days',
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.grey.shade700,
                            ),
                          ),
                          const SizedBox(height: 6),
                          ClipRRect(
                            borderRadius: BorderRadius.circular(4),
                            child: LinearProgressIndicator(
                              value: 0.7,
                              backgroundColor: Colors.grey.shade300,
                              valueColor: const AlwaysStoppedAnimation<Color>(AppColors.secondary),
                              minHeight: 8,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        );
      },
    );
  }
  
  /// Builds a single achievement badge
  Widget _buildAchievementBadge(
    BuildContext context,
    String badgeType,
    int level,
    String name,
    String description,
  ) {
    IconData iconData;
    Color color;
    
    // Determine icon and color based on achievement type
    switch (badgeType) {
      case 'eco_expert':
      case 'eco_master':
        iconData = Icons.star;
        color = AppColors.primary;
        break;
      case 'smooth_driver':
        iconData = Icons.waves;
        color = Colors.blue;
        break;
      case 'fuel_saver':
      case 'fuel_efficiency':
        iconData = Icons.local_gas_station;
        color = Colors.orange;
        break;
      case 'streak_keeper':
      case 'consistent_driver':
        iconData = Icons.local_fire_department;
        color = Colors.red;
        break;
      case 'carbon_reducer':
        iconData = Icons.cloud;
        color = Colors.green;
        break;
      case 'road_veteran':
        iconData = Icons.map;
        color = Colors.purple;
        break;
      case 'speed_master':
        iconData = Icons.speed;
        color = Colors.amber;
        break;
      default:
        iconData = Icons.emoji_events;
        color = AppColors.secondary;
    }
    
    return GestureDetector(
      onTap: () {
        // Show achievement details
        _showAchievementDetails(context, name, description, level);
      },
      child: Container(
        decoration: BoxDecoration(
          color: color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: color.withOpacity(0.3),
          ),
        ),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              iconData,
              color: color,
              size: 24,
            ),
            const SizedBox(height: 4),
            Text(
              name,
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 11,
                fontWeight: FontWeight.bold,
                color: color,
              ),
            ),
            const SizedBox(height: 2),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 1),
              decoration: BoxDecoration(
                color: color.withOpacity(0.2),
                borderRadius: BorderRadius.circular(4),
              ),
              child: Text(
                'Lvl $level',
                style: TextStyle(
                  fontSize: 9,
                  fontWeight: FontWeight.bold,
                  color: color,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  /// Builds the statistics summary section
  Widget _buildStatisticsSummary(
    BuildContext context,
    UserProfile friend,
    InsightsProvider insightsProvider,
  ) {
    // Mock statistics - in a real app, this would come from a service
    final stats = {
      'Total Trips': '145',
      'Distance Driven': '2,876 km',
      'Average Eco-Score': '87',
      'Best Eco-Score': '98',
      'Total Driving Time': '156 hrs',
      'Fuel Saved': '145 L',
    };
    
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                'Statistics',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              // Compare toggle
              GestureDetector(
                onTap: () {
                  setState(() {
                    _isCompareMode = !_isCompareMode;
                  });
                },
                child: Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 6,
                  ),
                  decoration: BoxDecoration(
                    color: _isCompareMode
                        ? AppColors.secondary.withOpacity(0.2)
                        : Colors.grey.shade200,
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(
                        Icons.compare_arrows,
                        size: 16,
                        color: _isCompareMode
                            ? AppColors.secondary
                            : Colors.grey.shade700,
                      ),
                      const SizedBox(width: 4),
                      Text(
                        'Compare',
                        style: TextStyle(
                          fontSize: 12,
                          fontWeight: FontWeight.w500,
                          color: _isCompareMode
                              ? AppColors.secondary
                              : Colors.grey.shade700,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
          
          const SizedBox(height: 16),
          
          // Statistics grid
          GridView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 2,
              childAspectRatio: 2.5,
              crossAxisSpacing: 12,
              mainAxisSpacing: 12,
            ),
            itemCount: stats.length,
            itemBuilder: (context, index) {
              final entry = stats.entries.elementAt(index);
              // Mock data for comparison
              final yourValue = _isCompareMode ? {
                'Total Trips': '98',
                'Distance Driven': '1,920 km',
                'Average Eco-Score': '82',
                'Best Eco-Score': '95',
                'Total Driving Time': '108 hrs',
                'Fuel Saved': '98 L',
              }[entry.key] : null;
              
              return _buildStatisticItem(
                entry.key,
                entry.value,
                yourValue,
              );
            },
          ),
          
          const SizedBox(height: 24),
          
          // Recent activity
          const Text(
            'Recent Activity',
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          
          const SizedBox(height: 12),
          
          // Activity timeline
          _buildActivityTimeline(),
        ],
      ),
    );
  }
  
  /// Builds a single statistic item
  Widget _buildStatisticItem(String label, String value, String? yourValue) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade200),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            label,
            style: TextStyle(
              fontSize: 12,
              color: Colors.grey.shade700,
            ),
          ),
          const SizedBox(height: 4),
          Row(
            children: [
              Text(
                value,
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
              ),
              if (yourValue != null) ...[
                const SizedBox(width: 8),
                Container(
                  height: 12,
                  width: 1,
                  color: Colors.grey.shade300,
                ),
                const SizedBox(width: 8),
                Text(
                  'You: $yourValue',
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey.shade600,
                  ),
                ),
              ],
            ],
          ),
        ],
      ),
    );
  }
  
  /// Builds the activity timeline
  Widget _buildActivityTimeline() {
    // Mock activity data - in a real app, this would come from a service
    final activities = [
      {
        'type': 'challenge',
        'title': 'Completed "Eco Week" Challenge',
        'time': DateTime.now().subtract(const Duration(days: 2)),
      },
      {
        'type': 'badge',
        'title': 'Earned "Smooth Driver" Level 3',
        'time': DateTime.now().subtract(const Duration(days: 5)),
      },
      {
        'type': 'trip',
        'title': 'Achieved 95 Eco-Score on commute',
        'time': DateTime.now().subtract(const Duration(days: 7)),
      },
    ];
    
    return Column(
      children: activities.map((activity) {
        IconData iconData;
        Color color;
        
        // Determine icon and color based on activity type
        switch (activity['type']) {
          case 'challenge':
            iconData = Icons.emoji_events;
            color = AppColors.secondary;
            break;
          case 'badge':
            iconData = Icons.verified;
            color = AppColors.primary;
            break;
          case 'trip':
            iconData = Icons.route;
            color = Colors.blue;
            break;
          default:
            iconData = Icons.circle;
            color = Colors.grey;
        }
        
        return Padding(
          padding: const EdgeInsets.only(bottom: 16),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                width: 32,
                height: 32,
                decoration: BoxDecoration(
                  color: color.withOpacity(0.2),
                  shape: BoxShape.circle,
                ),
                child: Icon(
                  iconData,
                  color: color,
                  size: 18,
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      activity['title'] as String,
                      style: const TextStyle(
                        fontSize: 14,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                    const SizedBox(height: 2),
                    Text(
                      _formatActivityTime(activity['time'] as DateTime),
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey.shade600,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        );
      }).toList(),
    );
  }
  
  /// Builds the interaction section with buttons
  Widget _buildInteractionSection(
    BuildContext context,
    UserProfile friend,
    SocialProvider socialProvider,
  ) {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Interact',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          
          const SizedBox(height: 16),
          
          Row(
            children: [
              // Challenge button
              Expanded(
                child: ElevatedButton.icon(
                  onPressed: () => _showChallengeInvite(context, friend),
                  icon: const Icon(Icons.emoji_events_outlined),
                  label: const Text('Challenge'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppColors.primary,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                ),
              ),
              
              const SizedBox(width: 12),
              
              // Message button
              Expanded(
                child: OutlinedButton.icon(
                  onPressed: () {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text('Messaging feature coming soon'),
                        duration: Duration(seconds: 2),
                      ),
                    );
                  },
                  icon: const Icon(Icons.message_outlined),
                  label: const Text('Message'),
                  style: OutlinedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    side: const BorderSide(color: AppColors.primary),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
  
  /// Shows challenge invitation dialog
  void _showChallengeInvite(BuildContext context, UserProfile friend) {
    // Mock challenges - in a real app, this would come from a service
    final challenges = [
      {'id': 'c1', 'title': 'Weekend Warrior', 'description': 'Achieve 90+ eco-score on weekend drives'},
      {'id': 'c2', 'title': 'Fuel Master', 'description': 'Save at least 5L of fuel in the next week'},
      {'id': 'c3', 'title': 'Smooth Operator', 'description': 'No harsh acceleration events for 5 days'},
    ];
    
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) => DraggableScrollableSheet(
        initialChildSize: 0.7,
        maxChildSize: 0.9,
        minChildSize: 0.5,
        expand: false,
        builder: (context, scrollController) => Column(
          children: [
            // Handle
            Container(
              margin: const EdgeInsets.only(top: 8, bottom: 16),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: Colors.grey.shade300,
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            
            // Title
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              child: Text(
                'Challenge ${friend.name}',
                style: const TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            
            const SizedBox(height: 16),
            
            // Challenge list
            Expanded(
              child: ListView.builder(
                controller: scrollController,
                padding: const EdgeInsets.symmetric(horizontal: 16),
                itemCount: challenges.length,
                itemBuilder: (context, index) {
                  final challenge = challenges[index];
                  return Card(
                    margin: const EdgeInsets.only(bottom: 8),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Padding(
                      padding: const EdgeInsets.all(16),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            challenge['title'] as String,
                            style: const TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          const SizedBox(height: 8),
                          Text(
                            challenge['description'] as String,
                            style: TextStyle(
                              fontSize: 14,
                              color: Colors.grey.shade700,
                            ),
                          ),
                          const SizedBox(height: 16),
                          Align(
                            alignment: Alignment.centerRight,
                            child: ElevatedButton(
                              onPressed: () {
                                Navigator.pop(context);
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text('Challenge invitation sent to ${friend.name}'),
                                    duration: const Duration(seconds: 2),
                                  ),
                                );
                              },
                              style: ElevatedButton.styleFrom(
                                backgroundColor: AppColors.primary,
                                foregroundColor: Colors.white,
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(20),
                                ),
                              ),
                              child: const Text('Send Invite'),
                            ),
                          ),
                        ],
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  /// Shows achievement details dialog
  void _showAchievementDetails(
    BuildContext context,
    String name,
    String description,
    int level,
  ) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(name),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(description),
            const SizedBox(height: 8),
            Text('Level: $level'),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }
  
  /// Shows more options menu
  void _showMoreOptions(BuildContext context, UserProfile friend) {
    showModalBottomSheet(
      context: context,
      builder: (context) => Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          ListTile(
            leading: const Icon(Icons.share),
            title: const Text('Share Profile'),
            onTap: () {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Sharing feature coming soon'),
                  duration: Duration(seconds: 2),
                ),
              );
            },
          ),
          ListTile(
            leading: const Icon(Icons.flag),
            title: const Text('Report User'),
            onTap: () {
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Reporting feature coming soon'),
                  duration: Duration(seconds: 2),
                ),
              );
            },
          ),
          ListTile(
            leading: const Icon(Icons.person_remove),
            title: const Text('Remove Friend'),
            onTap: () {
              Navigator.pop(context);
              _showRemoveFriendConfirmation(context, friend);
            },
          ),
        ],
      ),
    );
  }
  
  /// Shows confirmation dialog for removing a friend
  void _showRemoveFriendConfirmation(BuildContext context, UserProfile friend) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Remove Friend'),
        content: Text('Are you sure you want to remove ${friend.name} from your friends?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () async {
              Navigator.pop(context);
              
              final socialProvider = Provider.of<SocialProvider>(context, listen: false);
              final success = await socialProvider.removeFriend(friend.id);
              
              if (success && mounted) {
                Navigator.pop(context); // Return to previous screen
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text('${friend.name} removed from friends'),
                    duration: const Duration(seconds: 2),
                  ),
                );
              }
            },
            child: const Text('Remove'),
          ),
        ],
      ),
    );
  }
  
  /// Format date for display
  String _formatDate(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date);
    
    if (difference.inDays < 30) {
      return '${difference.inDays} days ago';
    } else if (difference.inDays < 365) {
      final months = (difference.inDays / 30).floor();
      return '$months ${months == 1 ? 'month' : 'months'} ago';
    } else {
      final years = (difference.inDays / 365).floor();
      return '$years ${years == 1 ? 'year' : 'years'} ago';
    }
  }
  
  /// Format time for activity timeline
  String _formatActivityTime(DateTime time) {
    final now = DateTime.now();
    final difference = now.difference(time);
    
    if (difference.inHours < 24) {
      return 'Today';
    } else if (difference.inDays < 2) {
      return 'Yesterday';
    } else if (difference.inDays < 7) {
      return '${difference.inDays} days ago';
    } else if (difference.inDays < 30) {
      final weeks = (difference.inDays / 7).floor();
      return '$weeks ${weeks == 1 ? 'week' : 'weeks'} ago';
    } else {
      final months = (difference.inDays / 30).floor();
      return '$months ${months == 1 ? 'month' : 'months'} ago';
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/community/community_screen.dart
################################################################################

import 'package:flutter/material.dart';

import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/presentation/screens/community/components/leaderboard_view.dart';
import 'package:going50/presentation/screens/community/components/challenges_view.dart';
import 'package:going50/presentation/screens/community/components/friends_view.dart';

/// CommunityScreen is the main screen for the Community tab.
///
/// This screen provides access to leaderboards, challenges, and friend features.
/// The screen is organized as a scrollable list of sections rather than tabs
/// to reduce navigation depth and improve user experience.
class CommunityScreen extends StatefulWidget {
  const CommunityScreen({super.key});

  @override
  State<CommunityScreen> createState() => _CommunityScreenState();
}

class _CommunityScreenState extends State<CommunityScreen> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.grey.shade100, // Light gray background between cards
      appBar: AppBar(
        title: const Text(
          'Community',
          style: TextStyle(
            fontWeight: FontWeight.bold,
            color: Colors.black,
            fontSize: 26, // Increased size to be larger than section headings
          ),
        ),
        backgroundColor: Colors.white, // White background for AppBar
        elevation: 0, // Remove shadow for a more modern look
        centerTitle: false, // Left-aligned title
        actions: [
          // Search icon in the app bar
          IconButton(
            icon: const Icon(Icons.search, color: Colors.black),
            onPressed: () {
              // TODO: Implement search functionality
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const SizedBox(height: 12), // Add top padding
            
            // Leaderboard Section - Compact version
            _buildLeaderboardSection(),
            
            const SizedBox(height: 16), // Space between sections
            
            // Active Challenges Section - Compact version
            _buildActiveChallengesSection(),
            
            const SizedBox(height: 16), // Space between sections
            
            // Friends Section - Compact version
            _buildFriendsSection(),
            
            // Add bottom padding to ensure content doesn't get cut off
            const SizedBox(height: 24),
          ],
        ),
      ),
    );
  }
  
  Widget _buildLeaderboardSection() {
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 12.0),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8.0),
        border: Border.all(color: Colors.grey.shade200), // Add thin border
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 12.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'Leaderboard',
                  style: TextStyle(
                    fontSize: 22, // Smaller than parent title, larger than subheadings
                    fontWeight: FontWeight.bold,
                  ),
                ),
                GestureDetector(
                  onTap: () {
                    // Navigate to full leaderboard view with proper back navigation
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => Scaffold(
                          appBar: AppBar(
                            title: const Text('Leaderboard'),
                            elevation: 0,
                            backgroundColor: Colors.white,
                            foregroundColor: Colors.black,
                            centerTitle: false,
                          ),
                          body: const Padding(
                            padding: EdgeInsets.symmetric(vertical: 8.0),
                            child: LeaderboardView(),
                          ),
                        ),
                      ),
                    );
                  },
                  child: Text(
                    'View All',
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                      color: AppColors.primary, // Green color like in mockup
                    ),
                  ),
                ),
              ],
            ),
          ),
          // Embed a compact version of LeaderboardView
          SizedBox(
            height: 320, // Fixed height for compact view
            child: const LeaderboardView(isCompactMode: true),
          ),
        ],
      ),
    );
  }
  
  Widget _buildActiveChallengesSection() {
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 12.0),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8.0),
        border: Border.all(color: Colors.grey.shade200), // Add thin border
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 12.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'Active Challenges',
                  style: TextStyle(
                    fontSize: 22, // Smaller than parent title, larger than subheadings
                    fontWeight: FontWeight.bold,
                  ),
                ),
                GestureDetector(
                  onTap: () {
                    // Navigate to full challenges view with proper back navigation
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => Scaffold(
                          appBar: AppBar(
                            title: const Text('Challenges'),
                            elevation: 0,
                            backgroundColor: Colors.white,
                            foregroundColor: Colors.black,
                            centerTitle: false,
                          ),
                          body: const Padding(
                            padding: EdgeInsets.symmetric(vertical: 8.0),
                            child: ChallengesView(),
                          ),
                        ),
                      ),
                    );
                  },
                  child: Text(
                    'View All', 
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                      color: AppColors.primary, // Green color like in mockup
                    ),
                  ),
                ),
              ],
            ),
          ),
          // Embed a compact version of ChallengesView with increased height
          SizedBox(
            height: 320, // Adjusted height for compact view
            child: const ChallengesView(isCompactMode: true),
          ),
        ],
      ),
    );
  }
  
  Widget _buildFriendsSection() {
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 12.0),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8.0),
        border: Border.all(color: Colors.grey.shade200), // Add thin border
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 12.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'Friends',
                  style: TextStyle(
                    fontSize: 22, // Smaller than parent title, larger than subheadings
                    fontWeight: FontWeight.bold,
                  ),
                ),
                GestureDetector(
                  onTap: () {
                    // Show add friends dialog
                    _showAddFriendsDialog(context);
                  },
                  child: Text(
                    'Add Friends',
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                      color: AppColors.primary, // Green color like in mockup
                    ),
                  ),
                ),
              ],
            ),
          ),
          // Embed a compact version of FriendsView
          SizedBox(
            height: 320, // Fixed height for compact view
            child: const FriendsView(isCompactMode: true),
          ),
        ],
      ),
    );
  }
  
  // Keep the existing dialog logic for adding friends
  void _showAddFriendsDialog(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (BuildContext context) {
        return Padding(
          padding: EdgeInsets.only(
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          child: Container(
            padding: const EdgeInsets.all(24),
            height: MediaQuery.of(context).size.height * 0.7,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Find Friends',
                  style: TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                const Text(
                  'Connect with other eco-drivers to compare your performance and compete in challenges together.',
                  style: TextStyle(
                    fontSize: 14,
                    color: Colors.grey,
                  ),
                ),
                const SizedBox(height: 24),
                Container(
                  decoration: BoxDecoration(
                    color: Colors.grey.shade100,
                    borderRadius: BorderRadius.circular(24),
                    border: Border.all(color: Colors.grey.shade300),
                  ),
                  child: const TextField(
                    decoration: InputDecoration(
                      hintText: 'Search by name or email',
                      prefixIcon: Icon(Icons.search),
                      border: InputBorder.none,
                      contentPadding: EdgeInsets.symmetric(
                        vertical: 15,
                        horizontal: 16,
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 24),
                const Text(
                  'Suggested Friends',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                Expanded(
                  child: ListView(
                    children: [
                      _buildSuggestedFriendTile(context, 'Riley Johnson', 'Based on your location', 4, 88),
                      const SizedBox(height: 12),
                      _buildSuggestedFriendTile(context, 'Morgan Smith', 'Similar driving patterns', 2, 92),
                      const SizedBox(height: 12),
                      _buildSuggestedFriendTile(context, 'Casey Williams', 'Completed same challenges', 1, 79),
                    ],
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: () {
                      Navigator.pop(context);
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppColors.primary,
                      foregroundColor: Colors.white,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(24),
                      ),
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                    child: const Text('Close'),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
  
  Widget _buildSuggestedFriendTile(BuildContext context, String name, String reason, int mutualFriends, int ecoScore) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade200),
      ),
      child: Row(
        children: [
          // Avatar placeholder
          Container(
            width: 48,
            height: 48,
            decoration: BoxDecoration(
              color: Colors.grey.shade300,
              shape: BoxShape.circle,
            ),
            child: Center(
              child: Text(
                name.substring(0, 1).toUpperCase(),
                style: TextStyle(
                  color: Colors.grey.shade700,
                  fontWeight: FontWeight.bold,
                  fontSize: 20,
                ),
              ),
            ),
          ),
          const SizedBox(width: 16),
          
          // Friend info
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  name,
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  reason,
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey.shade600,
                  ),
                ),
                const SizedBox(height: 4),
                Row(
                  children: [
                    Icon(
                      Icons.people_outline,
                      size: 12,
                      color: Colors.grey.shade600,
                    ),
                    const SizedBox(width: 4),
                    Text(
                      '$mutualFriends mutual',
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey.shade600,
                      ),
                    ),
                    const SizedBox(width: 8),
                    Icon(
                      Icons.eco_outlined,
                      size: 12,
                      color: Colors.green.shade600,
                    ),
                    const SizedBox(width: 4),
                    Text(
                      'Score: $ecoScore',
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey.shade600,
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
          
          // Add button
          ElevatedButton(
            onPressed: () {
              // Add friend functionality
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('Friend request sent to $name'),
                  duration: const Duration(seconds: 2),
                ),
              );
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.primary,
              foregroundColor: Colors.white,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(20),
              ),
              minimumSize: const Size(40, 36),
              padding: const EdgeInsets.symmetric(horizontal: 12),
            ),
            child: const Text('Add'),
          ),
        ],
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/community/components/leaderboard_view.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/presentation/providers/social_provider.dart';
import 'package:going50/presentation/screens/community/components/shared_filters.dart';

/// LeaderboardView displays the user ranking based on eco-driving performance.
///
/// This component includes:
/// - Filter for scope (friends, local, global)
/// - Time period filter (week, month, all time)
/// - User ranking display
/// - List of top performers
/// - Can be displayed in compact mode for the main community screen
class LeaderboardView extends StatefulWidget {
  /// Whether to display in compact mode with limited entries and UI elements
  final bool isCompactMode;
  
  const LeaderboardView({
    super.key, 
    this.isCompactMode = false,
  });

  @override
  State<LeaderboardView> createState() => _LeaderboardViewState();
}

class _LeaderboardViewState extends State<LeaderboardView> {
  int _filterIndex = 0;
  int _timeFilterIndex = 0;
  
  final List<String> _filterOptions = ["Friends", "Local", "Global"];
  final List<String> _timeFilterOptions = ["Week", "Month", "All time"];
  
  // Maps our UI indices to the provider's values
  final List<String> _leaderboardTypeValues = ["friends", "regional", "global"];
  final List<String> _timeframeValues = ["weekly", "monthly", "alltime"];
  
  @override
  Widget build(BuildContext context) {
    final provider = Provider.of<SocialProvider>(context);
    final leaderboardEntries = provider.leaderboardEntries;
    
    // Initialize the filter indices based on provider state
    if (_filterIndex != _leaderboardTypeValues.indexOf(provider.leaderboardType)) {
      _filterIndex = _leaderboardTypeValues.indexOf(provider.leaderboardType);
    }
    
    if (_timeFilterIndex != _timeframeValues.indexOf(provider.timeframe)) {
      _timeFilterIndex = _timeframeValues.indexOf(provider.timeframe);
    }
    
    // In compact mode, show a simplified view with fewer entries
    if (widget.isCompactMode) {
      return _buildCompactView(context, provider, leaderboardEntries);
    }
    
    // Otherwise show the full view
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Using shared segmented filter bar
        SegmentedFilterBar(
          options: _filterOptions,
          selectedIndex: _filterIndex,
          onSelectionChanged: (index) {
            setState(() {
              _filterIndex = index;
              provider.setLeaderboardType(_leaderboardTypeValues[index]);
            });
          },
        ),
        
        // Using shared time filter chip group
        TimeFilterChipGroup(
          options: _timeFilterOptions,
          selectedIndex: _timeFilterIndex,
          onSelectionChanged: (index) {
            setState(() {
              _timeFilterIndex = index;
              provider.setTimeframe(_timeframeValues[index]);
            });
          },
        ),
        
        // Your Ranking section
        _buildUserRankingCard(context, provider),
        
        const SizedBox(height: 24),
        
        // Top Performers section
        const Padding(
          padding: EdgeInsets.symmetric(horizontal: 18.0),
          child: Text(
            'Top Performers',
            style: TextStyle(
              fontSize: 20, 
              fontWeight: FontWeight.bold,
              letterSpacing: -0.5,
            ),
          ),
        ),
        
        const SizedBox(height: 12),
        
        // List of top performers
        Expanded(
          child: provider.isLoading 
            ? const Center(child: CircularProgressIndicator())
            : leaderboardEntries.isEmpty
              ? const Center(child: Text('No leaderboard data available'))
              : _buildLeaderboardList(context, leaderboardEntries),
        ),
      ],
    );
  }
  
  /// Build compact view for the main community screen
  Widget _buildCompactView(BuildContext context, SocialProvider provider, List<dynamic> entries) {
    return Column(
      children: [
        // Using a consistent design for the filter tabs similar to SegmentedFilterBar
        Container(
          height: 52, // Reduced height for compact view
          margin: const EdgeInsets.only(bottom: 20.0, left: 16.0, right: 16.0),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: Colors.grey.shade200, width: 1),
            // Subtle shadow
            boxShadow: [
              BoxShadow(
                color: Colors.grey.shade100,
                blurRadius: 4,
                offset: const Offset(0, 1),
              ),
            ],
          ),
          child: Row(
            children: List.generate(
              _filterOptions.length,
              (index) => Expanded(
                child: GestureDetector(
                  onTap: () => setState(() {
                    _filterIndex = index;
                    provider.setLeaderboardType(_leaderboardTypeValues[index]);
                  }),
                  child: Container(
                    margin: const EdgeInsets.all(4),
                    decoration: BoxDecoration(
                      color: _filterIndex == index ? Colors.white : Colors.transparent,
                      borderRadius: BorderRadius.circular(10),
                      border: _filterIndex == index 
                          ? Border.all(color: AppColors.primary, width: 1.5)
                          : null,
                    ),
                    child: Center(
                      child: Text(
                        _filterOptions[index],
                        style: TextStyle(
                          fontSize: 15, // Slightly smaller for compact view
                          fontWeight: _filterIndex == index ? FontWeight.w600 : FontWeight.w400,
                          color: _filterIndex == index ? AppColors.primary : Colors.grey.shade500,
                        ),
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        ),
        
        // User ranking - simplified version
        _buildUserRankingCard(context, provider),
        
        const SizedBox(height: 16),
        
        // Only show top 5 entries in compact mode - with better spacing
        Expanded(
          child: provider.isLoading 
            ? const Center(child: CircularProgressIndicator())
            : entries.isEmpty
              ? const Center(child: Text('No leaderboard data available'))
              : ListView.builder(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  physics: const NeverScrollableScrollPhysics(),
                  itemCount: entries.length > 5 ? 5 : entries.length,
                  itemBuilder: (context, index) {
                    final entry = entries[index];
                    return _buildCompactLeaderboardItem(context, entry);
                  },
                ),
        ),
      ],
    );
  }
  
  Widget _buildUserRankingCard(BuildContext context, SocialProvider provider) {
    // Find user's rank in the leaderboard entries
    final userRank = provider.leaderboardEntries
        .firstWhere((entry) => entry['isUser'] == true, 
                   orElse: () => {'rank': 0, 'score': 0, 'name': 'You'});
    
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16.0),
      padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 16.0),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade200, width: 1),
        // Subtle shadow for depth
        boxShadow: [
          BoxShadow(
            color: Colors.grey.shade100,
            blurRadius: 6,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Row(
        children: [
          Container(
            width: 48,
            height: 48,
            decoration: BoxDecoration(
              color: AppColors.primary,
              shape: BoxShape.circle,
              // Subtle glow effect for emphasis
              boxShadow: [
                BoxShadow(
                  color: AppColors.primary.withOpacity(0.2),
                  blurRadius: 8,
                  spreadRadius: 1,
                ),
              ],
            ),
            child: Center(
              child: Text(
                userRank['rank'] == 0 ? '-' : userRank['rank'].toString(),
                style: const TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                  fontSize: 22,
                ),
              ),
            ),
          ),
          const SizedBox(width: 20),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Your Ranking',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    letterSpacing: -0.5,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  userRank['rank'] == 0 
                      ? 'Complete more trips to get ranked' 
                      : 'Score: ${userRank['score']}',
                  style: TextStyle(
                    fontSize: 15,
                    color: Colors.grey.shade600,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildLeaderboardList(BuildContext context, List<dynamic> entries) {
    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      itemCount: entries.length,
      itemBuilder: (context, index) {
        final entry = entries[index];
        return _buildLeaderboardItem(context, entry);
      },
    );
  }
  
  Widget _buildLeaderboardItem(BuildContext context, Map<String, dynamic> entry) {
    final isUser = entry['isUser'] == true;
    
    return Container(
      margin: const EdgeInsets.only(bottom: 12.0),
      padding: const EdgeInsets.symmetric(horizontal: 18.0, vertical: 14.0),
      decoration: BoxDecoration(
        color: isUser ? AppColors.primary.withOpacity(0.07) : Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: isUser ? AppColors.primary.withOpacity(0.3) : Colors.grey.shade200,
          width: 1,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.shade100,
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Row(
        children: [
          Container(
            width: 44,
            height: 44,
            decoration: BoxDecoration(
              color: _getRankColor(entry['rank']),
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(
                  color: _getRankColor(entry['rank']).withOpacity(0.3),
                  blurRadius: 4,
                  spreadRadius: 0,
                ),
              ],
            ),
            child: Center(
              child: Text(
                entry['rank'].toString(),
                style: const TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                  fontSize: 18,
                ),
              ),
            ),
          ),
          const SizedBox(width: 18),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  entry['name'],
                  style: TextStyle(
                    fontWeight: isUser ? FontWeight.bold : FontWeight.w600,
                    fontSize: 16,
                    color: isUser ? AppColors.primary : Colors.black87,
                  ),
                ),
                const SizedBox(height: 2),
                Text(
                  'Score: ${entry['score']}',
                  style: TextStyle(
                    color: Colors.grey.shade600,
                    fontSize: 14,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  /// Build a more compact leaderboard item for the compact view
  Widget _buildCompactLeaderboardItem(BuildContext context, dynamic entry) {
    final bool isUser = entry['isUser'] ?? false;
    final bool isTopPerformer = entry['rank'] == 1;
    
    return Container(
      margin: const EdgeInsets.only(bottom: 8.0),
      decoration: BoxDecoration(
        color: isUser ? Colors.grey.shade200 : Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade200, width: 1),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
        child: Row(
          children: [
            // Rank
            Container(
              width: 28,
              height: 28,
              alignment: Alignment.center,
              child: Text(
                '${entry['rank']}',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                  color: Colors.grey.shade700,
                ),
              ),
            ),
            
            const SizedBox(width: 12),
            
            // User avatar
            Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(
                color: Colors.grey.shade300,
                shape: BoxShape.circle,
              ),
              child: entry['photoUrl'] != null && entry['photoUrl'].isNotEmpty
                ? ClipRRect(
                    borderRadius: BorderRadius.circular(20),
                    child: Image.network(
                      entry['photoUrl'],
                      width: 40,
                      height: 40,
                      fit: BoxFit.cover,
                    ),
                  )
                : Icon(
                    Icons.person,
                    color: Colors.grey.shade700,
                  ),
            ),
            
            const SizedBox(width: 12),
            
            // User name with badge for top performer
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Text(
                        entry['name'],
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          fontSize: 16,
                          color: isUser ? AppColors.primary : Colors.black,
                        ),
                      ),
                      if (isTopPerformer) ...[
                        const SizedBox(width: 8),
                        Container(
                          padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                          decoration: BoxDecoration(
                            color: Colors.amber.shade100,
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.emoji_events_outlined,
                                color: Colors.amber.shade800,
                                size: 14,
                              ),
                              const SizedBox(width: 4),
                              Text(
                                'Top Driver',
                                style: TextStyle(
                                  fontSize: 12,
                                  fontWeight: FontWeight.w500,
                                  color: Colors.amber.shade800,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ],
                  ),
                ],
              ),
            ),
            
            // Score
            Text(
              '${entry['score']}',
              style: const TextStyle(
                fontWeight: FontWeight.bold,
                fontSize: 18,
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  Color _getRankColor(int rank) {
    if (rank == 1) return Colors.amber;
    if (rank == 2) return Colors.grey.shade400;
    if (rank == 3) return Colors.brown.shade300;
    return AppColors.primary;
  }
} 

################################################################################
FILE: lib/presentation/screens/community/components/challenge_leaderboard.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/presentation/providers/social_provider.dart';

/// ChallengeLeaderboard displays the leaderboard for a specific challenge.
///
/// This component includes:
/// - List of top participants
/// - User's current position
/// - Each participant's score/progress
class ChallengeLeaderboard extends StatefulWidget {
  /// The unique identifier of the challenge
  final String challengeId;
  
  /// The title of the challenge
  final String challengeTitle;
  
  /// Constructor
  const ChallengeLeaderboard({
    super.key,
    required this.challengeId,
    required this.challengeTitle,
  });

  @override
  State<ChallengeLeaderboard> createState() => _ChallengeLeaderboardState();
}

class _ChallengeLeaderboardState extends State<ChallengeLeaderboard> {
  bool _isLoading = true;
  List<Map<String, dynamic>> _leaderboardEntries = [];
  Map<String, dynamic>? _currentUserEntry;
  
  @override
  void initState() {
    super.initState();
    _loadLeaderboardData();
  }
  
  /// Load leaderboard data
  Future<void> _loadLeaderboardData() async {
    setState(() {
      _isLoading = true;
    });
    
    try {
      // In a real app, this would fetch data from a service based on the challenge ID
      // For now, we'll use mock data
      await Future.delayed(const Duration(milliseconds: 500));
      
      // Simulate fetching challenge leaderboard data
      _leaderboardEntries = [
        {
          'rank': 1,
          'userId': 'user1',
          'name': 'Taylor Green',
          'progress': 5,
          'score': 100,
          'isCurrentUser': false,
        },
        {
          'rank': 2,
          'userId': 'user2',
          'name': 'Jordan Rivera',
          'progress': 4,
          'score': 80,
          'isCurrentUser': false,
        },
        {
          'rank': 3,
          'userId': 'user3',
          'name': 'Casey Lee',
          'progress': 3,
          'score': 60,
          'isCurrentUser': true,
        },
        {
          'rank': 4,
          'userId': 'user4',
          'name': 'Morgan Chen',
          'progress': 2,
          'score': 40,
          'isCurrentUser': false,
        },
        {
          'rank': 5,
          'userId': 'user5',
          'name': 'Alex Johnson',
          'progress': 1,
          'score': 20,
          'isCurrentUser': false,
        },
      ];
      
      // Find current user's entry
      _currentUserEntry = _leaderboardEntries.firstWhere(
        (entry) => entry['isCurrentUser'] == true,
        orElse: () => {
          'rank': 10,
          'userId': 'currentUser',
          'name': 'You',
          'progress': 0,
          'score': 0,
          'isCurrentUser': true,
        },
      );
    } catch (e) {
      debugPrint('Error loading leaderboard: $e');
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      color: Colors.white,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Leaderboard',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 6),
          Text(
            'Top participants in this challenge',
            style: TextStyle(
              fontSize: 14,
              color: Colors.grey.shade700,
            ),
          ),
          const SizedBox(height: 16),
          
          // Loading indicator or error message
          if (_isLoading)
            const Center(
              child: Padding(
                padding: EdgeInsets.all(16.0),
                child: CircularProgressIndicator(),
              ),
            )
          else if (_leaderboardEntries.isEmpty)
            Center(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Text(
                  'No participants yet',
                  style: TextStyle(
                    color: Colors.grey.shade700,
                  ),
                ),
              ),
            )
          else
            Column(
              children: [
                // Top participants list
                ..._leaderboardEntries
                    .take(5)
                    .map((entry) => _buildLeaderboardEntryTile(entry)),
                
                // Divider if current user is not in top 5
                if (_currentUserEntry != null && 
                    !_leaderboardEntries.take(5).any((e) => e['isCurrentUser'] == true))
                  Padding(
                    padding: const EdgeInsets.symmetric(vertical: 8.0),
                    child: Row(
                      children: [
                        Expanded(
                          child: Container(
                            height: 1,
                            color: Colors.grey.shade200,
                          ),
                        ),
                        Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 8.0),
                          child: Text(
                            '•••',
                            style: TextStyle(
                              color: Colors.grey.shade500,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                        Expanded(
                          child: Container(
                            height: 1,
                            color: Colors.grey.shade200,
                          ),
                        ),
                      ],
                    ),
                  ),
                
                // Current user's position (if not in top 5)
                if (_currentUserEntry != null && 
                    !_leaderboardEntries.take(5).any((e) => e['isCurrentUser'] == true))
                  _buildLeaderboardEntryTile(_currentUserEntry!),
              ],
            ),
          
          // View all button
          const SizedBox(height: 16),
          Center(
            child: TextButton.icon(
              onPressed: () {
                // Navigate to full leaderboard (not implemented)
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Full leaderboard view not implemented'),
                  ),
                );
              },
              icon: const Icon(Icons.people_outline),
              label: const Text('View All Participants'),
              style: TextButton.styleFrom(
                foregroundColor: AppColors.primary,
              ),
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildLeaderboardEntryTile(Map<String, dynamic> entry) {
    final bool isCurrentUser = entry['isCurrentUser'] == true;
    
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: isCurrentUser ? AppColors.primary.withOpacity(0.1) : Colors.grey.shade50,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: isCurrentUser ? AppColors.primary.withOpacity(0.3) : Colors.grey.shade200,
        ),
      ),
      child: Row(
        children: [
          // Rank
          Container(
            width: 30,
            height: 30,
            alignment: Alignment.center,
            decoration: BoxDecoration(
              color: _getRankColor(entry['rank']),
              shape: BoxShape.circle,
            ),
            child: Text(
              entry['rank'].toString(),
              style: const TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
                fontSize: 14,
              ),
            ),
          ),
          const SizedBox(width: 12),
          
          // User info
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  entry['name'],
                  style: TextStyle(
                    fontWeight: isCurrentUser ? FontWeight.bold : FontWeight.normal,
                    fontSize: 14,
                    color: isCurrentUser ? AppColors.primary : Colors.black,
                  ),
                ),
                Text(
                  'Progress: ${entry['progress']}',
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey.shade700,
                  ),
                ),
              ],
            ),
          ),
          
          // Score
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: Colors.grey.shade200,
              borderRadius: BorderRadius.circular(12),
            ),
            child: Text(
              '${entry['score']}',
              style: const TextStyle(
                fontWeight: FontWeight.bold,
                fontSize: 14,
              ),
            ),
          ),
        ],
      ),
    );
  }
  
  Color _getRankColor(int rank) {
    switch (rank) {
      case 1:
        return Colors.amber.shade700; // Gold
      case 2:
        return Colors.blueGrey.shade400; // Silver
      case 3:
        return Colors.brown.shade400; // Bronze
      default:
        return Colors.grey.shade500;
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/community/components/challenge_progress_section.dart
################################################################################

import 'package:flutter/material.dart';

import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/services/gamification/challenge_service.dart';

/// ChallengeProgressSection displays progress for a challenge.
///
/// This component includes:
/// - Visual progress indicator
/// - Current progress text
/// - Target description
/// - Time remaining
class ChallengeProgressSection extends StatelessWidget {
  /// Current progress value
  final int progress;
  
  /// Target value to complete the challenge
  final int targetValue;
  
  /// Type of metric being measured
  final String metricType;
  
  /// Whether the challenge is completed
  final bool isCompleted;
  
  /// Time remaining text
  final String timeRemaining;
  
  /// Constructor
  const ChallengeProgressSection({
    super.key,
    required this.progress,
    required this.targetValue,
    required this.metricType,
    required this.isCompleted,
    required this.timeRemaining,
  });

  @override
  Widget build(BuildContext context) {
    final double progressPercent = targetValue > 0 
        ? (progress / targetValue).clamp(0.0, 1.0) 
        : 0;
    
    return Container(
      padding: const EdgeInsets.all(16),
      color: Colors.white,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Progress',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Text(
                          '$progress/$targetValue',
                          style: const TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(width: 8),
                        Text(
                          _getMetricLabel(metricType),
                          style: TextStyle(
                            fontSize: 14,
                            color: Colors.grey.shade700,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 8),
                    ClipRRect(
                      borderRadius: BorderRadius.circular(6),
                      child: LinearProgressIndicator(
                        value: progressPercent,
                        backgroundColor: Colors.grey.shade200,
                        color: isCompleted ? AppColors.success : AppColors.primary,
                        minHeight: 12,
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(width: 16),
              _buildTimeRemaining(),
            ],
          ),
          const SizedBox(height: 16),
          _buildInfoNote(),
        ],
      ),
    );
  }
  
  Widget _buildTimeRemaining() {
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: 12,
        vertical: 6,
      ),
      decoration: BoxDecoration(
        color: isCompleted ? AppColors.success.withOpacity(0.1) : Colors.grey.shade100,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: isCompleted ? AppColors.success.withOpacity(0.3) : Colors.grey.shade300,
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            isCompleted ? Icons.check_circle : Icons.timer_outlined,
            size: 16,
            color: isCompleted ? AppColors.success : Colors.grey.shade700,
          ),
          const SizedBox(width: 4),
          Text(
            isCompleted ? 'Completed' : timeRemaining,
            style: TextStyle(
              fontSize: 12,
              fontWeight: isCompleted ? FontWeight.bold : FontWeight.normal,
              color: isCompleted ? AppColors.success : Colors.grey.shade700,
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildInfoNote() {
    if (isCompleted) {
      return Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: AppColors.success.withOpacity(0.1),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Row(
          children: [
            Icon(
              Icons.check_circle,
              color: AppColors.success,
              size: 20,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                'Congratulations! You have completed this challenge.',
                style: TextStyle(
                  color: AppColors.success,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
          ],
        ),
      );
    } else {
      final String description = _getProgressDescription();
      
      return Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: Colors.blue.withOpacity(0.1),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Row(
          children: [
            Icon(
              Icons.info_outline,
              color: Colors.blue.shade700,
              size: 20,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                description,
                style: TextStyle(
                  color: Colors.blue.shade800,
                ),
              ),
            ),
          ],
        ),
      );
    }
  }
  
  String _getMetricLabel(String metricType) {
    switch (metricType) {
      case MetricType.ecoScore:
        return 'points';
      case MetricType.tripCount:
        return 'trips';
      case MetricType.distanceKm:
        return 'kilometers';
      case MetricType.activeDays:
        return 'days';
      case MetricType.calmDriving:
        return 'points';
      case MetricType.speedOptimization:
        return 'points';
      case MetricType.idlingScore:
        return 'points';
      case MetricType.fuelSaved:
        return 'liters';
      case MetricType.co2Reduced:
        return 'kg';
      case MetricType.steadySpeed:
        return 'points';
      default:
        return '';
    }
  }
  
  String _getProgressDescription() {
    final int remaining = targetValue - progress;
    
    if (remaining <= 0) {
      return 'You have met the target! Complete any remaining requirements to finish the challenge.';
    }
    
    switch (metricType) {
      case MetricType.ecoScore:
        return 'Achieve a score of $targetValue to complete this challenge.';
      case MetricType.tripCount:
        return 'Complete $remaining more trip${remaining == 1 ? '' : 's'} to achieve this challenge.';
      case MetricType.distanceKm:
        return 'Drive $remaining more kilometer${remaining == 1 ? '' : 's'} to complete this challenge.';
      case MetricType.activeDays:
        return 'Drive on $remaining more day${remaining == 1 ? '' : 's'} to complete this challenge.';
      case MetricType.calmDriving:
        return 'Improve your calm driving score to $targetValue to complete this challenge.';
      case MetricType.fuelSaved:
        return 'Save $remaining more liter${remaining == 1 ? '' : 's'} of fuel to complete this challenge.';
      case MetricType.co2Reduced:
        return 'Reduce CO₂ emissions by $remaining more kg to complete this challenge.';
      default:
        return 'Complete the required progress to achieve this challenge.';
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/community/components/challenges_view.dart
################################################################################

import 'package:flutter/material.dart';
import 'dart:async';

import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/core/constants/route_constants.dart';
import 'package:going50/presentation/screens/community/components/shared_filters.dart';
import 'package:going50/services/gamification/challenge_service.dart';
import 'package:going50/services/service_locator.dart';
import 'package:going50/services/user/user_service.dart';
import 'package:going50/core_models/gamification_models.dart';
import 'package:logging/logging.dart';

/// ChallengesView displays active and available challenges.
///
/// This component includes:
/// - Active challenges with progress indicators
/// - Available challenges that users can join
/// - Completed challenges section
/// - Can be displayed in compact mode for the main community screen
class ChallengesView extends StatefulWidget {
  /// Whether to display in compact mode with limited entries and UI elements
  final bool isCompactMode;
  
  const ChallengesView({
    super.key, 
    this.isCompactMode = false,
  });

  @override
  State<ChallengesView> createState() => _ChallengesViewState();
}

// Maintain static variables for state persistence across widget rebuilds
class _ChallengesViewState extends State<ChallengesView> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  int _filterIndex = 0;
  int _timeFilterIndex = 0;
  
  // Static variables to persist state across rebuilds
  static int persistedFilterIndex = 0;
  static int persistedTimeFilterIndex = 0;
  
  final List<String> _filterOptions = ["Active", "Available", "Completed"];
  final List<String> _timeFilterOptions = ["Week", "Month", "All time"];
  
  // Services
  final ChallengeService _challengeService = serviceLocator<ChallengeService>();
  final UserService _userService = serviceLocator<UserService>();
  
  // Challenge data
  List<UserChallenge> _activeChallenges = [];
  List<Challenge> _availableChallenges = [];
  List<Challenge> _allChallenges = [];
  List<UserChallenge> _completedChallenges = [];
  
  // Loading state
  bool _isLoading = true;
  String? _errorMessage;
  
  // Subscription for challenge state changes
  StreamSubscription? _challengeStateSubscription;
  
  final _logger = Logger('ChallengesView');
  
  @override
  void initState() {
    super.initState();
    
    // Initialize with persisted values
    _filterIndex = persistedFilterIndex;
    _timeFilterIndex = persistedTimeFilterIndex;
    
    _tabController = TabController(
      length: 3, 
      vsync: this,
      initialIndex: _filterIndex, // Set initial tab from persisted state
    );
    
    _tabController.addListener(() {
      if (_tabController.indexIsChanging) {
        setState(() {
          _filterIndex = _tabController.index;
          persistedFilterIndex = _filterIndex; // Update persisted state
        });
      }
    });
    
    // Subscribe to challenge state changes
    _challengeStateSubscription = _challengeService.challengeStateChangeStream
        .listen(_handleChallengeStateChange);
    
    // Load challenges
    _loadChallenges();
  }
  
  /// Handle challenge state changes from the service
  void _handleChallengeStateChange(Map<String, dynamic> event) {
    _logger.info('Challenge state change: ${event['action']} - ${event['challengeId']}');
    
    // Reload challenges on any state change
    _loadChallenges();
    
    // If a challenge was joined, switch to active tab
    if (event['action'] == 'joined') {
      _tabController.animateTo(0); // Switch to active tab
    }
  }
  
  /// Load challenges from service
  Future<void> _loadChallenges() async {
    _logger.info('Loading challenges for user: ${_userService.currentUser?.id}');
    
    try {
      setState(() {
        _isLoading = true;
        _errorMessage = null;
      });
      
      var currentUser = _userService.currentUser;
      
      // Initialize UserService if needed
      if (currentUser == null) {
        _logger.info('User not available, initializing UserService');
        await _userService.initialize();
        currentUser = _userService.currentUser;
        
        final user = _userService.currentUser;
        if (user == null) {
          _logger.warning('Failed to get user after UserService initialization');
          if (mounted) {
            setState(() {
              _errorMessage = 'User not found. Please restart the app.';
              _isLoading = false;
            });
          }
          return;
        }
      }
      
      // Get all challenges
      _logger.info('Getting all challenges from ChallengeService');
      final allChallenges = await _challengeService.getAllChallenges();
      _logger.info('Retrieved ${allChallenges.length} total challenges');
      
      // Get user challenges - no need to explicitly invalidate cache as service handles this
      final userChallenges = await _challengeService.getUserChallenges(
        currentUser?.id ?? '',
      );
      _logger.info('Retrieved ${userChallenges.length} user challenges');
      
      if (mounted) {
        setState(() {
          // Store all challenges for reference
          _allChallenges = allChallenges;
          
          // Set up active challenges - ANY non-completed user challenge is considered active
          _activeChallenges = userChallenges
              .where((uc) => !uc.isCompleted)
              .toList();
          _logger.info('Active challenges: ${_activeChallenges.length}');
          
          // Set up completed challenges
          _completedChallenges = userChallenges
              .where((uc) => uc.isCompleted)
              .toList();
          _logger.info('Completed challenges: ${_completedChallenges.length}');
          
          // Get ALL user challenge IDs (both active and completed)
          final allUserChallengeIds = userChallenges
              .map((uc) => uc.challengeId)
              .toSet();
              
          // Available challenges should be challenges NOT in any user challenges list
          _availableChallenges = allChallenges
              .where((c) => !allUserChallengeIds.contains(c.id))
              .toList();
          _logger.info('Available challenges: ${_availableChallenges.length}');
          
          _isLoading = false;
        });
      }
    } catch (e) {
      _logger.severe('Error loading challenges: $e');
      if (mounted) {
        setState(() {
          _errorMessage = 'Failed to load challenges: $e';
          _isLoading = false;
        });
      }
    }
  }
  
  /// Create a formatted challenge map for UI components
  Map<String, dynamic> _formatChallengeForUI(Challenge challenge, {UserChallenge? userChallenge}) {
    final bool hasUserData = userChallenge != null;
    
    return {
      'id': challenge.id,
      'title': challenge.title,
      'description': challenge.description,
      'iconName': challenge.iconName ?? 'emoji_events',
      'difficulty': _getDifficultyText(challenge.difficultyLevel),
      'reward': '${challenge.rewardValue} ${challenge.rewardType ?? 'points'}',
      'duration': _getDurationText(challenge.type),
      'timeRemaining': _getTimeRemaining(challenge.type),
      'participants': 50 + (challenge.id.hashCode % 100).abs(), // Simulated count but deterministic
      
      // User-specific data if available
      if (hasUserData) ...{
        'progress': userChallenge.progress,
        'target': challenge.targetValue,
        'isCompleted': userChallenge.isCompleted,
        'completedDate': userChallenge.completedAt != null ? 
            _formatDate(userChallenge.completedAt!) : null,
      }
    };
  }
  
  @override
  void dispose() {
    _tabController.dispose();
    _challengeStateSubscription?.cancel();
    super.dispose();
  }
  
  @override
  Widget build(BuildContext context) {
    // In compact mode, only show active challenges
    if (widget.isCompactMode) {
      return _buildCompactView();
    }
    
    // Otherwise use the full tabbed view
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Using shared segmented filter bar
        SegmentedFilterBar(
          options: _filterOptions,
          selectedIndex: _filterIndex,
          onSelectionChanged: (index) {
            setState(() {
              _filterIndex = index;
              persistedFilterIndex = index; // Update persisted state
              _tabController.animateTo(index);
            });
          },
        ),
        
        // Using shared time filter chip group
        TimeFilterChipGroup(
          options: _timeFilterOptions,
          selectedIndex: _timeFilterIndex,
          onSelectionChanged: (index) {
            setState(() {
              _timeFilterIndex = index;
              persistedTimeFilterIndex = index; // Update persisted state
            });
          },
        ),
        
        Expanded(
          child: _isLoading
              ? const Center(child: CircularProgressIndicator())
              : _errorMessage != null
                  ? Center(child: Text(_errorMessage!))
                  : TabBarView(
                      controller: _tabController,
                      children: [
                        _buildActiveChallengesTab(),
                        _buildAvailableChallengesTab(),
                        _buildCompletedChallengesTab(),
                      ],
                    ),
        ),
      ],
    );
  }
  
  Widget _buildActiveChallengesTab() {
    if (_activeChallenges.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.emoji_events_outlined,
              size: 64,
              color: Colors.grey.shade400,
            ),
            const SizedBox(height: 16),
            Text(
              'No active challenges',
              style: TextStyle(
                fontSize: 16,
                color: Colors.grey.shade600,
              ),
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () {
                // Switch to available challenges tab
                _tabController.animateTo(1);
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: AppColors.primary,
                foregroundColor: Colors.white,
              ),
              child: const Text('Find Challenges'),
            ),
          ],
        )
      );
    }
    
    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      itemCount: _activeChallenges.length,
      itemBuilder: (context, index) {
        final userChallenge = _activeChallenges[index];
        
        // Find the challenge definition from ALL challenges
        final challengeDef = _allChallenges.firstWhere(
          (c) => c.id == userChallenge.challengeId,
          orElse: () => Challenge(
            id: userChallenge.challengeId,
            title: 'Unknown Challenge',
            description: 'Challenge details not available',
            type: 'unknown',
            targetValue: 1,
            metricType: 'unknown',
          ),
        );
        
        // Use the new formatter helper
        final challengeMap = _formatChallengeForUI(challengeDef, userChallenge: userChallenge);
        
        return _buildActiveChallengeCard(challengeMap);
      },
    );
  }
  
  Widget _buildAvailableChallengesTab() {
    if (_availableChallenges.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.search_off_outlined,
              size: 64,
              color: Colors.grey.shade400,
            ),
            const SizedBox(height: 16),
            Text(
              'No available challenges',
              style: TextStyle(
                fontSize: 16,
                color: Colors.grey.shade600,
              ),
            ),
            const SizedBox(height: 24),
            Text(
              'You\'ve accepted all available challenges!',
              style: TextStyle(
                fontSize: 14,
                color: Colors.grey.shade500,
              ),
            ),
          ],
        )
      );
    }
    
    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      itemCount: _availableChallenges.length,
      itemBuilder: (context, index) {
        final challenge = _availableChallenges[index];
        
        // Use the new formatter helper
        final challengeMap = _formatChallengeForUI(challenge);
        
        return _buildAvailableChallengeCard(challengeMap);
      },
    );
  }
  
  Widget _buildCompletedChallengesTab() {
    if (_completedChallenges.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.check_circle_outline,
              size: 64,
              color: Colors.grey.shade400,
            ),
            const SizedBox(height: 16),
            Text(
              'No completed challenges',
              style: TextStyle(
                fontSize: 16,
                color: Colors.grey.shade600,
              ),
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () {
                // Switch to available challenges tab
                _tabController.animateTo(1);
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: AppColors.primary,
                foregroundColor: Colors.white,
              ),
              child: const Text('Find Challenges'),
            ),
          ],
        )
      );
    }
    
    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      itemCount: _completedChallenges.length,
      itemBuilder: (context, index) {
        final userChallenge = _completedChallenges[index];
        
        // Find the challenge definition
        final challengeDef = _allChallenges.firstWhere(
          (c) => c.id == userChallenge.challengeId,
          orElse: () => Challenge(
            id: userChallenge.challengeId,
            title: 'Unknown Challenge',
            description: 'Challenge details not available',
            type: 'unknown',
            targetValue: 1,
            metricType: 'unknown',
          ),
        );
        
        // Use the new formatter helper
        final challengeMap = _formatChallengeForUI(challengeDef, userChallenge: userChallenge);
        
        return _buildCompletedChallengeCard(challengeMap);
      },
    );
  }
  
  // Helper methods for formatting
  String _getTimeRemaining(String challengeType) {
    switch (challengeType) {
      case 'daily':
        return 'Today';
      case 'weekly':
        return '7 days';
      case 'achievement':
        return 'Ongoing';
      default:
        return 'Limited time';
    }
  }
  
  String _getDifficultyText(int? difficultyLevel) {
    switch (difficultyLevel) {
      case 1:
        return 'Very Easy';
      case 2:
        return 'Easy';
      case 3:
        return 'Medium';
      case 4:
        return 'Hard';
      case 5:
        return 'Very Hard';
      default:
        return 'Medium';
    }
  }
  
  String _getDurationText(String challengeType) {
    switch (challengeType) {
      case 'daily':
        return '1 day';
      case 'weekly':
        return '7 days';
      case 'achievement':
        return 'Ongoing';
      default:
        return 'Limited time';
    }
  }
  
  String _formatDate(DateTime date) {
    final months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    return '${months[date.month - 1]} ${date.day}, ${date.year}';
  }
  
  Widget _buildActiveChallengeCard(Map<String, dynamic> challenge) {
    final double progressPercent = challenge['progress'] / challenge['target'];
    
    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: InkWell(
        onTap: () {
          // Navigate to challenge detail screen
          Navigator.of(context).pushNamed(
            CommunityRoutes.challengeDetail,
            arguments: challenge['id'],
          );
        },
        borderRadius: BorderRadius.circular(16),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Container(
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                      color: AppColors.primary.withOpacity(0.15),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Icon(
                      _getIconData(challenge['iconName']),
                      color: AppColors.primary,
                      size: 26,
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          challenge['title'],
                          style: const TextStyle(
                            fontSize: 17,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 6),
                        Text(
                          challenge['description'],
                          style: TextStyle(
                            fontSize: 14,
                            color: Colors.grey.shade700,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 20),
              Row(
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            Text(
                              'Progress: ',
                              style: TextStyle(
                                fontSize: 14,
                                color: Colors.grey.shade700,
                              ),
                            ),
                            Text(
                              '${challenge['progress']}/${challenge['target']}',
                              style: const TextStyle(
                                fontSize: 14,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 10),
                        Stack(
                          children: [
                            // Background track
                            Container(
                              height: 10,
                              width: double.infinity,
                              decoration: BoxDecoration(
                                color: Colors.grey.shade200,
                                borderRadius: BorderRadius.circular(5),
                              ),
                            ),
                            // Progress indicator
                            FractionallySizedBox(
                              widthFactor: progressPercent.clamp(0, 1),
                              child: Container(
                                height: 10,
                                decoration: BoxDecoration(
                                  gradient: LinearGradient(
                                    colors: [AppColors.primary.withOpacity(0.7), AppColors.primary],
                                    begin: Alignment.centerLeft,
                                    end: Alignment.centerRight,
                                  ),
                                  borderRadius: BorderRadius.circular(5),
                                ),
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(width: 20),
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.end,
                    children: [
                      Row(
                        children: [
                          Icon(
                            Icons.timer,
                            size: 16,
                            color: AppColors.secondary.withOpacity(0.7),
                          ),
                          const SizedBox(width: 6),
                          Text(
                            challenge['timeRemaining'],
                            style: TextStyle(
                              fontSize: 14,
                              color: Colors.grey.shade800,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 8),
                      Row(
                        children: [
                          Icon(
                            Icons.people,
                            size: 16,
                            color: AppColors.secondary.withOpacity(0.7),
                          ),
                          const SizedBox(width: 6),
                          Text(
                            '${challenge['participants']}',
                            style: TextStyle(
                              fontSize: 14,
                              color: Colors.grey.shade800,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildAvailableChallengeCard(Map<String, dynamic> challenge) {
    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: InkWell(
        onTap: () {
          // Navigate to challenge detail screen
          Navigator.of(context).pushNamed(
            CommunityRoutes.challengeDetail,
            arguments: challenge['id'],
          );
        },
        borderRadius: BorderRadius.circular(16),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Container(
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                      color: Colors.grey.shade200,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Icon(
                      _getIconData(challenge['iconName']),
                      color: Colors.grey.shade700,
                      size: 26,
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          challenge['title'],
                          style: const TextStyle(
                            fontSize: 17,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 6),
                        Text(
                          challenge['description'],
                          style: TextStyle(
                            fontSize: 14,
                            color: Colors.grey.shade700,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 20),
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: [
                  _buildDetailChip(Icons.star, challenge['difficulty']),
                  _buildDetailChip(Icons.card_giftcard, challenge['reward']),
                  _buildDetailChip(Icons.timer, challenge['duration']),
                ],
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Row(
                    children: [
                      Icon(
                        Icons.people,
                        size: 16,
                        color: Colors.grey.shade600,
                      ),
                      const SizedBox(width: 6),
                      Text(
                        '${challenge['participants']} participants',
                        style: TextStyle(
                          fontSize: 14,
                          color: Colors.grey.shade700,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                  ElevatedButton(
                    onPressed: () async {
                      final currentUser = _userService.currentUser;
                      if (currentUser != null) {
                        // Show loading indicator
                        setState(() {
                          _isLoading = true;
                        });
                        
                        try {
                          // Clear the cache to ensure fresh data
                          await _challengeService.invalidateUserChallengesCache(currentUser.id);
                          
                          // Start the challenge
                          final result = await _challengeService.startChallenge(
                            currentUser.id,
                            challenge['id'],
                          );
                          
                          if (result != null) {
                            _logger.info('Successfully joined challenge: ${challenge['title']}');
                            
                            // Reload challenges to update UI
                            await _loadChallenges();
                            
                            // Show success message
                            if (mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(
                                  content: Text('Joined ${challenge['title']} challenge'),
                                  duration: const Duration(seconds: 2),
                                ),
                              );
                              
                              // Switch to active challenges tab to show the user their joined challenge
                              _tabController.animateTo(0);
                              
                              // Log the lengths of each challenge list for debugging
                              _logger.info('After join - Active: ${_activeChallenges.length}, '
                                  'Available: ${_availableChallenges.length}, '
                                  'Completed: ${_completedChallenges.length}');
                            }
                          } else {
                            _logger.warning('Failed to join challenge: ${challenge['title']}');
                            
                            // Hide loading indicator
                            setState(() {
                              _isLoading = false;
                            });
                            
                            if (mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(
                                  content: Text('Failed to join challenge. Please try again.'),
                                  duration: Duration(seconds: 2),
                                ),
                              );
                            }
                          }
                        } catch (e) {
                          _logger.severe('Error joining challenge: $e');
                          
                          // Hide loading indicator
                          setState(() {
                            _isLoading = false;
                          });
                          
                          if (mounted) {
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(
                                content: Text('Error joining challenge: $e'),
                                duration: const Duration(seconds: 2),
                              ),
                            );
                          }
                        }
                      }
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppColors.primary,
                      foregroundColor: Colors.white,
                      elevation: 0,
                      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(20),
                      ),
                    ),
                    child: const Text(
                      'Join',
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildCompletedChallengeCard(Map<String, dynamic> challenge) {
    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: InkWell(
        onTap: () {
          // Navigate to challenge detail screen
          Navigator.of(context).pushNamed(
            CommunityRoutes.challengeDetail,
            arguments: challenge['id'],
          );
        },
        borderRadius: BorderRadius.circular(16),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Container(
                padding: const EdgeInsets.all(10),
                decoration: BoxDecoration(
                  color: Colors.grey.shade200,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  _getIconData(challenge['iconName']),
                  color: Colors.grey.shade700,
                  size: 26,
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      challenge['title'],
                      style: const TextStyle(
                        fontSize: 17,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 6),
                    Text(
                      challenge['description'],
                      style: TextStyle(
                        fontSize: 14,
                        color: Colors.grey.shade700,
                      ),
                    ),
                    const SizedBox(height: 10),
                    Row(
                      children: [
                        Expanded(
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.check_circle,
                                size: 16,
                                color: AppColors.success,
                              ),
                              const SizedBox(width: 6),
                              Flexible(
                                child: Text(
                                  'Completed on ${challenge['completedDate']}',
                                  style: TextStyle(
                                    fontSize: 13,
                                    color: Colors.grey.shade700,
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ],
                          ),
                        ),
                        Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(
                              Icons.card_giftcard,
                              size: 16,
                              color: AppColors.secondary,
                            ),
                            const SizedBox(width: 6),
                            Text(
                              challenge['reward'],
                              style: TextStyle(
                                fontSize: 13,
                                color: AppColors.secondary,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildDetailChip(IconData icon, String label) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.grey.shade300),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 14,
            color: AppColors.secondary,
          ),
          const SizedBox(width: 6),
          Text(
            label,
            style: TextStyle(
              fontSize: 13,
              fontWeight: FontWeight.w500,
              color: Colors.grey.shade800,
            ),
          ),
        ],
      ),
    );
  }
  
  IconData _getIconData(String? iconName) {
    switch (iconName) {
      case 'eco':
        return Icons.eco;
      case 'local_gas_station':
        return Icons.local_gas_station;
      case 'speed':
        return Icons.speed;
      case 'cloud':
        return Icons.cloud;
      case 'trending_up':
        return Icons.trending_up;
      case 'location_city':
        return Icons.location_city;
      case 'weekend':
        return Icons.weekend;
      case 'access_time':
        return Icons.access_time;
      case 'mood':
        return Icons.mood;
      case 'timer':
        return Icons.timer;
      case 'repeat':
        return Icons.repeat;
      case 'straighten':
        return Icons.straighten;
      case 'event_available':
        return Icons.event_available;
      case 'directions_car':
        return Icons.directions_car;
      case 'stars':
        return Icons.stars;
      default:
        return Icons.emoji_events;
    }
  }

  /// Build compact view for the main community screen - only showing active challenges
  Widget _buildCompactView() {
    if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }
    
    if (_errorMessage != null) {
      return Center(child: Text(_errorMessage!));
    }
    
    List<Widget> challengeWidgets = [];
    
    if (_activeChallenges.isEmpty) {
      challengeWidgets.add(_buildCompactEmptyChallenges());
    } else {
      // Show up to 2 challenges to match mockup
      final displayCount = _activeChallenges.length > 2 ? 2 : _activeChallenges.length;
      
      for (int i = 0; i < displayCount; i++) {
        final userChallenge = _activeChallenges[i];
        
        // Find the challenge details
        final challenge = _allChallenges.firstWhere(
          (c) => c.id == userChallenge.challengeId,
          orElse: () => Challenge(
            id: userChallenge.challengeId,
            title: 'Unknown Challenge',
            description: 'Challenge details not available',
            type: 'unknown',
            targetValue: 0,
            difficultyLevel: 1,
            rewardValue: 0,
            metricType: 'unknown',
          ),
        );
        
        challengeWidgets.add(
          InkWell(
            onTap: () {
              // Navigate to challenge detail screen
              Navigator.of(context).pushNamed(
                CommunityRoutes.challengeDetail,
                arguments: challenge.id,
              );
            },
            borderRadius: BorderRadius.circular(8),
            child: _buildCompactChallengeItem(challenge, userChallenge),
          ),
        );
      }
    }
    
    // Add "Browse All Challenges" button
    challengeWidgets.add(
      Padding(
        padding: const EdgeInsets.symmetric(horizontal: 0.0, vertical: 8.0),
        child: InkWell(
          onTap: () {
            // Navigate to full challenges view
            Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => Scaffold(
                          appBar: AppBar(
                            title: const Text('Leaderboard'),
                            elevation: 0,
                            backgroundColor: Colors.white,
                            foregroundColor: Colors.black,
                            centerTitle: false,
                          ),
                          body: const Padding(
                            padding: EdgeInsets.symmetric(vertical: 8.0),
                            child: ChallengesView(),
                          ),
                        ),
                      ),
                    );
          },
          child: Container(
            padding: const EdgeInsets.symmetric(vertical: 14.0),
            decoration: BoxDecoration(
              border: Border.all(color: Colors.grey.shade300),
              borderRadius: BorderRadius.circular(8.0),
            ),
            child: const Center(
              child: Text(
                'Browse All Challenges',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
          ),
        ),
      ),
    );
    
    return ListView(
      padding: const EdgeInsets.symmetric(horizontal: 16.0),
      physics: const NeverScrollableScrollPhysics(),
      shrinkWrap: true,
      children: challengeWidgets,
    );
  }

  /// Build a compact challenge item for the main community screen
  Widget _buildCompactChallengeItem(Challenge challenge, UserChallenge userChallenge) {
    final progress = userChallenge.progress / challenge.targetValue;
    final formattedChallenge = _formatChallengeForUI(challenge, userChallenge: userChallenge);
    
    // Simplified item card to match mockup
    return Container(
      margin: const EdgeInsets.only(bottom: 16.0),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.grey.shade200),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Row(
              children: [
                // Trophy/Challenge icon
                Container(
                  width: 48,
                  height: 48,
                  decoration: BoxDecoration(
                    color: Colors.green.shade50,
                    borderRadius: BorderRadius.circular(6),
                  ),
                  child: Icon(
                    Icons.emoji_events_outlined,
                    color: Colors.green,
                    size: 28,
                  ),
                ),
                
                const SizedBox(width: 16),
                
                // Challenge info
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        formattedChallenge['title'] as String,
                        style: const TextStyle(
                          fontWeight: FontWeight.bold,
                          fontSize: 18,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Row(
                        children: [
                          Container(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 8, 
                              vertical: 4,
                            ),
                            decoration: BoxDecoration(
                              color: Colors.grey.shade100,
                              borderRadius: BorderRadius.circular(4),
                            ),
                            child: Text(
                              'Ongoing',
                              style: TextStyle(
                                color: Colors.grey.shade700,
                                fontSize: 12,
                              ),
                            ),
                          ),
                          const SizedBox(width: 12),
                          Icon(Icons.people, size: 16, color: Colors.grey.shade600),
                          const SizedBox(width: 4),
                          Text(
                            '${formattedChallenge['participants']}',
                            style: TextStyle(
                              color: Colors.grey.shade600,
                              fontSize: 12,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          
          // Progress section
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      '${(progress * 100).toInt()}% Complete',
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 14,
                      ),
                    ),
                    Text(
                      '${userChallenge.progress}/${challenge.targetValue}',
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        color: Colors.grey.shade700,
                        fontSize: 14,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                ClipRRect(
                  borderRadius: BorderRadius.circular(4),
                  child: LinearProgressIndicator(
                    value: progress,
                    backgroundColor: Colors.grey.shade200,
                    valueColor: AlwaysStoppedAnimation<Color>(AppColors.primary),
                    minHeight: 8,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCompactEmptyChallenges() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.emoji_events_outlined,
            size: 48,
            color: Colors.grey.shade400,
          ),
          const SizedBox(height: 16),
          const Text(
            'No active challenges',
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Join a challenge to get started',
            style: TextStyle(
              fontSize: 14,
              color: Colors.grey.shade600,
            ),
          ),
        ],
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/community/components/friends_view.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/presentation/providers/social_provider.dart';
import 'package:going50/core_models/user_profile.dart';
import 'package:going50/core/constants/route_constants.dart';

/// FriendsView displays the user's connections and allows finding new friends.
///
/// This component includes:
/// - List of current friends
/// - Ability to search for new friends
/// - Friend request functionality
/// - Can be displayed in compact mode for the main community screen
class FriendsView extends StatefulWidget {
  /// Whether to display in compact mode with limited entries and UI elements
  final bool isCompactMode;
  
  const FriendsView({
    super.key, 
    this.isCompactMode = false,
  });

  @override
  State<FriendsView> createState() => _FriendsViewState();
}

class _FriendsViewState extends State<FriendsView> {
  final TextEditingController _searchController = TextEditingController();
  bool _isSearching = false;
  String _searchQuery = '';
  
  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }
  
  @override
  Widget build(BuildContext context) {
    final provider = Provider.of<SocialProvider>(context);
    final friends = provider.friends;
    
    // In compact mode, display a simplified view
    if (widget.isCompactMode) {
      return _buildCompactView(context, friends, provider);
    }
    
    // Full view with search
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSearchBar(context),
        const SizedBox(height: 16),
        if (_isSearching)
          _buildSearchResults(context)
        else
          _buildFriendsList(context, friends),
      ],
    );
  }
  
  /// Build a compact view of friends for the main community screen
  Widget _buildCompactView(BuildContext context, List<UserProfile> friends, SocialProvider provider) {
    if (provider.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }
    
    if (friends.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.people_outline,
              size: 48,
              color: Colors.grey.shade400,
            ),
            const SizedBox(height: 8),
            const Text(
              'No friends yet',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
          ],
        ),
      );
    }
    
    // Show a limited number of friends in a simple format
    // Use just 2 items to ensure they're fully visible in compact view
    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16.0),
      physics: const NeverScrollableScrollPhysics(),
      itemCount: friends.length > 2 ? 2 : friends.length,
      itemBuilder: (context, index) {
        final friend = friends[index];
        return InkWell(
          onTap: () {
            // Navigate to friend profile
            Navigator.of(context).pushNamed(
              CommunityRoutes.friendProfile,
              arguments: friend.id,
            );
          },
          borderRadius: BorderRadius.circular(8),
          child: _buildCompactFriendItem(context, friend),
        );
      },
    );
  }
  
  /// Build a compact friend item for the main screen
  Widget _buildCompactFriendItem(BuildContext context, UserProfile friend) {
    // Get time-based activity text based on createdAt timestamp
    final activityText = _getRelativeActivityTime(friend.createdAt);
    
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.grey.shade200),
      ),
      child: Row(
        children: [
          // Avatar placeholder
          Container(
            width: 40,
            height: 40,
            decoration: BoxDecoration(
              color: Colors.grey.shade200,
              shape: BoxShape.circle,
            ),
            child: Center(
              child: Text(
                friend.name.substring(0, 1).toUpperCase(),
                style: TextStyle(
                  color: Colors.grey.shade700,
                  fontWeight: FontWeight.bold,
                  fontSize: 18,
                ),
              ),
            ),
          ),
          const SizedBox(width: 12),
          
          // Friend name
          Expanded(
            child: Text(
              friend.name,
              style: const TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          
          // Activity indicator - using actual data from user profile
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: AppColors.primary.withOpacity(0.1),
              borderRadius: BorderRadius.circular(4),
            ),
            child: Row(
              children: [
                Icon(
                  Icons.access_time,
                  size: 14,
                  color: AppColors.primary,
                ),
                const SizedBox(width: 4),
                Text(
                  activityText,
                  style: TextStyle(
                    fontSize: 12,
                    color: AppColors.primary,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  // Helper to determine relative time for friend activity
  String _getRelativeActivityTime(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);
    
    if (difference.inMinutes < 60) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inHours < 24) {
      return '${difference.inHours}h ago';
    } else if (difference.inDays < 7) {
      return '${difference.inDays}d ago';
    } else {
      return '${(difference.inDays / 7).round()}w ago';
    }
  }
  
  Widget _buildSearchBar(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            decoration: BoxDecoration(
              color: Colors.grey.shade100,
              borderRadius: BorderRadius.circular(24),
              border: Border.all(color: Colors.grey.shade300),
            ),
            child: TextField(
              controller: _searchController,
              decoration: InputDecoration(
                hintText: 'Search for friends...',
                prefixIcon: const Icon(Icons.search),
                suffixIcon: _searchController.text.isNotEmpty
                    ? IconButton(
                        icon: const Icon(Icons.clear),
                        onPressed: () {
                          _searchController.clear();
                          setState(() {
                            _isSearching = false;
                            _searchQuery = '';
                          });
                        },
                      )
                    : null,
                border: InputBorder.none,
                contentPadding: const EdgeInsets.symmetric(
                  vertical: 15,
                  horizontal: 16,
                ),
              ),
              onChanged: (value) {
                setState(() {
                  _searchQuery = value;
                  _isSearching = value.isNotEmpty;
                });
              },
            ),
          ),
          const SizedBox(height: 16),
          if (!_isSearching)
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'My Friends',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                ElevatedButton.icon(
                  onPressed: () {
                    // Show find friends dialog
                    _showFindFriendsDialog(context);
                  },
                  icon: const Icon(Icons.person_add, size: 16),
                  label: const Text('Find Friends'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppColors.primary,
                    foregroundColor: Colors.white,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(20),
                    ),
                    padding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 8,
                    ),
                  ),
                ),
              ],
            ),
        ],
      ),
    );
  }
  
  Widget _buildFriendsList(BuildContext context, List<UserProfile> friends) {
    return Expanded(
      child: friends.isEmpty
          ? _buildEmptyFriendsList()
          : ListView.builder(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              itemCount: friends.length,
              itemBuilder: (context, index) {
                final friend = friends[index];
                return _buildFriendCard(context, friend);
              },
            ),
    );
  }
  
  Widget _buildEmptyFriendsList() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.people_outline,
            size: 64,
            color: Colors.grey.shade400,
          ),
          const SizedBox(height: 16),
          const Text(
            'No friends yet',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Connect with other eco-drivers',
            style: TextStyle(
              fontSize: 14,
              color: Colors.grey.shade600,
            ),
          ),
          const SizedBox(height: 24),
          ElevatedButton.icon(
            onPressed: () {
              // Show find friends dialog
              _showFindFriendsDialog(context);
            },
            icon: const Icon(Icons.person_add),
            label: const Text('Find Friends'),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.primary,
              foregroundColor: Colors.white,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(20),
              ),
              padding: const EdgeInsets.symmetric(
                horizontal: 16,
                vertical: 12,
              ),
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildFriendCard(BuildContext context, UserProfile friend) {
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Row(
          children: [
            // Avatar placeholder
            Container(
              width: 48,
              height: 48,
              decoration: BoxDecoration(
                color: Colors.grey.shade300,
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.person,
                color: Colors.grey.shade700,
                size: 32,
              ),
            ),
            const SizedBox(width: 16),
            
            // Friend info
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    friend.name,
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  Text(
                    'Member since ${_formatDate(friend.createdAt)}',
                    style: TextStyle(
                      fontSize: 12,
                      color: Colors.grey.shade600,
                    ),
                  ),
                ],
              ),
            ),
            
            // Actions
            IconButton(
              icon: const Icon(Icons.message_outlined),
              color: AppColors.secondary,
              onPressed: () {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Messaging feature coming soon'),
                    duration: Duration(seconds: 2),
                  ),
                );
              },
            ),
            IconButton(
              icon: const Icon(Icons.person_outlined),
              color: AppColors.secondary,
              onPressed: () {
                // Navigate to friend profile
                Navigator.of(context).pushNamed(
                  CommunityRoutes.friendProfile,
                  arguments: friend.id,
                );
              },
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildSearchResults(BuildContext context) {
    // Mock search results - in a real app, this would query a database
    final List<Map<String, dynamic>> searchResults = [
      {
        'id': 'result1',
        'name': 'Chris Taylor',
        'mutualFriends': 3,
        'ecoScore': 87,
      },
      {
        'id': 'result2',
        'name': 'Jordan Kim',
        'mutualFriends': 1,
        'ecoScore': 92,
      },
      {
        'id': 'result3',
        'name': 'Robin Chen',
        'mutualFriends': 0,
        'ecoScore': 76,
      },
    ].where((user) => 
        (user['name'] as String).toLowerCase().contains(_searchQuery.toLowerCase())
    ).toList();
    
    return Expanded(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Text(
              'Search Results (${searchResults.length})',
              style: const TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          const SizedBox(height: 8),
          Expanded(
            child: searchResults.isEmpty
                ? Center(
                    child: Text(
                      'No users found matching "$_searchQuery"',
                      style: TextStyle(
                        color: Colors.grey.shade600,
                      ),
                    ),
                  )
                : ListView.builder(
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    itemCount: searchResults.length,
                    itemBuilder: (context, index) {
                      final result = searchResults[index];
                      return _buildSearchResultCard(context, result);
                    },
                  ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildSearchResultCard(BuildContext context, Map<String, dynamic> result) {
    final SocialProvider provider = Provider.of<SocialProvider>(context, listen: false);
    
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Row(
          children: [
            // Avatar placeholder
            Container(
              width: 48,
              height: 48,
              decoration: BoxDecoration(
                color: Colors.grey.shade300,
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.person,
                color: Colors.grey.shade700,
                size: 32,
              ),
            ),
            const SizedBox(width: 16),
            
            // User info
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    result['name'],
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Flexible(
                    child: Wrap(
                      spacing: 8,
                      runSpacing: 4,
                      children: [
                        Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(
                              Icons.people_outline,
                              size: 12,
                              color: Colors.grey.shade700,
                            ),
                            const SizedBox(width: 4),
                            Flexible(
                              child: Text(
                                '${result['mutualFriends']} mutual friends',
                                style: TextStyle(
                                  fontSize: 12,
                                  color: Colors.grey.shade700,
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ),
                          ],
                        ),
                        Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(
                              Icons.eco_outlined,
                              size: 12,
                              color: AppColors.getEcoScoreColor(result['ecoScore'].toDouble()),
                            ),
                            const SizedBox(width: 4),
                            Text(
                              'Eco Score: ${result['ecoScore']}',
                              style: TextStyle(
                                fontSize: 12,
                                color: Colors.grey.shade700,
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
            
            // Add friend button
            ElevatedButton(
              onPressed: () async {
                final success = await provider.addFriend(result['id']);
                if (success && mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text('Friend request sent to ${result['name']}'),
                      duration: const Duration(seconds: 2),
                    ),
                  );
                  
                  // Clear search
                  _searchController.clear();
                  setState(() {
                    _isSearching = false;
                    _searchQuery = '';
                  });
                }
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: AppColors.primary,
                foregroundColor: Colors.white,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20),
                ),
                minimumSize: const Size(40, 36),
                padding: const EdgeInsets.symmetric(horizontal: 12),
              ),
              child: const Text('Add'),
            ),
          ],
        ),
      ),
    );
  }
  
  void _showFindFriendsDialog(BuildContext context) {
    showModalBottomSheet<void>(
      context: context,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (BuildContext context) {
        return Padding(
          padding: EdgeInsets.only(
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          child: Container(
            padding: const EdgeInsets.all(24),
            height: MediaQuery.of(context).size.height * 0.7,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Find Friends',
                  style: TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                const Text(
                  'Connect with other eco-drivers to compare your performance and compete in challenges together.',
                  style: TextStyle(
                    fontSize: 14,
                    color: Colors.grey,
                  ),
                ),
                const SizedBox(height: 24),
                Container(
                  decoration: BoxDecoration(
                    color: Colors.grey.shade100,
                    borderRadius: BorderRadius.circular(24),
                    border: Border.all(color: Colors.grey.shade300),
                  ),
                  child: const TextField(
                    decoration: InputDecoration(
                      hintText: 'Search by name or email',
                      prefixIcon: Icon(Icons.search),
                      border: InputBorder.none,
                      contentPadding: EdgeInsets.symmetric(
                        vertical: 15,
                        horizontal: 16,
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 24),
                const Text(
                  'Suggested Friends',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                Expanded(
                  child: ListView(
                    children: [
                      _buildSuggestedFriendTile(
                        'Riley Johnson',
                        'Based on your location',
                        4,
                        88,
                      ),
                      const SizedBox(height: 12),
                      _buildSuggestedFriendTile(
                        'Morgan Smith',
                        'Similar driving patterns',
                        2,
                        92,
                      ),
                      const SizedBox(height: 12),
                      _buildSuggestedFriendTile(
                        'Casey Williams',
                        'Completed same challenges',
                        1,
                        79,
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: () {
                      Navigator.pop(context);
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppColors.primary,
                      foregroundColor: Colors.white,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(24),
                      ),
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                    child: const Text('Close'),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
  
  Widget _buildSuggestedFriendTile(
    String name, String reason, int mutualFriends, int ecoScore) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade200),
      ),
      child: Row(
        children: [
          Container(
            width: 48,
            height: 48,
            decoration: BoxDecoration(
              color: Colors.grey.shade300,
              shape: BoxShape.circle,
            ),
            child: Icon(
              Icons.person,
              color: Colors.grey.shade700,
              size: 32,
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  name,
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  reason,
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey.shade600,
                  ),
                ),
                const SizedBox(height: 4),
                Flexible(
                  child: Wrap(
                    spacing: 8,
                    runSpacing: 4,
                    children: [
                      Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(
                            Icons.people_outline,
                            size: 12,
                            color: Colors.grey.shade700,
                          ),
                          const SizedBox(width: 4),
                          Flexible(
                            child: Text(
                              '$mutualFriends mutual friends',
                              style: TextStyle(
                                fontSize: 12,
                                color: Colors.grey.shade700,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                          ),
                        ],
                      ),
                      Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(
                            Icons.eco_outlined,
                            size: 12,
                            color: AppColors.getEcoScoreColor(ecoScore.toDouble()),
                          ),
                          const SizedBox(width: 4),
                          Text(
                            'Eco Score: $ecoScore',
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.grey.shade700,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          ElevatedButton(
            onPressed: () {},
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.primary,
              foregroundColor: Colors.white,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(20),
              ),
              minimumSize: const Size(40, 36),
              padding: const EdgeInsets.symmetric(horizontal: 12),
            ),
            child: const Text('Add'),
          ),
        ],
      ),
    );
  }
  
  String _formatDate(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date);
    
    if (difference.inDays < 30) {
      return '${difference.inDays} days ago';
    } else if (difference.inDays < 365) {
      final months = (difference.inDays / 30).floor();
      return '$months ${months == 1 ? 'month' : 'months'} ago';
    } else {
      final years = (difference.inDays / 365).floor();
      return '$years ${years == 1 ? 'year' : 'years'} ago';
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/community/components/shared_filters.dart
################################################################################

import 'package:flutter/material.dart';

import 'package:going50/core/theme/app_colors.dart';

/// Shared filter components for community screens.
/// 
/// These components ensure consistent styling and behavior across
/// the leaderboard and challenges views.

/// SegmentedFilterBar provides a segmented control for filtering content.
///
/// Used across multiple components for consistent filtering UI.
class SegmentedFilterBar extends StatelessWidget {
  final List<String> options;
  final int selectedIndex;
  final Function(int) onSelectionChanged;
  
  const SegmentedFilterBar({
    super.key,
    required this.options,
    required this.selectedIndex,
    required this.onSelectionChanged,
  });
  
  @override
  Widget build(BuildContext context) {
    // Clean, modern design with better spacing and visual clarity
    return Container(
      height: 52, // Optimal touch target height
      margin: const EdgeInsets.only(top: 4.0, bottom: 16.0), // Better spacing
      padding: const EdgeInsets.symmetric(horizontal: 16.0),
      decoration: BoxDecoration(
        color: Colors.white, // Clean white background
        border: Border(
          bottom: BorderSide(color: Colors.grey.shade200, width: 1), // Subtle bottom border only
        ),
      ),
      child: Row(
        children: List.generate(
          options.length,
          (index) => Expanded(
            child: GestureDetector(
              onTap: () => onSelectionChanged(index),
              child: Container(
                margin: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 2.0),
                decoration: BoxDecoration(
                  color: Colors.white, // Keep it clean
                  borderRadius: BorderRadius.circular(12), // More rounded corners
                  border: selectedIndex == index
                      ? Border.all(color: AppColors.primary, width: 1.5) // Slightly thicker border for emphasis
                      : null,
                ),
                child: Center(
                  child: Text(
                    options[index],
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: selectedIndex == index ? FontWeight.w600 : FontWeight.w400,
                      color: selectedIndex == index ? AppColors.primary : Colors.grey.shade500,
                    ),
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

/// TimeFilterChipGroup provides chips for time-based filtering.
///
/// Used across multiple components for consistent time filtering UI.
class TimeFilterChipGroup extends StatelessWidget {
  final List<String> options;
  final int selectedIndex;
  final Function(int) onSelectionChanged;
  
  const TimeFilterChipGroup({
    super.key,
    required this.options,
    required this.selectedIndex,
    required this.onSelectionChanged,
  });
  
  @override
  Widget build(BuildContext context) {
    // Modern pill-style design with better spacing
    return Container(
      height: 44, // Optimal height
      margin: const EdgeInsets.only(bottom: 24.0), // More bottom margin for better section separation
      padding: const EdgeInsets.symmetric(horizontal: 16.0),
      child: Row(
        children: List.generate(
          options.length,
          (index) {
            final isSelected = selectedIndex == index;
            
            return Padding(
              padding: EdgeInsets.only(right: index < options.length - 1 ? 12 : 0), // More space between chips
              child: GestureDetector(
                onTap: () => onSelectionChanged(index),
                child: AnimatedContainer(
                  duration: const Duration(milliseconds: 200), // Smooth transition
                  padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10), // More comfortable padding
                  decoration: BoxDecoration(
                    color: isSelected ? AppColors.primary : Colors.white,
                    borderRadius: BorderRadius.circular(22), // More pronounced pill shape
                    border: Border.all(
                      color: isSelected ? AppColors.primary : Colors.grey.shade300,
                      width: isSelected ? 1.5 : 1, // Thicker border for selected item
                    ),
                    // Subtle shadow for depth
                    boxShadow: isSelected ? [
                      BoxShadow(
                        color: AppColors.primary.withOpacity(0.2),
                        blurRadius: 4,
                        offset: const Offset(0, 2),
                      ),
                    ] : null,
                  ),
                  child: Text(
                    options[index],
                    style: TextStyle(
                      fontSize: 14,
                      color: isSelected ? Colors.white : Colors.grey.shade700,
                      fontWeight: isSelected ? FontWeight.w600 : FontWeight.w400,
                    ),
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/drive/trip_summary_screen.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:going50/core/constants/route_constants.dart';
import 'package:going50/core_models/trip.dart';
import 'package:going50/presentation/providers/driving_provider.dart';
import 'package:going50/presentation/screens/drive/components/trip_overview_header.dart';
import 'package:going50/presentation/screens/drive/components/savings_metrics_section.dart';
import 'package:going50/presentation/screens/drive/components/behavior_breakdown_chart.dart';
import 'package:going50/presentation/screens/drive/components/improvement_suggestion_card.dart';
import 'package:going50/services/driving/analytics_service.dart';

/// A screen that displays a detailed summary of a completed trip.
///
/// This screen shows:
/// - Basic trip information (date, time, duration, distance)
/// - Eco-score and driving behavior analysis
/// - Estimated savings (fuel, CO2, money)
/// - Improvement suggestions for future trips
class TripSummaryScreen extends StatefulWidget {
  /// Optional trip ID to display a historical trip
  /// If not provided, the most recently completed trip will be shown
  final String? tripId;
  
  /// Constructor
  const TripSummaryScreen({
    super.key,
    this.tripId,
  });

  @override
  State<TripSummaryScreen> createState() => _TripSummaryScreenState();
}

class _TripSummaryScreenState extends State<TripSummaryScreen> {
  Trip? _trip;
  double _ecoScore = 0.0;
  List<FeedbackSuggestion> _suggestions = [];
  bool _isLoading = true;
  String? _errorMessage;
  
  @override
  void initState() {
    super.initState();
    _loadTripData();
  }
  
  /// Load trip data and related metrics
  Future<void> _loadTripData() async {
    final drivingProvider = Provider.of<DrivingProvider>(context, listen: false);
    
    try {
      setState(() {
        _isLoading = true;
      });
      
      Trip? loadedTrip;
      
      // Get the trip data
      if (widget.tripId != null) {
        // We need to implement this method in the driving provider
        // For now, we'll use the most recent trip
        final trips = await drivingProvider.getTrips(limit: 5);
        loadedTrip = trips.isNotEmpty 
            ? trips.firstWhere(
                (t) => t.id == widget.tripId,
                orElse: () => trips.first,
              )
            : null;
      } else {
        // Get most recent trip
        final trips = await drivingProvider.getTrips(limit: 1);
        loadedTrip = trips.isNotEmpty ? trips.first : null;
      }
      
      if (loadedTrip != null) {
        _trip = loadedTrip;
        _ecoScore = drivingProvider.currentEcoScore;
        
        // For now, we'll create some mock suggestions since we can't
        // directly access the analytics service
        _suggestions = _createMockSuggestions();
      }
      
      setState(() {
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _isLoading = false;
        _errorMessage = 'Failed to load trip data: $e';
      });
    }
  }
  
  /// Create mock suggestions for demonstration
  List<FeedbackSuggestion> _createMockSuggestions() {
    return [
      FeedbackSuggestion(
        category: 'calmDriving',
        suggestion: 'Try to accelerate and brake more gently',
        benefit: 'Smoother driving can improve fuel efficiency by up to 30%',
        priority: 3,
      ),
      FeedbackSuggestion(
        category: 'speedOptimization',
        suggestion: 'Maintain a steady speed between 50-80 km/h when possible',
        benefit: 'Optimal speed ranges use fuel more efficiently',
        priority: 2,
      ),
      FeedbackSuggestion(
        category: 'idling',
        suggestion: 'Consider turning off the engine when stopped for more than 30 seconds',
        benefit: 'Reducing idling can save up to 2% in fuel consumption',
        priority: 1,
      ),
    ];
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Trip Summary'),
        leading: IconButton(
          icon: const Icon(Icons.close),
          onPressed: () {
            // Navigate back to the app root (TabNavigator)
            Navigator.of(context).popUntil((route) => route.isFirst);
          },
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.share),
            onPressed: () {
              // TODO: Implement sharing functionality
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Sharing coming soon!'))
              );
            },
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _trip == null
              ? _buildNoTripView()
              : _buildTripSummary(),
    );
  }
  
  /// Builds the trip summary content
  Widget _buildTripSummary() {
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Trip overview header
          TripOverviewHeader(
            trip: _trip!,
            ecoScore: _ecoScore,
          ),
          
          // Savings metrics
          SavingsMetricsSection(
            trip: _trip!,
            ecoScore: _ecoScore,
          ),
          
          // Driving behavior breakdown
          BehaviorBreakdownChart(
            trip: _trip!,
          ),
          
          // Improvement suggestions
          if (_suggestions.isNotEmpty) ...[
            Padding(
              padding: const EdgeInsets.fromLTRB(24, 16, 24, 8),
              child: Text(
                'Suggestions for Improvement',
                style: Theme.of(context).textTheme.titleLarge?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              child: Column(
                children: _suggestions
                    .take(3) // Limit to 3 suggestions
                    .map((s) => Padding(
                          padding: const EdgeInsets.symmetric(vertical: 8),
                          child: ImprovementSuggestionCard(suggestion: s),
                        ))
                    .toList(),
              ),
            ),
          ],
          
          // Add Bottom Action Buttons
          Padding(
            padding: const EdgeInsets.fromLTRB(24, 32, 24, 40),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // Primary Share Button
                ElevatedButton.icon(
                  icon: const Icon(Icons.share),
                  label: const Text('Share Your Trip'),
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  onPressed: () {
                    // TODO: Implement sharing functionality
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Sharing coming soon!'))
                    );
                  },
                ),
                
                const SizedBox(height: 12),
                
                // Secondary Close Button
                OutlinedButton(
                  child: const Text('Close Summary'),
                  style: OutlinedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  onPressed: () {
                    // Navigate back to the app root (TabNavigator)
                    Navigator.of(context).popUntil((route) => route.isFirst);
                  },
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  /// Builds the view shown when no trip is available
  Widget _buildNoTripView() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(
            Icons.error_outline,
            size: 64,
            color: Colors.grey,
          ),
          const SizedBox(height: 16),
          Text(
            'No trip data available',
            style: Theme.of(context).textTheme.titleLarge,
          ),
          const SizedBox(height: 8),
          Text(
            _errorMessage ?? 'Try completing a trip first',
            style: Theme.of(context).textTheme.bodyMedium,
          ),
          const SizedBox(height: 24),
          ElevatedButton(
            onPressed: () {
              // Navigate back to the app root (TabNavigator)
              Navigator.of(context).popUntil((route) => route.isFirst);
            },
            child: const Text('Go to Drive'),
          ),
        ],
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/drive/active_drive_screen.dart
################################################################################

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:going50/core/constants/route_constants.dart';
import 'package:going50/presentation/providers/driving_provider.dart';
import 'package:going50/presentation/screens/drive/components/eco_score_display.dart';
import 'package:going50/presentation/screens/drive/components/current_metrics_strip.dart';
import 'package:going50/presentation/screens/drive/components/event_notification.dart';
import 'package:going50/core_models/driving_event.dart';

/// ActiveDriveScreen is the distraction-minimized screen shown during active driving.
///
/// This screen provides real-time feedback on driving performance while minimizing
/// distractions. It features a large eco-score, essential metrics, and event notifications.
class ActiveDriveScreen extends StatefulWidget {
  const ActiveDriveScreen({super.key});

  @override
  State<ActiveDriveScreen> createState() => _ActiveDriveScreenState();
}

class _ActiveDriveScreenState extends State<ActiveDriveScreen> with WidgetsBindingObserver {
  // Event notification display
  DrivingEvent? _currentEvent;
  Timer? _eventTimer;
  // Track the last processed event to avoid duplicate notifications
  DrivingEvent? _lastProcessedEvent;
  
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    
    // Set preferred orientation to portrait
    SystemChrome.setPreferredOrientations([
      DeviceOrientation.portraitUp,
      DeviceOrientation.portraitDown,
    ]);
    
    // Set system UI to immersive mode during driving
    _setImmersiveMode();
    
    // Schedule a check for events after the first build is complete
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _checkForNewEvents();
    });
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    
    // Reset orientation constraints
    SystemChrome.setPreferredOrientations([]);
    
    // Reset system UI
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.edgeToEdge);
    
    _eventTimer?.cancel();
    super.dispose();
  }
  
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      // When app is resumed, reset immersive mode
      _setImmersiveMode();
    }
  }
  
  // Set immersive mode to minimize distractions
  void _setImmersiveMode() {
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);
  }
  
  void _checkForNewEvents() {
    if (!mounted) return;
    
    final drivingProvider = Provider.of<DrivingProvider>(context, listen: false);
    
    if (drivingProvider.recentEvents.isNotEmpty && 
        _lastProcessedEvent != drivingProvider.recentEvents.first) {
      _lastProcessedEvent = drivingProvider.recentEvents.first;
      _showEventNotification(_lastProcessedEvent!);
    }
  }

  void _showEventNotification(DrivingEvent event) {
    // Only call setState if we're not currently in build phase
    if (mounted) {
      setState(() {
        _currentEvent = event;
      });
      
      // Clear previous timer if it exists
      _eventTimer?.cancel();
      
      // Set a timer to clear the notification after 3 seconds
      _eventTimer = Timer(const Duration(seconds: 3), () {
        if (mounted) {
          setState(() {
            _currentEvent = null;
          });
        }
      });
    }
  }
  
  void _endTrip(BuildContext context) async {
    final navigator = Navigator.of(context);
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final drivingProvider = Provider.of<DrivingProvider>(context, listen: false);
    
    final success = await drivingProvider.endTrip();
    
    if (!mounted) return;
    
    if (success) {
      // Navigate to trip summary screen
      navigator.pushReplacementNamed(DriveRoutes.tripSummary);
    } else {
      scaffoldMessenger.showSnackBar(
        const SnackBar(content: Text('Failed to end trip. Please try again.')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<DrivingProvider>(
      builder: (context, drivingProvider, child) {
        // Instead of calling _showEventNotification directly in build,
        // we schedule it for after this frame is complete
        WidgetsBinding.instance.addPostFrameCallback((_) {
          _checkForNewEvents();
        });
        
        return Scaffold(
          backgroundColor: Colors.black,
          body: SafeArea(
            child: Stack(
              children: [
                // Main content
                Column(
                  children: [
                    // Status bar with minimal info
                    _buildStatusBar(context, drivingProvider),
                    
                    // Main eco-score display (takes most of the screen)
                    Expanded(
                      flex: 7,
                      child: EcoScoreDisplay(
                        ecoScore: drivingProvider.currentEcoScore,
                      ),
                    ),
                    
                    // Current metrics strip at bottom
                    Expanded(
                      flex: 2,
                      child: CurrentMetricsStrip(
                        onEndTripTap: () => _endTrip(context),
                      ),
                    ),
                  ],
                ),
                
                // Event notification overlay (conditionally shown)
                if (_currentEvent != null)
                  Positioned(
                    top: 100,
                    left: 0,
                    right: 0,
                    child: EventNotification(
                      event: _currentEvent!,
                    ),
                  ),
              ],
            ),
          ),
        );
      },
    );
  }
  
  Widget _buildStatusBar(BuildContext context, DrivingProvider drivingProvider) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.black.withAlpha(178),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          // Trip duration
          Text(
            drivingProvider.currentTrip?.startTime != null 
                ? _formatDuration(DateTime.now().difference(drivingProvider.currentTrip!.startTime))
                : '00:00',
            style: const TextStyle(
              color: Colors.white,
              fontWeight: FontWeight.bold,
            ),
          ),
          
          // Exit button
          IconButton(
            icon: const Icon(Icons.close, color: Colors.white),
            onPressed: () => _endTrip(context),
          ),
        ],
      ),
    );
  }
  
  String _formatDuration(Duration duration) {
    String twoDigits(int n) => n.toString().padLeft(2, '0');
    String twoDigitMinutes = twoDigits(duration.inMinutes.remainder(60));
    String twoDigitSeconds = twoDigits(duration.inSeconds.remainder(60));
    return "$twoDigitMinutes:$twoDigitSeconds";
  }
} 

################################################################################
FILE: lib/presentation/screens/drive/drive_screen.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/core/constants/route_constants.dart';
import 'package:going50/presentation/providers/driving_provider.dart';
import 'package:going50/presentation/providers/insights_provider.dart';
import 'package:going50/presentation/screens/drive/components/connection_status_widget.dart';
import 'package:going50/presentation/screens/drive/components/start_trip_button.dart';
import 'package:going50/presentation/screens/drive/components/recent_trip_card.dart';
import 'package:going50/core_models/trip.dart';
import 'package:going50/services/service_locator.dart';
import 'package:going50/services/permission_service.dart';

/// DriveScreen is the main screen for the Drive tab.
///
/// This screen provides access to trip recording functionality and displays
/// connection status as well as recent trip information.
class DriveScreen extends StatefulWidget {
  const DriveScreen({super.key});

  @override
  State<DriveScreen> createState() => _DriveScreenState();
}

class _DriveScreenState extends State<DriveScreen> {
  bool _audioFeedbackEnabled = true;
  
  @override
  Widget build(BuildContext context) {
    final drivingProvider = Provider.of<DrivingProvider>(context);
    final insightsProvider = Provider.of<InsightsProvider>(context);
    final currentEcoScore = drivingProvider.currentEcoScore;
    final ecoScoreColor = AppColors.getEcoScoreColor(currentEcoScore);
    final isFirstUse = insightsProvider.recentTrips.isEmpty;
    final mostRecentTrip = insightsProvider.recentTrips.isNotEmpty 
        ? insightsProvider.recentTrips.first 
        : null;
    
    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Status section (30% of the screen)
              Expanded(
                flex: 3,
                child: _buildStatusSection(
                  context, 
                  drivingProvider, 
                  currentEcoScore, 
                  ecoScoreColor
                ),
              ),
              
              // Action section (40% of the screen)
              Expanded(
                flex: 4,
                child: _buildActionSection(
                  context, 
                  drivingProvider
                ),
              ),
              
              // Quick stats section (30% of the screen)
              Expanded(
                flex: 3,
                child: _buildQuickStatsSection(
                  context, 
                  isFirstUse, 
                  mostRecentTrip
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  /// Builds the status section with connection status and eco-score
  Widget _buildStatusSection(
    BuildContext context, 
    DrivingProvider drivingProvider,
    double currentEcoScore,
    Color ecoScoreColor,
  ) {
    final statusMessage = _getStatusMessage(drivingProvider);
    
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // Connection status
          const ConnectionStatusWidget(),
          
          const SizedBox(height: 16),
          
          // Latest eco-score
          if (drivingProvider.isObdConnected || drivingProvider.isCollecting)
            Column(
              children: [
                Container(
                  width: 80,
                  height: 80,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    color: ecoScoreColor.withOpacity(0.1),
                    border: Border.all(
                      color: ecoScoreColor,
                      width: 2,
                    ),
                  ),
                  child: Center(
                    child: Text(
                      currentEcoScore.toInt().toString(),
                      style: TextStyle(
                        fontSize: 32,
                        fontWeight: FontWeight.bold,
                        color: ecoScoreColor,
                      ),
                    ),
                  ),
                ),
                
                const SizedBox(height: 8),
                
                // Status message
                Text(
                  statusMessage,
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
            ),
        ],
      ),
    );
  }
  
  /// Builds the action section with Start Trip button
  Widget _buildActionSection(BuildContext context, DrivingProvider drivingProvider) {
    return SingleChildScrollView(
      child: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // Start trip button
            StartTripButton(
              size: 100,
              onBeforeStart: () async {
                // Show an explanation dialog about permissions and wait for user to acknowledge
                // before proceeding with permission requests
                bool? dialogResult = await showDialog<bool>(
                  context: context,
                  barrierDismissible: false, // User must take an action
                  builder: (context) => AlertDialog(
                    title: const Text('Required Permissions'),
                    content: const Text(
                      'Going50 needs access to your location and motion sensors to track your trip. '
                      'Bluetooth access may also be requested for OBD connectivity. '
                      'These permissions are only used while you are actively recording a trip.'
                    ),
                    actions: [
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(false),
                        child: const Text('Cancel'),
                      ),
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(true),
                        child: const Text('Continue'),
                      ),
                    ],
                  ),
                );
                
                // If user didn't confirm, stop the flow by throwing an exception
                // The StartTripButton will catch this and not proceed
                if (dialogResult != true) {
                  throw Exception('Permission dialog canceled by user');
                }
              },
            ),
            
            const SizedBox(height: 16),
            
            // Device connection shortcut (if not connected)
            if (!drivingProvider.isObdConnected)
              TextButton.icon(
                onPressed: () {
                  // Navigate to device connection screen
                  Navigator.of(context).pushNamed(ProfileRoutes.deviceConnection);
                },
                icon: const Icon(Icons.bluetooth),
                label: const Text('Connect OBD Device'),
                style: TextButton.styleFrom(
                  foregroundColor: AppColors.secondary,
                ),
              ),
              
            const SizedBox(height: 24),
            
            // Audio feedback toggle
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Text(
                  'Audio Feedback',
                  style: TextStyle(
                    fontSize: 16,
                  ),
                ),
                const SizedBox(width: 8),
                Switch(
                  value: _audioFeedbackEnabled,
                  onChanged: (value) {
                    setState(() {
                      _audioFeedbackEnabled = value;
                    });
                    // TODO: Implement audio feedback toggle in driving provider
                  },
                  activeColor: AppColors.primary,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
  
  /// Builds the quick stats section with recent trip or first use card
  Widget _buildQuickStatsSection(
    BuildContext context, 
    bool isFirstUse, 
    Trip? mostRecentTrip,
  ) {
    if (isFirstUse) {
      return _buildFirstUseCard(context);
    } else if (mostRecentTrip != null) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Padding(
            padding: EdgeInsets.only(bottom: 8),
            child: Text(
              'Recent Trip',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          Expanded(
            child: RecentTripCard(
              trip: mostRecentTrip,
              onTap: () {
                // TODO: Navigate to trip details
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Trip details not yet implemented'),
                  ),
                );
              },
            ),
          ),
          const SizedBox(height: 8),
          Center(
            child: Text(
              'Pull for more',
              style: TextStyle(
                fontSize: 12,
                color: AppColors.textSecondary,
              ),
            ),
          ),
        ],
      );
    } else {
      return const Center(
        child: CircularProgressIndicator(),
      );
    }
  }
  
  /// Builds a card for first-time users
  Widget _buildFirstUseCard(BuildContext context) {
    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(
                Icons.directions_car,
                size: 48,
                color: AppColors.primary,
              ),
              const SizedBox(height: 12),
              const Text(
                'Welcome to Going50!',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 8),
              const Text(
                'Start your first trip to begin tracking your eco-driving performance.',
                style: TextStyle(fontSize: 14),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 12),
              OutlinedButton(
                onPressed: () {
                  // TODO: Navigate to onboarding guide or help
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Help not yet implemented'),
                    ),
                  );
                },
                style: OutlinedButton.styleFrom(
                  foregroundColor: AppColors.primary,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(24),
                  ),
                ),
                child: const Text('Learn More'),
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  /// Gets an appropriate status message based on the current driving state
  String _getStatusMessage(DrivingProvider drivingProvider) {
    if (drivingProvider.isRecording) {
      return 'Trip in progress';
    } else if (drivingProvider.isObdConnected) {
      return 'Ready to drive';
    } else if (drivingProvider.isCollecting) {
      return 'Using phone sensors';
    } else if (drivingProvider.errorMessage != null) {
      return 'Connection error';
    } else {
      return 'Connect device to start';
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/drive/components/event_notification.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:going50/core_models/driving_event.dart';
import 'package:going50/core/theme/app_colors.dart';

/// A component to display driving event notifications.
///
/// This appears temporarily when significant driving events occur
/// (like aggressive acceleration, hard braking, etc.) to provide
/// immediate feedback to the driver.
class EventNotification extends StatelessWidget {
  /// The driving event to display
  final DrivingEvent event;
  
  /// Constructor
  const EventNotification({
    super.key,
    required this.event,
  });

  @override
  Widget build(BuildContext context) {
    // Format the event info
    final eventInfo = _getEventInfo(event);
    
    return SafeArea(
      child: Center(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
            decoration: BoxDecoration(
              color: eventInfo.backgroundColor,
              borderRadius: BorderRadius.circular(12),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.3),
                  blurRadius: 10,
                  offset: const Offset(0, 4),
                ),
              ],
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Icon
                Icon(
                  eventInfo.icon,
                  color: eventInfo.iconColor,
                  size: 32,
                ),
                const SizedBox(width: 12),
                
                // Message
                Flexible(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Event title
                      Text(
                        eventInfo.title,
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      if (eventInfo.message.isNotEmpty) ...[
                        const SizedBox(height: 4),
                        // Event message
                        Text(
                          eventInfo.message,
                          style: const TextStyle(
                            color: Colors.white70,
                            fontSize: 14,
                          ),
                        ),
                      ],
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
  
  /// Returns formatted event information based on event type
  _EventInfo _getEventInfo(DrivingEvent event) {
    switch (event.eventType) {
      case 'behavior_aggressive_acceleration':
        return _EventInfo(
          title: 'Aggressive Acceleration',
          message: 'Try accelerating more gradually',
          icon: Icons.speed,
          iconColor: Colors.white,
          backgroundColor: AppColors.ecoScoreLow.withOpacity(0.9),
        );
        
      case 'behavior_hard_braking':
        return _EventInfo(
          title: 'Hard Braking',
          message: 'Anticipate stops for smoother braking',
          icon: Icons.do_not_disturb,
          iconColor: Colors.white,
          backgroundColor: AppColors.ecoScoreLow.withOpacity(0.9),
        );
        
      case 'behavior_idling':
        return _EventInfo(
          title: 'Extended Idling',
          message: 'Consider turning off engine when stopped',
          icon: Icons.timer,
          iconColor: Colors.white,
          backgroundColor: AppColors.ecoScoreMedium.withOpacity(0.9),
        );
        
      case 'behavior_excessive_speed':
        return _EventInfo(
          title: 'Excessive Speed',
          message: 'Reduce speed for optimal efficiency',
          icon: Icons.shutter_speed,
          iconColor: Colors.white,
          backgroundColor: AppColors.ecoScoreLow.withOpacity(0.9),
        );
        
      case 'behavior_optimal_speed':
        return _EventInfo(
          title: 'Optimal Speed',
          message: 'Great job maintaining efficient speed',
          icon: Icons.thumb_up,
          iconColor: Colors.white,
          backgroundColor: AppColors.ecoScoreHigh.withOpacity(0.9),
        );
        
      case 'behavior_high_rpm':
        return _EventInfo(
          title: 'High RPM',
          message: 'Consider shifting up for better efficiency',
          icon: Icons.swap_vert_circle,
          iconColor: Colors.white,
          backgroundColor: AppColors.ecoScoreMedium.withOpacity(0.9),
        );
        
      case 'trip_started':
        return _EventInfo(
          title: 'Trip Started',
          message: '',
          icon: Icons.play_circle,
          iconColor: Colors.white,
          backgroundColor: AppColors.secondary.withOpacity(0.9),
        );
        
      case 'obd_connection_error':
        return _EventInfo(
          title: 'OBD Connection Lost',
          message: 'Using phone sensors for data',
          icon: Icons.bluetooth_disabled,
          iconColor: Colors.white,
          backgroundColor: AppColors.ecoScoreMedium.withOpacity(0.9),
        );
        
      default:
        // If we get an unknown event type, provide a generic notification
        final String eventName = event.eventType.split('_').map((word) => 
            word.isNotEmpty ? word[0].toUpperCase() + word.substring(1) : '').join(' ');
            
        return _EventInfo(
          title: eventName,
          message: '',
          icon: Icons.info,
          iconColor: Colors.white,
          backgroundColor: AppColors.info.withOpacity(0.9),
        );
    }
  }
}

/// Helper class to store event information
class _EventInfo {
  final String title;
  final String message;
  final IconData icon;
  final Color iconColor;
  final Color backgroundColor;
  
  _EventInfo({
    required this.title,
    required this.message,
    required this.icon,
    required this.iconColor,
    required this.backgroundColor,
  });
} 

################################################################################
FILE: lib/presentation/screens/drive/components/eco_score_display.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:going50/core/theme/app_colors.dart';

/// A large, visually prominent eco-score display.
///
/// This component is designed to be the focal point of the active driving screen,
/// showing the driver's current eco-score in a minimalist, distraction-free way.
class EcoScoreDisplay extends StatelessWidget {
  /// The current eco-score value (0-100)
  final double ecoScore;
  
  /// Constructor
  const EcoScoreDisplay({
    super.key,
    required this.ecoScore,
  });

  @override
  Widget build(BuildContext context) {
    final score = ecoScore.toInt();
    final ecoScoreColor = AppColors.getEcoScoreColor(ecoScore);
    final message = _getEcoScoreMessage(score);
    
    return Container(
      width: double.infinity,
      color: Colors.black,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // Score value display
          Container(
            width: 200,
            height: 200,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: Colors.black,
              border: Border.all(
                color: ecoScoreColor,
                width: 4,
              ),
              boxShadow: [
                BoxShadow(
                  color: ecoScoreColor.withOpacity(0.3),
                  blurRadius: 20,
                  spreadRadius: 5,
                ),
              ],
            ),
            child: Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  // Score number
                  Text(
                    score.toString(),
                    style: TextStyle(
                      fontSize: 80,
                      fontWeight: FontWeight.bold,
                      color: ecoScoreColor,
                    ),
                  ),
                  // Score label
                  Text(
                    'ECO-SCORE',
                    style: TextStyle(
                      fontSize: 14,
                      fontWeight: FontWeight.w600,
                      color: ecoScoreColor.withOpacity(0.8),
                      letterSpacing: 2,
                    ),
                  ),
                ],
              ),
            ),
          ),
          
          // Feedback message
          Padding(
            padding: const EdgeInsets.only(top: 40),
            child: Text(
              message,
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.w600,
                color: ecoScoreColor,
              ),
              textAlign: TextAlign.center,
            ),
          ),
        ],
      ),
    );
  }
  
  /// Returns a message based on the current eco-score
  String _getEcoScoreMessage(int score) {
    if (score < 30) {
      return 'Room for improvement';
    } else if (score < 50) {
      return 'Getting better';
    } else if (score < 70) {
      return 'Good driving';
    } else if (score < 90) {
      return 'Great eco-driving!';
    } else {
      return 'Eco-driving master!';
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/drive/components/connection_status_widget.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/presentation/providers/driving_provider.dart';

/// A widget that displays the current connection status.
///
/// Shows whether the app is connected to an OBD device or using phone sensors,
/// with appropriate styling and messaging.
class ConnectionStatusWidget extends StatelessWidget {
  const ConnectionStatusWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final drivingProvider = Provider.of<DrivingProvider>(context);
    final isObdConnected = drivingProvider.isObdConnected;
    final isCollecting = drivingProvider.isCollecting;
    final preferOBD = drivingProvider.preferOBD;
    
    // Determine status text and styling based on connection state
    String statusText;
    IconData iconData;
    Color backgroundColor;
    Color borderColor;
    Color textColor;
    
    if (isObdConnected) {
      statusText = 'OBD Connected';
      iconData = Icons.bluetooth_connected;
      backgroundColor = AppColors.success.withOpacity(0.1);
      borderColor = AppColors.success;
      textColor = AppColors.success;
    } else if (isCollecting) {
      statusText = 'Using Phone Sensors';
      iconData = Icons.phone_android;
      backgroundColor = AppColors.warning.withOpacity(0.1);
      borderColor = AppColors.warning;
      textColor = AppColors.warning;
    } else if (preferOBD) {
      statusText = 'OBD Not Connected';
      iconData = Icons.bluetooth_disabled;
      backgroundColor = AppColors.neutralGray.withOpacity(0.1);
      borderColor = AppColors.neutralGray;
      textColor = AppColors.neutralGray;
    } else {
      statusText = 'Sensors Ready';
      iconData = Icons.sensors;
      backgroundColor = AppColors.neutralGray.withOpacity(0.1);
      borderColor = AppColors.neutralGray;
      textColor = AppColors.neutralGray;
    }
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: borderColor,
          width: 1,
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            iconData,
            color: textColor,
            size: 20,
          ),
          const SizedBox(width: 8),
          Text(
            statusText,
            style: TextStyle(
              color: textColor,
              fontWeight: FontWeight.w500,
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/drive/components/improvement_suggestion_card.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/services/driving/analytics_service.dart';

/// A card that displays an improvement suggestion for eco-driving.
///
/// This component shows a driving improvement tip with a description
/// of the benefits of implementing the suggestion.
class ImprovementSuggestionCard extends StatelessWidget {
  /// The suggestion to display
  final FeedbackSuggestion suggestion;
  
  /// Constructor
  const ImprovementSuggestionCard({
    super.key,
    required this.suggestion,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    // Determine priority icon and color
    final (IconData icon, Color color) = _getPriorityIconAndColor(suggestion.priority);
    
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: theme.dividerColor.withOpacity(0.5)),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header with icon and title
            Row(
              children: [
                Container(
                  width: 32,
                  height: 32,
                  decoration: BoxDecoration(
                    color: color.withOpacity(0.2),
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: Icon(
                    icon,
                    color: color,
                    size: 16,
                  ),
                ),
                
                const SizedBox(width: 12),
                
                Expanded(
                  child: Text(
                    _getCategoryTitle(suggestion.category),
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                
                _buildPriorityTag(context, suggestion.priority),
              ],
            ),
            
            const SizedBox(height: 12),
            
            // Suggestion text
            Text(
              suggestion.suggestion,
              style: theme.textTheme.bodyLarge?.copyWith(
                fontWeight: FontWeight.w500,
              ),
            ),
            
            const SizedBox(height: 8),
            
            // Benefit text
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Icon(
                  Icons.check_circle_outline,
                  color: AppColors.primary,
                  size: 16,
                ),
                
                const SizedBox(width: 8),
                
                Expanded(
                  child: Text(
                    suggestion.benefit,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: AppColors.textSecondary,
                    ),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
  
  /// Build a priority tag widget
  Widget _buildPriorityTag(BuildContext context, int priority) {
    final color = priority == 3 
        ? AppColors.error 
        : (priority == 2 ? AppColors.warning : AppColors.info);
    
    final label = priority == 3 
        ? 'High' 
        : (priority == 2 ? 'Medium' : 'Low');
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
      decoration: BoxDecoration(
        color: color.withOpacity(0.2),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Text(
        label,
        style: TextStyle(
          fontSize: 12,
          fontWeight: FontWeight.w600,
          color: color,
        ),
      ),
    );
  }
  
  /// Get an icon and color based on priority
  (IconData, Color) _getPriorityIconAndColor(int priority) {
    switch (priority) {
      case 3: // High
        return (Icons.priority_high, AppColors.error);
      case 2: // Medium
        return (Icons.notifications, AppColors.warning);
      default: // Low
        return (Icons.lightbulb_outline, AppColors.info);
    }
  }
  
  /// Get a human-readable title for a category
  String _getCategoryTitle(String category) {
    switch (category) {
      case 'calmDriving':
        return 'Smoother Driving';
      case 'speedOptimization':
        return 'Speed Management';
      case 'idling':
        return 'Reduce Idling';
      case 'shortDistance':
        return 'Trip Planning';
      case 'rpmManagement':
        return 'Engine Efficiency';
      case 'stopManagement':
        return 'Anticipate Traffic';
      case 'followDistance':
        return 'Following Distance';
      default:
        return 'Driving Improvement';
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/drive/components/behavior_breakdown_chart.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/core_models/trip.dart';

/// A component that displays a breakdown of driving behaviors in a visual chart.
///
/// This chart shows the different driving behavior categories and their scores 
/// based on the trip data.
class BehaviorBreakdownChart extends StatelessWidget {
  /// The trip to analyze
  final Trip trip;
  
  /// Constructor
  const BehaviorBreakdownChart({
    super.key,
    required this.trip,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    // Calculate behavior scores from trip data
    final behaviorScores = _calculateBehaviorScores(trip);
    
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Section title
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8),
            child: Text(
              'Driving Behavior Breakdown',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          
          const SizedBox(height: 24),
          
          // Behavior chart
          ...behaviorScores.entries.map((entry) => 
            _buildBehaviorScoreBar(
              context, 
              entry.key, 
              entry.value, 
              _getBehaviorDescription(entry.key),
            ),
          ),
        ],
      ),
    );
  }
  
  /// Builds a horizontal score bar for a behavior
  Widget _buildBehaviorScoreBar(
    BuildContext context,
    String behavior,
    double score,
    String description,
  ) {
    final theme = Theme.of(context);
    final screenWidth = MediaQuery.of(context).size.width;
    final maxBarWidth = screenWidth - 76; // Account for padding and labels
    final barWidth = (score / 100) * maxBarWidth;
    
    // Determine color based on score
    final Color barColor = _getScoreColor(score);
    
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Behavior name and score
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                behavior,
                style: theme.textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
              ),
              Text(
                score.round().toString(),
                style: theme.textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: barColor,
                ),
              ),
            ],
          ),
          
          const SizedBox(height: 6),
          
          // Score bar
          Stack(
            children: [
              // Background bar
              Container(
                height: 8,
                width: maxBarWidth,
                decoration: BoxDecoration(
                  color: theme.dividerColor.withOpacity(0.3),
                  borderRadius: BorderRadius.circular(4),
                ),
              ),
              // Filled bar
              Container(
                height: 8,
                width: barWidth,
                decoration: BoxDecoration(
                  color: barColor,
                  borderRadius: BorderRadius.circular(4),
                ),
              ),
            ],
          ),
          
          const SizedBox(height: 4),
          
          // Description
          Text(
            description,
            style: theme.textTheme.bodySmall?.copyWith(
              color: AppColors.textSecondary,
            ),
          ),
          
          const SizedBox(height: 8),
          
          // Divider
          const Divider(height: 1),
        ],
      ),
    );
  }
  
  /// Calculate behavior scores based on trip data
  Map<String, double> _calculateBehaviorScores(Trip trip) {
    // Default score (perfect)
    final scores = {
      'Acceleration': 100.0,
      'Braking': 100.0,
      'Speed': 100.0,
      'Idling': 100.0,
      'Consistency': 100.0,
    };
    
    // Adjust scores based on trip events
    // Note: These are simplified calculations that could be improved
    
    // Acceleration score
    if (trip.aggressiveAccelerationEvents != null && trip.aggressiveAccelerationEvents! > 0) {
      final events = trip.aggressiveAccelerationEvents!;
      scores['Acceleration'] = 100.0 - (events * 20.0).clamp(0.0, 100.0);
    }
    
    // Braking score
    if (trip.hardBrakingEvents != null && trip.hardBrakingEvents! > 0) {
      final events = trip.hardBrakingEvents!;
      scores['Braking'] = 100.0 - (events * 20.0).clamp(0.0, 100.0);
    }
    
    // Speed score
    if (trip.excessiveSpeedEvents != null && trip.excessiveSpeedEvents! > 0) {
      final events = trip.excessiveSpeedEvents!;
      scores['Speed'] = 100.0 - (events * 15.0).clamp(0.0, 100.0);
    }
    
    // Idling score
    if (trip.idlingEvents != null && trip.idlingEvents! > 0) {
      final events = trip.idlingEvents!;
      scores['Idling'] = 100.0 - (events * 10.0).clamp(0.0, 100.0);
    }
    
    // Consistency score (based on stop events)
    if (trip.stopEvents != null && trip.stopEvents! > 0) {
      final events = trip.stopEvents!;
      final distanceKm = trip.distanceKm ?? 10.0;
      
      // Calculate events per km (more events per km = lower consistency)
      final eventsPerKm = events / distanceKm;
      scores['Consistency'] = 100.0 - (eventsPerKm * 25.0).clamp(0.0, 100.0);
    }
    
    return scores;
  }
  
  /// Get color for a score
  Color _getScoreColor(double score) {
    return AppColors.getEcoScoreColor(score);
  }
  
  /// Get description for a behavior category
  String _getBehaviorDescription(String behavior) {
    switch (behavior) {
      case 'Acceleration':
        return 'Smooth acceleration saves fuel and reduces wear on the vehicle';
      case 'Braking':
        return 'Gentle braking improves safety and fuel efficiency';
      case 'Speed':
        return 'Maintaining optimal speed ranges improves fuel economy';
      case 'Idling':
        return 'Reducing idle time saves fuel and reduces emissions';
      case 'Consistency':
        return 'Consistent driving with fewer stops improves efficiency';
      default:
        return 'Eco-driving improves efficiency and reduces environmental impact';
    }
  }
} 

################################################################################
FILE: lib/presentation/screens/drive/components/current_metrics_strip.dart
################################################################################

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/presentation/providers/driving_provider.dart';
import 'package:going50/core_models/combined_driving_data.dart';

/// A strip of current driving metrics shown at the bottom of the active driving screen.
///
/// This component displays essential real-time metrics such as speed, acceleration, and RPM,
/// along with a button to end the current trip.
class CurrentMetricsStrip extends StatefulWidget {
  /// Callback when end trip button is tapped
  final VoidCallback onEndTripTap;
  
  /// Constructor
  const CurrentMetricsStrip({
    super.key,
    required this.onEndTripTap,
  });

  @override
  State<CurrentMetricsStrip> createState() => _CurrentMetricsStripState();
}

class _CurrentMetricsStripState extends State<CurrentMetricsStrip> {
  CombinedDrivingData? _latestData;
  Timer? _refreshTimer;
  
  @override
  void initState() {
    super.initState();
    _setupRefreshTimer();
  }
  
  @override
  void dispose() {
    _refreshTimer?.cancel();
    super.dispose();
  }
  
  void _setupRefreshTimer() {
    // Refresh metrics every 1 second
    _refreshTimer = Timer.periodic(const Duration(seconds: 1), (_) {
      _refreshData();
    });
    
    // Initial data load
    _refreshData();
  }
  
  Future<void> _refreshData() async {
    final drivingProvider = Provider.of<DrivingProvider>(context, listen: false);
    final latestData = await drivingProvider.getLatestDrivingData();
    
    if (mounted && latestData != null) {
      setState(() {
        _latestData = latestData;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      color: Colors.black,
      padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          // Metrics row
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: [
              _buildMetricItem(
                label: 'SPEED',
                value: _getSpeedValue(),
                unit: 'km/h',
              ),
              _buildMetricItem(
                label: 'RPM',
                value: _getRpmValue(),
                unit: '',
              ),
              _buildMetricItem(
                label: 'ACCEL',
                value: _getAccelerationValue(),
                unit: 'm/s²',
                isGood: _isAccelerationGood(),
              ),
            ],
          ),
          
          // End trip button
          TextButton.icon(
            onPressed: widget.onEndTripTap,
            icon: const Icon(Icons.stop_circle_outlined),
            label: const Text('END TRIP'),
            style: TextButton.styleFrom(
              foregroundColor: Colors.white,
              padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(20),
                side: const BorderSide(color: Colors.white, width: 1),
              ),
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildMetricItem({
    required String label,
    required String value,
    required String unit,
    bool? isGood,
  }) {
    // Determine color based on whether the value is good/optimal
    Color valueColor = Colors.white;
    if (isGood != null) {
      valueColor = isGood ? AppColors.ecoScoreHigh : AppColors.ecoScoreLow;
    }
    
    return Column(
      children: [
        // Label
        Text(
          label,
          style: const TextStyle(
            color: Colors.white70,
            fontSize: 12,
            fontWeight: FontWeight.w600,
          ),
        ),
        const SizedBox(height: 4),
        // Value and unit
        RichText(
          text: TextSpan(
            children: [
              TextSpan(
                text: value,
                style: TextStyle(
                  color: valueColor,
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
              TextSpan(
                text: unit.isNotEmpty ? ' $unit' : '',
                style: const TextStyle(
                  color: Colors.white70,
                  fontSize: 14,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
  
  // Helper methods to extract and format data
  
  String _getSpeedValue() {
    if (_latestData == null) return '0';
    final speed = _latestData!.obdData?.vehicleSpeed ?? _latestData!.sensorData?.gpsSpeed;
    if (speed == null) return '0';
    return speed.toInt().toString();
  }
  
  String _getRpmValue() {
    if (_latestData == null || _latestData!.obdData?.rpm == null) return '0';
    final rpm = _latestData!.obdData!.rpm!.toInt();
    return rpm.toString();
  }
  
  String _getAccelerationValue() {
    if (_latestData == null) return '0.0';
    final accel = _latestData!.calculatedAcceleration ?? _latestData!.sensorData?.accelerationX;
    if (accel == null) return '0.0';
    // Convert to m/s² and limit to one decimal place
    return accel.toStringAsFixed(1);
  }
  
  bool? _isAccelerationGood() {
    if (_latestData == null) return null;
    if (_latestData!.isAggressive != null) {
      return !_latestData!.isAggressive!;
    }
    // Determine based on raw values if the derived flag is not available
    final accel = _latestData!.calculatedAcceleration ?? _latestData!.sensorData?.accelerationX;
    if (accel == null) return null;
    // Moderate acceleration is considered good (values are approximate)
    // Positive means acceleration, negative means braking
    return (accel > -3.0 && accel < 2.0);
  }
} 

################################################################################
FILE: lib/presentation/screens/drive/components/savings_metrics_section.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/core_models/trip.dart';

/// A section that displays savings metrics for a trip, including
/// fuel savings, CO2 emissions reduction, and money saved.
class SavingsMetricsSection extends StatelessWidget {
  /// The trip to calculate savings for
  final Trip trip;
  
  /// The eco-score, used to calculate savings
  final double ecoScore;
  
  /// Constructor
  const SavingsMetricsSection({
    super.key,
    required this.trip,
    required this.ecoScore,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    // Calculate savings based on trip data and eco score
    final savingsData = _calculateSavings(trip, ecoScore);
    
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Section title
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8),
            child: Text(
              'Estimated Savings',
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          
          const SizedBox(height: 16),
          
          // Savings cards
          Row(
            children: [
              // Fuel savings
              Expanded(
                child: _buildSavingsCard(
                  context,
                  'Fuel Saved',
                  '${savingsData['fuelSaved']!.toStringAsFixed(2)} L',
                  Icons.local_gas_station,
                  AppColors.ecoScoreHigh,
                ),
              ),
              
              const SizedBox(width: 12),
              
              // CO2 savings
              Expanded(
                child: _buildSavingsCard(
                  context,
                  'CO₂ Reduced',
                  '${savingsData['co2Reduced']!.toStringAsFixed(2)} kg',
                  Icons.cloud_outlined,
                  AppColors.primary,
                ),
              ),
            ],
          ),
          
          const SizedBox(height: 12),
          
          // Money saved
          _buildSavingsCard(
            context,
            'Money Saved',
            '\$${savingsData['moneySaved']!.toStringAsFixed(2)}',
            Icons.attach_money,
            AppColors.secondary,
            large: true,
          ),
        ],
      ),
    );
  }
  
  /// Builds a savings card with an icon, title, and value
  Widget _buildSavingsCard(
    BuildContext context,
    String title,
    String value,
    IconData icon,
    Color color, {
    bool large = false,
  }) {
    final theme = Theme.of(context);
    
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: theme.dividerColor.withOpacity(0.5)),
      ),
      child: Padding(
        padding: EdgeInsets.all(large ? 16 : 12),
        child: Row(
          children: [
            // Icon
            Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(
                color: color.withOpacity(0.2),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Icon(
                icon,
                color: color,
                size: 24,
              ),
            ),
            
            const SizedBox(width: 12),
            
            // Text content
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: AppColors.textSecondary,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    value,
                    style: theme.textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.bold,
                      fontSize: large ? 24 : 18,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  /// Calculate savings based on trip and eco-score
  /// This uses simplified estimates that could be improved with more accurate models
  Map<String, double> _calculateSavings(Trip trip, double ecoScore) {
    // Default values if we don't have distance or fuel data
    double distanceKm = trip.distanceKm ?? 10.0;
    double fuelUsedL = trip.fuelUsedL ?? (distanceKm * 0.08); // Assume 8L/100km
    
    // Calculate savings based on eco-score
    // Better eco-score = more savings (linear relationship for simplicity)
    double savingsPercentage = (ecoScore / 100) * 0.2; // Up to 20% savings at 100 score
    
    // Fuel saved
    double fuelSaved = fuelUsedL * savingsPercentage;
    
    // CO2 reduced (approx. 2.3kg CO2 per liter of gasoline)
    double co2Reduced = fuelSaved * 2.3;
    
    // Money saved (assume $1.50 per liter - this would vary by location)
    double moneySaved = fuelSaved * 1.50;
    
    return {
      'fuelSaved': fuelSaved,
      'co2Reduced': co2Reduced,
      'moneySaved': moneySaved,
    };
  }
} 

################################################################################
FILE: lib/presentation/screens/drive/components/recent_trip_card.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/core_models/trip.dart';
import 'package:going50/core/utils/formatter_utils.dart';

/// A card that displays information about the most recent trip.
///
/// Shows date/time, distance, eco-score, and savings metrics.
class RecentTripCard extends StatelessWidget {
  /// The trip to display
  final Trip trip;
  
  /// Callback when the card is tapped
  final VoidCallback? onTap;
  
  /// Constructor
  const RecentTripCard({
    super.key,
    required this.trip,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    // Format trip date/time
    final dateFormat = DateFormat('MMM d, yyyy');
    final timeFormat = DateFormat('h:mm a');
    final tripDate = dateFormat.format(trip.startTime);
    final tripTime = timeFormat.format(trip.startTime);
    
    // Format trip duration
    final duration = trip.endTime != null 
        ? trip.endTime!.difference(trip.startTime) 
        : Duration.zero;
    final durationText = FormatterUtils.formatDuration(duration);
    
    // Format trip distance
    final distanceText = trip.distanceKm != null
        ? FormatterUtils.formatDistance(trip.distanceKm!)
        : 'N/A';
    
    // Calculate eco-score (based on events)
    // This is a simple calculation that could be improved with a dedicated algorithm
    final ecoScore = _calculateEcoScore(trip);
    final ecoScoreColor = AppColors.getEcoScoreColor(ecoScore);
    
    // Calculate estimated savings
    // These are simple estimates that could be improved with more sophisticated calculations
    final fuelSavedLiters = _calculateFuelSaved(trip);
    final co2SavedKg = fuelSavedLiters * 2.3; // ~2.3kg CO2 per liter of fuel
    final moneySaved = fuelSavedLiters * 1.5; // Assuming $1.50 per liter
    
    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      clipBehavior: Clip.antiAlias,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Row(
                children: [
                  // Date and time
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          tripDate,
                          style: theme.textTheme.bodyMedium?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 2),
                        Text(
                          tripTime,
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: AppColors.textSecondary,
                          ),
                        ),
                      ],
                    ),
                  ),
                  
                  // Eco-score badge
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 6,
                    ),
                    decoration: BoxDecoration(
                      color: ecoScoreColor.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(12),
                      border: Border.all(
                        color: ecoScoreColor,
                        width: 1,
                      ),
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(
                          Icons.eco,
                          color: ecoScoreColor,
                          size: 14,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          ecoScore.toInt().toString(),
                          style: TextStyle(
                            color: ecoScoreColor,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: 8),
              
              // Trip details
              Row(
                children: [
                  // Distance
                  Expanded(
                    child: Row(
                      children: [
                        const Icon(
                          Icons.route,
                          size: 16,
                          color: AppColors.textSecondary,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          distanceText,
                          style: theme.textTheme.bodyMedium,
                        ),
                      ],
                    ),
                  ),
                  
                  // Duration
                  Expanded(
                    child: Row(
                      children: [
                        const Icon(
                          Icons.timer,
                          size: 16,
                          color: AppColors.textSecondary,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          durationText,
                          style: theme.textTheme.bodyMedium,
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              
              const SizedBox(height: 8),
              
              // Savings section
              Row(
                children: [
                  // Fuel saved
                  Expanded(
                    child: _buildSavingsItem(
                      context,
                      icon: Icons.local_gas_station,
                      label: 'Fuel',
                      value: '${fuelSavedLiters.toStringAsFixed(1)}L',
                    ),
                  ),
                  
                  // CO2 saved
                  Expanded(
                    child: _buildSavingsItem(
                      context,
                      icon: Icons.cloud,
                      label: 'CO₂',
                      value: '${co2SavedKg.toStringAsFixed(1)}kg',
                    ),
                  ),
                  
                  // Money saved
                  Expanded(
                    child: _buildSavingsItem(
                      context,
                      icon: Icons.attach_money,
                      label: 'Money',
                      value: FormatterUtils.formatCurrency(moneySaved),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  /// Calculates an eco-score based on trip data
  double _calculateEcoScore(Trip trip) {
    // Start with a perfect score and subtract for events
    double score = 100;
    
    // Only calculate if the trip is completed
    if (!trip.isCompleted || trip.distanceKm == null || trip.distanceKm! <= 0) {
      return 50; // Default score for incomplete or invalid trips
    }
    
    // Get total events, or use default values if null
    final idling = trip.idlingEvents ?? 0;
    final acceleration = trip.aggressiveAccelerationEvents ?? 0;
    final braking = trip.hardBrakingEvents ?? 0;
    final speeding = trip.excessiveSpeedEvents ?? 0;
    
    // Calculate events per km
    final distance = trip.distanceKm!;
    final eventsPerKm = (idling + acceleration + braking + speeding) / distance;
    
    // Subtract points based on events per km (adjust these values as needed)
    if (eventsPerKm > 5) {
      score -= 50;
    } else if (eventsPerKm > 2) {
      score -= 30;
    } else if (eventsPerKm > 1) {
      score -= 15;
    } else if (eventsPerKm > 0.5) {
      score -= 5;
    }
    
    // Ensure score stays within 0-100 range
    return score.clamp(0, 100);
  }
  
  /// Calculates estimated fuel saved based on trip data
  double _calculateFuelSaved(Trip trip) {
    // This is a very simple estimate - in a real app this would be more sophisticated
    if (!trip.isCompleted || trip.distanceKm == null || trip.fuelUsedL == null) {
      return 0.5; // Default value for incomplete trips
    }
    
    // Calculate based on distance and actual fuel used
    // Here we're making a simple assumption of potential savings
    // In a real implementation, this would compare to baseline fuel consumption
    final distance = trip.distanceKm!;
    final fuelUsed = trip.fuelUsedL!;
    
    // Estimate 10% better than average for a positive user experience
    return (distance * 0.07) - fuelUsed; // 0.07L/km is an average consumption
  }
  
  /// Builds a savings item with icon, label, and value
  Widget _buildSavingsItem(
    BuildContext context, {
    required IconData icon,
    required String label,
    required String value,
  }) {
    final theme = Theme.of(context);
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(
              icon,
              size: 14,
              color: AppColors.textSecondary,
            ),
            const SizedBox(width: 4),
            Text(
              label,
              style: theme.textTheme.bodySmall?.copyWith(
                color: AppColors.textSecondary,
              ),
            ),
          ],
        ),
        const SizedBox(height: 2),
        Text(
          value,
          style: theme.textTheme.bodyMedium?.copyWith(
            fontWeight: FontWeight.bold,
            color: AppColors.secondary,
          ),
        ),
      ],
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/drive/components/start_trip_button.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/core/constants/route_constants.dart';
import 'package:going50/presentation/providers/driving_provider.dart';
import 'package:going50/services/driving/driving_service.dart';
import 'package:going50/services/permission_service.dart';
import 'package:going50/services/service_locator.dart';

/// A large circular button that starts a trip recording.
///
/// Changes appearance based on the current driving status and 
/// provides appropriate feedback when pressed.
class StartTripButton extends StatelessWidget {
  /// The size of the button in diameter (dp)
  final double size;
  
  /// Optional callback for when the button is pressed
  /// Should return a Future to allow awaiting its completion
  final Future<void> Function()? onBeforeStart;

  /// Constructor
  const StartTripButton({
    super.key, 
    this.size = 80, 
    this.onBeforeStart,
  });

  @override
  Widget build(BuildContext context) {
    final drivingProvider = Provider.of<DrivingProvider>(context);
    final drivingStatus = drivingProvider.drivingStatus;
    final bool isRecording = drivingProvider.isRecording;
    
    // Determine if the button should be enabled
    bool isEnabled = drivingStatus == DrivingStatus.ready;
    
    // Don't log during build - can cause issues with setState during build
    // print('StartTripButton: status=$drivingStatus, isEnabled=$isEnabled, isRecording=$isRecording, isCollecting=${drivingProvider.isCollecting}, isObdConnected=${drivingProvider.isObdConnected}');
    
    // Handle button press
    void onPressed() async {
      if (!isEnabled) {
        // If a trip is already in progress, navigate to active drive screen
        if (isRecording) {
          Navigator.of(context).pushNamed(DriveRoutes.activeDrive);
          return;
        }
        
        // Otherwise show a snackbar with explanation if button is disabled
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Cannot start trip. Please check connection status.'),
            duration: Duration(seconds: 3),
          ),
        );
        return;
      }
      
      try {
        // Get permission service
        final permissionService = serviceLocator<PermissionService>();
        
        // Check if permissions are already granted
        bool hasAllPermissions = await permissionService.areAllPermissionsGranted();
        
        // Only show the permission explanation dialog if permissions aren't already granted
        if (!hasAllPermissions && context.mounted) {
          // Call the optional callback before starting the trip
          if (onBeforeStart != null) {
            await onBeforeStart!();
          }
          
          // This will ensure we don't proceed until the explanation dialog is closed
          await Future.delayed(Duration.zero);
          
          // Request permissions separately and wait for each one
          if (context.mounted) {
            // Request location permissions first
            await permissionService.requestLocationPermissions();
            
            // Request Bluetooth permissions if needed
            if (drivingProvider.isObdConnected) {
              await permissionService.requestBluetoothPermissions();
            }
            
            // Request activity recognition permission
            await permissionService.requestActivityRecognitionPermission();
            
            // Check if all required permissions are granted
            hasAllPermissions = await permissionService.areAllPermissionsGranted();
          }
        }
        
        // Only proceed if permissions are granted and context is still valid
        if (hasAllPermissions && context.mounted) {
          // Start the trip, skipping permission checks since we've already done them
          final success = await drivingProvider.startTrip(skipPermissionChecks: true);
          
          if (success && context.mounted) {
            // Navigate to active drive screen when trip starts successfully
            Navigator.of(context).pushNamed(DriveRoutes.activeDrive);
          } else if (!success && context.mounted) {
            // Show error snackbar if trip start failed
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Failed to start trip. Please try again.'),
                duration: Duration(seconds: 3),
              ),
            );
          }
        } else if (!hasAllPermissions && context.mounted) {
          // Show error message if permissions were denied
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Cannot start trip without required permissions.'),
              duration: Duration(seconds: 3),
            ),
          );
        }
      } catch (e) {
        // Handle exceptions from the permission flow, like when user cancels the permission dialog
        if (context.mounted) {
          // Only show a message if the exception wasn't about user cancellation
          if (!e.toString().contains('canceled by user')) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Trip start canceled: ${e.toString()}'),
                duration: const Duration(seconds: 3),
              ),
            );
          }
        }
      }
    }
    
    return Container(
      width: size,
      height: size,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        boxShadow: isEnabled ? [
          BoxShadow(
            color: AppColors.primary.withOpacity(0.3),
            blurRadius: 10,
            spreadRadius: 2,
          ),
        ] : [],
      ),
      child: Material(
        color: isEnabled ? AppColors.primary : AppColors.neutralGray,
        shape: const CircleBorder(),
        clipBehavior: Clip.antiAlias,
        child: InkWell(
          onTap: onPressed,
          splashColor: Colors.white24,
          child: Center(
            child: Icon(
              Icons.play_arrow_rounded,
              color: Colors.white,
              size: size / 2,
            ),
          ),
        ),
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/drive/components/trip_overview_header.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:going50/core/theme/app_colors.dart';
import 'package:going50/core_models/trip.dart';
import 'package:going50/core/utils/formatter_utils.dart';

/// Header component for the trip summary screen that shows basic
/// trip information like date, time, duration, and eco-score.
class TripOverviewHeader extends StatelessWidget {
  /// The trip to display
  final Trip trip;
  
  /// Optional custom eco-score to display
  final double? ecoScore;
  
  /// Constructor
  const TripOverviewHeader({
    super.key,
    required this.trip,
    this.ecoScore,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    // Format trip date/time
    final dateFormat = DateFormat('EEEE, MMMM d, yyyy');
    final timeFormat = DateFormat('h:mm a');
    final tripDate = dateFormat.format(trip.startTime);
    final tripTime = timeFormat.format(trip.startTime);
    
    // Format trip duration
    final duration = trip.endTime != null 
        ? trip.endTime!.difference(trip.startTime) 
        : Duration.zero;
    final durationText = FormatterUtils.formatDuration(duration);
    
    // Calculate eco-score
    final score = ecoScore ?? _calculateEcoScore(trip);
    final scoreColor = AppColors.getEcoScoreColor(score);
    
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: theme.colorScheme.primary,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Title
          Text(
            'Trip Summary',
            style: theme.textTheme.headlineSmall?.copyWith(
              color: Colors.white,
              fontWeight: FontWeight.bold,
            ),
          ),
          
          const SizedBox(height: 8),
          
          // Date and time
          Text(
            tripDate,
            style: theme.textTheme.bodyLarge?.copyWith(
              color: Colors.white.withOpacity(0.9),
              fontWeight: FontWeight.w500,
            ),
          ),
          Text(
            'Started at $tripTime',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: Colors.white.withOpacity(0.8),
            ),
          ),
          
          const SizedBox(height: 24),
          
          // Stats row
          Row(
            children: [
              // Duration
              Expanded(
                child: _buildStatItem(
                  context,
                  'Duration',
                  durationText,
                  Icons.access_time,
                ),
              ),
              
              // Distance
              Expanded(
                child: _buildStatItem(
                  context,
                  'Distance',
                  trip.distanceKm != null
                      ? FormatterUtils.formatDistance(trip.distanceKm!)
                      : 'N/A',
                  Icons.straighten,
                ),
              ),
              
              // Eco-score
              Expanded(
                child: _buildStatItem(
                  context,
                  'Eco-Score',
                  '${score.toInt()}',
                  Icons.eco,
                  valueColor: scoreColor,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
  
  /// Builds a stat item with an icon, label, and value
  Widget _buildStatItem(
    BuildContext context,
    String label,
    String value,
    IconData icon, {
    Color? valueColor,
  }) {
    return Column(
      children: [
        Icon(
          icon,
          color: Colors.white.withOpacity(0.9),
          size: 24,
        ),
        const SizedBox(height: 4),
        Text(
          value,
          style: TextStyle(
            color: valueColor ?? Colors.white,
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 2),
        Text(
          label,
          style: TextStyle(
            color: Colors.white.withOpacity(0.8),
            fontSize: 12,
          ),
        ),
      ],
    );
  }
  
  /// Calculate eco-score based on trip data
  /// This is a simplified version that could be improved with a more sophisticated algorithm
  double _calculateEcoScore(Trip trip) {
    if (!trip.isCompleted) return 0.0;
    
    // Base score
    double score = 100.0;
    
    // Event penalties
    if (trip.idlingEvents != null && trip.idlingEvents! > 0) {
      score -= trip.idlingEvents! * 2;
    }
    
    if (trip.aggressiveAccelerationEvents != null && trip.aggressiveAccelerationEvents! > 0) {
      score -= trip.aggressiveAccelerationEvents! * 5;
    }
    
    if (trip.hardBrakingEvents != null && trip.hardBrakingEvents! > 0) {
      score -= trip.hardBrakingEvents! * 5;
    }
    
    if (trip.excessiveSpeedEvents != null && trip.excessiveSpeedEvents! > 0) {
      score -= trip.excessiveSpeedEvents! * 3;
    }
    
    // Clamp score between 0 and 100
    return score.clamp(0.0, 100.0);
  }
} 

################################################################################
FILE: lib/presentation/screens/onboarding/value_carousel_screen.dart
################################################################################

import 'package:flutter/material.dart';
import '../../widgets/common/buttons/primary_button.dart';
import '../../widgets/common/buttons/secondary_button.dart';

/// A screen that showcases the core benefits of the app through
/// a carousel of value propositions.
class ValueCarouselScreen extends StatefulWidget {
  /// Callback function when the user taps the "Next" or "Get Started" button
  final VoidCallback? onNext;
  
  /// Callback function when the user taps the "Skip" button
  final VoidCallback? onSkip;

  /// Creates a value carousel screen.
  const ValueCarouselScreen({
    super.key,
    this.onNext,
    this.onSkip,
  });

  @override
  State<ValueCarouselScreen> createState() => _ValueCarouselScreenState();
}

class _ValueCarouselScreenState extends State<ValueCarouselScreen> {
  final PageController _pageController = PageController();
  int _currentPage = 0;

  final List<Map<String, dynamic>> _values = [
    {
      'icon': Icons.savings_outlined,
      'title': 'Save Money',
      'description': 'Reduce fuel consumption by up to 25% with personalized eco-driving feedback.',
    },
    {
      'icon': Icons.nature_people_outlined,
      'title': 'Reduce Emissions',
      'description': 'Cut your carbon footprint and contribute to a cleaner environment.',
    },
    {
      'icon': Icons.sports_score_outlined,
      'title': 'Track Progress',
      'description': 'Monitor your improvement and compete with friends to become an eco-driving champion.',
    },
  ];

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Stack(
      children: [
        // Skip button at top right
        Positioned(
          top: 16,
          right: 16,
          child: TextButton(
            onPressed: widget.onSkip,
            child: Text('Skip', style: theme.textTheme.bodyLarge),
          ),
        ),
        
        // Main content
        Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            children: [
              // Top space
              const SizedBox(height: 56),
              
              // Carousel
              Expanded(
                child: PageView.builder(
                  controller: _pageController,
                  itemCount: _values.length,
                  onPageChanged: (index) {
                    setState(() {
                      _currentPage = index;
                    });
                  },
                  itemBuilder: (context, index) {
                    final value = _values[index];
                    return _ValuePageItem(
                      icon: value['icon'],
                      title: value['title'],
                      description: value['description'],
                    );
                  },
                ),
              ),
              
              // Page indicator
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: List.generate(
                  _values.length,
                  (index) => Container(
                    margin: const EdgeInsets.symmetric(horizontal: 4),
                    width: 8,
                    height: 8,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      color: _currentPage == index
                          ? theme.colorScheme.primary
                          : theme.colorScheme.surfaceContainerHighest,
                    ),
                  ),
                ),
              ),
              
              const SizedBox(height: 32),
              
              // Next/Get Started button
              _currentPage == _values.length - 1
                  ? PrimaryButton(
                      text: 'Get Started',
                      onPressed: widget.onNext,
                    )
                  : SecondaryButton(
                      text: 'Next',
                      onPressed: () {
                        _pageController.animateToPage(
                          _currentPage + 1,
                          duration: const Duration(milliseconds: 300),
                          curve: Curves.easeInOut,
                        );
                      },
                    ),
              
              // Bottom space
              SizedBox(height: MediaQuery.of(context).padding.bottom + 16),
            ],
          ),
        ),
      ],
    );
  }
}

/// A single page item in the value carousel.
class _ValuePageItem extends StatelessWidget {
  final IconData icon;
  final String title;
  final String description;

  const _ValuePageItem({
    required this.icon,
    required this.title,
    required this.description,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        // Icon
        Icon(
          icon,
          size: 120,
          color: theme.colorScheme.primary,
        ),
        const SizedBox(height: 32),
        
        // Title
        Text(
          title,
          style: theme.textTheme.headlineMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 16),
        
        // Description
        Text(
          description,
          style: theme.textTheme.bodyLarge,
          textAlign: TextAlign.center,
        ),
      ],
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/onboarding/onboarding_screen.dart
################################################################################

import 'package:flutter/material.dart';
import '../../../core/constants/route_constants.dart';
import 'welcome_screen.dart';
import 'value_carousel_screen.dart';
import 'account_choice_screen.dart';
import 'connection_setup_screen.dart';

/// The main onboarding wrapper screen that manages navigation between
/// the different onboarding screens.
///
/// The onboarding flow consists of:
/// 1. Welcome screen
/// 2. Value carousel
/// 3. Account choice
/// 4. Connection setup
class OnboardingScreen extends StatefulWidget {
  /// Callback function when onboarding is complete
  final VoidCallback? onComplete;

  /// Creates an onboarding screen.
  const OnboardingScreen({
    super.key,
    this.onComplete,
  });

  @override
  State<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenState extends State<OnboardingScreen> {
  final _pageController = PageController();
  int _currentPageIndex = 0;

  final List<Widget> _pages = [
    const WelcomeScreen(),
    const ValueCarouselScreen(),
    const AccountChoiceScreen(),
    const ConnectionSetupScreen(),
  ];

  /// Navigate to the next page
  void _nextPage() {
    if (_currentPageIndex < _pages.length - 1) {
      _pageController.animateToPage(
        _currentPageIndex + 1,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
      );
    } else {
      // Complete onboarding and navigate to main app
      _completeOnboarding();
    }
  }

  /// Skip to the account choice screen
  void _skipToAccountChoice() {
    _pageController.animateToPage(
      2, // Index of AccountChoiceScreen
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
  }

  /// Complete the onboarding flow and navigate to the main app
  void _completeOnboarding() {
    // Call the onComplete callback if provided
    if (widget.onComplete != null) {
      widget.onComplete!();
    }
    
    // Navigate to the main app
    Navigator.of(context).pushReplacementNamed(TabRoutes.driveTab);
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: PageView(
          controller: _pageController,
          onPageChanged: (index) {
            setState(() {
              _currentPageIndex = index;
            });
          },
          physics: const ClampingScrollPhysics(),
          children: _pages.map((page) {
            if (page is WelcomeScreen) {
              return WelcomeScreen(onGetStarted: _nextPage);
            } else if (page is ValueCarouselScreen) {
              return ValueCarouselScreen(
                onNext: _nextPage,
                onSkip: _skipToAccountChoice,
              );
            } else if (page is AccountChoiceScreen) {
              return AccountChoiceScreen(onContinue: _nextPage);
            } else if (page is ConnectionSetupScreen) {
              return ConnectionSetupScreen(onContinue: _completeOnboarding);
            }
            return page;
          }).toList(),
        ),
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/onboarding/connection_setup_screen.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/driving_provider.dart';
import '../../widgets/common/buttons/primary_button.dart';
import 'package:going50/services/permission_service.dart';
import 'package:going50/services/service_locator.dart';

/// A screen that guides users through OBD connection options.
class ConnectionSetupScreen extends StatefulWidget {
  /// Callback function when the user taps the "Continue" button
  final VoidCallback? onContinue;

  /// Creates a connection setup screen.
  const ConnectionSetupScreen({
    super.key,
    this.onContinue,
  });

  @override
  State<ConnectionSetupScreen> createState() => _ConnectionSetupScreenState();
}

class _ConnectionSetupScreenState extends State<ConnectionSetupScreen> {
  // Connection options
  String? _selectedOption;
  
  // Whether to show the OBD help dialog
  bool _showOBDHelp = false;
  
  // Permission service reference
  late final PermissionService _permissionService;
  
  @override
  void initState() {
    super.initState();
    _permissionService = serviceLocator<PermissionService>();
  }

  // Request permissions based on connection choice
  Future<void> _requestPermissions(String option) async {
    if (option == 'obd_adapter') {
      // For OBD adapter, we need Bluetooth permissions
      // First check if permissions are already granted
      final hasBluetoothPermission = await _permissionService.areBluetoothPermissionsGranted();
      
      if (!hasBluetoothPermission) {
        // Show explanation dialog first
        if (mounted) {
          await showDialog(
            context: context,
            builder: (context) => AlertDialog(
              title: const Text('Bluetooth Permission'),
              content: const Text(
                'Going50 needs Bluetooth permission to connect to your OBD adapter. '
                'This allows the app to read vehicle data for more accurate eco-driving analysis.'
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: const Text('OK'),
                ),
              ],
            ),
          );
        }
        
        // Request Bluetooth permissions
        await _permissionService.requestBluetoothPermissions();
      }
    }
    
    // For both options, we need location permissions
    final hasLocationPermission = await _permissionService.areLocationPermissionsGranted();
    
    if (!hasLocationPermission && mounted) {
      // Show explanation dialog first
      await showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Location Permission'),
          content: const Text(
            'Going50 needs location permission to track your trips and provide accurate eco-driving feedback. '
            'This data stays on your device unless you choose to share it.'
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('OK'),
            ),
          ],
        ),
      );
      
      // Request location permission
      await _permissionService.requestLocationPermissions(background: false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Stack(
      children: [
        // Main content
        Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 24),
              
              // Headline
              Text(
                'Choose your setup',
                style: theme.textTheme.headlineMedium,
              ),
              
              const SizedBox(height: 8),
              
              // Explanation text
              Text(
                'Going50 works with or without an OBD adapter. Choose the option that works best for you.',
                style: theme.textTheme.bodyLarge,
              ),
              
              const SizedBox(height: 24),
              
              // Connection options
              Expanded(
                child: SingleChildScrollView(
                  child: Column(
                    children: [
                      // Phone only option
                      _ConnectionOptionCard(
                        title: 'Phone only',
                        subtitle: 'Use your phone sensors for basic tracking',
                        icon: Icons.phone_android,
                        benefits: [
                          'No additional hardware required',
                          'Easy setup with no connections',
                          'Works in any vehicle',
                        ],
                        limitations: [
                          'Limited accuracy for some metrics',
                          'No engine-specific data available',
                        ],
                        isSelected: _selectedOption == 'phone_only',
                        onTap: () {
                          setState(() {
                            _selectedOption = 'phone_only';
                          });
                        },
                      ),
                      
                      const SizedBox(height: 16),
                      
                      // OBD adapter option
                      _ConnectionOptionCard(
                        title: 'Connect OBD adapter',
                        subtitle: 'Get enhanced data with an OBD2 adapter',
                        icon: Icons.bluetooth,
                        benefits: [
                          'Higher accuracy for all metrics',
                          'Real-time engine data',
                          'More detailed feedback and analysis',
                          'Better fuel savings estimates',
                        ],
                        isSelected: _selectedOption == 'obd_adapter',
                        onTap: () {
                          setState(() {
                            _selectedOption = 'obd_adapter';
                          });
                        },
                      ),
                      
                      const SizedBox(height: 16),
                      
                      // Help link
                      Center(
                        child: TextButton.icon(
                          icon: const Icon(Icons.help_outline, size: 16),
                          label: const Text("What's an OBD adapter?"),
                          onPressed: () {
                            setState(() {
                              _showOBDHelp = true;
                            });
                          },
                        ),
                      ),
                    ],
                  ),
                ),
              ),
              
              const SizedBox(height: 24),
              
              // Continue button
              PrimaryButton(
                text: 'Continue',
                onPressed: _selectedOption == null
                    ? null
                    : () async {
                        // Request appropriate permissions first
                        await _requestPermissions(_selectedOption!);
                        
                        // Set the connection choice in the provider
                        final drivingProvider = Provider.of<DrivingProvider>(
                          context, 
                          listen: false
                        );
                        
                        if (_selectedOption == 'obd_adapter') {
                          // Users who want to use an OBD adapter should be taken to scan for devices
                          // This will be implemented in the next step - for now just set a flag
                          drivingProvider.setPreferOBD(true);
                          
                          // TODO: Show device scan screen when it's implemented
                          // For now, we'll just continue to the main app
                          if (widget.onContinue != null) {
                            widget.onContinue!();
                          }
                        } else {
                          // Users who want to use phone only can proceed directly
                          drivingProvider.setPreferOBD(false);
                          
                          if (widget.onContinue != null) {
                            widget.onContinue!();
                          }
                        }
                      },
              ),
              
              SizedBox(height: MediaQuery.of(context).padding.bottom + 16),
            ],
          ),
        ),
        
        // OBD Help Dialog
        if (_showOBDHelp)
          _OBDHelpDialog(
            onClose: () {
              setState(() {
                _showOBDHelp = false;
              });
            },
          ),
      ],
    );
  }
}

/// A card widget for connection options.
class _ConnectionOptionCard extends StatelessWidget {
  final String title;
  final String subtitle;
  final IconData icon;
  final List<String> benefits;
  final List<String>? limitations;
  final bool isSelected;
  final VoidCallback onTap;

  const _ConnectionOptionCard({
    required this.title,
    required this.subtitle,
    required this.icon,
    required this.benefits,
    this.limitations,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: isSelected
              ? theme.colorScheme.primaryContainer.withOpacity(0.3)
              : theme.colorScheme.surface,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: isSelected
                ? theme.colorScheme.primary
                : theme.colorScheme.outline.withOpacity(0.5),
            width: isSelected ? 2 : 1,
          ),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Icon and title
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: theme.colorScheme.primaryContainer,
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Icon(
                    icon,
                    color: theme.colorScheme.primary,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        title,
                        style: theme.textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        subtitle,
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],
                  ),
                ),
                Icon(
                  isSelected ? Icons.check_circle : Icons.circle_outlined,
                  color: isSelected
                      ? theme.colorScheme.primary
                      : theme.colorScheme.onSurfaceVariant,
                ),
              ],
            ),
            
            const SizedBox(height: 16),
            
            // Benefits
            ...benefits.map((benefit) => _BulletItem(
              text: benefit,
              iconColor: theme.colorScheme.primary,
              isPositive: true,
            )),
            
            // Limitations
            if (limitations != null && limitations!.isNotEmpty) ...[
              const SizedBox(height: 8),
              ...limitations!.map((limitation) => _BulletItem(
                text: limitation,
                iconColor: theme.colorScheme.error,
                isPositive: false,
              )),
            ],
          ],
        ),
      ),
    );
  }
}

/// A bullet point item for lists.
class _BulletItem extends StatelessWidget {
  final String text;
  final Color iconColor;
  final bool isPositive;

  const _BulletItem({
    required this.text,
    required this.iconColor,
    required this.isPositive,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(
            isPositive ? Icons.check_circle_outline : Icons.info_outline,
            size: 16,
            color: iconColor,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              text,
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ],
      ),
    );
  }
}

/// A dialog explaining what an OBD adapter is.
class _OBDHelpDialog extends StatelessWidget {
  final VoidCallback onClose;

  const _OBDHelpDialog({
    required this.onClose,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return GestureDetector(
      onTap: onClose,
      child: Container(
        color: Colors.black.withOpacity(0.5),
        alignment: Alignment.center,
        child: GestureDetector(
          onTap: () {}, // Prevent tap through
          child: Container(
            margin: const EdgeInsets.all(24),
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: theme.colorScheme.surface,
              borderRadius: BorderRadius.circular(16),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.2),
                  blurRadius: 10,
                  offset: const Offset(0, 4),
                ),
              ],
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Title
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        'What is an OBD adapter?',
                        style: theme.textTheme.titleLarge?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                    IconButton(
                      icon: const Icon(Icons.close),
                      onPressed: onClose,
                    ),
                  ],
                ),
                
                const SizedBox(height: 16),
                
                // Content
                Text(
                  'An OBD (On-Board Diagnostics) adapter is a small device that plugs into your car\'s diagnostic port, usually located under the dashboard.',
                  style: theme.textTheme.bodyMedium,
                ),
                
                const SizedBox(height: 8),
                
                Text(
                  'When connected to Going50, it provides real-time engine data that enables more accurate eco-driving analysis and personalized feedback.',
                  style: theme.textTheme.bodyMedium,
                ),
                
                const SizedBox(height: 16),
                
                // Where to buy
                Text(
                  'Where to get one:',
                  style: theme.textTheme.titleMedium,
                ),
                
                const SizedBox(height: 8),
                
                Text(
                  '• Auto parts stores like AutoZone or Advance Auto Parts\n'
                  '• Online retailers like Amazon or eBay\n'
                  '• Electronics stores',
                  style: theme.textTheme.bodyMedium,
                ),
                
                const SizedBox(height: 8),
                
                Text(
                  'Look for "ELM327 Bluetooth OBD2 Adapter" - they typically cost \$10-30.',
                  style: theme.textTheme.bodyMedium?.copyWith(
                    fontStyle: FontStyle.italic,
                  ),
                ),
                
                const SizedBox(height: 24),
                
                // Close button
                Center(
                  child: PrimaryButton(
                    text: 'Got it',
                    onPressed: onClose,
                    fullWidth: false,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/onboarding/welcome_screen.dart
################################################################################

import 'package:flutter/material.dart';
import '../../../core/constants/app_constants.dart';
import '../../widgets/common/buttons/primary_button.dart';

/// The initial welcome screen of the onboarding flow.
///
/// This screen introduces the app to new users and provides
/// a brief overview of the value proposition.
class WelcomeScreen extends StatelessWidget {
  /// Callback function when the user taps the "Get Started" button
  final VoidCallback? onGetStarted;

  /// Creates a welcome screen.
  const WelcomeScreen({
    super.key,
    this.onGetStarted,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final screenHeight = MediaQuery.of(context).size.height;
    
    return Padding(
      padding: const EdgeInsets.all(24.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          // Top section with logo and tagline
          Column(
            children: [
              SizedBox(height: screenHeight * 0.05),
              // App logo
              const Icon(
                Icons.eco, // Using placeholder icon - replace with actual logo
                size: 80,
                color: Colors.green,
              ),
              const SizedBox(height: 16),
              // App name
              Text(
                AppInfo.appName,
                style: theme.textTheme.headlineMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 8),
              // Tagline
              Text(
                'Drive Smart, Live Green',
                style: theme.textTheme.titleLarge,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32),
              // Value proposition
              Text(
                'Cut your fuel costs by up to 25% and reduce your carbon footprint with personalized eco-driving insights.',
                style: theme.textTheme.bodyLarge,
                textAlign: TextAlign.center,
              ),
            ],
          ),
          
          // Bottom section with CTA buttons
          Column(
            children: [
              // Primary CTA
              PrimaryButton(
                text: 'Get Started',
                onPressed: onGetStarted,
                fullWidth: true,
              ),
              const SizedBox(height: 16),
              // Secondary CTA (login link)
              GestureDetector(
                onTap: () {
                  // TODO: Implement login flow when available
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Login feature coming soon'),
                    ),
                  );
                },
                child: Text(
                  'Already have an account? Log in',
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.primary,
                  ),
                ),
              ),
              SizedBox(height: MediaQuery.of(context).padding.bottom + 16),
            ],
          ),
        ],
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/screens/onboarding/account_choice_screen.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../core/constants/app_constants.dart';
import '../../providers/user_provider.dart';
import '../../widgets/common/buttons/primary_button.dart';

/// A screen that allows users to choose between a quick start
/// (anonymous) or creating an account.
class AccountChoiceScreen extends StatefulWidget {
  /// Callback function when the user taps the "Continue" button
  final VoidCallback? onContinue;

  /// Creates an account choice screen.
  const AccountChoiceScreen({
    super.key,
    this.onContinue,
  });

  @override
  State<AccountChoiceScreen> createState() => _AccountChoiceScreenState();
}

class _AccountChoiceScreenState extends State<AccountChoiceScreen> {
  // Choice options
  final _choices = [
    {
      'id': 'quick_start',
      'title': 'Quick Start',
      'subtitle': 'Get started immediately with basic features',
      'benefits': [
        'No account required',
        'No email or personal information needed',
        'Start driving immediately',
      ],
      'limitations': [
        'Some features limited',
        'Progress not synced between devices',
      ],
    },
    {
      'id': 'create_account',
      'title': 'Create Account',
      'subtitle': 'Access all features and sync your data',
      'benefits': [
        'Access all premium features',
        'Save data across multiple devices',
        'Join challenges and leaderboards',
        'Track your progress long-term',
      ],
    },
  ];

  // Selected choice
  String? _selectedChoiceId;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Padding(
      padding: const EdgeInsets.all(24.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Top section with app logo
          Center(
            child: Column(
              children: [
                const SizedBox(height: 24),
                Icon(
                  Icons.eco, // Placeholder icon - replace with actual logo
                  size: 40,
                  color: theme.colorScheme.primary,
                ),
                const SizedBox(height: 8),
                Text(
                  AppInfo.appName,
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
          
          const SizedBox(height: 32),
          
          // Question headline
          Text(
            'How would you like to continue?',
            style: theme.textTheme.headlineSmall,
          ),
          
          const SizedBox(height: 24),
          
          // Choice cards
          Expanded(
            child: ListView.builder(
              itemCount: _choices.length,
              itemBuilder: (context, index) {
                final choice = _choices[index];
                final isSelected = _selectedChoiceId == choice['id'];
                
                return _ChoiceCard(
                  title: choice['title'] as String,
                  subtitle: choice['subtitle'] as String,
                  benefits: choice['benefits'] as List<String>,
                  limitations: (choice['limitations'] as List<String>?) ?? [],
                  isSelected: isSelected,
                  onTap: () {
                    setState(() {
                      _selectedChoiceId = choice['id'] as String;
                    });
                  },
                );
              },
            ),
          ),
          
          const SizedBox(height: 24),
          
          // Continue button
          PrimaryButton(
            text: 'Continue',
            onPressed: _selectedChoiceId == null
                ? null
                : () {
                    // Handle the selected choice
                    if (_selectedChoiceId == 'quick_start') {
                      // Set user as anonymous
                      final userProvider = Provider.of<UserProvider>(
                        context, 
                        listen: false
                      );
                      
                      // TODO: Implement proper quick start flow
                      // In the future, we would use userProvider to set anonymous user
                      
                    } else if (_selectedChoiceId == 'create_account') {
                      // Set up for account creation
                      // TODO: Implement account creation flow
                    }
                    
                    // Continue to next screen
                    if (widget.onContinue != null) {
                      widget.onContinue!();
                    }
                  },
          ),
          
          SizedBox(height: MediaQuery.of(context).padding.bottom + 16),
        ],
      ),
    );
  }
}

/// A card widget that represents a choice option.
class _ChoiceCard extends StatelessWidget {
  final String title;
  final String subtitle;
  final List<String> benefits;
  final List<String> limitations;
  final bool isSelected;
  final VoidCallback onTap;

  const _ChoiceCard({
    required this.title,
    required this.subtitle,
    required this.benefits,
    required this.limitations,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return GestureDetector(
      onTap: onTap,
      child: Container(
        margin: const EdgeInsets.only(bottom: 16),
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: isSelected
              ? theme.colorScheme.primaryContainer.withOpacity(0.3)
              : theme.colorScheme.surface,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: isSelected
                ? theme.colorScheme.primary
                : theme.colorScheme.outline.withOpacity(0.5),
            width: isSelected ? 2 : 1,
          ),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Title and selection indicator
            Row(
              children: [
                Expanded(
                  child: Text(
                    title,
                    style: theme.textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                Icon(
                  isSelected ? Icons.check_circle : Icons.circle_outlined,
                  color: isSelected
                      ? theme.colorScheme.primary
                      : theme.colorScheme.onSurfaceVariant,
                ),
              ],
            ),
            
            const SizedBox(height: 4),
            
            // Subtitle
            Text(
              subtitle,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
            
            const SizedBox(height: 16),
            
            // Benefits
            ...benefits.map((benefit) => _BulletItem(
              text: benefit,
              iconColor: theme.colorScheme.primary,
            )),
            
            // Limitations (if any)
            if (limitations.isNotEmpty) ...[
              const SizedBox(height: 8),
              ...limitations.map((limitation) => _BulletItem(
                text: limitation,
                iconColor: theme.colorScheme.error,
                isNegative: true,
              )),
            ],
          ],
        ),
      ),
    );
  }
}

/// A bullet point list item.
class _BulletItem extends StatelessWidget {
  final String text;
  final Color iconColor;
  final bool isNegative;

  const _BulletItem({
    required this.text,
    required this.iconColor,
    this.isNegative = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(
            isNegative ? Icons.remove_circle_outline : Icons.check_circle_outline,
            size: 16,
            color: iconColor,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              text,
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ],
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/widgets/achievements/achievement_celebration.dart
################################################################################

import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:going50/core/theme/app_colors.dart';

/// A widget that displays a celebration animation when a user unlocks an achievement
///
/// This widget shows a visually rewarding animation to celebrate achievement unlocks,
/// making the achievement experience more engaging and satisfying.
class AchievementCelebration extends StatefulWidget {
  /// Title of the achievement
  final String title;
  
  /// Description of the achievement
  final String description;
  
  /// Icon to display
  final IconData icon;
  
  /// Whether to auto-dismiss after a certain duration
  final bool autoDismiss;
  
  /// Callback when the celebration is dismissed
  final VoidCallback? onDismiss;
  
  /// Duration before auto-dismissing (if autoDismiss is true)
  final Duration autoDismissDuration;
  
  /// Constructor
  const AchievementCelebration({
    super.key,
    required this.title,
    required this.description,
    required this.icon,
    this.autoDismiss = true,
    this.onDismiss,
    this.autoDismissDuration = const Duration(seconds: 5),
  });

  @override
  State<AchievementCelebration> createState() => _AchievementCelebrationState();
}

class _AchievementCelebrationState extends State<AchievementCelebration> with TickerProviderStateMixin {
  late AnimationController _entryController;
  late AnimationController _shineController;
  late AnimationController _confettiController;
  late Animation<double> _scaleAnimation;
  late Animation<double> _rotateAnimation;
  late Animation<double> _shineAnimation;
  
  @override
  void initState() {
    super.initState();
    
    // Entry animations
    _entryController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1200),
    );
    
    _scaleAnimation = TweenSequence<double>([
      TweenSequenceItem(tween: Tween<double>(begin: 0.0, end: 1.2), weight: 1),
      TweenSequenceItem(tween: Tween<double>(begin: 1.2, end: 1.0), weight: 1),
    ]).animate(
      CurvedAnimation(
        parent: _entryController,
        curve: Interval(0.0, 0.7, curve: Curves.elasticOut),
      ),
    );
    
    _rotateAnimation = TweenSequence<double>([
      TweenSequenceItem(tween: Tween<double>(begin: -0.05, end: 0.05), weight: 1),
      TweenSequenceItem(tween: Tween<double>(begin: 0.05, end: 0.0), weight: 1),
    ]).animate(
      CurvedAnimation(
        parent: _entryController,
        curve: Interval(0.4, 0.6, curve: Curves.easeInOut),
      ),
    );
    
    // Shine animation
    _shineController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    );
    
    _shineAnimation = Tween<double>(begin: -1.0, end: 2.0).animate(
      CurvedAnimation(
        parent: _shineController,
        curve: Curves.easeInOut,
      ),
    );
    
    // Confetti animation
    _confettiController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 3000),
    );
    
    // Start animations in sequence
    _entryController.forward().then((_) {
      _shineController.repeat(min: -1.0, max: 2.0, period: const Duration(milliseconds: 2000));
      _confettiController.forward();
      
      // Auto-dismiss if enabled
      if (widget.autoDismiss) {
        Future.delayed(widget.autoDismissDuration, () {
          if (mounted) {
            _dismiss();
          }
        });
      }
    });
  }
  
  @override
  void dispose() {
    _entryController.dispose();
    _shineController.dispose();
    _confettiController.dispose();
    super.dispose();
  }
  
  /// Dismiss the celebration
  void _dismiss() {
    Navigator.of(context).pop();
    if (widget.onDismiss != null) {
      widget.onDismiss!();
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.black54,
      child: GestureDetector(
        onTap: _dismiss,
        behavior: HitTestBehavior.opaque,
        child: Center(
          child: AnimatedBuilder(
            animation: Listenable.merge([_entryController, _shineController, _confettiController]),
            builder: (context, child) {
              return Stack(
                alignment: Alignment.center,
                children: [
                  // Confetti particles
                  ...List.generate(30, (i) {
                    final random = math.Random(i);
                    final size = random.nextDouble() * 10 + 5;
                    final angle = random.nextDouble() * math.pi * 2;
                    final maxDistance = MediaQuery.of(context).size.width * 0.45;
                    final distance = maxDistance * _confettiController.value;
                    final opacity = 1.0 - _confettiController.value;
                    final baseColor = [
                      AppColors.primary,
                      AppColors.secondary,
                      AppColors.ecoScoreHigh,
                      AppColors.ecoScoreLow,
                      AppColors.ecoScoreMedium,
                    ][random.nextInt(5)];
                    
                    return Positioned(
                      left: MediaQuery.of(context).size.width / 2 + math.cos(angle) * distance,
                      top: MediaQuery.of(context).size.height / 2 + math.sin(angle) * distance,
                      child: Opacity(
                        opacity: opacity > 0 ? opacity : 0,
                        child: Transform.rotate(
                          angle: angle,
                          child: Container(
                            width: size,
                            height: size,
                            decoration: BoxDecoration(
                              color: baseColor.withOpacity(0.9),
                              shape: random.nextBool() ? BoxShape.circle : BoxShape.rectangle,
                            ),
                          ),
                        ),
                      ),
                    );
                  }),
                  
                  // Main achievement card
                  Transform.scale(
                    scale: _scaleAnimation.value,
                    child: Transform.rotate(
                      angle: _rotateAnimation.value * math.pi,
                      child: Container(
                        width: MediaQuery.of(context).size.width * 0.85,
                        padding: const EdgeInsets.all(24),
                        decoration: BoxDecoration(
                          color: Theme.of(context).cardColor,
                          borderRadius: BorderRadius.circular(24),
                          boxShadow: [
                            BoxShadow(
                              color: AppColors.ecoScoreHigh.withOpacity(0.5),
                              blurRadius: 15,
                              spreadRadius: 5,
                            ),
                          ],
                          border: Border.all(
                            color: AppColors.ecoScoreHigh,
                            width: 3,
                          ),
                        ),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            // Achievement unlocked banner
                            Container(
                              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                              decoration: BoxDecoration(
                                color: AppColors.ecoScoreHigh.withOpacity(0.2),
                                borderRadius: BorderRadius.circular(16),
                                border: Border.all(
                                  color: AppColors.ecoScoreHigh,
                                  width: 2,
                                ),
                              ),
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  Icon(
                                    Icons.emoji_events,
                                    color: AppColors.ecoScoreHigh,
                                    size: 20,
                                  ),
                                  const SizedBox(width: 8),
                                  Text(
                                    'Achievement Unlocked!',
                                    style: TextStyle(
                                      color: AppColors.ecoScoreHigh,
                                      fontWeight: FontWeight.bold,
                                      fontSize: 16,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                            
                            const SizedBox(height: 24),
                            
                            // Badge icon
                            Stack(
                              alignment: Alignment.center,
                              children: [
                                // Shine effect around the badge
                                Container(
                                  width: 100,
                                  height: 100,
                                  decoration: BoxDecoration(
                                    shape: BoxShape.circle,
                                    gradient: RadialGradient(
                                      colors: [
                                        AppColors.ecoScoreHigh.withOpacity(0.7),
                                        AppColors.ecoScoreHigh.withOpacity(0.0),
                                      ],
                                      stops: const [0.7, 1.0],
                                    ),
                                  ),
                                ),
                                
                                // Badge container with shine effect
                                ClipOval(
                                  child: Container(
                                    width: 80,
                                    height: 80,
                                    color: AppColors.ecoScoreHigh.withOpacity(0.2),
                                    child: Stack(
                                      children: [
                                        // Icon
                                        Center(
                                          child: Icon(
                                            widget.icon,
                                            size: 40,
                                            color: AppColors.ecoScoreHigh,
                                          ),
                                        ),
                                        
                                        // Shine overlay
                                        Transform.rotate(
                                          angle: math.pi / 4,
                                          child: Transform.translate(
                                            offset: Offset(
                                              _shineAnimation.value * 150,
                                              0,
                                            ),
                                            child: Container(
                                              width: 40,
                                              decoration: BoxDecoration(
                                                gradient: LinearGradient(
                                                  colors: [
                                                    Colors.white.withOpacity(0),
                                                    Colors.white.withOpacity(0.4),
                                                    Colors.white.withOpacity(0),
                                                  ],
                                                  stops: const [0.0, 0.5, 1.0],
                                                ),
                                              ),
                                            ),
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                                ),
                              ],
                            ),
                            
                            const SizedBox(height: 24),
                            
                            // Achievement title
                            Text(
                              widget.title,
                              textAlign: TextAlign.center,
                              style: const TextStyle(
                                fontSize: 22,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            
                            const SizedBox(height: 12),
                            
                            // Achievement description
                            Text(
                              widget.description,
                              textAlign: TextAlign.center,
                              style: TextStyle(
                                fontSize: 16,
                                color: Theme.of(context).textTheme.bodyLarge?.color?.withOpacity(0.8),
                              ),
                            ),
                            
                            const SizedBox(height: 24),
                            
                            // Dismiss button
                            TextButton(
                              onPressed: _dismiss,
                              style: TextButton.styleFrom(
                                padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(20),
                                ),
                                backgroundColor: AppColors.primary.withOpacity(0.1),
                              ),
                              child: const Text('Awesome!'),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ],
              );
            },
          ),
        ),
      ),
    );
  }
}

/// Shows the achievement celebration dialog
void showAchievementCelebration(
  BuildContext context, {
  required String title,
  required String description,
  required IconData icon,
  bool autoDismiss = true,
  VoidCallback? onDismiss,
  Duration autoDismissDuration = const Duration(seconds: 5),
}) {
  showDialog(
    context: context,
    barrierDismissible: true,
    builder: (context) => AchievementCelebration(
      title: title,
      description: description,
      icon: icon,
      autoDismiss: autoDismiss,
      onDismiss: onDismiss,
      autoDismissDuration: autoDismissDuration,
    ),
  );
} 

################################################################################
FILE: lib/presentation/widgets/common/buttons/primary_button.dart
################################################################################

import 'package:flutter/material.dart';

/// A primary action button with the app's brand color.
/// 
/// This button is used for primary actions in the app.
/// It follows the design system with a specific height,
/// padding, background color, text color, and corner radius.
///
/// Example:
/// ```dart
/// PrimaryButton(
///   onPressed: () {
///     // Handle button press
///   },
///   text: 'Start Trip',
/// )
/// ```
class PrimaryButton extends StatelessWidget {
  /// The text to display on the button
  final String text;
  
  /// The callback function when the button is pressed
  final VoidCallback? onPressed;
  
  /// Optional icon to display before the text
  final IconData? icon;
  
  /// Whether the button should take the full width available
  final bool fullWidth;
  
  /// Optional custom padding override
  final EdgeInsetsGeometry? padding;
  
  /// Create a primary button with the app's brand styling
  const PrimaryButton({
    super.key,
    required this.text,
    required this.onPressed,
    this.icon,
    this.fullWidth = true,
    this.padding,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    Widget buttonContent = Text(
      text,
      style: theme.textTheme.labelLarge?.copyWith(
        color: theme.colorScheme.onPrimary,
      ),
    );
    
    if (icon != null) {
      buttonContent = Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 18),
          const SizedBox(width: 8),
          buttonContent,
        ],
      );
    }
    
    return SizedBox(
      width: fullWidth ? double.infinity : null,
      height: 48,
      child: ElevatedButton(
        onPressed: onPressed,
        style: theme.elevatedButtonTheme.style,
        child: Padding(
          padding: padding ?? const EdgeInsets.symmetric(horizontal: 24),
          child: buttonContent,
        ),
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/widgets/common/buttons/secondary_button.dart
################################################################################

import 'package:flutter/material.dart';

/// A secondary action button with transparent background and outlined border.
/// 
/// This button is used for secondary actions in the app.
/// It follows the design system with a specific height,
/// padding, transparent background, primary color text, and corner radius.
///
/// Example:
/// ```dart
/// SecondaryButton(
///   onPressed: () {
///     // Handle button press
///   },
///   text: 'Cancel',
/// )
/// ```
class SecondaryButton extends StatelessWidget {
  /// The text to display on the button
  final String text;
  
  /// The callback function when the button is pressed
  final VoidCallback? onPressed;
  
  /// Optional icon to display before the text
  final IconData? icon;
  
  /// Whether the button should take the full width available
  final bool fullWidth;
  
  /// Optional custom padding override
  final EdgeInsetsGeometry? padding;
  
  /// Create a secondary button with the app's brand styling
  const SecondaryButton({
    super.key,
    required this.text,
    required this.onPressed,
    this.icon,
    this.fullWidth = true,
    this.padding,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    Widget buttonContent = Text(
      text,
      style: theme.textTheme.labelLarge?.copyWith(
        color: theme.colorScheme.primary,
      ),
    );
    
    if (icon != null) {
      buttonContent = Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 18, color: theme.colorScheme.primary),
          const SizedBox(width: 8),
          buttonContent,
        ],
      );
    }
    
    return SizedBox(
      width: fullWidth ? double.infinity : null,
      height: 48,
      child: OutlinedButton(
        onPressed: onPressed,
        style: theme.outlinedButtonTheme.style,
        child: Padding(
          padding: padding ?? const EdgeInsets.symmetric(horizontal: 24),
          child: buttonContent,
        ),
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/widgets/common/layout/section_container.dart
################################################################################

import 'package:flutter/material.dart';

/// A container for sections of content with consistent styling.
///
/// This component provides a standardized way to layout sections
/// with optional titles, padding, and consistent spacing.
///
/// Example:
/// ```dart
/// SectionContainer(
///   title: 'Recent Trips',
///   child: ListView(
///     children: [
///       // List items
///     ],
///   ),
/// )
/// ```
class SectionContainer extends StatelessWidget {
  /// Optional title for the section
  final String? title;
  
  /// The content to display in the section
  final Widget child;
  
  /// Optional background color for the section
  final Color? backgroundColor;
  
  /// Optional padding to apply to the section contents
  final EdgeInsetsGeometry padding;
  
  /// Optional margin to apply around the container
  final EdgeInsetsGeometry margin;
  
  /// Whether to add a divider at the top of the section
  final bool topDivider;
  
  /// Whether to add a divider at the bottom of the section
  final bool bottomDivider;
  
  /// Optional action widget to display next to the title (e.g., "See All" button)
  final Widget? action;
  
  /// Create a section container with the app's styling
  const SectionContainer({
    super.key,
    this.title,
    required this.child,
    this.backgroundColor,
    this.padding = const EdgeInsets.all(16),
    this.margin = const EdgeInsets.only(bottom: 16),
    this.topDivider = false,
    this.bottomDivider = false,
    this.action,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Container(
      margin: margin,
      decoration: BoxDecoration(
        color: backgroundColor ?? theme.cardTheme.color,
        boxShadow: backgroundColor != null 
            ? null 
            : [
                BoxShadow(
                  color: Colors.black.withAlpha(13), // ~0.05 opacity
                  blurRadius: 4,
                  offset: const Offset(0, 2),
                ),
              ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          if (topDivider) Divider(height: 1, thickness: 1, color: theme.dividerTheme.color),
          
          if (title != null) ...[
            Padding(
              padding: EdgeInsets.only(
                left: padding.horizontal / 2,
                right: padding.horizontal / 2,
                top: padding.vertical / 2,
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    title!,
                    style: theme.textTheme.titleLarge?.copyWith(
                      fontSize: 18,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  if (action != null) action!,
                ],
              ),
            ),
          ],
          
          Padding(
            padding: title != null 
                ? EdgeInsets.only(
                    left: padding.horizontal / 2,
                    right: padding.horizontal / 2,
                    top: padding.vertical / 4,
                    bottom: padding.vertical / 2,
                  ) 
                : padding,
            child: child,
          ),
          
          if (bottomDivider) Divider(height: 1, thickness: 1, color: theme.dividerTheme.color),
        ],
      ),
    );
  }
}

/// Extension to get horizontal and vertical padding from EdgeInsetsGeometry
extension EdgeInsetsGeometryExtension on EdgeInsetsGeometry {
  /// The horizontal padding value
  double get horizontal {
    if (this is EdgeInsets) {
      final EdgeInsets edgeInsets = this as EdgeInsets;
      return edgeInsets.left + edgeInsets.right;
    }
    return 32; // Default if not EdgeInsets
  }
  
  /// The vertical padding value
  double get vertical {
    if (this is EdgeInsets) {
      final EdgeInsets edgeInsets = this as EdgeInsets;
      return edgeInsets.top + edgeInsets.bottom;
    }
    return 32; // Default if not EdgeInsets
  }
} 

################################################################################
FILE: lib/presentation/widgets/common/indicators/status_indicator.dart
################################################################################

import 'package:flutter/material.dart';

/// Status indicator types that determine the visual appearance
enum StatusType {
  /// For successful operations or good status
  success,
  
  /// For caution or pending operations
  warning,
  
  /// For errors or critical issues
  error,
  
  /// For informational or neutral status
  info,
  
  /// For inactive or disabled status
  inactive
}

/// A status indicator pill that displays the current status with an icon and text.
///
/// This component follows the design system with specific styling for different
/// status types (success, warning, error, info, inactive).
///
/// Example:
/// ```dart
/// StatusIndicator(
///   type: StatusType.success,
///   text: 'Connected',
///   icon: Icons.bluetooth_connected,
/// )
/// ```
class StatusIndicator extends StatelessWidget {
  /// The type of status to display
  final StatusType type;
  
  /// The text to display inside the pill
  final String text;
  
  /// Optional icon to display before the text
  final IconData? icon;
  
  /// Optional custom background color to override the default
  final Color? backgroundColor;
  
  /// Optional custom text color to override the default
  final Color? textColor;
  
  /// Create a status indicator with the app's styling
  const StatusIndicator({
    super.key,
    required this.type,
    required this.text,
    this.icon,
    this.backgroundColor,
    this.textColor,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    // Default colors based on status type
    final Color defaultBgColor = _getBackgroundColor(theme, type);
    final Color defaultTextColor = _getTextColor(theme, type);
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      decoration: BoxDecoration(
        color: backgroundColor ?? defaultBgColor,
        borderRadius: BorderRadius.circular(16),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (icon != null) ...[
            Icon(
              icon,
              size: 16,
              color: textColor ?? defaultTextColor,
            ),
            const SizedBox(width: 6),
          ],
          Text(
            text,
            style: theme.textTheme.bodySmall?.copyWith(
              color: textColor ?? defaultTextColor,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }
  
  /// Returns the background color for a given status type
  Color _getBackgroundColor(ThemeData theme, StatusType type) {
    switch (type) {
      case StatusType.success:
        return theme.colorScheme.primary.withAlpha(38); // ~0.15 opacity
      case StatusType.warning:
        return const Color(0xFFFF9800).withAlpha(38); // ~0.15 opacity
      case StatusType.error:
        return theme.colorScheme.error.withAlpha(38); // ~0.15 opacity
      case StatusType.info:
        return theme.colorScheme.secondary.withAlpha(38); // ~0.15 opacity
      case StatusType.inactive:
        return const Color(0xFF9E9E9E).withAlpha(38); // ~0.15 opacity
    }
  }
  
  /// Returns the text color for a given status type
  Color _getTextColor(ThemeData theme, StatusType type) {
    switch (type) {
      case StatusType.success:
        return theme.colorScheme.primary;
      case StatusType.warning:
        return const Color(0xFFFF9800); // Warning color
      case StatusType.error:
        return theme.colorScheme.error;
      case StatusType.info:
        return theme.colorScheme.secondary;
      case StatusType.inactive:
        return const Color(0xFF9E9E9E); // Gray
    }
  }
} 

################################################################################
FILE: lib/presentation/widgets/common/cards/stats_card.dart
################################################################################

import 'package:flutter/material.dart';

/// A card for displaying statistic data with a headline figure and label.
///
/// This card follows the design system with specific padding,
/// corner radius, elevation, and text styles for statistics display.
///
/// Example:
/// ```dart
/// StatsCard(
///   headline: '87',
///   label: 'Eco-Score',
///   comparisonText: '12% better than last week',
///   isPositiveComparison: true,
///   onTap: () {
///     // Handle card tap
///   },
/// )
/// ```
class StatsCard extends StatelessWidget {
  /// The headline figure to display prominently
  final String headline;
  
  /// The label describing what the headline represents
  final String label;
  
  /// Optional text to show comparison with previous period
  final String? comparisonText;
  
  /// Whether the comparison is positive (true) or negative (false)
  final bool? isPositiveComparison;
  
  /// Optional icon to display with the headline
  final IconData? icon;
  
  /// Optional callback when the card is tapped
  final VoidCallback? onTap;
  
  /// Create a stats card with the app's styling
  const StatsCard({
    super.key,
    required this.headline,
    required this.label,
    this.comparisonText,
    this.isPositiveComparison,
    this.icon,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Card(
      elevation: 1,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(8),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  if (icon != null) ...[
                    Icon(icon, color: theme.colorScheme.primary, size: 18),
                    const SizedBox(width: 8),
                  ],
                  Text(
                    label,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: theme.colorScheme.onSurface.withAlpha(178), // ~0.7 opacity
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 4),
              Text(
                headline,
                style: theme.textTheme.headlineMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                  fontSize: 24,
                ),
              ),
              if (comparisonText != null) ...[
                const SizedBox(height: 4),
                Row(
                  children: [
                    if (isPositiveComparison != null)
                      Icon(
                        isPositiveComparison! 
                            ? Icons.arrow_upward 
                            : Icons.arrow_downward,
                        color: isPositiveComparison! 
                            ? theme.colorScheme.primary 
                            : theme.colorScheme.error,
                        size: 14,
                      ),
                    const SizedBox(width: 4),
                    Flexible(
                      child: Text(
                        comparisonText!,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: isPositiveComparison != null
                              ? (isPositiveComparison!
                                  ? theme.colorScheme.primary
                                  : theme.colorScheme.error)
                              : theme.colorScheme.onSurface.withAlpha(178), // ~0.7 opacity
                          fontSize: 12,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/widgets/common/cards/info_card.dart
################################################################################

import 'package:flutter/material.dart';

/// A card that displays informational content with optional icon.
///
/// This card follows the design system with specific padding,
/// corner radius, elevation, and text styles.
///
/// Example:
/// ```dart
/// InfoCard(
///   title: 'Eco-Driving Tip',
///   content: 'Avoid aggressive acceleration to improve fuel efficiency.',
///   icon: Icons.lightbulb_outline,
///   onTap: () {
///     // Handle card tap
///   },
/// )
/// ```
class InfoCard extends StatelessWidget {
  /// The title of the card
  final String title;
  
  /// The main content text of the card
  final String content;
  
  /// Optional icon to display with the title
  final IconData? icon;
  
  /// Optional image to display at the top of the card
  final Widget? image;
  
  /// Optional callback when the card is tapped
  final VoidCallback? onTap;
  
  /// Whether the card has a border
  final bool hasBorder;
  
  /// Optional custom padding override
  final EdgeInsetsGeometry? padding;
  
  /// Create an info card with the app's styling
  const InfoCard({
    super.key,
    required this.title,
    required this.content,
    this.icon,
    this.image,
    this.onTap,
    this.hasBorder = false,
    this.padding,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    Widget cardContent = Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        if (image != null) ...[
          ClipRRect(
            borderRadius: const BorderRadius.only(
              topLeft: Radius.circular(8),
              topRight: Radius.circular(8),
            ),
            child: image!,
          ),
          const SizedBox(height: 12),
        ],
        Row(
          children: [
            if (icon != null) ...[
              Icon(icon, color: theme.colorScheme.primary, size: 20),
              const SizedBox(width: 8),
            ],
            Expanded(
              child: Text(
                title,
                style: theme.textTheme.titleLarge?.copyWith(
                  fontSize: 16, 
                  fontWeight: FontWeight.w600,
                ),
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Text(
          content,
          style: theme.textTheme.bodyMedium,
        ),
      ],
    );
    
    return Card(
      elevation: hasBorder ? 0 : 1,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8),
        side: hasBorder 
            ? BorderSide(color: theme.dividerColor, width: 1) 
            : BorderSide.none,
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(8),
        child: Padding(
          padding: padding ?? const EdgeInsets.all(16),
          child: cardContent,
        ),
      ),
    );
  }
} 

################################################################################
FILE: lib/presentation/widgets/common/charts/line_chart.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'dart:math'; // Import for max function

/// A reusable line chart component that can be used throughout the app.
///
/// This component provides a customizable line chart with support for
/// multiple data series, animations, and various styling options.
class AppLineChart extends StatefulWidget {
  /// The data points for the chart.
  /// 
  /// Each list represents a separate line series.
  /// Each point should have an x and y value.
  final List<List<FlSpot>> dataPoints;
  
  /// Labels for the X-axis.
  final List<String>? xLabels;
  
  /// Labels for the Y-axis.
  final List<String>? yLabels;
  
  /// Whether to show grid lines.
  final bool showGrid;
  
  /// Whether to fill the area below the line.
  final bool showFill;
  
  /// Whether to show the line dots.
  final bool showDots;
  
  /// The y-axis minimum value.
  final double? minY;
  
  /// The y-axis maximum value.
  final double? maxY;
  
  /// The title of the chart.
  final String? title;
  
  /// The colors for each line series.
  final List<Color>? lineColors;
  
  /// The fill colors for each line series.
  final List<Color>? fillColors;
  
  /// The width of the lines.
  final double lineWidth;
  
  /// The radius of the dots.
  final double dotRadius;
  
  /// The height of the chart.
  final double height;
  
  /// The width of the chart.
  /// 
  /// If null, the chart will take the full available width.
  final double? width;
  
  /// Creates a line chart.
  const AppLineChart({
    super.key,
    required this.dataPoints,
    this.xLabels,
    this.yLabels,
    this.showGrid = true,
    this.showFill = true,
    this.showDots = true,
    this.minY,
    this.maxY,
    this.title,
    this.lineColors,
    this.fillColors,
    this.lineWidth = 2,
    this.dotRadius = 3,
    this.height = 200,
    this.width,
  });

  @override
  State<AppLineChart> createState() => _AppLineChartState();
}

class _AppLineChartState extends State<AppLineChart> with SingleTickerProviderStateMixin {
  late Animation<double> _animation;
  late AnimationController _animationController;
  
  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    );
    
    _animation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOutCubic,
    );
    
    _animationController.forward();
  }
  
  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }
  
  @override
  void didUpdateWidget(AppLineChart oldWidget) {
    super.didUpdateWidget(oldWidget);
    
    // Reset animation if data changes
    if (widget.dataPoints != oldWidget.dataPoints) {
      _animationController.reset();
      _animationController.forward();
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    if (widget.dataPoints.isEmpty || 
        widget.dataPoints.any((series) => series.isEmpty)) {
      return SizedBox(
        height: widget.height,
        width: widget.width,
        child: Center(
          child: Text(
            'No data available',
            style: theme.textTheme.bodyMedium,
          ),
        ),
      );
    }
    
    // Calculate min/max Y if not provided
    double effectiveMinY = widget.minY ?? double.infinity;
    double effectiveMaxY = widget.maxY ?? -double.infinity;
    
    if (widget.minY == null || widget.maxY == null) {
      for (final series in widget.dataPoints) {
        for (final spot in series) {
          if (spot.y < effectiveMinY) effectiveMinY = spot.y;
          if (spot.y > effectiveMaxY) effectiveMaxY = spot.y;
        }
      }
      
      // Add some padding
      final range = effectiveMaxY - effectiveMinY;
      effectiveMinY -= range * 0.1;
      effectiveMaxY += range * 0.1;
      
      // Ensure non-zero range
      if (effectiveMinY == effectiveMaxY) {
        effectiveMinY -= 1;
        effectiveMaxY += 1;
      }
    }
    
    // Calculate min/max X
    double minX = double.infinity;
    double maxX = -double.infinity;
    
    for (final series in widget.dataPoints) {
      for (final spot in series) {
        if (spot.x < minX) minX = spot.x;
        if (spot.x > maxX) maxX = spot.x;
      }
    }
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (widget.title != null)
          Padding(
            padding: const EdgeInsets.only(bottom: 16.0, left: 8.0),
            child: Text(
              widget.title!,
              style: theme.textTheme.titleMedium,
            ),
          ),
        SizedBox(
          height: widget.height,
          width: widget.width,
          child: AnimatedBuilder(
            animation: _animation,
            builder: (context, _) {
              return LineChart(
                LineChartData(
                  lineTouchData: LineTouchData(
                    touchTooltipData: LineTouchTooltipData(
                      tooltipBgColor: theme.colorScheme.surfaceContainerHighest.withOpacity(0.8),
                      getTooltipItems: (spots) {
                        return spots.map((spot) {
                          final seriesIndex = spot.barIndex;
                          final color = widget.lineColors != null && 
                                       seriesIndex < widget.lineColors!.length
                              ? widget.lineColors![seriesIndex]
                              : theme.colorScheme.primary;
                              
                          return LineTooltipItem(
                            spot.y.toStringAsFixed(1),
                            TextStyle(
                              color: theme.colorScheme.onSurface,
                              fontWeight: FontWeight.bold,
                            ),
                            children: widget.xLabels != null && 
                                  spot.x.toInt() < widget.xLabels!.length
                                ? [
                                    TextSpan(
                                      text: '\n${widget.xLabels![spot.x.toInt()]}',
                                      style: TextStyle(
                                        color: theme.colorScheme.onSurface.withOpacity(0.7),
                                        fontWeight: FontWeight.normal,
                                      ),
                                    ),
                                  ]
                                : null,
                          );
                        }).toList();
                      },
                    ),
                  ),
                  gridData: FlGridData(
                    show: widget.showGrid,
                    drawVerticalLine: widget.showGrid,
                    horizontalInterval: max((effectiveMaxY - effectiveMinY) / 4, 0.1),
                    verticalInterval: max((maxX - minX) / 6, 0.1),
                    checkToShowHorizontalLine: (value) => 
                      value % max((effectiveMaxY - effectiveMinY) / 4, 0.1) < 0.01,
                    getDrawingHorizontalLine: (_) => FlLine(
                      color: theme.colorScheme.outline.withOpacity(0.2),
                      strokeWidth: 0.5,
                    ),
                    getDrawingVerticalLine: (_) => FlLine(
                      color: theme.colorScheme.outline.withOpacity(0.2),
                      strokeWidth: 0.5,
                    ),
                  ),
                  titlesData: FlTitlesData(
                    show: true,
                    rightTitles: const AxisTitles(
                      sideTitles: SideTitles(showTitles: false),
                    ),
                    topTitles: const AxisTitles(
                      sideTitles: SideTitles(showTitles: false),
                    ),
                    bottomTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: widget.xLabels != null,
                        getTitlesWidget: (value, meta) {
                          if (widget.xLabels == null || 
                              value < 0 || 
                              value >= widget.xLabels!.length) {
                            return const SizedBox();
                          }
                          
                          return Padding(
                            padding: const EdgeInsets.only(top: 8.0),
                            child: Text(
                              widget.xLabels![value.toInt()],
                              style: theme.textTheme.bodySmall?.copyWith(
                                color: theme.colorScheme.onSurfaceVariant,
                              ),
                              textAlign: TextAlign.center,
                            ),
                          );
                        },
                        reservedSize: 30,
                      ),
                    ),
                    leftTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        reservedSize: 40,
                        getTitlesWidget: (value, meta) {
                          if (widget.yLabels != null) {
                            // Use custom labels if provided
                            final index = ((value - effectiveMinY) / 
                                (effectiveMaxY - effectiveMinY) * 
                                widget.yLabels!.length).floor();
                                
                            if (index >= 0 && index < widget.yLabels!.length) {
                              return Padding(
                                padding: const EdgeInsets.only(right: 8.0),
                                child: Text(
                                  widget.yLabels![index],
                                  style: theme.textTheme.bodySmall?.copyWith(
                                    color: theme.colorScheme.onSurfaceVariant,
                                  ),
                                  textAlign: TextAlign.end,
                                ),
                              );
                            }
                          }
                          
                          // Default numeric labels
                          if ((value == effectiveMinY || 
                               value == effectiveMaxY || 
                               value == (effectiveMinY + effectiveMaxY) / 2)) {
                            return Padding(
                              padding: const EdgeInsets.only(right: 8.0),
                              child: Text(
                                value.toStringAsFixed(1),
                                style: theme.textTheme.bodySmall?.copyWith(
                                  color: theme.colorScheme.onSurfaceVariant,
                                ),
                                textAlign: TextAlign.end,
                              ),
                            );
                          }
                          
                          return const SizedBox();
                        },
                      ),
                    ),
                  ),
                  borderData: FlBorderData(
                    show: true,
                    border: Border(
                      bottom: BorderSide(
                        color: theme.colorScheme.outline.withOpacity(0.5),
                        width: 1,
                      ),
                      left: BorderSide(
                        color: theme.colorScheme.outline.withOpacity(0.5),
                        width: 1,
                      ),
                    ),
                  ),
                  minX: minX,
                  maxX: maxX,
                  minY: effectiveMinY,
                  maxY: effectiveMaxY,
                  lineBarsData: _buildLineData(
                    theme,
                    widget.dataPoints,
                    _animation.value,
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }
  
  /// Builds line chart data with animation
  List<LineChartBarData> _buildLineData(
    ThemeData theme,
    List<List<FlSpot>> seriesData,
    double animationValue,
  ) {
    return List.generate(seriesData.length, (seriesIndex) {
      final spots = seriesData[seriesIndex];
      
      final color = widget.lineColors != null && 
                   seriesIndex < widget.lineColors!.length
          ? widget.lineColors![seriesIndex]
          : theme.colorScheme.primary;
          
      final fillColor = widget.fillColors != null && 
                       seriesIndex < widget.fillColors!.length
          ? widget.fillColors![seriesIndex]
          : color.withOpacity(0.2);
      
      // For animation, we'll show only a portion of the line based on animation value
      final animatedSpots = <FlSpot>[];
      final pointCount = spots.length;
      
      for (var i = 0; i < pointCount; i++) {
        final spot = spots[i];
        if (i <= pointCount * animationValue) {
          animatedSpots.add(spot);
        }
      }
      
      return LineChartBarData(
        spots: animatedSpots,
        isCurved: true,
        curveSmoothness: 0.3,
        color: color,
        barWidth: widget.lineWidth,
        isStrokeCapRound: true,
        dotData: FlDotData(
          show: widget.showDots,
          getDotPainter: (spot, percent, barData, index) => FlDotCirclePainter(
            radius: widget.dotRadius,
            color: color,
            strokeWidth: 1,
            strokeColor: Colors.white,
          ),
        ),
        belowBarData: BarAreaData(
          show: widget.showFill,
          color: fillColor,
          cutOffY: widget.minY ?? 0,
        ),
      );
    });
  }
} 

################################################################################
FILE: lib/presentation/widgets/common/charts/radar_chart.dart
################################################################################

import 'package:flutter/material.dart';
import 'dart:math' as math;

/// A radar chart component that visualizes multiple metrics in a radial formation.
///
/// This component is useful for displaying skill assessments, behavior patterns,
/// or any multi-dimensional data that can be represented in a radial format.
class AppRadarChart extends StatefulWidget {
  /// The data to display in the chart
  final Map<String, double> data;
  
  /// The maximum value for the data points (usually 100.0)
  final double maxValue;
  
  /// The number of rings to display in the chart background
  final int rings;
  
  /// The size of the chart (both width and height)
  final double size;
  
  /// The color of the chart fill
  final Color? fillColor;
  
  /// The color of the chart outline
  final Color? outlineColor;
  
  /// The color for the chart grid lines
  final Color? gridColor;
  
  /// The color for the chart labels
  final Color? labelColor;
  
  /// Whether to animate the chart when it first appears
  final bool animate;
  
  /// Creates a radar chart
  const AppRadarChart({
    super.key,
    required this.data,
    this.maxValue = 100.0,
    this.rings = 4,
    this.size = 300.0,
    this.fillColor,
    this.outlineColor,
    this.gridColor,
    this.labelColor,
    this.animate = true,
  });

  @override
  State<AppRadarChart> createState() => _AppRadarChartState();
}

class _AppRadarChartState extends State<AppRadarChart> with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _animation;
  
  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    );
    
    _animation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeOutCubic,
    );
    
    if (widget.animate) {
      _animationController.forward();
    } else {
      _animationController.value = 1.0;
    }
  }
  
  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }
  
  @override
  void didUpdateWidget(AppRadarChart oldWidget) {
    super.didUpdateWidget(oldWidget);
    
    // Reset animation if data changes
    if (widget.data != oldWidget.data) {
      if (widget.animate) {
        _animationController.reset();
        _animationController.forward();
      } else {
        _animationController.value = 1.0;
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    // If no data, display a placeholder
    if (widget.data.isEmpty) {
      return SizedBox(
        width: widget.size,
        height: widget.size,
        child: Center(
          child: Text(
            'No data available',
            style: theme.textTheme.bodyMedium,
          ),
        ),
      );
    }
    
    // Get effective colors
    final fillColor = widget.fillColor ?? theme.colorScheme.primary.withOpacity(0.2);
    final outlineColor = widget.outlineColor ?? theme.colorScheme.primary;
    final gridColor = widget.gridColor ?? theme.colorScheme.outline.withOpacity(0.3);
    final labelColor = widget.labelColor ?? theme.colorScheme.onSurface;
    
    return AnimatedBuilder(
      animation: _animation,
      builder: (context, _) {
        return SizedBox(
          width: widget.size,
          height: widget.size,
          child: CustomPaint(
            painter: _RadarChartPainter(
              data: widget.data,
              maxValue: widget.maxValue,
              rings: widget.rings,
              animation: _animation.value,
              fillColor: fillColor,
              outlineColor: outlineColor,
              gridColor: gridColor,
              labelColor: labelColor,
              textStyle: theme.textTheme.bodySmall,
            ),
            size: Size(widget.size, widget.size),
          ),
        );
      },
    );
  }
}

class _RadarChartPainter extends CustomPainter {
  final Map<String, double> data;
  final double maxValue;
  final int rings;
  final double animation;
  final Color fillColor;
  final Color outlineColor;
  final Color gridColor;
  final Color labelColor;
  final TextStyle? textStyle;
  
  _RadarChartPainter({
    required this.data,
    required this.maxValue,
    required this.rings,
    required this.animation,
    required this.fillColor,
    required this.outlineColor,
    required this.gridColor,
    required this.labelColor,
    this.textStyle,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    final center = Offset(size.width / 2, size.height / 2);
    final radius = math.min(size.width, size.height) / 2 - 30; // Leave space for labels
    
    final categories = data.keys.toList();
    final values = data.values.toList();
    final count = categories.length;
    
    if (count < 3) {
      // Not enough points for a radar chart
      _drawErrorMessage(canvas, size, 'Insufficient data (need at least 3 points)');
      return;
    }
    
    // Draw rings and spokes
    _drawGrid(canvas, center, radius, count);
    
    // Draw data polygon
    _drawData(canvas, center, radius, count, values);
    
    // Draw labels
    _drawLabels(canvas, center, radius, count, categories);
  }
  
  void _drawGrid(Canvas canvas, Offset center, double radius, int count) {
    final gridPaint = Paint()
      ..color = gridColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = 0.5;
    
    // Draw concentric rings
    for (int i = 1; i <= rings; i++) {
      final ringRadius = radius * i / rings;
      canvas.drawCircle(center, ringRadius, gridPaint);
    }
    
    // Draw spokes from center to each corner
    for (int i = 0; i < count; i++) {
      final angle = 2 * math.pi * i / count - math.pi / 2; // Start from top (270 degrees)
      final x = center.dx + radius * math.cos(angle);
      final y = center.dy + radius * math.sin(angle);
      
      canvas.drawLine(
        center,
        Offset(x, y),
        gridPaint,
      );
    }
  }
  
  void _drawData(Canvas canvas, Offset center, double radius, int count, List<double> values) {
    // Create a path for the data polygon
    final path = Path();
    
    // Move to the first point
    final firstAngle = -math.pi / 2; // Start from top (270 degrees)
    final firstValue = (values[0] / maxValue).clamp(0.0, 1.0) * animation;
    final firstX = center.dx + radius * firstValue * math.cos(firstAngle);
    final firstY = center.dy + radius * firstValue * math.sin(firstAngle);
    path.moveTo(firstX, firstY);
    
    // Draw lines to each point
    for (int i = 1; i < count; i++) {
      final angle = 2 * math.pi * i / count - math.pi / 2;
      final value = (values[i] / maxValue).clamp(0.0, 1.0) * animation;
      final x = center.dx + radius * value * math.cos(angle);
      final y = center.dy + radius * value * math.sin(angle);
      
      path.lineTo(x, y);
    }
    
    // Close the path
    path.close();
    
    // Draw fill
    final fillPaint = Paint()
      ..color = fillColor
      ..style = PaintingStyle.fill;
    canvas.drawPath(path, fillPaint);
    
    // Draw outline
    final outlinePaint = Paint()
      ..color = outlineColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.0;
    canvas.drawPath(path, outlinePaint);
    
    // Draw data points
    final pointPaint = Paint()
      ..color = outlineColor
      ..style = PaintingStyle.fill;
    
    for (int i = 0; i < count; i++) {
      final angle = 2 * math.pi * i / count - math.pi / 2;
      final value = (values[i] / maxValue).clamp(0.0, 1.0) * animation;
      final x = center.dx + radius * value * math.cos(angle);
      final y = center.dy + radius * value * math.sin(angle);
      
      canvas.drawCircle(Offset(x, y), 3, pointPaint);
    }
  }
  
  void _drawLabels(Canvas canvas, Offset center, double radius, int count, List<String> categories) {
    final effectiveTextStyle = textStyle ?? const TextStyle(fontSize: 12, color: Colors.black);
    
    for (int i = 0; i < count; i++) {
      final angle = 2 * math.pi * i / count - math.pi / 2;
      final labelRadius = radius + 20; // Position labels slightly outside the chart
      
      final x = center.dx + labelRadius * math.cos(angle);
      final y = center.dy + labelRadius * math.sin(angle);
      
      final textSpan = TextSpan(
        text: categories[i],
        style: effectiveTextStyle.copyWith(color: labelColor),
      );
      
      final textPainter = TextPainter(
        text: textSpan,
        textDirection: TextDirection.ltr,
        textAlign: TextAlign.center,
      );
      
      textPainter.layout(minWidth: 0, maxWidth: 80);
      
      // Adjust text position based on angle
      Offset textOffset;
      if (angle == -math.pi / 2) { // Top
        textOffset = Offset(x - textPainter.width / 2, y - textPainter.height);
      } else if (angle > -math.pi / 2 && angle < math.pi / 2) { // Right side
        textOffset = Offset(x, y - textPainter.height / 2);
      } else if (angle == math.pi / 2) { // Bottom
        textOffset = Offset(x - textPainter.width / 2, y);
      } else { // Left side
        textOffset = Offset(x - textPainter.width, y - textPainter.height / 2);
      }
      
      textPainter.paint(canvas, textOffset);
    }
  }
  
  void _drawErrorMessage(Canvas canvas, Size size, String message) {
    final textSpan = TextSpan(
      text: message,
      style: TextStyle(color: labelColor, fontSize: 12),
    );
    
    final textPainter = TextPainter(
      text: textSpan,
      textDirection: TextDirection.ltr,
      textAlign: TextAlign.center,
    );
    
    textPainter.layout(minWidth: 0, maxWidth: size.width);
    
    textPainter.paint(
      canvas,
      Offset((size.width - textPainter.width) / 2, (size.height - textPainter.height) / 2),
    );
  }
  
  @override
  bool shouldRepaint(covariant _RadarChartPainter oldDelegate) {
    return oldDelegate.data != data ||
           oldDelegate.maxValue != maxValue ||
           oldDelegate.rings != rings ||
           oldDelegate.animation != animation ||
           oldDelegate.fillColor != fillColor ||
           oldDelegate.outlineColor != outlineColor ||
           oldDelegate.gridColor != gridColor ||
           oldDelegate.labelColor != labelColor ||
           oldDelegate.textStyle != textStyle;
  }
} 

################################################################################
FILE: lib/presentation/widgets/common/charts/eco_score_gauge.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:going50/core/theme/app_colors.dart';
import 'dart:math' as math;

/// A gauge chart that displays an eco-score value.
///
/// This component provides a visually appealing gauge visualization
/// for displaying eco-score values from 0-100, with appropriate colors
/// based on the score range. The gauge includes animations and an
/// optional text display.
class EcoScoreGauge extends StatefulWidget {
  /// The eco-score value to display (0-100)
  final double score;
  
  /// The size of the gauge
  final double size;
  
  /// Whether to show the score text
  final bool showScore;
  
  /// Whether to show the gauge label
  final bool showLabel;
  
  /// The thickness of the gauge arc
  final double thickness;
  
  /// The background color of the gauge
  final Color? backgroundColor;
  
  /// Optional custom label text
  final String? label;
  
  /// Creates an eco-score gauge
  const EcoScoreGauge({
    super.key,
    required this.score,
    this.size = 150,
    this.showScore = true,
    this.showLabel = true,
    this.thickness = 10.0,
    this.backgroundColor,
    this.label,
  });

  @override
  State<EcoScoreGauge> createState() => _EcoScoreGaugeState();
}

class _EcoScoreGaugeState extends State<EcoScoreGauge> with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    );
    
    _animation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeOutCubic,
    );
    
    _animationController.forward();
  }
  
  @override
  void didUpdateWidget(EcoScoreGauge oldWidget) {
    super.didUpdateWidget(oldWidget);
    
    if (oldWidget.score != widget.score) {
      _animationController.reset();
      _animationController.forward();
    }
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final scoreValue = widget.score.clamp(0.0, 100.0);
    
    return SizedBox(
      width: widget.size,
      height: widget.size,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Expanded(
            child: AnimatedBuilder(
              animation: _animation,
              builder: (context, child) {
                return CustomPaint(
                  painter: _EcoScoreGaugePainter(
                    score: scoreValue * _animation.value,
                    backgroundColor: widget.backgroundColor ?? 
                        theme.colorScheme.surfaceContainerHighest.withOpacity(0.4),
                    thickness: widget.thickness,
                  ),
                  size: Size(widget.size, widget.size),
                );
              },
            ),
          ),
          if (widget.showScore)
            Padding(
              padding: const EdgeInsets.only(top: 8.0),
              child: Text(
                scoreValue.round().toString(),
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: AppColors.getEcoScoreColor(scoreValue),
                ),
              ),
            ),
          if (widget.showLabel)
            Padding(
              padding: const EdgeInsets.only(top: 4.0),
              child: Text(
                widget.label ?? 'Eco-Score',
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.7),
                ),
              ),
            ),
        ],
      ),
    );
  }
}

/// Custom painter for the eco-score gauge
class _EcoScoreGaugePainter extends CustomPainter {
  final double score;
  final Color backgroundColor;
  final double thickness;
  
  _EcoScoreGaugePainter({
    required this.score,
    required this.backgroundColor,
    required this.thickness,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    final center = Offset(size.width / 2, size.height / 2);
    final radius = math.min(size.width, size.height) / 2 - thickness / 2;
    
    // Draw background arc
    final backgroundPaint = Paint()
      ..color = backgroundColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = thickness
      ..strokeCap = StrokeCap.round;
    
    canvas.drawArc(
      Rect.fromCircle(center: center, radius: radius),
      math.pi * 0.8, // Start at 144 degrees
      math.pi * 1.4, // End at 396 degrees (or 36 degrees)
      false,
      backgroundPaint,
    );
    
    // Calculate the angle based on the score (0-100)
    final angle = (score / 100) * math.pi * 1.4;
    
    // Draw colored arc
    final scorePaint = Paint()
      ..color = AppColors.getEcoScoreColor(score)
      ..style = PaintingStyle.stroke
      ..strokeWidth = thickness
      ..strokeCap = StrokeCap.round;
    
    canvas.drawArc(
      Rect.fromCircle(center: center, radius: radius),
      math.pi * 0.8, // Start at 144 degrees
      angle, // End based on score
      false,
      scorePaint,
    );
    
    // Draw small ticks for gauge markings
    _drawTicks(canvas, center, radius, size);
  }
  
  /// Draws tick marks around the gauge
  void _drawTicks(Canvas canvas, Offset center, double radius, Size size) {
    final tickPaint = Paint()
      ..color = Colors.grey.withOpacity(0.5)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;
    
    const tickCount = 10; // Number of ticks
    final outerRadius = radius + thickness / 2 + 2;
    final innerRadius = radius + thickness / 2 - 2;
    
    for (int i = 0; i <= tickCount; i++) {
      // Calculate angle for this tick
      final angle = math.pi * 0.8 + (i / tickCount) * math.pi * 1.4;
      
      // Calculate start and end points for tick line
      final outerX = center.dx + outerRadius * math.cos(angle);
      final outerY = center.dy + outerRadius * math.sin(angle);
      final innerX = center.dx + innerRadius * math.cos(angle);
      final innerY = center.dy + innerRadius * math.sin(angle);
      
      // Draw the tick
      canvas.drawLine(
        Offset(innerX, innerY),
        Offset(outerX, outerY),
        tickPaint,
      );
    }
  }
  
  @override
  bool shouldRepaint(covariant _EcoScoreGaugePainter oldDelegate) {
    return oldDelegate.score != score ||
           oldDelegate.backgroundColor != backgroundColor ||
           oldDelegate.thickness != thickness;
  }
} 

################################################################################
FILE: lib/presentation/widgets/common/charts/bar_chart.dart
################################################################################

import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'dart:math'; // Import for max function

/// A reusable bar chart component that can be used throughout the app.
///
/// This component provides a customizable bar chart with support for
/// multiple series, animations, and various styling options.
class AppBarChart extends StatefulWidget {
  /// The data for the chart.
  /// 
  /// List of x values paired with y values (height).
  final List<BarData> data;
  
  /// Labels for the X-axis.
  final List<String>? xLabels;
  
  /// The interval between x values. Defaults to 1.0.
  final double xInterval;
  
  /// The y-axis minimum value.
  final double? minY;
  
  /// The y-axis maximum value.
  final double? maxY;
  
  /// The title of the chart.
  final String? title;
  
  /// Whether to show the grid.
  final bool showGrid;
  
  /// The width of the bars.
  final double barWidth;
  
  /// The height of the chart.
  final double height;
  
  /// The width of the chart.
  final double? width;
  
  /// The color of the bars.
  final Color? barColor;
  
  /// Function to determine the color of the bar based on its value.
  final Color Function(double value)? getBarColor;
  
  /// Creates a bar chart.
  const AppBarChart({
    super.key,
    required this.data,
    this.xLabels,
    this.xInterval = 1.0,
    this.minY,
    this.maxY,
    this.title,
    this.showGrid = true,
    this.barWidth = 20,
    this.height = 200,
    this.width,
    this.barColor,
    this.getBarColor,
  });

  @override
  State<AppBarChart> createState() => _AppBarChartState();
}

class _AppBarChartState extends State<AppBarChart> with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    );
    
    _animation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeOutCubic,
    );
    
    _animationController.forward();
  }
  
  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }
  
  @override
  void didUpdateWidget(AppBarChart oldWidget) {
    super.didUpdateWidget(oldWidget);
    
    // Reset animation if data changes
    if (widget.data != oldWidget.data) {
      _animationController.reset();
      _animationController.forward();
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    if (widget.data.isEmpty) {
      return SizedBox(
        height: widget.height,
        width: widget.width,
        child: Center(
          child: Text(
            'No data available',
            style: theme.textTheme.bodyMedium,
          ),
        ),
      );
    }
    
    // Calculate min/max Y if not provided
    double effectiveMinY = widget.minY ?? 0;
    double effectiveMaxY = widget.maxY ?? 0;
    
    if (widget.maxY == null) {
      for (final bar in widget.data) {
        if (bar.y > effectiveMaxY) {
          effectiveMaxY = bar.y;
        }
      }
      // Add 10% padding at the top
      effectiveMaxY += effectiveMaxY * 0.1;
    }
    
    // Ensure non-zero range
    if (effectiveMaxY == effectiveMinY) {
      effectiveMaxY = effectiveMinY + 1;
    }
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (widget.title != null)
          Padding(
            padding: const EdgeInsets.only(bottom: 16.0, left: 8.0),
            child: Text(
              widget.title!,
              style: theme.textTheme.titleMedium,
            ),
          ),
        SizedBox(
          height: widget.height,
          width: widget.width,
          child: AnimatedBuilder(
            animation: _animation,
            builder: (context, _) {
              return BarChart(
                BarChartData(
                  alignment: BarChartAlignment.spaceAround,
                  maxY: effectiveMaxY,
                  minY: effectiveMinY,
                  barTouchData: BarTouchData(
                    enabled: true,
                    touchTooltipData: BarTouchTooltipData(
                      tooltipBgColor: theme.colorScheme.surfaceContainerHighest.withOpacity(0.8),
                      getTooltipItem: (group, groupIndex, rod, rodIndex) {
                        final barData = widget.data[groupIndex];
                        return BarTooltipItem(
                          barData.y.toStringAsFixed(1),
                          TextStyle(
                            color: theme.colorScheme.onSurface,
                            fontWeight: FontWeight.bold,
                          ),
                          children: widget.xLabels != null && 
                                  groupIndex < widget.xLabels!.length
                              ? [
                                  TextSpan(
                                    text: '\n${widget.xLabels![groupIndex]}',
                                    style: TextStyle(
                                      color: theme.colorScheme.onSurface.withOpacity(0.7),
                                      fontWeight: FontWeight.normal,
                                    ),
                                  ),
                                ]
                              : null,
                        );
                      },
                    ),
                  ),
                  titlesData: FlTitlesData(
                    show: true,
                    bottomTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: widget.xLabels != null,
                        reservedSize: 30,
                        getTitlesWidget: (value, meta) {
                          final index = value.toInt();
                          if (widget.xLabels == null || 
                              index < 0 || 
                              index >= widget.xLabels!.length) {
                            return const SizedBox();
                          }
                          
                          return Padding(
                            padding: const EdgeInsets.only(top: 8.0),
                            child: Text(
                              widget.xLabels![index],
                              style: theme.textTheme.bodySmall?.copyWith(
                                color: theme.colorScheme.onSurfaceVariant,
                              ),
                              textAlign: TextAlign.center,
                            ),
                          );
                        },
                      ),
                    ),
                    leftTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        reservedSize: 40,
                        getTitlesWidget: (value, meta) {
                          // Only show a few labels
                          if (value == effectiveMinY || 
                              value == effectiveMaxY || 
                              value == (effectiveMinY + effectiveMaxY) / 2) {
                            return Padding(
                              padding: const EdgeInsets.only(right: 8.0),
                              child: Text(
                                value.toStringAsFixed(1),
                                style: theme.textTheme.bodySmall?.copyWith(
                                  color: theme.colorScheme.onSurfaceVariant,
                                ),
                                textAlign: TextAlign.end,
                              ),
                            );
                          }
                          
                          return const SizedBox();
                        },
                      ),
                    ),
                    topTitles: const AxisTitles(
                      sideTitles: SideTitles(showTitles: false),
                    ),
                    rightTitles: const AxisTitles(
                      sideTitles: SideTitles(showTitles: false),
                    ),
                  ),
                  gridData: FlGridData(
                    show: widget.showGrid,
                    drawVerticalLine: false,
                    horizontalInterval: max((widget.maxY ?? 1) / 4, 0.1),
                    getDrawingHorizontalLine: (value) => FlLine(
                      color: theme.colorScheme.outline.withOpacity(0.2),
                      strokeWidth: 0.5,
                    ),
                  ),
                  borderData: FlBorderData(
                    show: true,
                    border: Border(
                      bottom: BorderSide(
                        color: theme.colorScheme.outline.withOpacity(0.5),
                        width: 1,
                      ),
                      left: BorderSide(
                        color: theme.colorScheme.outline.withOpacity(0.5),
                        width: 1,
                      ),
                    ),
                  ),
                  barGroups: _buildBarGroups(widget.data, _animation.value),
                ),
              );
            },
          ),
        ),
      ],
    );
  }
  
  /// Builds bar groups with animation
  List<BarChartGroupData> _buildBarGroups(List<BarData> data, double animationValue) {
    return List.generate(data.length, (index) {
      final barData = data[index];
      final animatedHeight = barData.y * animationValue;
      
      Color barColor = widget.barColor ?? 
          Theme.of(context).colorScheme.primary;
          
      if (widget.getBarColor != null) {
        barColor = widget.getBarColor!(barData.y);
      } else if (barData.color != null) {
        barColor = barData.color!;
      }
      
      return BarChartGroupData(
        x: barData.x.toInt(),
        barRods: [
          BarChartRodData(
            toY: animatedHeight,
            color: barColor,
            width: widget.barWidth,
            borderRadius: const BorderRadius.only(
              topLeft: Radius.circular(4),
              topRight: Radius.circular(4),
            ),
            backDrawRodData: BackgroundBarChartRodData(
              show: true,
              toY: data.map((e) => e.y).reduce((a, b) => a > b ? a : b),
              color: Theme.of(context).colorScheme.surface,
            ),
          ),
        ],
      );
    });
  }
}

/// Data for a single bar in the chart
class BarData {
  /// X-coordinate of the bar
  final double x;
  
  /// Height of the bar
  final double y;
  
  /// Optional color of the bar
  final Color? color;
  
  /// Optional label for the bar
  final String? label;
  
  /// Creates a bar data object
  const BarData({
    required this.x,
    required this.y,
    this.color,
    this.label,
  });
} 

################################################################################
FILE: lib/services/permission_service.dart
################################################################################

import 'dart:io';

import 'package:logging/logging.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Service for handling all permission-related functionality
///
/// This class provides methods to request, check, and manage all permissions
/// required by the app for proper operation.
class PermissionService {
  final Logger _logger = Logger('PermissionService');
  
  // Key for first-time permission request tracking
  static const String _firstTimeRequestKey = 'first_time_permission_request';
  
  /// Get the list of all permissions required by the app
  List<Permission> get _requiredPermissions {
    final permissions = <Permission>[];
    
    // Location permissions (required on both platforms)
    permissions.add(Permission.locationWhenInUse);
    permissions.add(Permission.locationAlways);
    
    // Platform-specific Bluetooth permissions
    if (Platform.isAndroid) {
      // Android 12+ requires these specific Bluetooth permissions
      permissions.add(Permission.bluetoothScan);
      permissions.add(Permission.bluetoothConnect);
      
      // Activity recognition (for motion sensors)
      permissions.add(Permission.activityRecognition);
    } else if (Platform.isIOS) {
      // iOS has a single Bluetooth permission
      permissions.add(Permission.bluetooth);
      
      // Add motion sensor permission for iOS
      permissions.add(Permission.sensors);
    }
    
    return permissions;
  }
  
  /// Public getter for all required permissions
  List<Permission> get allPermissions => _requiredPermissions;
  
  /// Checks if all required permissions are granted
  ///
  /// Returns true if all permissions are granted, false otherwise
  Future<bool> areAllPermissionsGranted() async {
    _logger.info('Checking if all permissions are granted');
    
    for (final permission in _requiredPermissions) {
      final status = await permission.status;
      _logger.info('Permission ${permission.toString()}: ${status.toString()}');
      
      if (status != PermissionStatus.granted) {
        return false;
      }
    }
    return true;
  }
  
  /// Requests all permissions required by the app
  ///
  /// Returns a map of permission statuses for each required permission
  Future<Map<Permission, PermissionStatus>> requestAllPermissions() async {
    _logger.info('Requesting all required permissions');
    
    // Request all permissions
    Map<Permission, PermissionStatus> statuses = await _requiredPermissions.request();
    
    // Log the status of each permission
    for (final entry in statuses.entries) {
      _logger.info('Permission ${entry.key}: ${entry.value}');
    }
    
    return statuses;
  }
  
  /// Checks if Bluetooth permissions are granted
  Future<bool> areBluetoothPermissionsGranted() async {
    if (Platform.isAndroid) {
      final scanStatus = await Permission.bluetoothScan.status;
      final connectStatus = await Permission.bluetoothConnect.status;
      _logger.info('Bluetooth scan: $scanStatus, connect: $connectStatus');
      return scanStatus == PermissionStatus.granted && 
             connectStatus == PermissionStatus.granted;
    } else if (Platform.isIOS) {
      // iOS uses a single Bluetooth permission
      final status = await Permission.bluetooth.status;
      _logger.info('Bluetooth: $status');
      return status == PermissionStatus.granted;
    }
    return false;
  }
  
  /// Checks if location permissions are granted
  Future<bool> areLocationPermissionsGranted() async {
    final status = await Permission.locationWhenInUse.status;
    _logger.info('Location when in use: $status');
    return status == PermissionStatus.granted;
  }
  
  /// Checks if background location permission is granted
  Future<bool> isBackgroundLocationGranted() async {
    final status = await Permission.locationAlways.status;
    _logger.info('Location always: $status');
    return status == PermissionStatus.granted;
  }
  
  /// Check if this is the first time asking for permissions
  Future<bool> isFirstTimeRequest() async {
    final prefs = await SharedPreferences.getInstance();
    final isFirstTime = !(prefs.getBool(_firstTimeRequestKey) ?? false);
    _logger.info('Is first time permission request? $isFirstTime');
    return isFirstTime;
  }
  
  /// Mark that we have asked for permissions
  Future<void> markPermissionsRequested() async {
    final prefs = await SharedPreferences.getInstance();
    _logger.info('Marking permissions as requested');
    await prefs.setBool(_firstTimeRequestKey, true);
  }
  
  /// Force reset first time request flag (for testing purposes)
  Future<void> resetFirstTimeRequestFlag() async {
    final prefs = await SharedPreferences.getInstance();
    _logger.info('Resetting first-time permission request flag');
    await prefs.setBool(_firstTimeRequestKey, false);
  }
  
  /// Requests location permissions (when in use and always)
  Future<void> requestLocationPermissions({bool background = true}) async {
    _logger.info('Requesting location permissions');
    
    // Check if it's the first time we're asking for permissions
    final isFirstTime = await isFirstTimeRequest();
    
    // Special handling for iOS
    if (Platform.isIOS) {
      var status = await Permission.locationWhenInUse.status;
      
      // If permission is permanently denied on iOS and it's not the first time
      if (status == PermissionStatus.permanentlyDenied && !isFirstTime) {
        _logger.warning('Location permission is permanently denied on iOS. User needs to enable in settings.');
        return;
      }
      
      // Request "when in use" permission
      _logger.info('Requesting location when in use on iOS...');
      status = await Permission.locationWhenInUse.request();
      _logger.info('Location when in use status after request: $status');
      
      // Only request "always" if "when in use" is granted and background is requested
      if (status == PermissionStatus.granted && background) {
        // Delay before requesting background permission on iOS
        // This is a UX best practice on iOS to not request both permissions immediately
        await Future.delayed(const Duration(milliseconds: 500));
        _logger.info('Requesting background location on iOS...');
        final backgroundStatus = await Permission.locationAlways.request();
        _logger.info('Location always status after request: $backgroundStatus');
      }
      
      // Mark that we've requested permissions
      await markPermissionsRequested();
    } else {
      // Android flow - more explicit error handling and checks
      try {
        // First, request location when in use permission
        _logger.info('Requesting location when in use on Android...');
        var status = await Permission.locationWhenInUse.request();
        _logger.info('Location when in use status after request: $status');
        
        // Only request background location if "when in use" is granted and background is requested
        if (status == PermissionStatus.granted && background) {
          await Future.delayed(const Duration(milliseconds: 500));
          _logger.info('Requesting background location on Android...');
          final backgroundStatus = await Permission.locationAlways.request();
          _logger.info('Location always status after request: $backgroundStatus');
        }
        
        // Mark that we've requested permissions
        await markPermissionsRequested();
      } catch (e) {
        _logger.severe('Error requesting location permissions on Android: $e');
      }
    }
  }
  
  /// Requests Bluetooth permissions
  Future<void> requestBluetoothPermissions() async {
    _logger.info('Requesting Bluetooth permissions');
    
    // Check if it's the first time we're asking for permissions
    final isFirstTime = await isFirstTimeRequest();
    
    // Special handling for iOS
    if (Platform.isIOS) {
      var status = await Permission.bluetooth.status;
      
      // If permission is permanently denied on iOS and it's not the first time
      if (status == PermissionStatus.permanentlyDenied && !isFirstTime) {
        _logger.warning('Bluetooth permission is permanently denied on iOS. User needs to enable in settings.');
        return;
      }
      
      _logger.info('Requesting Bluetooth permission on iOS...');
      status = await Permission.bluetooth.request();
      _logger.info('After request - Bluetooth: $status');
      
      // Mark that we've requested permissions
      await markPermissionsRequested();
    } else if (Platform.isAndroid) {
      try {
        _logger.info('Requesting Bluetooth scan permission on Android...');
        final scanStatus = await Permission.bluetoothScan.request();
        _logger.info('After request - Bluetooth scan: $scanStatus');
        
        // Add a small delay between permission requests
        await Future.delayed(const Duration(milliseconds: 300));
        
        _logger.info('Requesting Bluetooth connect permission on Android...');
        final connectStatus = await Permission.bluetoothConnect.request();
        _logger.info('After request - Bluetooth connect: $connectStatus');
        
        // Mark that we've requested permissions
        await markPermissionsRequested();
      } catch (e) {
        _logger.severe('Error requesting Bluetooth permissions on Android: $e');
      }
    }
  }
  
  /// Requests activity recognition permission (Android) or motion sensor permission (iOS)
  Future<void> requestActivityRecognitionPermission() async {
    _logger.info('Requesting activity recognition permission');
    
    try {
      if (Platform.isAndroid) {
        final status = await Permission.activityRecognition.request();
        _logger.info('Activity recognition permission status: $status');
      } else if (Platform.isIOS) {
        final status = await Permission.sensors.request();
        _logger.info('Sensors permission status: $status');
      }
    } catch (e) {
      _logger.severe('Error requesting activity recognition permission: $e');
    }
  }
  
  /// Opens app settings so user can manually enable permissions
  Future<bool> openSettings() async {
    _logger.info('Opening app settings');
    return await openAppSettings();
  }
  
  /// Determines if the permanent permission denial message should be shown
  ///
  /// Returns true if any permission is permanently denied
  Future<bool> shouldShowPermanentDenialMessage() async {
    // Check if it's the first time we're asking for permissions
    final isFirstTime = await isFirstTimeRequest();
    
    // On first-time requests, don't show the permanent denial message
    if (isFirstTime) {
      return false;
    }
    
    // On iOS, we handle permission denials differently - we should guide
    // users to settings rather than showing permanent denial message
    if (Platform.isIOS) {
      var anyPermanentlyDenied = false;
      
      for (final permission in _requiredPermissions) {
        final status = await permission.status;
        if (status == PermissionStatus.permanentlyDenied) {
          _logger.info('${permission.toString()} is permanently denied on iOS');
          anyPermanentlyDenied = true;
        }
      }
      
      // For iOS, we need to check the essential permissions
      if (anyPermanentlyDenied) {
        final locationStatus = await Permission.locationWhenInUse.status;
        final bluetoothStatus = Platform.isIOS 
          ? await Permission.bluetooth.status
          : await Permission.bluetoothConnect.status;
        
        // Show permanent denial screen if both essential permissions are denied
        return locationStatus == PermissionStatus.permanentlyDenied &&
               bluetoothStatus == PermissionStatus.permanentlyDenied;
      }
      
      return false;
    } else {
      // Android behavior
      for (final permission in _requiredPermissions) {
        final status = await permission.status;
        if (status == PermissionStatus.permanentlyDenied) {
          _logger.info('${permission.toString()} is permanently denied');
          return true;
        }
      }
      return false;
    }
  }
} 

################################################################################
FILE: lib/services/service_locator.dart
################################################################################

import 'package:get_it/get_it.dart';
import 'package:flutter/foundation.dart';
import 'package:going50/obd_lib/obd_service.dart';
import 'package:going50/sensor_lib/sensor_service.dart' as sensor_lib;
import 'package:going50/data_lib/data_storage_manager.dart';
import 'package:going50/behavior_classifier_lib/managers/eco_driving_manager.dart';
import 'package:going50/services/driving/obd_connection_service.dart';
import 'package:going50/services/driving/sensor_service.dart';
import 'package:going50/services/driving/data_collection_service.dart';
import 'package:going50/services/driving/analytics_service.dart';
import 'package:going50/services/driving/trip_service.dart';
import 'package:going50/services/driving/driving_service.dart';
import 'package:going50/services/driving/performance_metrics_service.dart';
import 'package:going50/services/user/user_service.dart';
import 'package:going50/services/user/preferences_service.dart';
import 'package:going50/services/user/privacy_service.dart';
import 'package:going50/services/user/authentication_service.dart';
import 'package:going50/services/gamification/achievement_service.dart';
import 'package:going50/services/gamification/challenge_service.dart';
import 'package:going50/services/permission_service.dart';
import 'package:going50/services/background/background_service.dart';
import 'package:going50/services/background/notification_service.dart';
import 'package:going50/services/social/social_service.dart';
import 'package:going50/services/social/leaderboard_service.dart';
import 'package:going50/services/social/sharing_service.dart';
import 'package:logging/logging.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_analytics/firebase_analytics.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';

/// Global instance of the service locator
final serviceLocator = GetIt.instance;

/// Initialize the service locator with all required dependencies
Future<void> setupServiceLocator() async {
  // Set up logging
  _setupLogging();
  
  // Register existing libraries as singletons
  _registerExistingLibraries();
  
  // Register services
  _registerServices();
  
  // Register Firebase services (if Firebase is initialized)
  await _registerFirebaseServices();
  
  // Setup is complete
  debugPrint('Service locator initialized successfully');
}

/// Set up logging for the application
void _setupLogging() {
  // Configure logging based on build mode
  if (kDebugMode) {
    Logger.root.level = Level.ALL;
    Logger.root.onRecord.listen((record) {
      // ignore: avoid_print
      print('${record.level.name}: ${record.loggerName}: ${record.time}: ${record.message}');
      if (record.error != null) {
        // ignore: avoid_print
        print('Error: ${record.error}');
      }
      if (record.stackTrace != null) {
        // ignore: avoid_print
        print('Stack trace: ${record.stackTrace}');
      }
    });
  } else {
    // In release mode, only show warnings and errors
    Logger.root.level = Level.WARNING;
    Logger.root.onRecord.listen((record) {
      // In a real app, you might want to use a logging service
      // or store logs for later analysis
      if (record.level >= Level.WARNING) {
        debugPrint('${record.level.name}: ${record.message}');
      }
    });
  }
}

/// Register existing library instances as singletons
void _registerExistingLibraries() {
  // Register OBD service
  serviceLocator.registerLazySingleton<ObdService>(
    () => ObdService(isDebugMode: kDebugMode),
  );

  // Register Sensor Service from lib 
  serviceLocator.registerLazySingleton<sensor_lib.SensorService>(
    () => sensor_lib.SensorService(isDebugMode: kDebugMode),
  );
  
  // Register Data Storage manager
  serviceLocator.registerLazySingleton<DataStorageManager>(
    () => DataStorageManager(),
  );
  
  // Register Eco Driving manager
  serviceLocator.registerLazySingleton<EcoDrivingManager>(
    () => EcoDrivingManager(),
  );
}

/// Register Firebase services
Future<void> _registerFirebaseServices() async {
  final log = Logger('ServiceLocator');
  log.info('Attempting to register Firebase services');
  
  try {
    // Check if Firebase is already initialized
    if (Firebase.apps.isNotEmpty) {
      log.info('Firebase is already initialized');
      
      // Register Firebase services
      serviceLocator.registerLazySingleton<FirebaseAuth>(
        () => FirebaseAuth.instance,
      );
      
      serviceLocator.registerLazySingleton<FirebaseFirestore>(
        () => FirebaseFirestore.instance,
      );
      
      serviceLocator.registerLazySingleton<FirebaseStorage>(
        () => FirebaseStorage.instance,
      );
      
      serviceLocator.registerLazySingleton<FirebaseAnalytics>(
        () => FirebaseAnalytics.instance,
      );
      
      // Register AuthenticationService
      serviceLocator.registerLazySingleton<AuthenticationService>(
        () => AuthenticationService(
          serviceLocator<FirebaseAuth>(),
          serviceLocator<DataStorageManager>(),
          serviceLocator<UserService>(),
        ),
      );
      
      log.info('Firebase services registered successfully');
    } else {
      log.info('Firebase is not initialized yet, skipping Firebase service registration');
    }
  } catch (e) {
    log.warning('Error registering Firebase services: $e');
    log.info('The app will continue to function with local storage only');
  }
}

/// Register application services
void _registerServices() {
  // Register Sensor Service
  serviceLocator.registerLazySingleton<SensorService>(
    () => SensorService(serviceLocator<sensor_lib.SensorService>()),
  );
  
  // Register OBD Connection Service
  serviceLocator.registerLazySingleton<ObdConnectionService>(
    () => ObdConnectionService(
      serviceLocator<ObdService>()
    ),
  );
  
  // Register Data Collection Service
  serviceLocator.registerLazySingleton<DataCollectionService>(
    () => DataCollectionService(
      serviceLocator<ObdConnectionService>(),
      serviceLocator<SensorService>(),
      serviceLocator<EcoDrivingManager>(),
    ),
  );
  
  // Register Analytics Service
  serviceLocator.registerLazySingleton<AnalyticsService>(
    () => AnalyticsService(
      serviceLocator<EcoDrivingManager>(),
    ),
  );
  
  // Register Trip Service
  serviceLocator.registerLazySingleton<TripService>(
    () => TripService(
      serviceLocator<DataStorageManager>(),
    ),
  );
  
  // Register Performance Metrics Service
  serviceLocator.registerLazySingleton<PerformanceMetricsService>(
    () => PerformanceMetricsService(
      serviceLocator<DataStorageManager>(),
    ),
  );
  
  // Register Achievement Service
  serviceLocator.registerLazySingleton<AchievementService>(
    () => AchievementService(
      serviceLocator<DataStorageManager>(),
      serviceLocator<PerformanceMetricsService>(),
    ),
  );

  // Register Challenge Service
  serviceLocator.registerLazySingleton<ChallengeService>(
    () => ChallengeService(
      serviceLocator<DataStorageManager>(),
      serviceLocator<PerformanceMetricsService>(),
    ),
  );
  
  // Register Driving Service (main facade)
  serviceLocator.registerLazySingleton<DrivingService>(
    () => DrivingService(
      serviceLocator<ObdConnectionService>(),
      serviceLocator<SensorService>(),
      serviceLocator<DataCollectionService>(),
      serviceLocator<AnalyticsService>(),
      serviceLocator<TripService>(),
    ),
  );
  
  // Register Permission Service
  serviceLocator.registerLazySingleton<PermissionService>(
    () => PermissionService(),
  );
  
  // Register User Service
  serviceLocator.registerLazySingleton<UserService>(
    () => UserService(
      serviceLocator<DataStorageManager>(),
    ),
  );
  
  // Register Preferences Service
  serviceLocator.registerLazySingleton<PreferencesService>(
    () => PreferencesService(
      serviceLocator<DataStorageManager>(),
    ),
  );
  
  // Register Privacy Service
  serviceLocator.registerLazySingleton<PrivacyService>(
    () => PrivacyService(
      serviceLocator<DataStorageManager>(),
    ),
  );
  
  // Register Background Service
  serviceLocator.registerLazySingleton<BackgroundService>(
    () => BackgroundService(
      serviceLocator<DataCollectionService>(),
      serviceLocator<ObdConnectionService>(),
      serviceLocator<TripService>(),
      serviceLocator<PreferencesService>(),
    ),
  );
  
  // Register Notification Service
  serviceLocator.registerLazySingleton<NotificationService>(
    () => NotificationService(
      serviceLocator<PreferencesService>(),
    ),
  );
  
  // Register Social Services
  serviceLocator.registerLazySingleton<SocialService>(
    () => SocialService(
      serviceLocator<DataStorageManager>(),
      serviceLocator<UserService>(),
      serviceLocator<PrivacyService>(),
    ),
  );
  
  serviceLocator.registerLazySingleton<LeaderboardService>(
    () => LeaderboardService(
      serviceLocator<DataStorageManager>(),
      serviceLocator<PerformanceMetricsService>(),
    ),
  );
  
  serviceLocator.registerLazySingleton<SharingService>(
    () => SharingService(
      serviceLocator<DataStorageManager>(),
      serviceLocator<PrivacyService>(),
    ),
  );
  
  // Additional services will be registered here as they are implemented
} 

################################################################################
FILE: lib/services/background/background_service.dart
################################################################################

import 'dart:async';
import 'dart:io';
import 'dart:ui';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:logging/logging.dart';
import 'package:shared_preferences/shared_preferences.dart';

import 'package:going50/services/driving/data_collection_service.dart';
import 'package:going50/services/driving/obd_connection_service.dart';
import 'package:going50/services/driving/trip_service.dart';
import 'package:going50/services/user/preferences_service.dart';
import 'package:going50/services/background/notification_service.dart';
import 'package:going50/core_models/combined_driving_data.dart';

/// ServiceStatus represents the current state of the background service
enum ServiceStatus {
  /// Service is inactive/stopped
  inactive,
  
  /// Service is starting up
  starting,
  
  /// Service is actively running
  running,
  
  /// Service is in the process of stopping
  stopping,
  
  /// Service is in an error state
  error
}

/// Manages the background service for continuous data collection and processing.
///
/// This class provides a facade for interacting with the platform-specific
/// background service implementation using method channels. It coordinates
/// background operation of several key features:
/// - Data collection (OBD and sensors)
/// - Trip monitoring
/// - Battery optimization
/// - Background notifications
class BackgroundService extends ChangeNotifier {
  static const String _methodChannelName = 'com.example.going50/background_service';
  static const String _callbackHandleKey = 'background_service_callback_handle';
  
  final Logger _logger = Logger('BackgroundService');
  final MethodChannel _methodChannel = const MethodChannel(_methodChannelName);
  
  // Dependencies
  final DataCollectionService _dataCollectionService;
  final ObdConnectionService _obdConnectionService;
  final TripService _tripService;
  final PreferencesService _preferencesService;
  late final NotificationService _notificationService;
  
  // Service state
  ServiceStatus _serviceStatus = ServiceStatus.inactive;
  String? _errorMessage;
  bool _isPowerSaveEnabled = false;
  final StreamController<CombinedDrivingData> _backgroundDataController = 
      StreamController<CombinedDrivingData>.broadcast();

  // Subscription for data collection
  StreamSubscription<CombinedDrivingData>? _dataSubscription;
  
  // Timer for background health checks
  Timer? _healthCheckTimer;
  Timer? _idleDetectionTimer;
  DateTime? _lastDataTimestamp;
  
  /// Creates a new BackgroundService
  BackgroundService(
    this._dataCollectionService,
    this._obdConnectionService,
    this._tripService,
    this._preferencesService,
  ) {
    _logger.info('BackgroundService created');
    _methodChannel.setMethodCallHandler(_handleMethodCall);
    _checkServiceStatus();
    _loadPowerSaveSettings();
  }
  
  /// Set the notification service
  /// 
  /// This is done after creation to avoid circular dependencies
  void setNotificationService(NotificationService notificationService) {
    _notificationService = notificationService;
  }
  
  /// Get current service status
  ServiceStatus get serviceStatus => _serviceStatus;
  
  /// Get any current error message
  String? get errorMessage => _errorMessage;
  
  /// Get whether power saving mode is enabled
  bool get isPowerSaveEnabled => _isPowerSaveEnabled;
  
  /// Get whether the service is running
  bool get isRunning => _serviceStatus == ServiceStatus.running;
  
  /// Stream of data collected while in the background
  Stream<CombinedDrivingData> get backgroundDataStream => _backgroundDataController.stream;
  
  /// Start the background service
  /// 
  /// This will launch a foreground service on Android or register for
  /// background processing on iOS. Returns true if successful.
  Future<bool> startBackgroundService() async {
    try {
      if (_serviceStatus == ServiceStatus.running || 
          _serviceStatus == ServiceStatus.starting) {
        _logger.info('Service already running or starting');
        return true;
      }
      
      _serviceStatus = ServiceStatus.starting;
      notifyListeners();
      
      _logger.info('Starting background service');
      
      // Register callback first
      await _registerCallback();
      
      // Configure background operation mode based on user preferences
      await _configureBackgroundMode();
      
      // Show a notification that the background service is starting
      if (Platform.isAndroid) {
        // Send startup notification if we have the notification service
        try {
          if (_notificationService != null) {
            await _notificationService.showNotification(
              title: 'Going50 Background Service',
              body: 'Starting data collection service...',
              type: NotificationType.background,
              priority: NotificationPriority.low,
            );
          }
        } catch (e) {
          _logger.warning('Error showing startup notification: $e');
          // Continue even if notification fails
        }
        
        // Get the callback handle for the static entry point
        final callbackHandle = await _getCallbackHandle();
        if (callbackHandle == null) {
          _setError('Could not get callback handle');
          return false;
        }
        
        // Prepare notification configuration
        final notificationConfig = await _getNotificationConfig();
        
        // Start the Android service
        final Map<String, dynamic> args = {
          'backgroundCallbackHandle': callbackHandle,
          'notificationConfig': notificationConfig,
          'batteryOptimization': _isPowerSaveEnabled,
        };
        
        await _methodChannel.invokeMethod('startService', args);
      } else if (Platform.isIOS) {
        // iOS doesn't use the same service model, but we can register background tasks
        await _methodChannel.invokeMethod('startBackgroundTask', {
          'batteryOptimization': _isPowerSaveEnabled,
        });
      }
      
      // Start listening to data collection stream
      _startDataListening();
      
      // Start health check timer
      _startHealthCheck();
      
      _serviceStatus = ServiceStatus.running;
      notifyListeners();
      return true;
    } catch (e) {
      _setError('Error starting background service: $e');
      return false;
    }
  }
  
  /// Stop the background service
  /// 
  /// This will stop the foreground service on Android or unregister
  /// background processing on iOS. Returns true if successful.
  Future<bool> stopBackgroundService() async {
    try {
      if (_serviceStatus == ServiceStatus.inactive || 
          _serviceStatus == ServiceStatus.stopping) {
        _logger.info('Service already stopped or stopping');
        return true;
      }
      
      _serviceStatus = ServiceStatus.stopping;
      notifyListeners();
      
      _logger.info('Stopping background service');
      
      // Stop health check timer
      _stopHealthCheck();
      
      // Stop data listening
      _stopDataListening();
      
      // Stop platform service
      await _methodChannel.invokeMethod('stopService');
      
      _serviceStatus = ServiceStatus.inactive;
      notifyListeners();
      return true;
    } catch (e) {
      _setError('Error stopping background service: $e');
      return false;
    }
  }
  
  /// Set power saving mode
  /// 
  /// When enabled, this will reduce data collection frequency and
  /// disable certain features to conserve battery.
  Future<void> setPowerSaveMode(bool enabled) async {
    try {
      _isPowerSaveEnabled = enabled;
      
      // Save preference using setPreference instead of savePreference
      await _preferencesService.setPreference(
        'background', 
        'powerSaveMode', 
        enabled
      );
      
      // If service is running, reconfigure
      if (_serviceStatus == ServiceStatus.running) {
        await _configureBackgroundMode();
        
        // Notify platform of change
        await _methodChannel.invokeMethod('updatePowerMode', {
          'batteryOptimization': enabled,
        });
      }
      
      notifyListeners();
    } catch (e) {
      _logger.warning('Error setting power save mode: $e');
    }
  }
  
  /// Check if the service can run in the background
  /// 
  /// This checks if all required permissions are granted and
  /// if the device supports background execution.
  Future<bool> canRunInBackground() async {
    try {
      final result = await _methodChannel.invokeMethod('checkBackgroundCapability');
      return result ?? false;
    } catch (e) {
      _logger.warning('Error checking background capability: $e');
      return false;
    }
  }
  
  /// Manually attempt to keep the service alive
  /// 
  /// This is useful for devices that aggressively kill background processes.
  /// It will attempt to ensure the service stays running.
  Future<void> keepAlive() async {
    try {
      await _methodChannel.invokeMethod('keepAlive');
    } catch (e) {
      _logger.warning('Error sending keepAlive signal: $e');
    }
  }
  
  /// Configure background mode based on user preferences
  Future<void> _configureBackgroundMode() async {
    // We don't have direct control over collection intervals
    // So we'll restart collection with appropriate settings when needed
    if (_dataCollectionService.isCollecting) {
      // Stop and restart collection to apply new settings
      await _dataCollectionService.stopCollection();
      await _dataCollectionService.startCollection();
    }
  }
  
  /// Handle method calls from the native side
  Future<dynamic> _handleMethodCall(MethodCall call) async {
    _logger.info('Received method call: ${call.method}');
    
    switch (call.method) {
      case 'onServiceStatusChanged':
        final String status = call.arguments['status'] as String;
        _logger.info('Service status changed: $status');
        
        switch (status) {
          case 'started':
            _serviceStatus = ServiceStatus.running;
            _notifyServiceRunning();
            break;
          case 'stopped':
            _serviceStatus = ServiceStatus.inactive;
            break;
          case 'error':
            final String errorMessage = call.arguments['errorMessage'] as String;
            _setError(errorMessage);
            break;
        }
        
        notifyListeners();
        return null;
        
      case 'onLowMemory':
        // Handle low memory warning
        _logger.warning('Low memory warning from system');
        // Maybe reduce collection frequency or stop non-essential features
        break;
        
      case 'onPowerSaveModeChanged':
        final bool enabled = call.arguments['enabled'] ?? false;
        await setPowerSaveMode(enabled);
        break;
        
      case 'onBackgroundTimeout':
        // Handle background execution time limit reached
        _logger.warning('Background execution time limit reached');
        await _methodChannel.invokeMethod('extendBackgroundExecution');
        break;
        
      default:
        _logger.warning('Unknown method call: ${call.method}');
        throw MissingPluginException();
    }
  }
  
  /// Start listening to data from the data collection service
  void _startDataListening() {
    _stopDataListening(); // Make sure we don't have multiple subscriptions
    
    _dataSubscription = _dataCollectionService.dataStream.listen((data) {
      _lastDataTimestamp = DateTime.now();
      _backgroundDataController.add(data);
    }, onError: (error) {
      _logger.warning('Error from data stream: $error');
    });
  }
  
  /// Stop listening to data
  void _stopDataListening() {
    _dataSubscription?.cancel();
    _dataSubscription = null;
  }
  
  /// Start a health check timer to monitor service health
  void _startHealthCheck() {
    _stopHealthCheck(); // Make sure we don't have multiple timers
    
    // Health check every 30 seconds
    _healthCheckTimer = Timer.periodic(const Duration(seconds: 30), (_) async {
      try {
        // Check if service is still running
        final isRunning = await _isServiceRunning();
        if (!isRunning && _serviceStatus == ServiceStatus.running) {
          _logger.warning('Service stopped unexpectedly, attempting to restart');
          await startBackgroundService();
        }
        
        // Check OBD connection if applicable
        if (_obdConnectionService.isConnected) {
          // Since we don't have a checkConnection method,
          // we'll check if we have recent OBD data
          final latestData = _obdConnectionService.getLatestOBDData();
          final isStale = latestData == null || 
              DateTime.now().difference(latestData.timestamp).inSeconds > 10;
              
          if (isStale) {
            _logger.warning('OBD connection may be lost - no recent data');
            // No automatic reconnection to avoid battery drain,
            // just notify about the disconnection
          }
        }
        
        // Check data collection
        if (_dataCollectionService.isCollecting) {
          // Check if we've received data recently (2 minutes timeout)
          if (_lastDataTimestamp != null) {
            final now = DateTime.now();
            final difference = now.difference(_lastDataTimestamp!);
            
            if (difference.inMinutes >= 2) {
              _logger.warning('No data received for 2 minutes, checking for idle');
              _startIdleDetection();
            }
          }
        }
        
        // Ping to keep alive
        await keepAlive();
      } catch (e) {
        _logger.warning('Error in health check: $e');
      }
    });
  }
  
  /// Stop the health check timer
  void _stopHealthCheck() {
    _healthCheckTimer?.cancel();
    _healthCheckTimer = null;
    _stopIdleDetection();
  }
  
  /// Start idle detection process
  void _startIdleDetection() {
    _stopIdleDetection(); // Make sure we don't have multiple timers
    
    // If we already have an active trip, we need to check if vehicle has stopped
    if (_tripService.currentTrip != null) {
      // Set a timer for additional 3 minutes to see if we should end the trip
      _idleDetectionTimer = Timer(const Duration(minutes: 3), () async {
        // If no data has been received for 5 minutes total, consider ending the trip
        if (_lastDataTimestamp != null) {
          final now = DateTime.now();
          final difference = now.difference(_lastDataTimestamp!);
          
          if (difference.inMinutes >= 5) {
            _logger.info('Vehicle appears to be stopped for 5+ minutes, ending trip');
            await _tripService.endTrip();
          }
        }
      });
    }
  }
  
  /// Stop idle detection timer
  void _stopIdleDetection() {
    _idleDetectionTimer?.cancel();
    _idleDetectionTimer = null;
  }
  
  /// Check if the background service is running
  Future<bool> _isServiceRunning() async {
    try {
      final result = await _methodChannel.invokeMethod('isServiceRunning');
      final bool isRunning = result ?? false;
      
      // Update service status based on platform info
      if (isRunning && _serviceStatus != ServiceStatus.running) {
        _serviceStatus = ServiceStatus.running;
        notifyListeners();
      } else if (!isRunning && _serviceStatus == ServiceStatus.running) {
        _serviceStatus = ServiceStatus.inactive;
        notifyListeners();
      }
      
      return isRunning;
    } catch (e) {
      _logger.warning('Error checking service status: $e');
      return false;
    }
  }
  
  /// Get notification configuration from user preferences
  Future<Map<String, dynamic>> _getNotificationConfig() async {
    try {
      // Default configuration
      Map<String, dynamic> config = {
        'title': 'Going50 - Eco Driving Active',
        'content': 'Collecting driving data...',
        'channelId': 'going50_background_service',
        'channelName': 'Driving Data Collection',
        'importance': 3, // IMPORTANCE_DEFAULT
        'priority': 0, // PRIORITY_DEFAULT
        'showActivityButton': true,
        'showStopButton': true
      };
      
      // Get user preferences
      final notificationPrefs = await _preferencesService.getPreference(
        'notifications', 
        'background'
      );
      
      // Override defaults with user preferences if available
      if (notificationPrefs != null && notificationPrefs is Map<String, dynamic>) {
        config.addAll(notificationPrefs);
      }
      
      return config;
    } catch (e) {
      _logger.warning('Error getting notification config: $e');
      return {
        'title': 'Going50 - Eco Driving Active',
        'content': 'Collecting driving data...',
        'channelId': 'going50_background_service',
        'channelName': 'Driving Data Collection',
        'importance': 3,
        'priority': 0,
        'showActivityButton': true,
        'showStopButton': true
      };
    }
  }
  
  /// Load power save settings from preferences
  Future<void> _loadPowerSaveSettings() async {
    try {
      final powerSaveMode = await _preferencesService.getPreference(
        'background', 
        'powerSaveMode'
      );
      
      if (powerSaveMode != null) {
        _isPowerSaveEnabled = powerSaveMode as bool;
      } else {
        // Default to enabled for better battery life out of the box
        _isPowerSaveEnabled = true;
      }
    } catch (e) {
      _logger.warning('Error loading power save settings: $e');
      _isPowerSaveEnabled = true; // Default to battery saving mode
    }
  }
  
  /// Update the current service status
  Future<void> _checkServiceStatus() async {
    try {
      await _isServiceRunning();
    } catch (e) {
      _logger.warning('Error checking service status: $e');
    }
  }
  
  /// Set error state
  void _setError(String message) {
    _errorMessage = message;
    _serviceStatus = ServiceStatus.error;
    _logger.severe(message);
    notifyListeners();
  }
  
  /// Register the callback for the service
  Future<void> _registerCallback() async {
    try {
      // Get the callback handle for the static entry point
      final handle = PluginUtilities.getCallbackHandle(backgroundServiceCallback)?.toRawHandle();
      if (handle == null) {
        _logger.severe('Could not get callback handle');
        return;
      }
      
      // Store the callback handle
      final prefs = await SharedPreferences.getInstance();
      await prefs.setInt(_callbackHandleKey, handle);
    } catch (e) {
      _logger.severe('Error registering callback: $e');
    }
  }
  
  /// Get the stored callback handle
  Future<int?> _getCallbackHandle() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      return prefs.getInt(_callbackHandleKey);
    } catch (e) {
      _logger.severe('Error getting callback handle: $e');
      return null;
    }
  }
  
  /// Notify user that the service is running via notification
  void _notifyServiceRunning() {
    try {
      if (_notificationService != null) {
        _notificationService.showNotification(
          title: 'Going50 Active',
          body: 'Eco-driving monitoring is active. Your data is being collected in the background.',
          type: NotificationType.background,
          priority: NotificationPriority.low,
        );
      }
    } catch (e) {
      _logger.warning('Error showing service running notification: $e');
    }
  }
  
  /// Clean up resources
  @override
  void dispose() {
    _logger.info('Disposing BackgroundService');
    
    // Stop health check
    _stopHealthCheck();
    
    // Stop data listening
    _stopDataListening();
    
    // Close stream controller
    _backgroundDataController.close();
    
    super.dispose();
  }
}

/// Static entry point for the background service
@pragma('vm:entry-point')
void backgroundServiceCallback() {
  // This is the entry point for the background service
  // It will be called when the service starts in the background
  
  // Set up method channel for communication
  const MethodChannel methodChannel = 
      MethodChannel('com.example.going50/background_service');
      
  // Initialize any required services here
  WidgetsFlutterBinding.ensureInitialized();
  
  // Log startup
  print('Background service started on Dart side');
} 

################################################################################
FILE: lib/services/background/notification_service.dart
################################################################################

import 'dart:async';
import 'dart:io';

import 'package:flutter/services.dart';
import 'package:logging/logging.dart';
import 'package:going50/services/user/preferences_service.dart';
import 'package:going50/core_models/driving_event.dart';

/// NotificationType represents the different types of notifications the app can send
enum NotificationType {
  /// Regular system notifications
  system,
  
  /// Notifications related to driving behavior
  drivingEvent,
  
  /// Notifications related to achievements
  achievement,
  
  /// Notifications related to social features
  social,
  
  /// Notifications related to trips (completion, summary, etc.)
  trip,
  
  /// Background service notifications
  background,
  
  /// Notifications for eco tips and suggestions
  ecoTip,
}

/// NotificationPriority represents the urgency/importance of the notification
enum NotificationPriority {
  /// Low priority, silent notifications
  low,
  
  /// Default priority, makes a sound but doesn't pop up
  medium,
  
  /// High priority, makes sound and appears as a pop-up
  high,
}

/// NotificationService manages all in-app and system notifications
///
/// This service is responsible for:
/// - Creating and managing notification channels
/// - Sending different types of notifications based on app events
/// - Respecting user notification preferences
/// - Handling platform-specific notification implementation
class NotificationService {
  static const String _methodChannelName = 'com.example.going50/notifications';
  
  final Logger _logger = Logger('NotificationService');
  final MethodChannel _methodChannel = const MethodChannel(_methodChannelName);
  
  // Dependencies
  final PreferencesService _preferencesService;
  
  // Channel IDs for Android
  static const Map<NotificationType, String> _notificationChannels = {
    NotificationType.system: 'going50_system',
    NotificationType.drivingEvent: 'going50_driving_events',
    NotificationType.achievement: 'going50_achievements',
    NotificationType.social: 'going50_social',
    NotificationType.trip: 'going50_trips',
    NotificationType.background: 'going50_background_service',
    NotificationType.ecoTip: 'going50_eco_tips',
  };
  
  // Channel names for Android
  static const Map<NotificationType, String> _channelNames = {
    NotificationType.system: 'System Notifications',
    NotificationType.drivingEvent: 'Driving Events',
    NotificationType.achievement: 'Achievements',
    NotificationType.social: 'Social Updates',
    NotificationType.trip: 'Trip Information',
    NotificationType.background: 'Background Service',
    NotificationType.ecoTip: 'Eco Tips',
  };
  
  // Channel descriptions for Android
  static const Map<NotificationType, String> _channelDescriptions = {
    NotificationType.system: 'General app notifications',
    NotificationType.drivingEvent: 'Notifications for driving behavior events',
    NotificationType.achievement: 'Notifications for earned achievements',
    NotificationType.social: 'Notifications for social activity',
    NotificationType.trip: 'Notifications about trips and summaries',
    NotificationType.background: 'Required notifications for background service',
    NotificationType.ecoTip: 'Tips for improving eco-driving score',
  };
  
  // Notification stream controller for in-app notifications
  final _notificationStreamController = StreamController<Map<String, dynamic>>.broadcast();
  
  // Track notification permissions status
  bool _areNotificationsPermitted = false;
  
  /// Constructor
  NotificationService(this._preferencesService) {
    _logger.info('NotificationService created');
    _methodChannel.setMethodCallHandler(_handleMethodCall);
  }
  
  /// Stream of in-app notifications
  Stream<Map<String, dynamic>> get notificationStream => _notificationStreamController.stream;
  
  /// Get whether notifications are permitted
  bool get areNotificationsPermitted => _areNotificationsPermitted;
  
  /// Initialize the notification service
  /// 
  /// This creates notification channels on Android and requests permissions on iOS.
  Future<bool> initialize() async {
    try {
      _logger.info('Initializing NotificationService');
      
      // Create notification channels on Android
      if (Platform.isAndroid) {
        await _createNotificationChannels();
      }
      
      // Request notification permissions
      _areNotificationsPermitted = await requestPermissions();
      
      _logger.info('NotificationService initialized successfully. Permissions granted: $_areNotificationsPermitted');
      return true;
    } catch (e) {
      _logger.severe('Error initializing NotificationService: $e');
      return false;
    }
  }
  
  /// Create notification channels on Android
  Future<void> _createNotificationChannels() async {
    try {
      List<Map<String, dynamic>> channels = [];
      
      // Create channel configuration for each notification type
      for (var type in NotificationType.values) {
        final channelId = _notificationChannels[type];
        final channelName = _channelNames[type];
        final channelDescription = _channelDescriptions[type];
        
        // Skip if any are missing
        if (channelId == null || channelName == null || channelDescription == null) {
          continue;
        }
        
        // Determine importance based on notification type
        int importance;
        switch (type) {
          case NotificationType.drivingEvent:
          case NotificationType.background:
            importance = 3; // IMPORTANCE_DEFAULT
            break;
          case NotificationType.achievement:
          case NotificationType.trip:
            importance = 4; // IMPORTANCE_HIGH
            break;
          default:
            importance = 2; // IMPORTANCE_LOW
            break;
        }
        
        channels.add({
          'id': channelId,
          'name': channelName,
          'description': channelDescription,
          'importance': importance,
        });
      }
      
      // Create all channels at once
      await _methodChannel.invokeMethod('createNotificationChannels', {'channels': channels});
      _logger.info('Created ${channels.length} notification channels');
    } catch (e) {
      _logger.warning('Error creating notification channels: $e');
    }
  }
  
  /// Request permission to show notifications
  Future<bool> requestPermissions() async {
    try {
      final result = await _methodChannel.invokeMethod('requestNotificationPermissions');
      return result == true;
    } catch (e) {
      _logger.warning('Error requesting notification permissions: $e');
      return false;
    }
  }
  
  /// Show a notification
  /// 
  /// This will show a system notification if the app is in the background
  /// or an in-app notification if the app is in the foreground.
  /// Returns true if the notification was shown.
  Future<bool> showNotification({
    required String title,
    required String body,
    required NotificationType type,
    NotificationPriority priority = NotificationPriority.medium,
    Map<String, dynamic>? data,
    String? notificationId,
  }) async {
    // Check if notifications of this type are enabled
    if (!isNotificationTypeEnabled(type)) {
      _logger.info('Notification of type $type is disabled by user preferences');
      return false;
    }
    
    final id = notificationId ?? DateTime.now().millisecondsSinceEpoch.toString();
    
    try {
      // Create notification payload
      final notification = {
        'id': id,
        'title': title,
        'body': body,
        'type': type.toString(),
        'priority': priority.toString(),
        'data': data ?? {},
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      };
      
      // Emit to in-app stream first
      _notificationStreamController.add(notification);
      
      // Only send system notification if app is not in foreground
      final isAppInForeground = await _methodChannel.invokeMethod('isAppInForeground');
      if (isAppInForeground == true) {
        _logger.info('App is in foreground, showing in-app notification only');
        return true;
      }
      
      // Send system notification
      await _methodChannel.invokeMethod('showNotification', {
        'id': id,
        'title': title,
        'body': body,
        'channelId': _notificationChannels[type],
        'priority': _getPriorityValue(priority),
        'data': data ?? {},
      });
      
      _logger.info('Showed notification: $title');
      return true;
    } catch (e) {
      _logger.warning('Error showing notification: $e');
      return false;
    }
  }
  
  /// Show a driving event notification
  /// 
  /// Specialized method for showing notifications related to driving events.
  Future<bool> showDrivingEventNotification(DrivingEvent event) async {
    // Format title and message based on event type
    String title;
    String message;
    
    switch (event.eventType) {
      case 'harsh_acceleration':
        title = 'Aggressive Acceleration';
        message = 'Try accelerating more gradually for better efficiency';
        break;
      case 'harsh_braking':
        title = 'Hard Braking';
        message = 'Try to anticipate stops and brake gradually';
        break;
      case 'excessive_speed':
        title = 'Speeding';
        message = 'Maintaining a consistent, legal speed improves efficiency';
        break;
      case 'excessive_idling':
        title = 'Excessive Idling';
        message = 'Consider turning off your engine when stopped for long periods';
        break;
      case 'trip_completed':
        title = 'Trip Completed';
        message = 'Check your summary for eco-driving insights';
        break;
      default:
        // Use the additionalData if available
        title = event.additionalData?['title'] as String? ?? 'Driving Event';
        message = event.additionalData?['message'] as String? ?? '';
    }
    
    return showNotification(
      title: title,
      body: message, 
      type: NotificationType.drivingEvent,
      priority: NotificationPriority.medium,
      data: {'eventType': event.eventType, 'eventId': event.id},
      notificationId: 'driving_event_${event.id}',
    );
  }
  
  /// Show an achievement notification
  Future<bool> showAchievementNotification({
    required String title,
    required String message,
    required String badgeType,
    required int level,
  }) {
    return showNotification(
      title: title,
      body: message,
      type: NotificationType.achievement,
      priority: NotificationPriority.high,
      data: {'badgeType': badgeType, 'level': level},
      notificationId: 'achievement_${badgeType}_$level',
    );
  }
  
  /// Show a trip summary notification
  Future<bool> showTripSummaryNotification({
    required String tripId,
    required int ecoScore,
    required double distanceKm,
    required double fuelSavedL,
  }) {
    String title = 'Trip Summary';
    String message = 'Eco-Score: $ecoScore | Distance: ${distanceKm.toStringAsFixed(1)} km';
    
    if (fuelSavedL > 0) {
      message += ' | Saved: ${fuelSavedL.toStringAsFixed(2)}L';
    }
    
    return showNotification(
      title: title,
      body: message,
      type: NotificationType.trip,
      priority: NotificationPriority.medium,
      data: {'tripId': tripId, 'ecoScore': ecoScore},
      notificationId: 'trip_summary_$tripId',
    );
  }
  
  /// Cancel a notification by ID
  Future<void> cancelNotification(String id) async {
    try {
      await _methodChannel.invokeMethod('cancelNotification', {'id': id});
      _logger.info('Cancelled notification: $id');
    } catch (e) {
      _logger.warning('Error cancelling notification: $e');
    }
  }
  
  /// Cancel all notifications
  Future<void> cancelAllNotifications() async {
    try {
      await _methodChannel.invokeMethod('cancelAllNotifications');
      _logger.info('Cancelled all notifications');
    } catch (e) {
      _logger.warning('Error cancelling all notifications: $e');
    }
  }
  
  /// Update notification settings for a given type
  Future<void> updateNotificationSetting(NotificationType type, bool enabled) async {
    final category = 'notifications';
    String key;
    
    switch (type) {
      case NotificationType.achievement:
        key = 'achievements';
        break;
      case NotificationType.drivingEvent:
        key = 'driving_events';
        break;
      case NotificationType.trip:
        key = 'trip_summary';
        break;
      case NotificationType.social:
        key = 'social';
        break;
      case NotificationType.ecoTip:
        key = 'eco_tips';
        break;
      case NotificationType.background:
        key = 'background_collection';
        break;
      default:
        key = 'system';
    }
    
    await _preferencesService.setPreference(category, key, enabled);
    _logger.info('Updated notification setting: $type => $enabled');
  }
  
  /// Check if a notification type is enabled based on user preferences
  bool isNotificationTypeEnabled(NotificationType type) {
    final category = 'notifications';
    String key;
    
    switch (type) {
      case NotificationType.achievement:
        key = 'achievements';
        break;
      case NotificationType.drivingEvent:
        key = 'driving_events';
        break;
      case NotificationType.trip:
        key = 'trip_summary';
        break;
      case NotificationType.social:
        key = 'social';
        break;
      case NotificationType.ecoTip:
        key = 'eco_tips';
        break;
      case NotificationType.background:
        key = 'background_collection';
        break;
      default:
        // System notifications are always enabled
        return true;
    }
    
    // Get user preference, defaulting to true if not found
    return _preferencesService.getPreference(category, key) ?? true;
  }
  
  /// Handle incoming method calls from the platform
  Future<dynamic> _handleMethodCall(MethodCall call) async {
    switch (call.method) {
      case 'onNotificationClicked':
        // Handle notification click
        _logger.info('Notification clicked: ${call.arguments}');
        return null;
      default:
        throw PlatformException(
          code: 'Unimplemented',
          details: 'Method ${call.method} not implemented',
        );
    }
  }
  
  /// Get platform-specific priority value
  int _getPriorityValue(NotificationPriority priority) {
    switch (priority) {
      case NotificationPriority.low:
        return 0; // PRIORITY_LOW
      case NotificationPriority.high:
        return 1; // PRIORITY_HIGH
      case NotificationPriority.medium:
        return 0; // PRIORITY_DEFAULT
    }
  }
  
  /// Dispose resources
  void dispose() {
    _notificationStreamController.close();
  }
} 

################################################################################
FILE: lib/services/gamification/achievement_service.dart
################################################################################

import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:logging/logging.dart';
import 'package:uuid/uuid.dart';

import 'package:going50/data_lib/data_storage_manager.dart';
import 'package:going50/core_models/trip.dart';
import 'package:going50/services/driving/performance_metrics_service.dart';

/// Represents an achievement event when a badge is earned
class AchievementEvent {
  /// Unique identifier for the event
  final String id;
  
  /// User ID associated with this event
  final String userId;
  
  /// Type of badge earned
  final String badgeType;
  
  /// Name of the badge for display
  final String badgeName;
  
  /// Description of the badge
  final String badgeDescription;
  
  /// Level of the badge (if applicable)
  final int level;
  
  /// When the badge was earned
  final DateTime timestamp;
  
  /// Whether this is an upgrade to an existing badge
  final bool isUpgrade;
  
  /// Constructor
  AchievementEvent({
    required this.id,
    required this.userId,
    required this.badgeType,
    required this.badgeName,
    required this.badgeDescription,
    required this.level,
    required this.timestamp,
    this.isUpgrade = false,
  });

  /// Convert to a map
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'userId': userId,
      'badgeType': badgeType,
      'badgeName': badgeName,
      'badgeDescription': badgeDescription,
      'level': level,
      'timestamp': timestamp.toIso8601String(),
      'isUpgrade': isUpgrade,
    };
  }
}

/// Definition of the available badge types in the app
class BadgeType {
  /// Smooth Driver - maintain smooth driving style
  static const String smoothDriver = 'smooth_driver';
  
  /// Eco Warrior - achieve high eco-scores
  static const String ecoWarrior = 'eco_warrior';
  
  /// Fuel Saver - save fuel through eco-driving
  static const String fuelSaver = 'fuel_saver';
  
  /// Carbon Reducer - reduce CO2 emissions
  static const String carbonReducer = 'carbon_reducer';
  
  /// Road Veteran - complete many trips
  static const String roadVeteran = 'road_veteran';
  
  /// Speed Master - maintain optimal speeds
  static const String speedMaster = 'speed_master';
  
  /// Eco Expert - achieve excellent overall eco-score
  static const String ecoExpert = 'eco_expert';
  
  /// Fuel Efficiency - maintain good fuel efficiency
  static const String fuelEfficiency = 'fuel_efficiency';
  
  /// Consistent Driver - maintain consistent driving behavior
  static const String consistentDriver = 'consistent_driver';
  
  /// Early Adopter - used app in early stages
  static const String earlyAdopter = 'early_adopter';
  
  /// First Trip - completed first trip with the app
  static const String firstTrip = 'first_trip';
  
  /// OBD Connected - successfully connected to an OBD-II adapter
  static const String obdConnected = 'obd_connected';
}

/// Service that manages achievement tracking and awarding
class AchievementService extends ChangeNotifier {
  final Logger _logger = Logger('AchievementService');
  final DataStorageManager _dataStorageManager;
  final PerformanceMetricsService _performanceMetricsService;
  final Uuid _uuid = Uuid();
  
  // Event stream controller
  final StreamController<AchievementEvent> _achievementEventController = 
      StreamController<AchievementEvent>.broadcast();
  
  // Cache of user badges
  final Map<String, List<Map<String, dynamic>>> _userBadgesCache = {};
  
  // Achievement definitions with criteria
  late final Map<String, Map<String, dynamic>> _achievementDefinitions;
  
  // Service state
  bool _isInitialized = false;
  String? _errorMessage;
  
  // Public getters
  bool get isInitialized => _isInitialized;
  String? get errorMessage => _errorMessage;
  
  /// Stream of achievement events (when badges are earned)
  Stream<AchievementEvent> get achievementEventStream => _achievementEventController.stream;
  
  /// Constructor
  AchievementService(this._dataStorageManager, this._performanceMetricsService) {
    _logger.info('AchievementService created');
    _defineAchievements();
    _initialize();
  }
  
  /// Define all achievements and their criteria
  void _defineAchievements() {
    _achievementDefinitions = {
      BadgeType.smoothDriver: {
        'name': 'Smooth Driver',
        'description': 'Maintain calm driving for consecutive trips',
        'levels': [
          {'threshold': 5, 'description': 'Maintain calm driving for 5 trips'},
          {'threshold': 10, 'description': 'Maintain calm driving for 10 trips'},
          {'threshold': 25, 'description': 'Maintain calm driving for 25 trips'},
        ],
        'metric': 'calmDrivingScore',
        'minScore': 80,
      },
      
      BadgeType.ecoWarrior: {
        'name': 'Eco Warrior',
        'description': 'Achieve high eco-scores on multiple trips',
        'levels': [
          {'threshold': 3, 'description': 'Achieve 85+ eco-score for 3 consecutive trips'},
          {'threshold': 5, 'description': 'Achieve 90+ eco-score for 5 consecutive trips'},
          {'threshold': 10, 'description': 'Achieve 90+ eco-score for 10 consecutive trips'},
        ],
        'metric': 'overallScore',
        'minScore': 85,
      },
      
      BadgeType.fuelSaver: {
        'name': 'Fuel Saver',
        'description': 'Save fuel through eco-driving habits',
        'levels': [
          {'threshold': 10, 'description': 'Save 10 liters of fuel through eco-driving'},
          {'threshold': 20, 'description': 'Save 20 liters of fuel through eco-driving'},
          {'threshold': 50, 'description': 'Save 50 liters of fuel through eco-driving'},
        ],
        'metric': 'fuelSaved',
        'cumulative': true,
      },
      
      BadgeType.carbonReducer: {
        'name': 'Carbon Reducer',
        'description': 'Reduce CO2 emissions through efficient driving',
        'levels': [
          {'threshold': 20, 'description': 'Reduce CO2 emissions by 20kg'},
          {'threshold': 50, 'description': 'Reduce CO2 emissions by 50kg'},
          {'threshold': 100, 'description': 'Reduce CO2 emissions by 100kg'},
        ],
        'metric': 'co2Reduced',
        'cumulative': true,
      },
      
      BadgeType.roadVeteran: {
        'name': 'Road Veteran',
        'description': 'Complete trips with the app',
        'levels': [
          {'threshold': 10, 'description': 'Complete 10 trips with the app'},
          {'threshold': 50, 'description': 'Complete 50 trips with the app'},
          {'threshold': 100, 'description': 'Complete 100 trips with the app'},
        ],
        'metric': 'tripCount',
        'cumulative': true,
      },
      
      BadgeType.speedMaster: {
        'name': 'Speed Master',
        'description': 'Maintain optimal speed during trips',
        'levels': [
          {'threshold': 10, 'description': 'Maintain optimal speed for 10 minutes continuously'},
          {'threshold': 30, 'description': 'Maintain optimal speed for 30 minutes continuously'},
          {'threshold': 60, 'description': 'Maintain optimal speed for 60 minutes continuously'},
        ],
        'metric': 'speedOptimizationScore',
        'minScore': 85,
      },
      
      BadgeType.ecoExpert: {
        'name': 'Eco Expert',
        'description': 'Achieve excellent overall eco-score',
        'levels': [
          {'threshold': 85, 'description': 'Achieve an overall eco-score of 85+'},
          {'threshold': 90, 'description': 'Achieve an overall eco-score of 90+'},
          {'threshold': 95, 'description': 'Achieve an overall eco-score of 95+'},
        ],
        'metric': 'overallScore',
        'highest': true,
      },
      
      BadgeType.fuelEfficiency: {
        'name': 'Fuel Efficiency',
        'description': 'Maintain good fuel efficiency',
        'levels': [
          {'threshold': 5, 'description': 'Improve fuel efficiency by 5%'},
          {'threshold': 10, 'description': 'Improve fuel efficiency by 10%'},
          {'threshold': 20, 'description': 'Improve fuel efficiency by 20%'},
        ],
        'metric': 'fuelEfficiencyImprovement',
      },
      
      BadgeType.consistentDriver: {
        'name': 'Consistent Driver',
        'description': 'Maintain consistent eco-driving habits',
        'levels': [
          {'threshold': 5, 'description': 'Maintain 80+ eco-score for 5 days in a row'},
          {'threshold': 14, 'description': 'Maintain 80+ eco-score for 14 days in a row'},
          {'threshold': 30, 'description': 'Maintain 80+ eco-score for 30 days in a row'},
        ],
        'metric': 'consecutiveDaysWithGoodScore',
      },
      
      BadgeType.earlyAdopter: {
        'name': 'Early Adopter',
        'description': 'Used the app in its early stages',
        'levels': [
          {'threshold': 1, 'description': 'Started using Going50 as an early adopter'},
        ],
        'metric': 'appInstallDate',
        'special': true,
      },
      
      // New achievements
      BadgeType.firstTrip: {
        'name': 'First Journey',
        'description': 'Completed your first trip with Going50',
        'levels': [
          {'threshold': 1, 'description': 'Completed your first trip with Going50 - the beginning of your eco-driving journey!'},
        ],
        'metric': 'tripCount',
        'special': true,
      },
      
      BadgeType.obdConnected: {
        'name': 'Connected Driver',
        'description': 'Successfully connected to an OBD-II adapter',
        'levels': [
          {'threshold': 1, 'description': 'Successfully connected to an OBD-II adapter - unlocking enhanced driving insights!'},
        ],
        'metric': 'obdConnected',
        'special': true,
      },
    };
  }
  
  /// Initialize the service
  Future<bool> _initialize() async {
    _logger.info('Initializing AchievementService');
    
    try {
      // Nothing special to initialize yet
      _isInitialized = true;
      return true;
    } catch (e) {
      _errorMessage = 'Failed to initialize achievement service: $e';
      _logger.severe(_errorMessage);
      return false;
    }
  }
  
  /// Check for achievements after a trip
  Future<List<AchievementEvent>> checkAchievementsAfterTrip(Trip trip, String userId) async {
    _logger.info('Checking achievements after trip ${trip.id} for user $userId');
    
    final List<AchievementEvent> newAchievements = [];
    
    try {
      // Get user performance metrics
      final metrics = await _performanceMetricsService.getUserPerformanceMetrics(userId);
      
      if (metrics == null) {
        _logger.warning('No performance metrics found for user $userId');
        return [];
      }
      
      // Get user's existing badges
      final userBadges = await getUserBadges(userId);
      
      // Check each achievement type
      for (final entry in _achievementDefinitions.entries) {
        final badgeType = entry.key;
        final definition = entry.value;
        
        // Skip special achievements that are checked elsewhere
        if (definition['special'] == true) continue;
        
        // Get current badge level (0 if not earned yet)
        final currentLevel = _getCurrentBadgeLevel(userBadges, badgeType);
        
        // Check if user qualifies for next level
        final qualifiesForLevel = _checkQualification(
          metrics: metrics,
          badgeType: badgeType,
          definition: definition,
          currentLevel: currentLevel,
        );
        
        if (qualifiesForLevel > currentLevel) {
          // Award the new badge
          final achievementEvent = await _awardBadge(
            userId: userId,
            badgeType: badgeType,
            level: qualifiesForLevel,
            isUpgrade: currentLevel > 0,
          );
          
          if (achievementEvent != null) {
            newAchievements.add(achievementEvent);
          }
        }
      }
      
      return newAchievements;
    } catch (e) {
      _logger.severe('Error checking achievements: $e');
      return [];
    }
  }
  
  /// Check qualification for a specific badge type
  int _checkQualification({
    required Map<String, dynamic> metrics, 
    required String badgeType,
    required Map<String, dynamic> definition,
    required int currentLevel,
  }) {
    try {
      // If user already has max level, no need to check
      final levels = definition['levels'] as List;
      if (currentLevel >= levels.length) {
        return currentLevel;
      }
      
      // Get the next level to check
      final nextLevel = currentLevel + 1;
      final levelDef = levels[nextLevel - 1];
      final threshold = levelDef['threshold'] as int;
      final metric = definition['metric'] as String;
      
      // Get the metric value from performance metrics
      final dynamic metricValue = metrics[metric];
      
      if (metricValue == null) {
        _logger.warning('Metric $metric not found in performance data');
        return currentLevel;
      }
      
      // Different logic based on achievement type
      if (definition['cumulative'] == true) {
        // Cumulative achievements (like total distance)
        if (metricValue >= threshold) {
          return nextLevel;
        }
      } else if (definition['highest'] == true) {
        // Highest score achievements
        if (metricValue >= threshold) {
          return nextLevel;
        }
      } else if (definition.containsKey('minScore')) {
        // Consecutive achievements with minimum score
        final consecutiveCount = metrics['consecutive${metric.capitalize}'] ?? 0;
        if (consecutiveCount >= threshold && metricValue >= definition['minScore']) {
          return nextLevel;
        }
      } else {
        // Default check
        if (metricValue >= threshold) {
          return nextLevel;
        }
      }
      
      return currentLevel;
    } catch (e) {
      _logger.warning('Error checking qualification for $badgeType: $e');
      return currentLevel;
    }
  }
  
  /// Award a badge to a user
  Future<AchievementEvent?> _awardBadge({
    required String userId,
    required String badgeType,
    required int level,
    bool isUpgrade = false,
  }) async {
    try {
      _logger.info('Beginning award process for badge $badgeType level $level to user $userId');
      
      // Get badge definition
      final definition = _achievementDefinitions[badgeType];
      if (definition == null) {
        _logger.warning('Badge type $badgeType not found in definitions');
        return null;
      }
      
      final badgeName = definition['name'] as String;
      final levels = definition['levels'] as List;
      
      // Safety check for level boundaries
      if (level < 1 || level > levels.length) {
        _logger.warning('Invalid level $level for badge $badgeType (max level: ${levels.length})');
        // Default to level 1 if invalid
        level = 1;
      }
      
      final levelDef = levels[level - 1];
      final badgeDescription = levelDef['description'] as String;
      
      _logger.info('Creating badge data for "$badgeName" ($badgeDescription)');
      
      // Create badge data
      final badge = {
        'userId': userId,
        'badgeType': badgeType,
        'earnedDate': DateTime.now(),
        'level': level,
        'metadataJson': jsonEncode({
          'name': badgeName,
          'description': badgeDescription,
          'isUpgrade': isUpgrade,
        }),
      };
      
      // Save badge to database
      _logger.info('Saving badge $badgeType to database for user $userId');
      final savedBadge = await _dataStorageManager.saveBadge(badge);
      
      if (savedBadge == null) {
        _logger.warning('Failed to save badge $badgeType for user $userId');
        return null;
      }
      
      // Clear cache for this user
      _userBadgesCache.remove(userId);
      
      // Create achievement event
      final eventId = _uuid.v4();
      _logger.info('Creating achievement event with ID $eventId');
      
      // Create and broadcast achievement event
      final achievementEvent = AchievementEvent(
        id: eventId,
        userId: userId,
        badgeType: badgeType,
        badgeName: badgeName,
        badgeDescription: badgeDescription,
        level: level,
        timestamp: DateTime.now(),
        isUpgrade: isUpgrade,
      );
      
      // Broadcast event
      _achievementEventController.add(achievementEvent);
      _logger.info('Achievement event broadcasted: $badgeType level $level');
      
      // Update any metrics if needed
      
      return achievementEvent;
    } catch (e) {
      _logger.warning('Error awarding badge: $e');
      return null;
    }
  }
  
  /// Get current level of a specific badge (0 if not earned)
  int _getCurrentBadgeLevel(List<Map<String, dynamic>> userBadges, String badgeType) {
    try {
      for (final badge in userBadges) {
        if (badge['badgeType'] == badgeType) {
          return badge['level'] as int;
        }
      }
      return 0; // Badge not earned yet
    } catch (e) {
      _logger.warning('Error getting current badge level: $e');
      return 0;
    }
  }
  
  /// Get badges for a specific user
  Future<List<Map<String, dynamic>>> getUserBadges(String userId) async {
    try {
      _logger.info('Getting badges for user $userId');
      
      // Check cache first
      if (_userBadgesCache.containsKey(userId)) {
        _logger.info('Returning ${_userBadgesCache[userId]!.length} badges from cache for user $userId');
        return List.from(_userBadgesCache[userId]!);
      }
      
      // Fetch badges from database
      _logger.info('Fetching badges from database for user $userId');
      final badges = await _dataStorageManager.getUserBadges(userId);
      _logger.info('Retrieved ${badges.length} badges from database for user $userId');
      
      // If no badges found, return empty list
      if (badges.isEmpty) {
        _logger.info('No badges found for user $userId');
        _userBadgesCache[userId] = [];
        return [];
      }
      
      // Process badges to add name and description from definitions
      final processedBadges = badges.map((badge) {
        final badgeType = badge['badgeType'] as String;
        final level = badge['level'] as int;
        
        // Extract metadata or populate from definitions
        Map<String, dynamic> metadata = {};
        if (badge['metadataJson'] != null) {
          try {
            metadata = jsonDecode(badge['metadataJson'] as String);
          } catch (e) {
            _logger.warning('Error parsing badge metadata: $e');
          }
        }
        
        // Look up in definitions if needed
        if (!metadata.containsKey('name') || !metadata.containsKey('description')) {
          final definition = _achievementDefinitions[badgeType];
          if (definition != null) {
            final levels = definition['levels'] as List;
            final levelIdx = (level - 1).clamp(0, levels.length - 1);
            
            metadata['name'] = definition['name'];
            metadata['description'] = levels[levelIdx]['description'];
          }
        }
        
        // Merge metadata into badge
        return {
          ...badge,
          'name': metadata['name'] ?? 'Unknown Badge',
          'description': metadata['description'] ?? 'No description available',
        };
      }).toList();
      
      // Cache the results
      _userBadgesCache[userId] = processedBadges;
      _logger.info('Cached ${processedBadges.length} badges for user $userId');
      
      return processedBadges;
    } catch (e) {
      _logger.severe('Error getting user badges: $e');
      return [];
    }
  }
  
  /// Get all available badge types with descriptions
  List<Map<String, dynamic>> getAvailableBadgeTypes() {
    return _achievementDefinitions.entries.map((entry) {
      final badgeType = entry.key;
      final definition = entry.value;
      
      return {
        'badgeType': badgeType,
        'name': definition['name'],
        'description': definition['description'],
        'levels': definition['levels'],
      };
    }).toList();
  }
  
  /// Get a user's progress towards a specific badge type
  /// Returns a value between 0.0 and 1.0 representing progress percentage
  Future<double?> getBadgeProgress(String userId, String badgeType) async {
    try {
      _logger.info('Getting progress for badge $badgeType for user $userId');
      
      // Get the badge definition
      final definition = _achievementDefinitions[badgeType];
      if (definition == null) {
        _logger.warning('Badge type $badgeType not found in definitions');
        return null;
      }
      
      // Get current badge level (0 if not earned yet)
      final userBadges = await getUserBadges(userId);
      final currentLevel = _getCurrentBadgeLevel(userBadges, badgeType);
      
      // If user already has max level, return 1.0 (100%)
      final levels = definition['levels'] as List;
      if (currentLevel >= levels.length) {
        return 1.0;
      }
      
      // Get the next level to check
      final nextLevel = currentLevel + 1;
      final levelDef = levels[nextLevel - 1];
      final threshold = levelDef['threshold'] as int;
      final metric = definition['metric'] as String;
      
      // Get user's performance metrics
      final metrics = await _performanceMetricsService.getUserPerformanceMetrics(userId);
      if (metrics == null) {
        _logger.warning('No performance metrics found for user $userId');
        return 0.0;
      }
      
      // Get the metric value
      final dynamic metricValue = metrics[metric];
      if (metricValue == null) {
        _logger.warning('Metric $metric not found in performance data');
        return 0.0;
      }
      
      // Calculate progress based on achievement type
      double progress = 0.0;
      
      if (definition['cumulative'] == true) {
        // Cumulative achievements (like total distance)
        progress = (metricValue / threshold).clamp(0.0, 1.0);
      } else if (definition['highest'] == true) {
        // Highest score achievements
        progress = (metricValue / threshold).clamp(0.0, 1.0);
      } else if (definition.containsKey('minScore')) {
        // Consecutive achievements with minimum score
        final consecutiveCount = metrics['consecutive${metric.capitalize}'] ?? 0;
        progress = (consecutiveCount / threshold).clamp(0.0, 1.0);
      } else {
        // Default calculation
        progress = (metricValue / threshold).clamp(0.0, 1.0);
      }
      
      _logger.info('Progress for badge $badgeType: $progress');
      return progress;
    } catch (e) {
      _logger.warning('Error getting badge progress: $e');
      return 0.0;
    }
  }
  
  /// Award special badges triggered by special events
  Future<AchievementEvent?> awardSpecialBadge(String userId, String badgeType) async {
    try {
      _logger.info('Starting award process for special badge $badgeType to user $userId');
      
      if (!_achievementDefinitions.containsKey(badgeType)) {
        _logger.warning('Special badge type $badgeType not found in definitions');
        return null;
      }
      
      // Check if user already has this badge
      _logger.info('Checking if user $userId already has badge $badgeType');
      final userBadges = await getUserBadges(userId);
      _logger.info('User has ${userBadges.length} badges in total');
      
      // Log all badge types the user has for debugging
      if (userBadges.isNotEmpty) {
        final userBadgeTypes = userBadges.map((b) => b['badgeType'] as String).toList();
        _logger.info('User badge types: ${userBadgeTypes.join(', ')}');
      }
      
      final currentLevel = _getCurrentBadgeLevel(userBadges, badgeType);
      _logger.info('Current level for badge $badgeType: $currentLevel');
      
      if (currentLevel > 0) {
        _logger.info('User $userId already has badge $badgeType level $currentLevel');
        return null;
      }
      
      // Award the badge
      _logger.info('Awarding badge $badgeType to user $userId');
      final achievementEvent = await _awardBadge(
        userId: userId,
        badgeType: badgeType,
        level: 1,
      );
      
      if (achievementEvent != null) {
        _logger.info('Successfully awarded badge $badgeType to user $userId');
      } else {
        _logger.warning('Failed to award badge $badgeType to user $userId');
      }
      
      return achievementEvent;
    } catch (e) {
      _logger.severe('Error awarding special badge: $e');
      return null;
    }
  }
  
  /// Clean up resources
  @override
  void dispose() {
    _achievementEventController.close();
    super.dispose();
  }
}

/// String extension for capitalization
extension StringExtension on String {
  String capitalize() {
    return "${this[0].toUpperCase()}${substring(1)}";
  }
} 

################################################################################
FILE: lib/services/gamification/challenge_service.dart
################################################################################

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:logging/logging.dart';
import 'package:uuid/uuid.dart';

import 'package:going50/data_lib/data_storage_manager.dart';
import 'package:going50/core_models/gamification_models.dart';
import 'package:going50/core_models/trip.dart';
import 'package:going50/services/driving/performance_metrics_service.dart';

/// Represents a challenge event when a challenge is completed or updated
class ChallengeEvent {
  /// Unique identifier for the event
  final String id;
  
  /// User ID associated with this event
  final String userId;
  
  /// Challenge ID associated with this event
  final String challengeId;
  
  /// Title of the challenge
  final String challengeTitle;
  
  /// Current progress of the challenge
  final int progress;
  
  /// Target value of the challenge
  final int targetValue;
  
  /// Event timestamp
  final DateTime timestamp;
  
  /// Event type: 'started', 'updated', 'completed', 'reward_claimed'
  final String eventType;
  
  /// Whether the challenge is completed
  final bool isCompleted;
  
  /// Constructor
  ChallengeEvent({
    required this.id,
    required this.userId,
    required this.challengeId,
    required this.challengeTitle,
    required this.progress,
    required this.targetValue,
    required this.timestamp,
    required this.eventType,
    required this.isCompleted,
  });

  /// Convert to a map
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'userId': userId,
      'challengeId': challengeId,
      'challengeTitle': challengeTitle,
      'progress': progress,
      'targetValue': targetValue,
      'timestamp': timestamp.toIso8601String(),
      'eventType': eventType,
      'isCompleted': isCompleted,
    };
  }
}

/// Definition of the available challenge types in the app
class ChallengeType {
  /// Daily challenges that reset each day
  static const String daily = 'daily';
  
  /// Weekly challenges that reset each week
  static const String weekly = 'weekly';
  
  /// Long-term achievement challenges
  static const String achievement = 'achievement';
  
  /// Community challenges with group participation
  static const String community = 'community';
  
  /// Special event challenges available for limited times
  static const String event = 'event';
}

/// Definition of the available metric types for challenges
class MetricType {
  /// Overall eco-score value
  static const String ecoScore = 'eco_score';
  
  /// Number of trips completed
  static const String tripCount = 'trip_count';
  
  /// Total distance driven in km
  static const String distanceKm = 'distance_km';
  
  /// Number of days with at least one trip
  static const String activeDays = 'active_days';
  
  /// Calm driving score
  static const String calmDriving = 'calm_driving';
  
  /// Speed optimization score
  static const String speedOptimization = 'speed_optimization';
  
  /// Idling management score
  static const String idlingScore = 'idling_score';
  
  /// Fuel saved in liters
  static const String fuelSaved = 'fuel_saved';
  
  /// CO2 emissions reduced in kg
  static const String co2Reduced = 'co2_reduced';
  
  /// Consistent speed maintenance score
  static const String steadySpeed = 'steady_speed';
}

/// Service that manages challenges and their progress tracking.
///
/// IMPLEMENTATION NOTE:
/// This service currently uses a local-only implementation with client-side
/// challenge definitions. The current implementation uses deterministic IDs that
/// are consistent across app restarts to meet the 36-character database constraint.
///
/// MIGRATION PLAN:
/// This service will be migrated to use Firebase/server-based challenge definitions
/// during Phase 2/3 of implementation. The migration will involve:
/// 1. Fetching challenge definitions from Firestore
/// 2. Syncing user progress bidirectionally
/// 3. Supporting offline functionality with local caching
/// 4. Managing challenge lifecycle (seasonal, timed challenges)
///
/// See the MockReplacementRoadmap.md "Transition Plan" section for detailed steps.
class ChallengeService extends ChangeNotifier {
  final Logger _logger = Logger('ChallengeService');
  final DataStorageManager _dataStorageManager;
  final PerformanceMetricsService _performanceMetricsService;
  final Uuid _uuid = Uuid();
  
  // Event stream controller
  final StreamController<ChallengeEvent> _challengeEventController = 
      StreamController<ChallengeEvent>.broadcast();
  
  // Challenge state change stream for UI updates
  final StreamController<Map<String, dynamic>> _challengeStateChangeController = 
      StreamController<Map<String, dynamic>>.broadcast();
  
  // Cache of available challenges and user challenges
  final Map<String, Challenge> _challengesCache = {};
  final Map<String, List<UserChallenge>> _userChallengesCache = {};
  
  // Challenge definitions with criteria
  late final List<Challenge> _systemChallenges;
  
  // Service state
  bool _isInitialized = false;
  String? _errorMessage;
  
  // Public getters
  bool get isInitialized => _isInitialized;
  String? get errorMessage => _errorMessage;
  
  /// Stream of challenge events (when challenges are updated or completed)
  Stream<ChallengeEvent> get challengeEventStream => _challengeEventController.stream;
  
  /// Stream of challenge state changes (joined, left, etc.) for UI updates
  Stream<Map<String, dynamic>> get challengeStateChangeStream => _challengeStateChangeController.stream;
  
  /// Constructor
  ChallengeService(this._dataStorageManager, this._performanceMetricsService) {
    _logger.info('ChallengeService created');
    _defineSystemChallenges();
    _initialize();
  }
  
  /// Define system-provided challenges
  ///
  /// IMPLEMENTATION NOTE:
  /// This method creates hard-coded challenge definitions with 
  /// deterministic IDs that meet the 36-character database constraint.
  /// The createConsistentId() function generates IDs that are consistent
  /// across app restarts while preserving the descriptive ID structure.
  ///
  /// In the server-based implementation, this method will be replaced with
  /// code that fetches challenge definitions from Firebase/backend API.
  /// See MockReplacementRoadmap.md "Transition Plan" for migration details.
  void _defineSystemChallenges() {
    // Helper function to create consistent IDs that meet the 36-char requirement
    String createConsistentId(String shortId) {
      // Pad the ID to ensure it's always 36 characters
      // Format: original_id + underscore + padding_characters_to_reach_36
      const String padding = "0123456789abcdef0123456789abcdef0123456789";
      final int padLength = 36 - shortId.length - 1; // -1 for the underscore
      
      if (padLength <= 0) {
        // Already 36+ characters (shouldn't happen with our current IDs)
        return shortId;
      }
      
      return "$shortId${"_"}${padding.substring(0, padLength)}";
    }
    
    _systemChallenges = [
      // Daily challenges
      Challenge(
        id: createConsistentId('daily_eco_score_75'),
        title: 'Green Commuter',
        description: 'Achieve at least 75 eco-score on a trip today',
        type: ChallengeType.daily,
        targetValue: 75,
        metricType: MetricType.ecoScore,
        iconName: 'eco',
        rewardType: 'points',
        rewardValue: 50,
      ),
      Challenge(
        id: createConsistentId('daily_calm_driving_80'),
        title: 'Zen Driver',
        description: 'Maintain a calm driving score of 80+ today',
        type: ChallengeType.daily,
        targetValue: 80,
        metricType: MetricType.calmDriving,
        iconName: 'mood',
        rewardType: 'points',
        rewardValue: 50,
      ),
      Challenge(
        id: createConsistentId('daily_idle_reduction'),
        title: 'Idle Buster',
        description: 'Keep idling time under 3 minutes for all trips today',
        type: ChallengeType.daily,
        targetValue: 90,
        metricType: MetricType.idlingScore,
        iconName: 'timer',
        rewardType: 'points',
        rewardValue: 50,
      ),
      
      // Weekly challenges
      Challenge(
        id: createConsistentId('weekly_trips_5'),
        title: 'Regular Driver',
        description: 'Complete 5 trips this week',
        type: ChallengeType.weekly,
        targetValue: 5,
        metricType: MetricType.tripCount,
        iconName: 'repeat',
        rewardType: 'points',
        rewardValue: 100,
      ),
      Challenge(
        id: createConsistentId('weekly_distance_100'),
        title: 'Distance Champion',
        description: 'Drive 100km with eco-score above 80 this week',
        type: ChallengeType.weekly,
        targetValue: 100,
        metricType: MetricType.distanceKm,
        iconName: 'straighten',
        rewardType: 'points',
        rewardValue: 150,
      ),
      Challenge(
        id: createConsistentId('weekly_active_days_5'),
        title: 'Consistent Driver',
        description: 'Drive on 5 different days this week',
        type: ChallengeType.weekly,
        targetValue: 5,
        metricType: MetricType.activeDays,
        iconName: 'event_available',
        rewardType: 'points',
        rewardValue: 125,
      ),
      
      // Achievement challenges
      Challenge(
        id: createConsistentId('achievement_fuel_saved_20'),
        title: 'Fuel Miser',
        description: 'Save 20 liters of fuel through eco-driving',
        type: ChallengeType.achievement,
        targetValue: 20,
        metricType: MetricType.fuelSaved,
        iconName: 'local_gas_station',
        difficultyLevel: 3,
        rewardType: 'badge',
        rewardValue: 1,
      ),
      Challenge(
        id: createConsistentId('achievement_co2_reduced_50'),
        title: 'Climate Guardian',
        description: 'Reduce CO2 emissions by 50kg',
        type: ChallengeType.achievement,
        targetValue: 50,
        metricType: MetricType.co2Reduced,
        iconName: 'eco',
        difficultyLevel: 3,
        rewardType: 'badge',
        rewardValue: 1,
      ),
      Challenge(
        id: createConsistentId('achievement_trips_100'),
        title: 'Century Driver',
        description: 'Complete 100 trips with the app',
        type: ChallengeType.achievement,
        targetValue: 100,
        metricType: MetricType.tripCount,
        iconName: 'directions_car',
        difficultyLevel: 4,
        rewardType: 'badge',
        rewardValue: 1,
      ),
      Challenge(
        id: createConsistentId('achievement_perfect_week'),
        title: 'Perfect Week',
        description: 'Complete all daily challenges for 7 consecutive days',
        type: ChallengeType.achievement,
        targetValue: 7,
        metricType: 'consecutive_days',
        iconName: 'stars',
        difficultyLevel: 5,
        rewardType: 'badge',
        rewardValue: 2,
      ),
    ];
  }
  
  /// Initialize the service and ensure system challenges exist
  Future<void> _initialize() async {
    // TODO: During server migration, update this method to fetch challenges from Firebase
    // and implement local caching with offline support. See MockReplacementRoadmap.md.
    
    try {
      _logger.info('Initializing ChallengeService');
      
      // Load existing challenges from database
      final existingChallenges = await _dataStorageManager.getAllChallenges();
      
      // Add challenges to cache
      for (final challenge in existingChallenges) {
        _challengesCache[challenge.id] = challenge;
      }
      
      // Ensure system challenges exist
      for (final systemChallenge in _systemChallenges) {
        if (!_challengesCache.containsKey(systemChallenge.id)) {
          await _dataStorageManager.saveChallenge(systemChallenge);
          _challengesCache[systemChallenge.id] = systemChallenge;
          _logger.info('Created system challenge: ${systemChallenge.title}');
        }
      }
      
      _isInitialized = true;
      _logger.info('ChallengeService initialized successfully');
    } catch (e) {
      _errorMessage = 'Failed to initialize challenge service: $e';
      _logger.severe(_errorMessage);
    }
  }
  
  /// Get all active challenges
  Future<List<Challenge>> getAllChallenges() async {
    if (!_isInitialized) await _initialize();
    
    try {
      // If cache is empty, reload from database
      if (_challengesCache.isEmpty) {
        final challenges = await _dataStorageManager.getAllChallenges();
        for (final challenge in challenges) {
          _challengesCache[challenge.id] = challenge;
        }
      }
      
      return _challengesCache.values.where((c) => c.isActive).toList();
    } catch (e) {
      _logger.warning('Error getting challenges: $e');
      return [];
    }
  }
  
  /// Get challenges of a specific type
  Future<List<Challenge>> getChallengesByType(String type) async {
    final allChallenges = await getAllChallenges();
    return allChallenges.where((c) => c.type == type).toList();
  }
  
  /// Get challenges for a specific user
  Future<List<UserChallenge>> getUserChallenges(String userId) async {
    if (!_isInitialized) await _initialize();
    
    try {
      // Check cache first
      if (_userChallengesCache.containsKey(userId)) {
        return List.from(_userChallengesCache[userId]!);
      }
      
      // Fetch all user challenges from database
      final userChallenges = await _dataStorageManager.getUserChallenges();
      
      // Filter challenges for the current user
      final filteredChallenges = userChallenges
          .where((uc) => uc.userId == userId)
          .toList();
      
      // Cache the results
      _userChallengesCache[userId] = filteredChallenges;
      
      return filteredChallenges;
    } catch (e) {
      _logger.warning('Error getting user challenges: $e');
      return [];
    }
  }
  
  /// Invalidate the user challenges cache for a specific user
  /// This is used to ensure fresh data is loaded after a challenge is joined
  Future<void> invalidateUserChallengesCache(String userId) async {
    _logger.info('Invalidating user challenges cache for user: $userId');
    _userChallengesCache.remove(userId);
  }
  
  /// Get user challenges of a specific type
  Future<List<UserChallenge>> getUserChallengesByType(String userId, String type) async {
    final allChallenges = await getAllChallenges();
    final userChallenges = await getUserChallenges(userId);
    
    // Get the challenge IDs of the specified type
    final challengeIds = allChallenges
        .where((c) => c.type == type)
        .map((c) => c.id)
        .toSet();
    
    // Filter user challenges by those IDs
    return userChallenges
        .where((uc) => challengeIds.contains(uc.challengeId))
        .toList();
  }
  
  /// Get a specific challenge by ID
  Future<Challenge?> _getChallenge(String challengeId) async {
    // First check in cache
    if (_challengesCache.containsKey(challengeId)) {
      return _challengesCache[challengeId];
    }
    
    try {
      // Get all challenges if not in cache
      final challenges = await getAllChallenges();
      
      // Find matching challenge
      for (final challenge in challenges) {
        if (challenge.id == challengeId) {
          return challenge;
        }
      }
      
      _logger.warning('Challenge not found with ID: $challengeId');
      return null;
    } catch (e) {
      _logger.warning('Error getting challenge with ID $challengeId: $e');
      return null;
    }
  }
  
  /// Start a challenge for a user
  Future<UserChallenge?> startChallenge(String userId, String challengeId) async {
    if (!_isInitialized) await _initialize();
    
    try {
      // Get the challenge
      final challenge = _challengesCache[challengeId];
      if (challenge == null) {
        _logger.warning('Challenge not found with ID: $challengeId');
        return null;
      }
      
      _logger.info('Starting challenge for user $userId: ${challenge.title} (ID: $challengeId)');
      
      // Check if user already has this challenge
      final userChallenges = await getUserChallenges(userId);
      _logger.info('User has ${userChallenges.length} existing challenges');
      
      // Check if the user already has this challenge
      UserChallenge? existingActiveChallenge;
      for (final uc in userChallenges) {
        if (uc.challengeId == challengeId && !uc.isCompleted) {
          existingActiveChallenge = uc;
          break;
        }
      }
      
      // If active challenge found, return it
      if (existingActiveChallenge != null) {
        _logger.info('User $userId already has an active challenge: $challengeId');
        return existingActiveChallenge;
      }
      
      // Check if this challenge was completed before
      UserChallenge? existingCompletedChallenge;
      for (final uc in userChallenges) {
        if (uc.challengeId == challengeId && uc.isCompleted) {
          existingCompletedChallenge = uc;
          break;
        }
      }
      
      // If challenge exists but is completed, check if it's a repeatable type
      if (existingCompletedChallenge != null) {
        _logger.info('User $userId has completed this challenge before');
        
        if (challenge.type == ChallengeType.daily || challenge.type == ChallengeType.weekly) {
          // Create a new instance of the challenge
          _logger.info('Creating new instance of repeatable challenge type: ${challenge.type}');
          
          final newChallenge = UserChallenge(
            id: _uuid.v4(),
            userId: userId,
            challengeId: challengeId,
            startedAt: DateTime.now(),
          );
          
          await _dataStorageManager.saveUserChallenge(newChallenge);
          _logger.info('Saved new repeatable challenge instance to database');
          
          // Clear cache
          _userChallengesCache.remove(userId);
          
          // Create and broadcast event
          final event = ChallengeEvent(
            id: _uuid.v4(),
            userId: userId,
            challengeId: challengeId,
            challengeTitle: challenge.title,
            progress: 0,
            targetValue: challenge.targetValue,
            timestamp: DateTime.now(),
            eventType: 'started',
            isCompleted: false,
          );
          
          _challengeEventController.add(event);
          
          // Notify UI components about the state change
          _challengeStateChangeController.add({
            'action': 'joined',
            'userId': userId,
            'challengeId': challengeId,
            'challengeTitle': challenge.title
          });
          
          _logger.info('User $userId started challenge: ${challenge.title}');
          
          return newChallenge;
        } else {
          // Achievement challenges can only be completed once
          _logger.info('Challenge $challengeId already completed by user $userId and is not repeatable');
          return existingCompletedChallenge;
        }
      }
      
      // This is a new challenge the user hasn't started before
      _logger.info('Creating new challenge for user $userId: ${challenge.title}');
      
      // Create new challenge
      final newChallenge = UserChallenge(
        id: _uuid.v4(),
        userId: userId,
        challengeId: challengeId,
        startedAt: DateTime.now(),
      );
      
      // Save the new challenge
      await _dataStorageManager.saveUserChallenge(newChallenge);
      _logger.info('Saved new challenge to database with ID: ${newChallenge.id}');
      
      // Clear cache
      _userChallengesCache.remove(userId);
      
      // Create and broadcast event
      final event = ChallengeEvent(
        id: _uuid.v4(),
        userId: userId,
        challengeId: challengeId,
        challengeTitle: challenge.title,
        progress: 0,
        targetValue: challenge.targetValue,
        timestamp: DateTime.now(),
        eventType: 'started',
        isCompleted: false,
      );
      
      _challengeEventController.add(event);
      
      // Notify UI components about the state change
      _challengeStateChangeController.add({
        'action': 'joined',
        'userId': userId,
        'challengeId': challengeId,
        'challengeTitle': challenge.title
      });
      
      _logger.info('User $userId started challenge: ${challenge.title}');
      
      return newChallenge;
    } catch (e) {
      _logger.severe('Error starting challenge: $e');
      return null;
    }
  }
  
  /// Update progress on a challenge
  Future<UserChallenge?> updateChallengeProgress(
    String userId, 
    String challengeId, 
    int progress
  ) async {
    if (!_isInitialized) await _initialize();
    
    try {
      // Get the challenge
      final challenge = _challengesCache[challengeId];
      if (challenge == null) {
        _logger.warning('Challenge not found with ID: $challengeId');
        return null;
      }
      
      // Get user challenges
      final userChallenges = await getUserChallenges(userId);
      
      // Look for an existing active challenge
      UserChallenge? existingChallenge;
      for (final uc in userChallenges) {
        if (uc.challengeId == challengeId && !uc.isCompleted) {
          existingChallenge = uc;
          break;
        }
      }
      
      // If no active challenge found, start a new one
      if (existingChallenge == null) {
        _logger.info('No active challenge found, starting a new one');
        existingChallenge = UserChallenge(
          id: _uuid.v4(),
          userId: userId,
          challengeId: challengeId,
          startedAt: DateTime.now(),
        );
        
        // Save the new challenge
        await _dataStorageManager.saveUserChallenge(existingChallenge);
        _logger.info('Saved new challenge to database with ID: ${existingChallenge.id}');
      }
      
      // Update progress
      final wasCompleted = existingChallenge.isCompleted;
      final updatedChallenge = existingChallenge.copyWithProgress(
        progress, 
        challenge.targetValue
      );
      
      // Save updated challenge
      await _dataStorageManager.saveUserChallenge(updatedChallenge);
      
      // Clear cache
      _userChallengesCache.remove(userId);
      
      // Determine event type
      String eventType = 'updated';
      if (!wasCompleted && updatedChallenge.isCompleted) {
        eventType = 'completed';
      }
      
      // Create and broadcast event
      final event = ChallengeEvent(
        id: _uuid.v4(),
        userId: userId,
        challengeId: challengeId,
        challengeTitle: challenge.title,
        progress: updatedChallenge.progress,
        targetValue: challenge.targetValue,
        timestamp: DateTime.now(),
        eventType: eventType,
        isCompleted: updatedChallenge.isCompleted,
      );
      
      _challengeEventController.add(event);
      
      // Log progress update
      if (eventType == 'completed') {
        _logger.info('User $userId completed challenge: ${challenge.title}');
      } else {
        _logger.info('User $userId updated progress on challenge: ${challenge.title} to ${updatedChallenge.progress}/${challenge.targetValue}');
      }
      
      return updatedChallenge;
    } catch (e) {
      _logger.severe('Error updating challenge progress: $e');
      return null;
    }
  }
  
  /// Claim reward for a completed challenge
  Future<bool> claimChallengeReward(String userId, String challengeId) async {
    if (!_isInitialized) await _initialize();
    
    try {
      // Get the challenge
      final challenge = _challengesCache[challengeId];
      if (challenge == null) {
        _logger.warning('Challenge not found with ID: $challengeId');
        return false;
      }
      
      // Get user challenges
      final userChallenges = await getUserChallenges(userId);
      
      // Look for a completed challenge that hasn't had its reward claimed
      UserChallenge? existingChallenge;
      for (final uc in userChallenges) {
        if (uc.challengeId == challengeId && uc.isCompleted && !uc.rewardClaimed) {
          existingChallenge = uc;
          break;
        }
      }
      
      // Check if challenge is eligible for reward claim
      if (existingChallenge == null) {
        _logger.warning('Challenge $challengeId not eligible for reward claim');
        return false;
      }
      
      // Update challenge to mark reward as claimed
      final updatedChallenge = existingChallenge.copyWithRewardClaimed();
      
      // Save updated challenge
      await _dataStorageManager.saveUserChallenge(updatedChallenge);
      
      // Clear cache
      _userChallengesCache.remove(userId);
      
      // Create and broadcast event
      final event = ChallengeEvent(
        id: _uuid.v4(),
        userId: userId,
        challengeId: challengeId,
        challengeTitle: challenge.title,
        progress: updatedChallenge.progress,
        targetValue: challenge.targetValue,
        timestamp: DateTime.now(),
        eventType: 'reward_claimed',
        isCompleted: true,
      );
      
      _challengeEventController.add(event);
      _logger.info('User $userId claimed reward for challenge: ${challenge.title}');
      
      // Here you would apply the reward to the user
      // This could involve updating points, awarding badges, etc.
      // For now, we'll just assume this happens successfully
      
      return true;
    } catch (e) {
      _logger.severe('Error claiming challenge reward: $e');
      return false;
    }
  }
  
  /// Create a custom challenge
  Future<Challenge?> createCustomChallenge(Challenge challenge, String creatorId) async {
    if (!_isInitialized) await _initialize();
    
    try {
      // Verify challenge has required fields
      if (challenge.title.isEmpty || 
          challenge.description.isEmpty || 
          challenge.targetValue <= 0) {
        _logger.warning('Invalid challenge data');
        return null;
      }
      
      // Create new challenge with UUID
      final newChallenge = challenge.copyWith(
        id: _uuid.v4(),
        isSystem: false,
        creatorId: creatorId,
      );
      
      // Save to database
      await _dataStorageManager.saveChallenge(newChallenge);
      
      // Add to cache
      _challengesCache[newChallenge.id] = newChallenge;
      
      _logger.info('Created custom challenge: ${newChallenge.title}');
      return newChallenge;
    } catch (e) {
      _logger.severe('Error creating custom challenge: $e');
      return null;
    }
  }
  
  /// Check for challenge updates after a trip
  Future<void> checkChallengesAfterTrip(Trip trip, String userId) async {
    if (!_isInitialized) await _initialize();
    
    try {
      _logger.info('Checking challenges after trip ${trip.id} for user $userId');
      
      // Get all active challenges for the user
      final challenges = await getAllChallenges();
      final userChallenges = await getUserChallenges(userId);
      
      // Get all trip history to calculate metrics
      final allTrips = await _dataStorageManager.getAllTrips();
      
      // Filter for user's trips
      final userTrips = allTrips.where((t) => t.userId == userId).toList();
      
      // Calculate basic metrics
      int totalTrips = userTrips.length;
      double totalDistanceKm = 0;
      int completedTrips = 0;
      
      for (var t in userTrips) {
        if (t.distanceKm != null) {
          totalDistanceKm += t.distanceKm!;
        }
        if (t.isCompleted) {
          completedTrips++;
        }
      }
      
      // Process each challenge
      for (final challenge in challenges) {
        // Look for an existing active challenge
        UserChallenge? existingUserChallenge;
        for (final uc in userChallenges) {
          if (uc.challengeId == challenge.id && !uc.isCompleted) {
            existingUserChallenge = uc;
            break;
          }
        }
        
        // If this is a new challenge the user doesn't have yet, create and save it
        if (existingUserChallenge == null) {
          existingUserChallenge = UserChallenge(
            id: _uuid.v4(),
            userId: userId,
            challengeId: challenge.id,
            startedAt: DateTime.now(),
          );
          
          await _dataStorageManager.saveUserChallenge(existingUserChallenge);
          _userChallengesCache.remove(userId);
          _logger.info('Created new challenge for user: ${challenge.title}');
        }
        
        // Determine current progress based on metric type
        int progress = existingUserChallenge.progress;
        
        switch (challenge.metricType) {
          case MetricType.ecoScore:
            // We'll assume the AnalyticsService provides this via DrivingService
            // For now, use a simple heuristic based on events
            if (trip.hardBrakingEvents != null && 
                trip.aggressiveAccelerationEvents != null) {
              int totalEvents = (trip.hardBrakingEvents ?? 0) + 
                           (trip.aggressiveAccelerationEvents ?? 0);
              // Higher score if fewer events
              int estimatedScore = 100 - (totalEvents * 5);
              estimatedScore = estimatedScore.clamp(0, 100);
              
              if (estimatedScore >= challenge.targetValue) {
                progress = challenge.targetValue;
              }
            }
            break;
            
          case MetricType.tripCount:
            // Simply use the total number of trips
            progress = totalTrips;
            break;
            
          case MetricType.distanceKm:
            // Use total distance traveled
            progress = totalDistanceKm.toInt();
            break;
            
          case MetricType.activeDays:
            // Get number of unique days with trips
            // This would need a more sophisticated calculation
            // For now, use trip count as a proxy, clamped to max 7 days
            progress = completedTrips.clamp(0, 7);
            break;
            
          case MetricType.fuelSaved:
            // This would come from PerformanceMetricsService
            // For now, use a placeholder calculation
            double estimatedFuelSaved = totalDistanceKm * 0.01; // 1% fuel savings per km
            progress = estimatedFuelSaved.toInt();
            break;
            
          case MetricType.co2Reduced:
            // This would come from PerformanceMetricsService
            // For now, use a placeholder calculation
            double estimatedCO2Reduced = totalDistanceKm * 0.02; // 20g CO2 reduction per km
            progress = estimatedCO2Reduced.toInt();
            break;
            
          default:
            // Handle other metric types
            break;
        }
        
        // Update challenge progress if it changed
        if (progress > existingUserChallenge.progress) {
          await updateChallengeProgress(userId, challenge.id, progress);
        }
      }
      
      _logger.info('Completed challenge checking after trip ${trip.id}');
    } catch (e) {
      _logger.severe('Error checking challenges after trip: $e');
    }
  }
  
  /// Reset all daily challenges
  Future<void> resetDailyChallenges() async {
    if (!_isInitialized) await _initialize();
    
    try {
      _logger.info('Resetting daily challenges');
      
      // Get all daily challenges
      final dailyChallenges = await getChallengesByType(ChallengeType.daily);
      final dailyChallengeIds = dailyChallenges.map((c) => c.id).toSet();
      
      // Get all user challenges for daily challenges
      final allUserChallenges = await _dataStorageManager.getUserChallenges();
      final dailyUserChallenges = allUserChallenges
          .where((uc) => dailyChallengeIds.contains(uc.challengeId))
          .toList();
      
      // Group by user
      final userChallengesMap = <String, List<UserChallenge>>{};
      for (final uc in dailyUserChallenges) {
        if (!userChallengesMap.containsKey(uc.userId)) {
          userChallengesMap[uc.userId] = [];
        }
        userChallengesMap[uc.userId]!.add(uc);
      }
      
      // Process each user
      for (final userId in userChallengesMap.keys) {
        // Start new challenges for each user
        for (final challenge in dailyChallenges) {
          await startChallenge(userId, challenge.id);
        }
      }
      
      _logger.info('Daily challenges have been reset');
    } catch (e) {
      _logger.severe('Error resetting daily challenges: $e');
    }
  }
  
  /// Reset all weekly challenges
  Future<void> resetWeeklyChallenges() async {
    if (!_isInitialized) await _initialize();
    
    try {
      _logger.info('Resetting weekly challenges');
      
      // Get all weekly challenges
      final weeklyChallenges = await getChallengesByType(ChallengeType.weekly);
      final weeklyChallengeIds = weeklyChallenges.map((c) => c.id).toSet();
      
      // Get all user challenges for weekly challenges
      final allUserChallenges = await _dataStorageManager.getUserChallenges();
      final weeklyUserChallenges = allUserChallenges
          .where((uc) => weeklyChallengeIds.contains(uc.challengeId))
          .toList();
      
      // Group by user
      final userChallengesMap = <String, List<UserChallenge>>{};
      for (final uc in weeklyUserChallenges) {
        if (!userChallengesMap.containsKey(uc.userId)) {
          userChallengesMap[uc.userId] = [];
        }
        userChallengesMap[uc.userId]!.add(uc);
      }
      
      // Process each user
      for (final userId in userChallengesMap.keys) {
        // Start new challenges for each user
        for (final challenge in weeklyChallenges) {
          await startChallenge(userId, challenge.id);
        }
      }
      
      _logger.info('Weekly challenges have been reset');
    } catch (e) {
      _logger.severe('Error resetting weekly challenges: $e');
    }
  }
  
  /// Leave (abandon) a challenge that is in progress
  /// 
  /// This allows a user to opt out of a challenge they previously joined.
  /// The challenge will be removed from their active challenges list.
  Future<bool> leaveChallenge(String userId, String challengeId) async {
    if (!_isInitialized) await _initialize();
    
    try {
      _logger.info('User $userId attempting to leave challenge $challengeId');
      
      // Get the challenge definition
      final challenge = _challengesCache[challengeId];
      if (challenge == null) {
        _logger.warning('Challenge not found with ID: $challengeId');
        return false;
      }
      
      // Get user challenges
      final userChallenges = await getUserChallenges(userId);
      
      // Find the active challenge to leave
      UserChallenge? userChallenge;
      for (final uc in userChallenges) {
        if (uc.challengeId == challengeId && !uc.isCompleted) {
          userChallenge = uc;
          break;
        }
      }
      
      // Return false if challenge not found or already completed
      if (userChallenge == null) {
        _logger.warning('No active challenge found with ID $challengeId for user $userId');
        return false;
      }
      
      // Delete the user challenge from the database
      final success = await _dataStorageManager.deleteUserChallenge(userChallenge.id);
      if (!success) {
        _logger.warning('Failed to delete user challenge from database');
        return false;
      }
      
      // Clear the cache to ensure fresh data
      _userChallengesCache.remove(userId);
      
      // Create and broadcast event
      final event = ChallengeEvent(
        id: _uuid.v4(),
        userId: userId,
        challengeId: challengeId,
        challengeTitle: challenge.title,
        progress: 0,
        targetValue: challenge.targetValue,
        timestamp: DateTime.now(),
        eventType: 'abandoned',
        isCompleted: false,
      );
      
      _challengeEventController.add(event);
      
      // Notify UI components about the state change
      _challengeStateChangeController.add({
        'action': 'left',
        'userId': userId,
        'challengeId': challengeId,
        'challengeTitle': challenge.title
      });
      
      _logger.info('User $userId has left challenge: ${challenge.title}');
      
      return true;
    } catch (e) {
      _logger.severe('Error leaving challenge: $e');
      return false;
    }
  }
  
  /// Get detailed challenge with progress
  Future<Map<String, dynamic>?> getDetailedChallenge(String userId, String challengeId) async {
    if (!_isInitialized) await _initialize();
    
    try {
      // Get the challenge
      final challenge = _challengesCache[challengeId];
      if (challenge == null) {
        _logger.warning('Challenge not found with ID: $challengeId');
        return null;
      }
      
      // Get user challenge
      final userChallenges = await getUserChallenges(userId);
      
      // Look for an existing challenge
      UserChallenge? userChallenge;
      bool isJoined = false;
      
      for (final uc in userChallenges) {
        if (uc.challengeId == challengeId) {
          userChallenge = uc;
          isJoined = true;  // Found in user challenges = joined
          break;
        }
      }
      
      // If no user challenge found, create a template for display
      // but don't save it to the database
      if (userChallenge == null) {
        userChallenge = UserChallenge(
          id: _uuid.v4(),
          userId: userId,
          challengeId: challengeId,
          startedAt: DateTime.now(),
        );
      }
      
      // Combine challenge and user challenge info
      return {
        ...challenge.toJson(),
        'progress': userChallenge.progress,
        'isCompleted': userChallenge.isCompleted,
        'rewardClaimed': userChallenge.rewardClaimed,
        'startedAt': userChallenge.startedAt.toIso8601String(),
        'completedAt': userChallenge.completedAt?.toIso8601String(),
        'isJoined': isJoined,  // Add explicit joined flag
      };
    } catch (e) {
      _logger.severe('Error getting detailed challenge: $e');
      return null;
    }
  }
  
  /// Clean up resources
  @override
  void dispose() {
    _challengeEventController.close();
    _challengeStateChangeController.close();
    super.dispose();
  }
} 

################################################################################
FILE: lib/services/user/preferences_service.dart
################################################################################

import 'dart:async';
import 'dart:convert';
import 'package:logging/logging.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:going50/data_lib/data_storage_manager.dart';

/// PreferencesService manages user preferences
///
/// This service is responsible for:
/// - Storing and retrieving user preferences
/// - Providing default preferences
/// - Broadcasting preference changes
/// - Managing preference persistence
class PreferencesService {
  // Dependencies
  final DataStorageManager _dataStorageManager;
  
  // Logging
  final _log = Logger('PreferencesService');
  
  // State
  final Map<String, Map<String, dynamic>> _preferences = {};
  String? _currentUserId;
  final _preferencesStreamController = StreamController<Map<String, Map<String, dynamic>>>.broadcast();
  
  // Default preferences by category
  static final Map<String, Map<String, dynamic>> _defaultPreferences = {
    'notifications': {
      'trip_summary': true,
      'achievements': true,
      'eco_tips': true,
      'social': false,
      'background_collection': true,
    },
    'privacy': {
      'share_trip_data': false,
      'share_achievements': false,
      'allow_leaderboard': false,
      'collect_location': true,
    },
    'display': {
      'dark_mode': 'system', // 'light', 'dark', 'system'
      'units': 'metric', // 'metric', 'imperial'
      'glanceable_mode': true,
      'show_speed_gauge': true,
    },
    'driving': {
      'auto_start_trip': false,
      'auto_end_trip': true,
      'audio_feedback': true,
      'feedback_style': 'balanced', // 'gentle', 'balanced', 'direct'
      'focus_mode': false,
    },
    'feedback': {
      'acceleration_sensitivity': 'medium', // 'low', 'medium', 'high'
      'braking_sensitivity': 'medium', // 'low', 'medium', 'high'
      'speeding_threshold': 10, // km/h over limit
      'idling_threshold': 30, // seconds
    },
    'connection': {
      'preferred_obd_device_id': null,
      'connection_mode': 'auto', // 'auto', 'obd_only', 'phone_only'
      'auto_reconnect': true,
      'scan_on_startup': true,
    },
  };
  
  /// Constructor
  PreferencesService(this._dataStorageManager);
  
  /// Initialize the service
  Future<void> initialize(String userId) async {
    _log.info('Initializing PreferencesService for user: $userId');
    _currentUserId = userId;
    await _loadPreferences(userId);
  }
  
  /// Load preferences from storage
  Future<void> _loadPreferences(String userId) async {
    try {
      final userProfile = await _dataStorageManager.getUserProfileById(userId);
      
      if (userProfile != null && userProfile.preferences != null) {
        // Load from user profile if it has preferences
        _log.info('Loading preferences from user profile');
        
        final userPrefs = userProfile.preferences!;
        
        // Merge with default preferences to ensure all keys exist
        for (final category in _defaultPreferences.keys) {
          final defaultCategoryPrefs = _defaultPreferences[category]!;
          final userCategoryPrefs = userPrefs[category] as Map<String, dynamic>? ?? {};
          
          // Create category if it doesn't exist
          if (!_preferences.containsKey(category)) {
            _preferences[category] = {};
          }
          
          // Add all default preferences
          for (final key in defaultCategoryPrefs.keys) {
            _preferences[category]![key] = userCategoryPrefs[key] ?? defaultCategoryPrefs[key];
          }
        }
      } else {
        // Use default preferences
        _log.info('Using default preferences for user: $userId');
        _resetToDefaults();
      }
      
      // Notify listeners
      _preferencesStreamController.add(_preferences);
    } catch (e) {
      _log.severe('Error loading preferences: $e');
      _resetToDefaults();
      _preferencesStreamController.add(_preferences);
    }
  }
  
  /// Reset all preferences to defaults
  void _resetToDefaults() {
    _preferences.clear();
    
    // Deep copy default preferences
    for (final category in _defaultPreferences.keys) {
      _preferences[category] = Map.from(_defaultPreferences[category]!);
    }
  }
  
  /// Get all preferences
  Map<String, Map<String, dynamic>> getAllPreferences() {
    return Map.unmodifiable(_preferences);
  }
  
  /// Get a specific preference category
  Map<String, dynamic>? getCategory(String category) {
    if (!_preferences.containsKey(category)) {
      return null;
    }
    return Map.unmodifiable(_preferences[category]!);
  }
  
  /// Get a specific preference value
  dynamic getPreference(String category, String key) {
    if (!_preferences.containsKey(category)) {
      return _defaultPreferences[category]?[key];
    }
    
    if (!_preferences[category]!.containsKey(key)) {
      return _defaultPreferences[category]?[key];
    }
    
    return _preferences[category]![key];
  }
  
  /// Set a specific preference value
  Future<void> setPreference(String category, String key, dynamic value) async {
    // Validate category
    if (!_preferences.containsKey(category)) {
      if (!_defaultPreferences.containsKey(category)) {
        throw Exception('Invalid preference category: $category');
      }
      _preferences[category] = {};
    }
    
    // Update the preference
    _preferences[category]![key] = value;
    
    // Save preferences
    await _savePreferences();
    
    // Notify listeners
    _preferencesStreamController.add(_preferences);
    
    _log.info('Set preference: $category.$key = $value');
  }
  
  /// Save all preferences to storage
  Future<void> _savePreferences() async {
    if (_currentUserId == null) {
      _log.warning('Cannot save preferences: No current user ID');
      return;
    }
    
    try {
      // Get current user profile
      final userProfile = await _dataStorageManager.getUserProfileById(_currentUserId!);
      
      if (userProfile == null) {
        _log.warning('Cannot save preferences: User profile not found');
        return;
      }
      
      // Create updated profile with new preferences
      final updatedProfile = userProfile.copyWith(
        preferences: _preferences,
      );
      
      // Save updated profile
      await _dataStorageManager.saveUserProfile(
        updatedProfile.id,
        updatedProfile.name,
        updatedProfile.isPublic,
        updatedProfile.allowDataUpload,
      );
      
      // Also persist current preference state to shared preferences for fast access
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('preferences_json', jsonEncode(_preferences));
      
      _log.info('Saved preferences for user: $_currentUserId');
    } catch (e) {
      _log.severe('Error saving preferences: $e');
    }
  }
  
  /// Reset a category to default values
  Future<void> resetCategory(String category) async {
    if (!_defaultPreferences.containsKey(category)) {
      throw Exception('Invalid preference category: $category');
    }
    
    // Reset the category
    _preferences[category] = Map.from(_defaultPreferences[category]!);
    
    // Save preferences
    await _savePreferences();
    
    // Notify listeners
    _preferencesStreamController.add(_preferences);
    
    _log.info('Reset category to defaults: $category');
  }
  
  /// Reset all preferences to defaults
  Future<void> resetAllPreferences() async {
    _resetToDefaults();
    
    // Save preferences
    await _savePreferences();
    
    // Notify listeners
    _preferencesStreamController.add(_preferences);
    
    _log.info('Reset all preferences to defaults');
  }
  
  /// Check if a preference exists
  bool hasPreference(String category, String key) {
    return _preferences.containsKey(category) && _preferences[category]!.containsKey(key);
  }
  
  /// Stream of preference changes
  Stream<Map<String, Map<String, dynamic>>> get preferencesStream => _preferencesStreamController.stream;
  
  /// Dispose of resources
  void dispose() {
    _preferencesStreamController.close();
  }
} 

################################################################################
FILE: lib/services/user/privacy_service.dart
################################################################################

import 'dart:async';
import 'package:logging/logging.dart';
import 'package:uuid/uuid.dart';
import 'package:going50/core_models/data_privacy_settings.dart';
import 'package:going50/data_lib/data_storage_manager.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// PrivacyService manages user privacy settings and data access control
///
/// This service is responsible for:
/// - Managing privacy settings for different data types
/// - Checking permissions for data operations
/// - Enforcing data access controls
/// - Broadcasting privacy setting changes
class PrivacyService {
  // Dependencies
  final DataStorageManager _dataStorageManager;
  
  // Logging
  final _log = Logger('PrivacyService');
  
  // State
  final Map<String, DataPrivacySettings> _privacySettings = {};
  String? _currentUserId;
  final _privacyStreamController = StreamController<Map<String, DataPrivacySettings>>.broadcast();
  
  // Constants for data types
  static const String dataTypeTrips = 'trips';
  static const String dataTypeLocation = 'location';
  static const String dataTypeDrivingEvents = 'driving_events';
  static const String dataTypePerformanceMetrics = 'performance_metrics';
  
  // Constants for operations
  static const String operationLocalStorage = 'local_storage';
  static const String operationCloudSync = 'cloud_sync';
  static const String operationSharing = 'sharing';
  static const String operationAnalytics = 'analytics';
  
  // UUID generator
  final _uuid = const Uuid();
  
  /// Constructor
  PrivacyService(this._dataStorageManager);
  
  /// Initialize the service
  Future<void> initialize() async {
    _log.info('Initializing PrivacyService');
    await _loadCurrentUserId();
    await _loadPrivacySettings();
  }
  
  /// Get the map of privacy settings
  Map<String, DataPrivacySettings> get privacySettings => 
      Map.unmodifiable(_privacySettings);
  
  /// Stream of privacy setting updates
  Stream<Map<String, DataPrivacySettings>> get privacySettingsStream => 
      _privacyStreamController.stream;
  
  /// Load the current user ID
  Future<void> _loadCurrentUserId() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      _currentUserId = prefs.getString('user_id');
      _log.info('Current user ID: $_currentUserId');
    } catch (e) {
      _log.severe('Error loading current user ID: $e');
      rethrow;
    }
  }
  
  /// Load privacy settings for the current user
  Future<void> _loadPrivacySettings() async {
    if (_currentUserId == null) {
      _log.warning('Cannot load privacy settings: No user ID');
      return;
    }
    
    try {
      final settings = await _dataStorageManager.getDataPrivacySettings();
      _privacySettings.clear();
      
      for (final setting in settings) {
        _privacySettings[setting.dataType] = setting;
      }
      
      _log.info('Loaded ${settings.length} privacy settings');
      
      // If we don't have all required data types, create default settings
      await _ensureDefaultSettings();
      
      // Notify listeners
      _notifyListeners();
    } catch (e) {
      _log.severe('Error loading privacy settings: $e');
    }
  }
  
  /// Ensure default settings exist for all data types
  Future<void> _ensureDefaultSettings() async {
    final requiredDataTypes = [
      dataTypeTrips,
      dataTypeLocation,
      dataTypeDrivingEvents,
      dataTypePerformanceMetrics,
    ];
    
    for (final dataType in requiredDataTypes) {
      if (!_privacySettings.containsKey(dataType)) {
        await _createDefaultSetting(dataType);
      }
    }
  }
  
  /// Create a default setting for a data type
  Future<void> _createDefaultSetting(String dataType) async {
    if (_currentUserId == null) return;
    
    final setting = DataPrivacySettings(
      id: _uuid.v4(),
      userId: _currentUserId!,
      dataType: dataType,
      // Default settings - allow local storage but not sync or sharing
      allowLocalStorage: true,
      allowCloudSync: false,
      allowSharing: false,
      allowAnonymizedAnalytics: true,
    );
    
    _log.info('Creating default privacy setting for $dataType');
    
    await _dataStorageManager.saveDataPrivacySettings(setting);
    _privacySettings[dataType] = setting;
  }
  
  /// Get privacy setting for a specific data type
  Future<DataPrivacySettings?> getSettingForDataType(String dataType) async {
    // If in cache, return from cache
    if (_privacySettings.containsKey(dataType)) {
      return _privacySettings[dataType];
    }
    
    // Otherwise try to load from storage
    try {
      final setting = await _dataStorageManager.getDataPrivacySettingForType(dataType);
      if (setting != null) {
        _privacySettings[dataType] = setting;
      }
      return setting;
    } catch (e) {
      _log.warning('Error getting privacy setting for $dataType: $e');
      return null;
    }
  }
  
  /// Update privacy setting for a data type
  Future<bool> updatePrivacySetting({
    required String dataType,
    bool? allowLocalStorage,
    bool? allowCloudSync,
    bool? allowSharing,
    bool? allowAnonymizedAnalytics,
  }) async {
    if (_currentUserId == null) {
      _log.warning('Cannot update privacy setting: No user ID');
      return false;
    }
    
    try {
      // Get existing setting or create new one
      final existingSetting = await getSettingForDataType(dataType);
      
      final updatedSetting = existingSetting != null 
          ? existingSetting.copyWith(
              allowLocalStorage: allowLocalStorage,
              allowCloudSync: allowCloudSync,
              allowSharing: allowSharing,
              allowAnonymizedAnalytics: allowAnonymizedAnalytics,
            )
          : DataPrivacySettings(
              id: _uuid.v4(),
              userId: _currentUserId!,
              dataType: dataType,
              allowLocalStorage: allowLocalStorage ?? true,
              allowCloudSync: allowCloudSync ?? false,
              allowSharing: allowSharing ?? false,
              allowAnonymizedAnalytics: allowAnonymizedAnalytics ?? true,
            );
      
      // Save to storage
      await _dataStorageManager.saveDataPrivacySettings(updatedSetting);
      
      // Update cache
      _privacySettings[dataType] = updatedSetting;
      
      // Notify listeners
      _notifyListeners();
      
      _log.info('Updated privacy setting for $dataType');
      return true;
    } catch (e) {
      _log.severe('Error updating privacy setting for $dataType: $e');
      return false;
    }
  }
  
  /// Check if a specific operation is allowed for a data type
  Future<bool> isOperationAllowed(String dataType, String operation) async {
    _log.info('Checking if $operation is allowed for $dataType');
    
    try {
      // Get settings for this data type
      final settings = privacySettings[dataType];
      
      // If no settings exist, assume not allowed
      if (settings == null) {
        _log.info('No privacy settings found for $dataType, operation not allowed');
        return false;
      }
      
      // Check if operation is allowed based on settings
      switch (operation) {
        case 'local_storage':
          return settings.allowLocalStorage;
        case 'cloud_sync':
          return settings.allowCloudSync;
        case 'sharing':
          return settings.allowSharing;
        case 'analytics':
          return settings.allowAnonymizedAnalytics;
        default:
          _log.warning('Unknown operation: $operation');
          return false;
      }
    } catch (e) {
      _log.severe('Error checking operation permission: $e');
      return false;
    }
  }
  
  /// Reset privacy settings to defaults
  Future<bool> resetToDefaults() async {
    if (_currentUserId == null) {
      _log.warning('Cannot reset privacy settings: No user ID');
      return false;
    }
    
    try {
      _privacySettings.clear();
      await _ensureDefaultSettings();
      _notifyListeners();
      _log.info('Reset privacy settings to defaults');
      return true;
    } catch (e) {
      _log.severe('Error resetting privacy settings: $e');
      return false;
    }
  }
  
  /// Check if all required privacy settings exist
  Future<bool> checkPrivacySettingsComplete() async {
    if (_currentUserId == null) return false;
    
    final requiredDataTypes = [
      dataTypeTrips,
      dataTypeLocation,
      dataTypeDrivingEvents,
      dataTypePerformanceMetrics,
    ];
    
    // Check if all required data types have settings
    for (final dataType in requiredDataTypes) {
      final setting = await getSettingForDataType(dataType);
      if (setting == null) {
        return false;
      }
    }
    
    return true;
  }
  
  /// Handle user changes - reload settings when user changes
  Future<void> handleUserChanged(String? userId) async {
    if (userId != _currentUserId) {
      _currentUserId = userId;
      await _loadPrivacySettings();
    }
  }
  
  /// Notify listeners of changes
  void _notifyListeners() {
    if (!_privacyStreamController.isClosed) {
      _privacyStreamController.add(Map.unmodifiable(_privacySettings));
    }
  }
  
  /// Dispose resources
  void dispose() {
    _privacyStreamController.close();
  }
} 

################################################################################
FILE: lib/services/user/authentication_service.dart
################################################################################

import 'dart:async';
import 'package:firebase_auth/firebase_auth.dart' as firebase_auth;
import 'package:logging/logging.dart';
import 'package:going50/core_models/user_profile.dart';
import 'package:going50/data_lib/data_storage_manager.dart';
import 'package:going50/services/user/user_service.dart';

/// AuthenticationService handles user authentication operations
///
/// This service provides functionality for:
/// - User registration with email/password
/// - Login with email/password 
/// - Social sign-in (Google, Apple)
/// - Password reset
/// - Authentication state changes
/// - Linking accounts
/// 
/// It serves as a bridge between Firebase Authentication and the app's UserService.
class AuthenticationService {
  // Dependencies
  final firebase_auth.FirebaseAuth _firebaseAuth;
  final DataStorageManager _dataStorageManager;
  final UserService _userService;
  
  // Logging
  final _log = Logger('AuthenticationService');
  
  // Stream controllers
  final _authStateController = StreamController<AuthState>.broadcast();
  
  // Private state
  UserProfile? _authenticatedUserProfile;
  AuthState _currentAuthState = AuthState.notInitialized;
  
  /// Constructor
  AuthenticationService(this._firebaseAuth, this._dataStorageManager, this._userService) {
    _log.info('AuthenticationService created');
    _initialize();
  }
  
  /// Initialize the service and set up listeners
  Future<void> _initialize() async {
    _log.info('Initializing AuthenticationService');
    
    // Set initial state
    _currentAuthState = AuthState.initializing;
    _emitAuthState();
    
    // Start listening to Firebase auth state changes
    _firebaseAuth.authStateChanges().listen(_handleAuthStateChange);
    
    _log.info('AuthenticationService initialized');
  }
  
  /// Handle authentication state changes from Firebase
  Future<void> _handleAuthStateChange(firebase_auth.User? firebaseUser) async {
    _log.info('Auth state changed: ${firebaseUser != null ? 'signed in' : 'signed out'}');
    
    if (firebaseUser == null) {
      // User is signed out
      _authenticatedUserProfile = null;
      _currentAuthState = AuthState.signedOut;
    } else {
      // User is signed in - check if we have a profile for this user
      final userProfile = await _getUserProfileForFirebaseUser(firebaseUser);
      
      if (userProfile == null) {
        // No profile found - this is a new user
        _currentAuthState = AuthState.newUser;
      } else {
        // Profile found - set as current user
        _authenticatedUserProfile = userProfile;
        _currentAuthState = AuthState.signedIn;
        
        // Update UserService with the authenticated user
        await _userService.setCurrentUser(userProfile);
      }
    }
    
    // Emit the new state
    _emitAuthState();
  }
  
  /// Get or create user profile for a Firebase user
  Future<UserProfile?> _getUserProfileForFirebaseUser(firebase_auth.User firebaseUser) async {
    try {
      // Try to get existing profile by Firebase UID
      var userProfile = await _dataStorageManager.getUserProfileByFirebaseId(firebaseUser.uid);
      
      if (userProfile != null) {
        _log.info('Found existing profile for Firebase user: ${firebaseUser.uid}');
        return userProfile;
      }
      
      // No profile found - get current local user
      final currentUser = _userService.currentUser;
      
      if (currentUser != null) {
        // Link existing local user to this Firebase account
        _log.info('Linking existing local user ${currentUser.id} to Firebase user ${firebaseUser.uid}');
        
        // Update the profile with Firebase ID
        userProfile = await _dataStorageManager.updateUserProfileFirebaseId(
          currentUser.id, 
          firebaseUser.uid
        );
        
        return userProfile;
      }
      
      // No local user either - return null and let caller handle new user creation
      return null;
    } catch (e) {
      _log.severe('Error getting user profile for Firebase user: $e');
      return null;
    }
  }
  
  /// Emit the current authentication state to subscribers
  void _emitAuthState() {
    _authStateController.add(_currentAuthState);
  }
  
  /// Get the current authentication state
  AuthState get currentAuthState => _currentAuthState;
  
  /// Stream of authentication state changes
  Stream<AuthState> get authStateStream => _authStateController.stream;
  
  /// Get the current authenticated user profile
  UserProfile? get currentUser => _authenticatedUserProfile;
  
  /// Get the current Firebase user
  firebase_auth.User? get firebaseUser => _firebaseAuth.currentUser;
  
  /// Check if user is authenticated
  bool get isAuthenticated => _firebaseAuth.currentUser != null;
  
  /// Register with email and password
  Future<AuthResult> registerWithEmailPassword({
    required String email,
    required String password,
    required String displayName,
  }) async {
    try {
      _log.info('Registering new user with email: $email');
      
      // Create the user in Firebase
      final credential = await _firebaseAuth.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );
      
      // Update display name
      await credential.user?.updateDisplayName(displayName);
      
      // Get or create user profile
      if (credential.user != null) {
        final userProfile = await _getUserProfileForFirebaseUser(credential.user!);
        
        if (userProfile == null) {
          // Create new profile
          final localUserId = _userService.currentUser?.id;
          
          if (localUserId != null) {
            // Update existing local profile
            await _dataStorageManager.updateUserProfile(
              localUserId,
              displayName,
              email: email,
              firebaseId: credential.user!.uid,
            );
          } else {
            // Create completely new profile - this shouldn't happen as we should always have a local user
            _log.warning('No local user found during registration - creating new profile');
            await _dataStorageManager.saveUserProfileWithFirebase(
              credential.user!.uid,
              displayName,
              true, // isPublic 
              true, // allowDataUpload
              email: email,
              firebaseId: credential.user!.uid,
            );
          }
        }
      }
      
      return AuthResult(
        success: true,
        user: credential.user,
      );
    } on firebase_auth.FirebaseAuthException catch (e) {
      _log.severe('Firebase Auth error during registration: ${e.code}: ${e.message}');
      return AuthResult(
        success: false,
        errorCode: e.code,
        errorMessage: _getReadableErrorMessage(e.code),
      );
    } catch (e) {
      _log.severe('Error during registration: $e');
      return AuthResult(
        success: false,
        errorCode: 'unknown_error',
        errorMessage: 'An unexpected error occurred. Please try again.',
      );
    }
  }
  
  /// Sign in with email and password
  Future<AuthResult> signInWithEmailPassword({
    required String email,
    required String password,
  }) async {
    try {
      _log.info('Signing in user with email: $email');
      
      final credential = await _firebaseAuth.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      
      return AuthResult(
        success: true,
        user: credential.user,
      );
    } on firebase_auth.FirebaseAuthException catch (e) {
      _log.severe('Firebase Auth error during sign in: ${e.code}: ${e.message}');
      return AuthResult(
        success: false,
        errorCode: e.code,
        errorMessage: _getReadableErrorMessage(e.code),
      );
    } catch (e) {
      _log.severe('Error during sign in: $e');
      return AuthResult(
        success: false,
        errorCode: 'unknown_error',
        errorMessage: 'An unexpected error occurred. Please try again.',
      );
    }
  }
  
  /// Sign out the current user
  Future<void> signOut() async {
    try {
      _log.info('Signing out user');
      await _firebaseAuth.signOut();
      
      // The auth state listener will handle updating the state
    } catch (e) {
      _log.severe('Error during sign out: $e');
      rethrow;
    }
  }
  
  /// Send password reset email
  Future<AuthResult> sendPasswordResetEmail({required String email}) async {
    try {
      _log.info('Sending password reset email to: $email');
      await _firebaseAuth.sendPasswordResetEmail(email: email);
      
      return AuthResult(
        success: true,
      );
    } on firebase_auth.FirebaseAuthException catch (e) {
      _log.severe('Firebase Auth error sending reset email: ${e.code}: ${e.message}');
      return AuthResult(
        success: false,
        errorCode: e.code,
        errorMessage: _getReadableErrorMessage(e.code),
      );
    } catch (e) {
      _log.severe('Error sending reset email: $e');
      return AuthResult(
        success: false,
        errorCode: 'unknown_error',
        errorMessage: 'An unexpected error occurred. Please try again.',
      );
    }
  }
  
  /// Convert Firebase error codes to user-friendly messages
  String _getReadableErrorMessage(String errorCode) {
    switch (errorCode) {
      case 'email-already-in-use':
        return 'An account already exists with this email address.';
      case 'invalid-email':
        return 'Please enter a valid email address.';
      case 'user-disabled':
        return 'This account has been disabled. Please contact support.';
      case 'user-not-found':
        return 'No account found with this email address.';
      case 'wrong-password':
        return 'Incorrect password. Please try again.';
      case 'weak-password':
        return 'Password is too weak. Please use a stronger password.';
      case 'operation-not-allowed':
        return 'This operation is not allowed. Please contact support.';
      case 'too-many-requests':
        return 'Too many attempts. Please try again later.';
      default:
        return 'An error occurred. Please try again.';
    }
  }
  
  /// Dispose of resources
  void dispose() {
    _authStateController.close();
  }
}

/// Authentication state
enum AuthState {
  notInitialized,
  initializing,
  signedOut,
  signedIn,
  newUser,
}

/// Authentication result
class AuthResult {
  final bool success;
  final firebase_auth.User? user;
  final String? errorCode;
  final String? errorMessage;
  
  AuthResult({
    required this.success,
    this.user,
    this.errorCode,
    this.errorMessage,
  });
} 

################################################################################
FILE: lib/services/user/user_service.dart
################################################################################

import 'dart:async';
import 'package:logging/logging.dart';
import 'package:uuid/uuid.dart';
import 'package:going50/core_models/user_profile.dart';
import 'package:going50/data_lib/data_storage_manager.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// UserService manages user profiles and authentication
///
/// This service is responsible for:
/// - Creating and managing user profiles
/// - Supporting anonymous users
/// - Handling optional account registration
/// - Managing profile data
class UserService {
  // Dependencies
  final DataStorageManager _dataStorageManager;
  
  // Logging
  final _log = Logger('UserService');
  
  // State
  UserProfile? _currentUser;
  bool _isAnonymous = true;
  final _userProfileStreamController = StreamController<UserProfile?>.broadcast();
  
  // Constants
  static const _userIdKey = 'user_id';
  static const _isAnonymousKey = 'is_anonymous';
  static const _firebaseUserIdKey = 'firebase_user_id';
  
  /// Constructor
  UserService(this._dataStorageManager);
  
  /// Initialize the service
  Future<void> initialize() async {
    _log.info('Initializing UserService');
    await _loadCurrentUser();
  }
  
  /// Get the current user profile
  UserProfile? get currentUser => _currentUser;
  
  /// Is the current user anonymous?
  bool get isAnonymous => _isAnonymous;
  
  /// Stream of user profile updates
  Stream<UserProfile?> get userProfileStream => _userProfileStreamController.stream;
  
  /// Load the current user from storage
  Future<UserProfile?> _loadCurrentUser() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final userId = prefs.getString(_userIdKey);
      final firebaseUserId = prefs.getString(_firebaseUserIdKey);
      
      // If we have a Firebase user ID, prioritize loading by that
      if (firebaseUserId != null) {
        _log.info('Found Firebase user ID, loading by Firebase ID: $firebaseUserId');
        final firebaseUser = await _dataStorageManager.getUserProfileByFirebaseId(firebaseUserId);
        
        if (firebaseUser != null) {
          _currentUser = firebaseUser;
          _isAnonymous = false;
          _userProfileStreamController.add(firebaseUser);
          _log.info('Loaded Firebase user: ${firebaseUser.id}');
          return firebaseUser;
        } else {
          _log.warning('Firebase user not found in database: $firebaseUserId');
        }
      }
      
      // Check if we have a local user ID
      if (userId == null) {
        _log.info('No user ID found, creating anonymous user');
        return await createAnonymousUser();
      }
      
      // Check if user is anonymous
      _isAnonymous = prefs.getBool(_isAnonymousKey) ?? true;
      
      // Load the user from the database
      final user = await _dataStorageManager.getUserProfileById(userId);
      
      if (user != null) {
        _currentUser = user;
        _userProfileStreamController.add(user);
        _log.info('Loaded user: ${user.id} (${_isAnonymous ? 'anonymous' : 'registered'})');
        return user;
      } else {
        // User not found in database, create new anonymous user
        _log.warning('User not found in database, creating new anonymous user');
        return await createAnonymousUser();
      }
    } catch (e) {
      _log.severe('Error loading current user: $e');
      // In case of error, create an anonymous user
      return await createAnonymousUser();
    }
  }
  
  /// Create an anonymous user
  Future<UserProfile> createAnonymousUser() async {
    try {
      final userId = const Uuid().v4();
      final now = DateTime.now();
      
      // Create user profile object
      final user = UserProfile(
        id: userId,
        name: 'Anonymous User',
        createdAt: now,
        lastUpdatedAt: now,
        isPublic: false,
        allowDataUpload: false,
      );
      
      _log.info('Creating anonymous user with ID: $userId');
      
      // Clear any existing user data in shared preferences first
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_userIdKey);
      await prefs.remove(_isAnonymousKey);
      
      // Try to save to database with retry logic
      int attempts = 0;
      const maxAttempts = 3;
      bool saveSuccess = false;
      
      while (!saveSuccess && attempts < maxAttempts) {
        attempts++;
        try {
          // Save to database
          await _dataStorageManager.saveUserProfile(
            userId, 
            user.name, 
            user.isPublic, 
            user.allowDataUpload
          );
          
          // Verify user was saved
          final savedUser = await _dataStorageManager.getUserProfileById(userId);
          if (savedUser != null) {
            saveSuccess = true;
            _log.info('Successfully saved anonymous user on attempt $attempts');
          } else {
            _log.warning('Failed to verify user was saved on attempt $attempts');
            await Future.delayed(Duration(milliseconds: 100 * attempts));
          }
        } catch (e) {
          _log.warning('Error saving anonymous user on attempt $attempts: $e');
          await Future.delayed(Duration(milliseconds: 100 * attempts));
        }
      }
      
      if (!saveSuccess) {
        _log.severe('Failed to save anonymous user after $maxAttempts attempts');
        // We'll still continue to set shared preferences and update state
        // so the app can at least function with an in-memory user
      }
      
      // Update shared preferences
      await prefs.setString(_userIdKey, userId);
      await prefs.setBool(_isAnonymousKey, true);
      
      // Update state
      _currentUser = user;
      _isAnonymous = true;
      _userProfileStreamController.add(user);
      
      _log.info('Created anonymous user: $userId');
      return user;
    } catch (e) {
      _log.severe('Error creating anonymous user: $e');
      // Create a fallback in-memory-only user as a last resort
      final userId = const Uuid().v4();
      final user = UserProfile(
        id: userId,
        name: 'Emergency User',
        createdAt: DateTime.now(),
        lastUpdatedAt: DateTime.now(),
        isPublic: false,
        allowDataUpload: false,
      );
      _currentUser = user;
      _isAnonymous = true;
      _userProfileStreamController.add(user);
      return user;
    }
  }
  
  /// Register a new user account
  Future<UserProfile> registerUser({
    required String name,
    required bool isPublic,
    required bool allowDataUpload,
    String? email,
    String? firebaseId,
  }) async {
    // Check if we already have a user
    if (_currentUser == null) {
      await _loadCurrentUser();
    }
    
    // Start with existing ID or generate a new one if needed
    final userId = _currentUser?.id ?? const Uuid().v4();
    final now = DateTime.now();
    
    final user = UserProfile(
      id: userId,
      name: name,
      createdAt: _currentUser?.createdAt ?? now,
      lastUpdatedAt: now,
      isPublic: isPublic,
      allowDataUpload: allowDataUpload,
      email: email,
      firebaseId: firebaseId,
    );
    
    // Save to database
    if (email != null || firebaseId != null) {
      // If we have Firebase details, use the Firebase-specific method
      await _dataStorageManager.saveUserProfileWithFirebase(
        userId, 
        name, 
        isPublic, 
        allowDataUpload,
        email: email,
        firebaseId: firebaseId,
      );
    } else {
      // Otherwise use the standard method
      await _dataStorageManager.saveUserProfile(
        userId, 
        name, 
        isPublic, 
        allowDataUpload
      );
    }
    
    // Update shared preferences
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_userIdKey, userId);
    await prefs.setBool(_isAnonymousKey, false);
    
    // If we have a Firebase ID, also store it
    if (firebaseId != null) {
      await prefs.setString(_firebaseUserIdKey, firebaseId);
    }
    
    // Update state
    _currentUser = user;
    _isAnonymous = false;
    _userProfileStreamController.add(user);
    
    _log.info('Registered user: $userId${firebaseId != null ? ' with Firebase ID: $firebaseId' : ''}');
    return user;
  }
  
  /// Update user profile
  Future<UserProfile> updateProfile({
    String? name,
    bool? isPublic,
    bool? allowDataUpload,
    String? email,
    String? firebaseId,
  }) async {
    // Ensure we have a current user
    if (_currentUser == null) {
      throw Exception('No current user to update');
    }
    
    final user = UserProfile(
      id: _currentUser!.id,
      name: name ?? _currentUser!.name,
      createdAt: _currentUser!.createdAt,
      lastUpdatedAt: DateTime.now(),
      isPublic: isPublic ?? _currentUser!.isPublic,
      allowDataUpload: allowDataUpload ?? _currentUser!.allowDataUpload,
      preferences: _currentUser!.preferences,
      email: email ?? _currentUser!.email,
      firebaseId: firebaseId ?? _currentUser!.firebaseId,
    );
    
    // Use updateUserProfile instead of saveUserProfile for existing users
    await _dataStorageManager.updateUserProfile(
      user.id, 
      user.name,
      isPublic: user.isPublic,
      allowDataUpload: user.allowDataUpload,
      email: user.email,
      firebaseId: user.firebaseId,
    );
    
    // Update shared preferences
    final prefs = await SharedPreferences.getInstance();
    
    // If we have a Firebase ID, also store it
    if (firebaseId != null) {
      await prefs.setString(_firebaseUserIdKey, firebaseId);
    }
    
    // Update state
    _currentUser = user;
    _userProfileStreamController.add(user);
    
    _log.info('Updated user profile: ${user.id}');
    return user;
  }
  
  /// Set current user
  /// 
  /// This is used by the AuthenticationService to set the current user
  /// when a user signs in with Firebase.
  Future<void> setCurrentUser(UserProfile userProfile) async {
    try {
      _log.info('Setting current user: ${userProfile.id}');
      
      // Update state
      _currentUser = userProfile;
      _isAnonymous = false;
      
      // Update shared preferences to reflect current user
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_userIdKey, userProfile.id);
      await prefs.setBool(_isAnonymousKey, false);
      
      // If the user has a Firebase ID, store it
      if (userProfile.firebaseId != null) {
        await prefs.setString(_firebaseUserIdKey, userProfile.firebaseId!);
      }
      
      // Notify listeners
      _userProfileStreamController.add(userProfile);
      
      _log.info('Current user set: ${userProfile.id}');
    } catch (e) {
      _log.severe('Error setting current user: $e');
      rethrow;
    }
  }
  
  /// Sign out the current user
  ///
  /// This doesn't delete the user or data, just resets to anonymous state
  Future<void> signOut() async {
    try {
      _log.info('Signing out user');
      
      // Reset to anonymous
      _isAnonymous = true;
      
      // Remove Firebase user ID if present
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_firebaseUserIdKey);
      await prefs.setBool(_isAnonymousKey, true);
      
      // Keep the local user ID for data continuity
      
      // Notify listeners
      _userProfileStreamController.add(_currentUser);
      
      _log.info('User signed out, reverted to anonymous');
    } catch (e) {
      _log.severe('Error signing out user: $e');
      rethrow;
    }
  }
  
  /// Dispose of resources
  void dispose() {
    _userProfileStreamController.close();
  }
  
  /// Get user metrics for display in profile
  /// 
  /// This method fetches metrics like trip counts, streaks, and other user stats
  /// from the DataStorageManager
  Future<Map<String, dynamic>?> getUserMetrics(String userId) async {
    try {
      _log.info('Getting user metrics for user: $userId');
      
      // Get metrics from data storage manager
      final metrics = await _dataStorageManager.getUserMetrics(userId);
      
      // If metrics don't have a "bestDrivingStreak" field, add a default value
      if (metrics != null && !metrics.containsKey('bestDrivingStreak')) {
        // Default to 0 streak if not found
        metrics['bestDrivingStreak'] = 0;
      }
      
      return metrics;
    } catch (e) {
      _log.severe('Error getting user metrics: $e');
      return {
        'tripCount': 0,
        'fuelSaved': 0.0,
        'co2Reduced': 0.0,
        'bestDrivingStreak': 0,
      };
    }
  }
} 

################################################################################
FILE: lib/services/social/sharing_service.dart
################################################################################

import 'dart:async';
import 'package:logging/logging.dart';
import 'package:uuid/uuid.dart';
import 'package:going50/core_models/social_models.dart';
import 'package:going50/data_lib/data_storage_manager.dart';
import 'package:going50/services/user/privacy_service.dart';

/// SharingService manages content sharing functionality
///
/// This service is responsible for:
/// - Sharing content within the app's social features
/// - Generating public or restricted sharing links
/// - Managing privacy for shared content
/// - Supporting external sharing
class SharingService {
  // Dependencies
  final DataStorageManager _dataStorageManager;
  final PrivacyService _privacyService;
  
  // Logging
  final _log = Logger('SharingService');
  
  // Stream controllers
  final _sharingEventStreamController = StreamController<Map<String, dynamic>>.broadcast();
  
  /// Constructor
  SharingService(this._dataStorageManager, this._privacyService) {
    _log.info('SharingService created');
  }
  
  /// Stream of sharing events
  Stream<Map<String, dynamic>> get sharingEventStream => _sharingEventStreamController.stream;
  
  /// Share content within the app
  Future<SharedContent?> shareContent({
    required String userId,
    required String contentType,
    required String contentId,
    required String shareType,
    String? message,
  }) async {
    _log.info('Sharing $contentType content ($contentId) as $shareType by user $userId');
    
    try {
      // First check if sharing is allowed for this content type
      final sharingAllowed = await _privacyService.isOperationAllowed(
        contentType, 'sharing'
      );
      
      if (!sharingAllowed) {
        _log.warning('Sharing not allowed for $contentType by user $userId');
        return null;
      }
      
      // Generate a unique ID for the share
      final shareId = const Uuid().v4();
      final now = DateTime.now();
      
      // Create shared content record
      final sharedContent = SharedContent(
        id: shareId,
        userId: userId,
        contentType: contentType,
        contentId: contentId,
        shareType: shareType,
        externalPlatform: null,
        shareUrl: await _generateShareUrl(shareType, contentType, contentId),
        sharedAt: now,
        isActive: true,
      );
      
      // Save to storage - would use _dataStorageManager in real implementation
      await _saveSharedContent(sharedContent);
      
      // If sharing with friends, create social interactions
      if (shareType == 'friends') {
        await _notifyFriends(userId, shareId, contentType, contentId, message);
      }
      
      // Notify listeners
      _sharingEventStreamController.add({
        'type': 'content_shared',
        'contentType': contentType,
        'contentId': contentId,
        'shareType': shareType,
      });
      
      _log.info('Content shared successfully with ID: $shareId');
      return sharedContent;
    } catch (e) {
      _log.severe('Error sharing content: $e');
      return null;
    }
  }
  
  /// Share content to external platform
  Future<SharedContent?> shareToExternal({
    required String userId,
    required String contentType,
    required String contentId,
    required String platform,
    String? message,
  }) async {
    _log.info('Sharing $contentType content ($contentId) to $platform by user $userId');
    
    try {
      // First check if sharing is allowed for this content type
      final sharingAllowed = await _privacyService.isOperationAllowed(
        contentType, 'sharing'
      );
      
      if (!sharingAllowed) {
        _log.warning('Sharing not allowed for $contentType by user $userId');
        return null;
      }
      
      // Generate a unique ID for the share
      final shareId = const Uuid().v4();
      final now = DateTime.now();
      
      // Create shared content record
      final sharedContent = SharedContent(
        id: shareId,
        userId: userId,
        contentType: contentType,
        contentId: contentId,
        shareType: 'external',
        externalPlatform: platform,
        shareUrl: await _generateShareUrl('public', contentType, contentId),
        sharedAt: now,
        isActive: true,
      );
      
      // Save to storage
      await _saveSharedContent(sharedContent);
      
      // Notify listeners
      _sharingEventStreamController.add({
        'type': 'content_shared_external',
        'contentType': contentType,
        'contentId': contentId,
        'platform': platform,
      });
      
      _log.info('Content shared to external platform successfully with ID: $shareId');
      return sharedContent;
    } catch (e) {
      _log.severe('Error sharing content to external platform: $e');
      return null;
    }
  }
  
  /// Get a shared content by ID
  Future<SharedContent?> getSharedContent(String shareId) async {
    _log.info('Getting shared content with ID: $shareId');
    
    try {
      // In a real implementation, this would fetch from database
      // For now, we'll simulate (would be implemented in DataStorageManager)
      return null;
    } catch (e) {
      _log.severe('Error getting shared content: $e');
      return null;
    }
  }
  
  /// Deactivate a shared content
  Future<bool> deactivateSharedContent(String shareId) async {
    _log.info('Deactivating shared content with ID: $shareId');
    
    try {
      // In a real implementation, this would update the database record
      // For now, we'll simulate success (would be implemented in DataStorageManager)
      
      // Notify listeners
      _sharingEventStreamController.add({
        'type': 'content_share_deactivated',
        'shareId': shareId,
      });
      
      return true;
    } catch (e) {
      _log.severe('Error deactivating shared content: $e');
      return false;
    }
  }
  
  /// Get all shared content for a user
  Future<List<SharedContent>> getUserSharedContent(String userId) async {
    _log.info('Getting shared content for user $userId');
    
    try {
      // In a real implementation, this would fetch from database
      // For now, we'll return an empty list (would be implemented in DataStorageManager)
      return [];
    } catch (e) {
      _log.severe('Error getting user shared content: $e');
      return [];
    }
  }
  
  /// Save shared content to storage
  Future<void> _saveSharedContent(SharedContent content) async {
    _log.info('Saving shared content with ID: ${content.id}');
    
    try {
      // In a real implementation, this would save to database
      // For now, it's a placeholder (would be implemented in DataStorageManager)
      await Future.delayed(const Duration(milliseconds: 100));
    } catch (e) {
      _log.severe('Error saving shared content: $e');
      rethrow;
    }
  }
  
  /// Generate a share URL based on type
  Future<String?> _generateShareUrl(String shareType, String contentType, String contentId) async {
    // In a real implementation, this would generate a proper URL
    // For now, return a placeholder
    if (shareType == 'public') {
      return 'https://going50.app/share/$contentType/$contentId';
    }
    return null;
  }
  
  /// Notify friends about shared content
  Future<void> _notifyFriends(
    String userId,
    String shareId,
    String contentType,
    String contentId,
    String? message,
  ) async {
    _log.info('Notifying friends about shared content');
    
    try {
      // In a real implementation, this would create notifications
      // and social interaction records for all friends
      // For now, it's a placeholder (would be implemented in DataStorageManager)
    } catch (e) {
      _log.severe('Error notifying friends: $e');
    }
  }
  
  /// Dispose resources
  void dispose() {
    _sharingEventStreamController.close();
  }
} 

################################################################################
FILE: lib/services/social/social_service.dart
################################################################################

import 'dart:async';
import 'package:logging/logging.dart';
import 'package:uuid/uuid.dart';
import 'package:going50/core_models/user_profile.dart';
import 'package:going50/data_lib/data_storage_manager.dart';
import 'package:going50/services/user/user_service.dart';
import 'package:going50/services/user/privacy_service.dart';

/// SocialService manages user connections and social features
///
/// This service is responsible for:
/// - Managing connections between users (friends)
/// - Processing friend requests
/// - Handling user discovery
/// - Managing social visibility based on privacy settings
class SocialService {
  // Dependencies
  final DataStorageManager _dataStorageManager;
  final UserService _userService;
  final PrivacyService _privacyService;
  
  // Logging
  final _log = Logger('SocialService');
  
  // State
  final List<UserProfile> _friends = [];
  final List<String> _friendRequests = [];
  final List<String> _sentRequests = [];
  final Map<String, UserProfile> _userCache = {};
  
  // Stream controllers
  final _friendsStreamController = StreamController<List<UserProfile>>.broadcast();
  final _requestsStreamController = StreamController<List<String>>.broadcast();
  final _sentRequestsStreamController = StreamController<List<String>>.broadcast();
  final _socialEventStreamController = StreamController<Map<String, dynamic>>.broadcast();
  
  // Constants
  static const _friendsKey = 'friends';
  static const _friendRequestsKey = 'friend_requests';
  static const _sentRequestsKey = 'sent_requests';

  /// Constructor
  SocialService(this._dataStorageManager, this._userService, this._privacyService) {
    _log.info('SocialService created');
    _initialize();
  }
  
  /// Initialize the service and load data
  Future<void> _initialize() async {
    _log.info('Initializing SocialService');
    await _loadFriends();
    await _loadRequests();
  }
  
  /// Get the list of friends
  List<UserProfile> get friends => List.unmodifiable(_friends);
  
  /// Get the list of friend requests
  List<String> get friendRequests => List.unmodifiable(_friendRequests);
  
  /// Get the list of sent requests
  List<String> get sentRequests => List.unmodifiable(_sentRequests);
  
  /// Stream of friends updates
  Stream<List<UserProfile>> get friendsStream => _friendsStreamController.stream;
  
  /// Stream of friend requests updates
  Stream<List<String>> get requestsStream => _requestsStreamController.stream;
  
  /// Stream of sent requests updates
  Stream<List<String>> get sentRequestsStream => _sentRequestsStreamController.stream;
  
  /// Stream of social events (friend added, request received, etc.)
  Stream<Map<String, dynamic>> get socialEventStream => _socialEventStreamController.stream;
  
  /// Load friends from storage
  Future<void> _loadFriends() async {
    _log.info('Loading friends');
    _friends.clear();
    
    try {
      // Get current user
      final currentUser = _userService.currentUser;
      if (currentUser == null) {
        _log.warning('No current user found');
        return;
      }
      
      // Get friend IDs from storage
      final friendIds = await _dataStorageManager.getFriendIds(currentUser.id);
      if (friendIds.isEmpty) {
        _log.info('No friends found');
        _friendsStreamController.add(_friends);
        return;
      }
      
      // Load each friend's profile
      for (final friendId in friendIds) {
        final friendProfile = await _dataStorageManager.getUserProfileById(friendId);
        if (friendProfile != null) {
          _friends.add(friendProfile);
          _userCache[friendId] = friendProfile;
        } else {
          _log.warning('Friend profile not found for ID: $friendId');
        }
      }
      
      _log.info('Loaded ${_friends.length} friends');
      _friendsStreamController.add(_friends);
    } catch (e) {
      _log.severe('Error loading friends: $e');
    }
  }
  
  /// Load friend requests from storage
  Future<void> _loadRequests() async {
    _log.info('Loading friend requests');
    _friendRequests.clear();
    _sentRequests.clear();
    
    try {
      // Get current user
      final currentUser = _userService.currentUser;
      if (currentUser == null) {
        _log.warning('No current user found');
        return;
      }
      
      // Get received requests
      final receivedRequests = await _dataStorageManager.getReceivedFriendRequests(currentUser.id);
      _friendRequests.addAll(receivedRequests);
      
      // Get sent requests
      final sentRequests = await _dataStorageManager.getSentFriendRequests(currentUser.id);
      _sentRequests.addAll(sentRequests);
      
      _log.info('Loaded ${_friendRequests.length} received requests and ${_sentRequests.length} sent requests');
      _requestsStreamController.add(_friendRequests);
      _sentRequestsStreamController.add(_sentRequests);
    } catch (e) {
      _log.severe('Error loading friend requests: $e');
    }
  }
  
  /// Search for users by name
  Future<List<UserProfile>> searchUsers(String query) async {
    _log.info('Searching for users with query: $query');
    
    if (query.isEmpty) {
      return [];
    }
    
    try {
      // Get current user
      final currentUser = _userService.currentUser;
      if (currentUser == null) {
        _log.warning('No current user found');
        return [];
      }
      
      // Search for users
      final results = await _dataStorageManager.searchUserProfiles(query);
      
      // Filter out current user and respect privacy settings
      return results.where((user) {
        // Skip current user
        if (user.id == currentUser.id) return false;
        
        // Only include public profiles
        return user.isPublic;
      }).toList();
    } catch (e) {
      _log.severe('Error searching users: $e');
      return [];
    }
  }
  
  /// Get user profile by ID (respects privacy settings)
  Future<UserProfile?> getUserProfile(String userId) async {
    _log.info('Getting user profile for ID: $userId');
    
    // Check cache first
    if (_userCache.containsKey(userId)) {
      return _userCache[userId];
    }
    
    try {
      // Get current user
      final currentUser = _userService.currentUser;
      if (currentUser == null) {
        _log.warning('No current user found');
        return null;
      }
      
      // Don't return self
      if (userId == currentUser.id) {
        return currentUser;
      }
      
      // Get user profile
      final userProfile = await _dataStorageManager.getUserProfileById(userId);
      
      // Respect privacy settings - only return if public or friends
      if (userProfile != null) {
        if (userProfile.isPublic || _isFriend(userId)) {
          // Cache for future use
          _userCache[userId] = userProfile;
          return userProfile;
        } else {
          _log.info('User profile is private and not a friend: $userId');
          return null;
        }
      } else {
        _log.warning('User profile not found for ID: $userId');
        return null;
      }
    } catch (e) {
      _log.severe('Error getting user profile: $e');
      return null;
    }
  }
  
  /// Check if a user is a friend
  bool _isFriend(String userId) {
    return _friends.any((friend) => friend.id == userId);
  }
  
  /// Check if a user has a pending friend request
  bool hasPendingRequest(String userId) {
    return _friendRequests.contains(userId);
  }
  
  /// Check if we have sent a request to a user
  bool hasSentRequest(String userId) {
    return _sentRequests.contains(userId);
  }
  
  /// Send a friend request
  Future<bool> sendFriendRequest(String userId) async {
    _log.info('Sending friend request to user: $userId');
    
    try {
      // Get current user
      final currentUser = _userService.currentUser;
      if (currentUser == null) {
        _log.warning('No current user found');
        return false;
      }
      
      // Don't send request to self
      if (userId == currentUser.id) {
        _log.warning('Cannot send friend request to self');
        return false;
      }
      
      // Don't send request if already friends
      if (_isFriend(userId)) {
        _log.warning('Already friends with user: $userId');
        return false;
      }
      
      // Don't send request if already sent
      if (hasSentRequest(userId)) {
        _log.warning('Friend request already sent to user: $userId');
        return false;
      }
      
      // Send the request
      await _dataStorageManager.sendFriendRequest(currentUser.id, userId);
      
      // Update local state
      _sentRequests.add(userId);
      _sentRequestsStreamController.add(_sentRequests);
      
      // Send event
      _socialEventStreamController.add({
        'type': 'request_sent',
        'userId': userId,
      });
      
      _log.info('Friend request sent to user: $userId');
      return true;
    } catch (e) {
      _log.severe('Error sending friend request: $e');
      return false;
    }
  }
  
  /// Accept a friend request
  Future<bool> acceptFriendRequest(String userId) async {
    _log.info('Accepting friend request from user: $userId');
    
    try {
      // Get current user
      final currentUser = _userService.currentUser;
      if (currentUser == null) {
        _log.warning('No current user found');
        return false;
      }
      
      // Check if request exists
      if (!hasPendingRequest(userId)) {
        _log.warning('No pending request from user: $userId');
        return false;
      }
      
      // Accept the request
      await _dataStorageManager.acceptFriendRequest(currentUser.id, userId);
      
      // Get friend profile
      final friendProfile = await _dataStorageManager.getUserProfileById(userId);
      if (friendProfile != null) {
        _friends.add(friendProfile);
        _userCache[userId] = friendProfile;
      }
      
      // Update local state
      _friendRequests.remove(userId);
      _requestsStreamController.add(_friendRequests);
      _friendsStreamController.add(_friends);
      
      // Send event
      _socialEventStreamController.add({
        'type': 'request_accepted',
        'userId': userId,
      });
      
      _log.info('Friend request accepted from user: $userId');
      return true;
    } catch (e) {
      _log.severe('Error accepting friend request: $e');
      return false;
    }
  }
  
  /// Reject a friend request
  Future<bool> rejectFriendRequest(String userId) async {
    _log.info('Rejecting friend request from user: $userId');
    
    try {
      // Get current user
      final currentUser = _userService.currentUser;
      if (currentUser == null) {
        _log.warning('No current user found');
        return false;
      }
      
      // Check if request exists
      if (!hasPendingRequest(userId)) {
        _log.warning('No pending request from user: $userId');
        return false;
      }
      
      // Reject the request
      await _dataStorageManager.rejectFriendRequest(currentUser.id, userId);
      
      // Update local state
      _friendRequests.remove(userId);
      _requestsStreamController.add(_friendRequests);
      
      _log.info('Friend request rejected from user: $userId');
      return true;
    } catch (e) {
      _log.severe('Error rejecting friend request: $e');
      return false;
    }
  }
  
  /// Cancel a sent friend request
  Future<bool> cancelFriendRequest(String userId) async {
    _log.info('Canceling friend request to user: $userId');
    
    try {
      // Get current user
      final currentUser = _userService.currentUser;
      if (currentUser == null) {
        _log.warning('No current user found');
        return false;
      }
      
      // Check if request exists
      if (!hasSentRequest(userId)) {
        _log.warning('No sent request to user: $userId');
        return false;
      }
      
      // Cancel the request
      await _dataStorageManager.cancelFriendRequest(currentUser.id, userId);
      
      // Update local state
      _sentRequests.remove(userId);
      _sentRequestsStreamController.add(_sentRequests);
      
      _log.info('Friend request canceled to user: $userId');
      return true;
    } catch (e) {
      _log.severe('Error canceling friend request: $e');
      return false;
    }
  }
  
  /// Remove a friend
  Future<bool> removeFriend(String userId) async {
    _log.info('Removing friend: $userId');
    
    try {
      // Get current user
      final currentUser = _userService.currentUser;
      if (currentUser == null) {
        _log.warning('No current user found');
        return false;
      }
      
      // Check if friend exists
      if (!_isFriend(userId)) {
        _log.warning('Not friends with user: $userId');
        return false;
      }
      
      // Remove the friend
      await _dataStorageManager.removeFriend(currentUser.id, userId);
      
      // Update local state
      _friends.removeWhere((friend) => friend.id == userId);
      _friendsStreamController.add(_friends);
      
      // Send event
      _socialEventStreamController.add({
        'type': 'friend_removed',
        'userId': userId,
      });
      
      _log.info('Friend removed: $userId');
      return true;
    } catch (e) {
      _log.severe('Error removing friend: $e');
      return false;
    }
  }
  
  /// Block a user
  Future<bool> blockUser(String userId) async {
    _log.info('Blocking user: $userId');
    
    try {
      // Get current user
      final currentUser = _userService.currentUser;
      if (currentUser == null) {
        _log.warning('No current user found');
        return false;
      }
      
      // Block the user
      await _dataStorageManager.blockUser(currentUser.id, userId);
      
      // Also remove as friend if exists
      if (_isFriend(userId)) {
        await removeFriend(userId);
      }
      
      // Reject any pending requests
      if (hasPendingRequest(userId)) {
        await rejectFriendRequest(userId);
      }
      
      // Cancel any sent requests
      if (hasSentRequest(userId)) {
        await cancelFriendRequest(userId);
      }
      
      // Send event
      _socialEventStreamController.add({
        'type': 'user_blocked',
        'userId': userId,
      });
      
      _log.info('User blocked: $userId');
      return true;
    } catch (e) {
      _log.severe('Error blocking user: $e');
      return false;
    }
  }
  
  /// Unblock a user
  Future<bool> unblockUser(String userId) async {
    _log.info('Unblocking user: $userId');
    
    try {
      // Get current user
      final currentUser = _userService.currentUser;
      if (currentUser == null) {
        _log.warning('No current user found');
        return false;
      }
      
      // Unblock the user
      await _dataStorageManager.unblockUser(currentUser.id, userId);
      
      _log.info('User unblocked: $userId');
      return true;
    } catch (e) {
      _log.severe('Error unblocking user: $e');
      return false;
    }
  }
  
  /// Check if a user is blocked
  Future<bool> isUserBlocked(String userId) async {
    try {
      // Get current user
      final currentUser = _userService.currentUser;
      if (currentUser == null) {
        _log.warning('No current user found');
        return false;
      }
      
      return await _dataStorageManager.isUserBlocked(currentUser.id, userId);
    } catch (e) {
      _log.severe('Error checking if user is blocked: $e');
      return false;
    }
  }
  
  /// Dispose resources
  void dispose() {
    _friendsStreamController.close();
    _requestsStreamController.close();
    _sentRequestsStreamController.close();
    _socialEventStreamController.close();
  }
} 

################################################################################
FILE: lib/services/social/leaderboard_service.dart
################################################################################

import 'dart:async';
import 'package:logging/logging.dart';
import 'package:going50/core_models/user_profile.dart';
import 'package:going50/data_lib/data_storage_manager.dart';
import 'package:going50/services/driving/performance_metrics_service.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// LeaderboardService manages leaderboard functionality
///
/// This service is responsible for:
/// - Retrieving leaderboard data for different time periods and regions
/// - Calculating user rankings based on eco-driving performance
/// - Filtering leaderboard data based on criteria (global, regional, friends)
class LeaderboardService {
  // Dependencies
  final DataStorageManager _dataStorageManager;
  final PerformanceMetricsService _metricsService;
  
  // Logging
  final _log = Logger('LeaderboardService');
  
  // Caching
  final Map<String, List<Map<String, dynamic>>> _leaderboardCache = {};
  final Map<String, DateTime> _cacheTimestamps = {};
  
  // Constants
  static const cacheDuration = Duration(minutes: 15);
  
  /// Constructor
  LeaderboardService(this._dataStorageManager, this._metricsService) {
    _log.info('LeaderboardService created');
  }
  
  /// Get leaderboard data for the specified type and timeframe
  Future<List<Map<String, dynamic>>> getLeaderboard({
    required String type, // 'global', 'regional', 'friends'
    required String timeframe, // 'daily', 'weekly', 'monthly', 'alltime'
    String? regionId,
    int limit = 100,
    int offset = 0,
  }) async {
    _log.info('Getting $type leaderboard for $timeframe timeframe');
    
    // Create cache key
    final cacheKey = '${type}_${timeframe}_${regionId ?? "all"}_${limit}_$offset';
    
    // Check cache first
    if (_isValidCache(cacheKey)) {
      _log.info('Using cached leaderboard data');
      return _leaderboardCache[cacheKey]!;
    }
    
    try {
      List<Map<String, dynamic>> leaderboard;
      
      // In a real implementation, this would query a database or API
      // Here we'll use a mock implementation
      switch (type) {
        case 'friends':
          leaderboard = await _getFriendsLeaderboard(timeframe);
          break;
        case 'regional':
          leaderboard = await _getRegionalLeaderboard(timeframe, regionId);
          break;
        case 'global':
        default:
          leaderboard = await _getGlobalLeaderboard(timeframe);
          break;
      }
      
      // Add rank based on position
      for (int i = 0; i < leaderboard.length; i++) {
        leaderboard[i]['rank'] = i + 1 + offset;
      }
      
      // Cache the result
      _leaderboardCache[cacheKey] = leaderboard;
      _cacheTimestamps[cacheKey] = DateTime.now();
      
      return leaderboard;
    } catch (e) {
      _log.severe('Error getting leaderboard data: $e');
      return [];
    }
  }
  
  /// Get the user's current ranking
  Future<Map<String, dynamic>?> getUserRanking({
    required String userId,
    required String type, // 'global', 'regional', 'friends'
    required String timeframe, // 'daily', 'weekly', 'monthly', 'alltime'
    String? regionId,
  }) async {
    _log.info('Getting ranking for user $userId in $type leaderboard');
    
    try {
      // Get user profile
      final userProfile = await _dataStorageManager.getUserProfileById(userId);
      if (userProfile == null) {
        _log.warning('User profile not found: $userId');
        return null;
      }
      
      // Get user's metrics for the timeframe
      final metrics = await _metricsService.getUserPerformanceMetrics(userId);
      if (metrics == null) {
        _log.warning('No metrics found for user $userId');
        return null;
      }
      
      // Get leaderboard to determine rank
      final leaderboard = await getLeaderboard(
        type: type,
        timeframe: timeframe,
        regionId: regionId,
        limit: 1000, // Get a larger set to find the user
      );
      
      // Find user's position in leaderboard
      int rank = -1;
      for (int i = 0; i < leaderboard.length; i++) {
        if (leaderboard[i]['userId'] == userId) {
          rank = leaderboard[i]['rank'];
          break;
        }
      }
      
      // If user not found in top 1000, estimate position
      if (rank == -1) {
        rank = await _estimateUserRank(userId, metrics['ecoScore'] as double, type, timeframe, regionId);
      }
      
      // Create user ranking object
      return {
        'userId': userId,
        'name': userProfile.name,
        'score': metrics['ecoScore'],
        'rank': rank,
        'trend': await _getUserTrend(userId, timeframe),
        'isUser': true,
      };
    } catch (e) {
      _log.severe('Error getting user ranking: $e');
      return null;
    }
  }
  
  /// Get global leaderboard
  Future<List<Map<String, dynamic>>> _getGlobalLeaderboard(String timeframe) async {
    _log.info('Getting global leaderboard for $timeframe');
    
    try {
      // In a real implementation, this would use a dedicated API
      // For now, we'll create a simple leaderboard from available data
      final List<Map<String, dynamic>> leaderboardData = [];
      
      // Get a limited set of user IDs to test with
      // In the future, this would scale to handle all users
      final testUserIds = await _getTestUserIds();
      
      // For each user, get their profile and metrics
      for (final userId in testUserIds) {
        final userProfile = await _dataStorageManager.getUserProfileById(userId);
        
        // Skip if profile not found or not public
        if (userProfile == null || !userProfile.isPublic) {
          continue;
        }
        
        // Get user's performance metrics
        final metrics = await _metricsService.getUserPerformanceMetrics(userId);
        if (metrics == null) continue;
        
        final scoreKey = _getScoreKeyForTimeframe(timeframe);
        final score = metrics[scoreKey] ?? metrics['ecoScore'] ?? 0;
        
        leaderboardData.add({
          'userId': userId,
          'name': userProfile.name,
          'score': score,
          'trend': await _getUserTrend(userId, timeframe),
        });
      }
      
      // Sort by score (descending)
      leaderboardData.sort((a, b) => (b['score'] as num).compareTo(a['score'] as num));
      
      return leaderboardData;
    } catch (e) {
      _log.severe('Error getting global leaderboard: $e');
      return [];
    }
  }
  
  /// Get a list of user IDs for testing the leaderboard
  /// In a real implementation, this would be replaced with a proper user query
  Future<List<String>> _getTestUserIds() async {
    try {
      // Get current user ID
      final currentUserId = await _getCurrentUserId();
      if (currentUserId == null) return [];
      
      // Get friend IDs
      final friendIds = await _dataStorageManager.getFriendIds(currentUserId);
      
      // Combine current user and friends
      final userIds = [currentUserId, ...friendIds];
      
      // Add some sample IDs in case we don't have enough friends yet
      const sampleIds = ['user1', 'user2', 'user3', 'user4', 'user5'];
      
      // Only use sample IDs if we don't have enough real users
      if (userIds.length < 5) {
        for (final id in sampleIds) {
          if (!userIds.contains(id)) {
            userIds.add(id);
          }
          if (userIds.length >= 10) break;
        }
      }
      
      return userIds;
    } catch (e) {
      _log.warning('Error getting test user IDs: $e');
      return [];
    }
  }
  
  /// Get regional leaderboard
  Future<List<Map<String, dynamic>>> _getRegionalLeaderboard(String timeframe, String? regionId) async {
    _log.info('Getting regional leaderboard for $timeframe in region $regionId');
    
    try {
      // For now, return the global leaderboard as we don't have region data
      // In a real implementation, we would filter users by region
      return _getGlobalLeaderboard(timeframe);
    } catch (e) {
      _log.severe('Error getting regional leaderboard: $e');
      return [];
    }
  }
  
  /// Get friends leaderboard
  Future<List<Map<String, dynamic>>> _getFriendsLeaderboard(String timeframe) async {
    _log.info('Getting friends leaderboard for $timeframe');
    
    try {
      final List<Map<String, dynamic>> leaderboardData = [];
      
      // Get current user
      final currentUser = await _getCurrentUserId();
      if (currentUser == null) {
        _log.warning('No current user found');
        return [];
      }
      
      // Get friend IDs
      final friendIds = await _dataStorageManager.getFriendIds(currentUser);
      if (friendIds.isEmpty) {
        _log.info('No friends found');
        return [];
      }
      
      // Get current user's metrics and add to leaderboard
      final currentUserMetrics = await _metricsService.getUserPerformanceMetrics(currentUser);
      final currentUserProfile = await _dataStorageManager.getUserProfileById(currentUser);
      
      if (currentUserMetrics != null && currentUserProfile != null) {
        final scoreKey = _getScoreKeyForTimeframe(timeframe);
        final score = currentUserMetrics[scoreKey] ?? currentUserMetrics['ecoScore'] ?? 0;
        
        leaderboardData.add({
          'userId': currentUser,
          'name': currentUserProfile.name,
          'score': score,
          'trend': await _getUserTrend(currentUser, timeframe),
          'isUser': true,
        });
      }
      
      // Get friend metrics and add to leaderboard
      for (final friendId in friendIds) {
        final friendProfile = await _dataStorageManager.getUserProfileById(friendId);
        if (friendProfile == null) continue;
        
        final metrics = await _metricsService.getUserPerformanceMetrics(friendId);
        if (metrics != null) {
          final scoreKey = _getScoreKeyForTimeframe(timeframe);
          final score = metrics[scoreKey] ?? metrics['ecoScore'] ?? 0;
          
          leaderboardData.add({
            'userId': friendId,
            'name': friendProfile.name,
            'score': score,
            'trend': await _getUserTrend(friendId, timeframe),
            'isFriend': true,
          });
        }
      }
      
      // Sort by score (descending)
      leaderboardData.sort((a, b) => (b['score'] as num).compareTo(a['score'] as num));
      
      return leaderboardData;
    } catch (e) {
      _log.severe('Error getting friends leaderboard: $e');
      return [];
    }
  }
  
  /// Get the appropriate score key based on the timeframe
  String _getScoreKeyForTimeframe(String timeframe) {
    switch (timeframe) {
      case 'daily':
        return 'dailyEcoScore';
      case 'weekly':
        return 'weeklyEcoScore';
      case 'monthly':
        return 'monthlyEcoScore';
      case 'alltime':
      default:
        return 'ecoScore';
    }
  }
  
  /// Get current user ID
  Future<String?> _getCurrentUserId() async {
    try {
      // Get shared preferences
      final prefs = await SharedPreferences.getInstance();
      return prefs.getString('user_id');
    } catch (e) {
      _log.warning('Error getting current user ID: $e');
      return null;
    }
  }
  
  /// Check if cache is valid
  bool _isValidCache(String cacheKey) {
    if (!_leaderboardCache.containsKey(cacheKey) || !_cacheTimestamps.containsKey(cacheKey)) {
      return false;
    }
    
    final cacheTime = _cacheTimestamps[cacheKey]!;
    final now = DateTime.now();
    
    return now.difference(cacheTime) < cacheDuration;
  }
  
  /// Estimate user rank based on score
  Future<int> _estimateUserRank(
    String userId,
    double score,
    String type,
    String timeframe,
    String? regionId,
  ) async {
    // In a real implementation, this would query the database for count of users with higher scores
    // For now, we'll return a mock estimated rank
    return 1500;
  }
  
  /// Get user trend compared to previous timeframe
  Future<String> _getUserTrend(String userId, String timeframe) async {
    // In a real implementation, this would compare current and previous timeframe scores
    // For now, return a random trend
    final trends = ['up', 'down', 'same'];
    return trends[DateTime.now().millisecondsSinceEpoch % 3];
  }
  
  /// Clear all cached data
  void clearCache() {
    _log.info('Clearing leaderboard cache');
    _leaderboardCache.clear();
    _cacheTimestamps.clear();
  }
  
  /// Clear specific cached data
  void clearCacheForType(String type, String timeframe) {
    _log.info('Clearing leaderboard cache for $type $timeframe');
    
    // Create cache key pattern
    final pattern = '${type}_${timeframe}';
    
    // Remove all matching entries
    _leaderboardCache.removeWhere((key, _) => key.startsWith(pattern));
    _cacheTimestamps.removeWhere((key, _) => key.startsWith(pattern));
  }
} 

################################################################################
FILE: lib/services/driving/analytics_service.dart
################################################################################

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:going50/behavior_classifier_lib/managers/eco_driving_manager.dart';
import 'package:logging/logging.dart';

/// Service that analyzes driving behavior data and provides insights
///
/// This service is responsible for:
/// - Analyzing driving data using the behavior classifier
/// - Calculating eco-score based on driving patterns
/// - Detecting driving behavior events
/// - Generating real-time feedback on driving
class AnalyticsService extends ChangeNotifier {
  final Logger _logger = Logger('AnalyticsService');
  
  // Dependencies
  final EcoDrivingManager _ecoDrivingManager;
  
  // Service state
  bool _isInitialized = false;
  String? _errorMessage;
  
  // Analysis results
  double _currentEcoScore = 0.0;
  Map<String, dynamic>? _lastDetailedAnalysis;
  final List<DrivingBehaviorEvent> _recentEvents = [];
  final int _maxEventHistory = 50;
  
  // Stream controllers
  final StreamController<DrivingBehaviorEvent> _eventStreamController = 
      StreamController<DrivingBehaviorEvent>.broadcast();
  final StreamController<double> _ecoScoreStreamController = 
      StreamController<double>.broadcast();
  
  // Timers
  Timer? _analysisTimer;
  final int _analysisIntervalMs = 2000; // Analyze every 2 seconds
  
  // Thresholds for event detection
  static const double _eventSeverityThreshold = 0.6; // Events with severity > 0.6 get reported
  
  // Public getters
  bool get isInitialized => _isInitialized;
  String? get errorMessage => _errorMessage;
  double get currentEcoScore => _currentEcoScore;
  Map<String, dynamic>? get lastDetailedAnalysis => _lastDetailedAnalysis;
  List<DrivingBehaviorEvent> get recentEvents => List.unmodifiable(_recentEvents);
  
  /// Stream of detected driving behavior events
  Stream<DrivingBehaviorEvent> get eventStream => _eventStreamController.stream;
  
  /// Stream of eco-score updates
  Stream<double> get ecoScoreStream => _ecoScoreStreamController.stream;
  
  /// Constructor
  AnalyticsService(this._ecoDrivingManager) {
    _logger.info('AnalyticsService initialized');
  }
  
  /// Initialize the analytics service
  Future<bool> initialize() async {
    if (_isInitialized) return true;
    
    _logger.info('Initializing analytics service');
    
    try {
      // Set up periodic analysis
      _startPeriodicAnalysis();
      
      _isInitialized = true;
      _clearErrorMessage();
      notifyListeners();
      return true;
    } catch (e) {
      _setErrorMessage('Failed to initialize: $e');
      _logger.severe('Initialization error: $e');
      return false;
    }
  }
  
  /// Start periodic analysis of driving data
  void _startPeriodicAnalysis() {
    // Cancel existing timer if it exists
    _analysisTimer?.cancel();
    
    // Create new timer for analysis
    _analysisTimer = Timer.periodic(
      Duration(milliseconds: _analysisIntervalMs),
      (_) => _performAnalysis()
    );
    
    _logger.info('Started periodic analysis');
  }
  
  /// Stop periodic analysis
  void stopAnalysis() {
    _analysisTimer?.cancel();
    _analysisTimer = null;
    _logger.info('Stopped periodic analysis');
  }
  
  /// Perform analysis of current driving data
  void _performAnalysis() {
    try {
      // Calculate eco-score
      double newScore = _ecoDrivingManager.calculateOverallScore();
      
      // Only update and notify if score has changed significantly
      if ((newScore - _currentEcoScore).abs() > 0.5) {
        _currentEcoScore = newScore;
        _ecoScoreStreamController.add(_currentEcoScore);
        notifyListeners();
      }
      
      // Get detailed analysis
      final detailedAnalysis = _ecoDrivingManager.getDetailedAnalysis();
      _lastDetailedAnalysis = detailedAnalysis;
      
      // Check for events that need reporting
      _detectAndReportEvents(detailedAnalysis);
      
    } catch (e) {
      _logger.warning('Error during analysis: $e');
    }
  }
  
  /// Manually trigger analysis (for cases where periodic analysis is not running)
  Future<void> triggerAnalysis() async {
    _performAnalysis();
  }
  
  /// Detect events from analysis results and report them
  void _detectAndReportEvents(Map<String, dynamic> analysis) {
    final detailedScores = analysis['detailedScores'] as Map<String, dynamic>;
    
    // Check each behavior category for events
    detailedScores.forEach((key, value) {
      // Skip if we don't have full details
      if (value is! Map<String, dynamic>) return;
      
      final score = value['score'] as double? ?? 100.0;
      final confidence = value['confidence'] as double? ?? 0.0;
      final message = value['message'] as String?;
      final details = value['details'] as Map<String, dynamic>?;
      
      // Only consider high-confidence detections
      if (confidence < 0.7) return;
      
      // Low score (high severity) and high confidence means a significant event
      final severity = (100.0 - score) / 100.0;
      if (severity > _eventSeverityThreshold && message != null) {
        final event = DrivingBehaviorEvent(
          timestamp: DateTime.now(),
          behaviorType: key,
          severity: severity,
          message: message,
          details: details,
        );
        
        // Add to recent events
        _addEvent(event);
        
        // Emit the event
        _eventStreamController.add(event);
      }
    });
  }
  
  /// Add an event to recent events list with overflow protection
  void _addEvent(DrivingBehaviorEvent event) {
    _recentEvents.add(event);
    
    // Truncate list if too large
    while (_recentEvents.length > _maxEventHistory) {
      _recentEvents.removeAt(0);
    }
    
    notifyListeners();
  }
  
  /// Get all events during a specified time range
  List<DrivingBehaviorEvent> getEventsInTimeRange(DateTime start, DateTime end) {
    return _recentEvents.where((event) {
      return event.timestamp.isAfter(start) && event.timestamp.isBefore(end);
    }).toList();
  }
  
  /// Get feedback suggestions based on recent driving patterns
  List<FeedbackSuggestion> generateFeedbackSuggestions() {
    List<FeedbackSuggestion> suggestions = [];
    
    // Don't generate suggestions if we don't have detailed analysis
    if (_lastDetailedAnalysis == null) return suggestions;
    
    final detailedScores = _lastDetailedAnalysis!['detailedScores'] as Map<String, dynamic>;
    
    // Check each behavior category for areas of improvement
    detailedScores.forEach((key, value) {
      // Skip if we don't have full details
      if (value is! Map<String, dynamic>) return;
      
      final score = value['score'] as double? ?? 100.0;
      final confidence = value['confidence'] as double? ?? 0.0;
      
      // Only consider high-confidence detections
      if (confidence < 0.6) return;
      
      // For areas with score < 70, generate suggestion
      if (score < 70.0) {
        String suggestion;
        String benefit;
        
        switch (key) {
          case 'calmDriving':
            suggestion = 'Try to accelerate and brake more gently';
            benefit = 'Smoother driving can improve fuel efficiency by up to 30%';
            break;
          case 'speedOptimization':
            suggestion = 'Maintain a steady speed between 50-80 km/h when possible';
            benefit = 'Optimal speed ranges use fuel more efficiently';
            break;
          case 'idling':
            suggestion = 'Consider turning off the engine when stopped for more than 30 seconds';
            benefit = 'Reducing idling can save up to 2% in fuel consumption';
            break;
          case 'shortDistance':
            suggestion = 'Consider combining multiple short trips into one journey';
            benefit = 'Cold engines use more fuel and produce more emissions';
            break;
          case 'rpmManagement':
            suggestion = 'Try shifting gears earlier to keep RPM lower';
            benefit = 'Lower RPM generally means better fuel efficiency';
            break;
          case 'stopManagement':
            suggestion = 'Try to anticipate stops and coast to a stop when possible';
            benefit = 'Reduces fuel usage and brake wear';
            break;
          case 'followDistance':
            suggestion = 'Maintain a larger distance from the vehicle ahead';
            benefit = 'Allows for smoother driving patterns and better anticipation';
            break;
          default:
            suggestion = 'Continue monitoring your driving patterns';
            benefit = 'Regular attention to driving habits improves efficiency';
        }
        
        suggestions.add(FeedbackSuggestion(
          category: key,
          suggestion: suggestion,
          benefit: benefit,
          priority: _calculatePriority(score),
        ));
      }
    });
    
    // Sort by priority
    suggestions.sort((a, b) => b.priority.compareTo(a.priority));
    
    return suggestions;
  }
  
  /// Calculate priority of a suggestion based on score
  int _calculatePriority(double score) {
    if (score < 40.0) return 3; // High priority
    if (score < 60.0) return 2; // Medium priority
    return 1; // Low priority
  }
  
  /// Set error message
  void _setErrorMessage(String message) {
    _errorMessage = message;
    _logger.warning(message);
    notifyListeners();
  }
  
  /// Clear error message
  void _clearErrorMessage() {
    _errorMessage = null;
  }
  
  /// Clean up resources
  @override
  void dispose() {
    _logger.info('Disposing analytics service');
    
    // Stop analysis
    stopAnalysis();
    
    // Close stream controllers
    _eventStreamController.close();
    _ecoScoreStreamController.close();
    
    super.dispose();
  }
}

/// Represents a driving behavior event detected during analysis
class DrivingBehaviorEvent {
  final DateTime timestamp;
  final String behaviorType;
  final double severity; // 0.0 to 1.0
  final String message;
  final Map<String, dynamic>? details;
  
  DrivingBehaviorEvent({
    required this.timestamp,
    required this.behaviorType,
    required this.severity,
    required this.message,
    this.details,
  });
  
  @override
  String toString() {
    return '$behaviorType (${(severity * 100).toStringAsFixed(1)}%): $message';
  }
}

/// Represents a feedback suggestion for the user
class FeedbackSuggestion {
  final String category;
  final String suggestion;
  final String benefit;
  final int priority; // 1 (low) to 3 (high)
  
  FeedbackSuggestion({
    required this.category,
    required this.suggestion,
    required this.benefit,
    required this.priority,
  });
} 

################################################################################
FILE: lib/services/driving/driving_service.dart
################################################################################

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:logging/logging.dart';
import 'package:uuid/uuid.dart';

// Service imports
import 'package:going50/services/driving/obd_connection_service.dart';
import 'package:going50/services/driving/sensor_service.dart';
import 'package:going50/services/driving/data_collection_service.dart';
import 'package:going50/services/driving/analytics_service.dart';
import 'package:going50/services/driving/trip_service.dart';
import 'package:going50/services/permission_service.dart';
import 'package:going50/services/service_locator.dart';
import 'package:going50/services/gamification/achievement_service.dart' show AchievementService, BadgeType, AchievementEvent;
import 'package:going50/services/gamification/challenge_service.dart';
import 'package:going50/services/background/background_service.dart';
import 'package:going50/services/background/notification_service.dart';

// Model imports
import 'package:going50/core_models/trip.dart';
import 'package:going50/core_models/driving_event.dart';
import 'package:going50/core_models/combined_driving_data.dart';
import 'package:going50/obd_lib/models/bluetooth_device.dart';

/// DrivingStatus represents the current state of driving
enum DrivingStatus {
  /// Not ready (services not initialized)
  notReady,
  
  /// Ready to start a trip but not currently recording
  ready,
  
  /// Recording an active trip
  recording,
  
  /// Error state
  error
}

/// DrivingService acts as a facade to coordinate all driving-related services.
/// 
/// This service is responsible for:
/// - Coordinating the initialization and operation of all driving-related services
/// - Managing the overall driving state (not ready, ready, recording, error)
/// - Providing a unified interface to start/stop trips and access driving data
/// - Propagating driving events to consumers
class DrivingService extends ChangeNotifier {
  final Logger _logger = Logger('DrivingService');
  final Uuid _uuid = Uuid();
  
  // Dependencies
  final ObdConnectionService _obdConnectionService;
  final SensorService _sensorService;
  final DataCollectionService _dataCollectionService;
  final AnalyticsService _analyticsService;
  final TripService _tripService;
  late final PermissionService _permissionService;
  late final AchievementService _achievementService;
  late final ChallengeService _challengeService;
  late final NotificationService _notificationService;
  BackgroundService? _backgroundService;
  
  // Service state
  bool _isInitialized = false;
  String? _errorMessage;
  DrivingStatus _drivingStatus = DrivingStatus.notReady;
  
  // Event stream controller
  final StreamController<DrivingEvent> _drivingEventController = 
      StreamController<DrivingEvent>.broadcast();
  
  // Public getters
  bool get isInitialized => _isInitialized;
  String? get errorMessage => _errorMessage;
  DrivingStatus get drivingStatus => _drivingStatus;
  Trip? get currentTrip => _tripService.currentTrip;
  bool get isObdConnected => _obdConnectionService.isConnected;
  bool get isCollecting => _dataCollectionService.isCollecting;
  double get currentEcoScore => _analyticsService.currentEcoScore;
  
  /// Stream of driving events combining various service events
  Stream<DrivingEvent> get drivingEventStream => _drivingEventController.stream;
  
  /// Constructor
  DrivingService(
    this._obdConnectionService,
    this._sensorService,
    this._dataCollectionService,
    this._analyticsService,
    this._tripService,
  ) {
    _logger.info('DrivingService created');
    _permissionService = serviceLocator<PermissionService>();
    _achievementService = serviceLocator<AchievementService>();
    _challengeService = serviceLocator<ChallengeService>();
    _notificationService = serviceLocator<NotificationService>();
    
    // Access the background service after both services are initialized
    try {
      _backgroundService = serviceLocator<BackgroundService>();
      // Set the notification service in the background service to avoid circular dependencies
      _backgroundService?.setNotificationService(_notificationService);
    } catch (e) {
      _logger.warning('Background service not available: $e');
    }
    
    _setupEventListeners();
    _initializeServices();
  }
  
  /// Setup event listeners from all services
  void _setupEventListeners() {
    // Listen for data collection events
    _dataCollectionService.addListener(_handleDataCollectionStateChange);
    
    // Listen for OBD connection events
    _obdConnectionService.addListener(_handleObdConnectionStateChange);
    
    // Listen for driving behavior events
    _analyticsService.eventStream.listen(_handleDrivingBehaviorEvent);
    
    // Listen for trip state changes
    _tripService.addListener(_updateDrivingStatus);
    
    // Listen for achievement events
    _achievementService.achievementEventStream.listen(_handleAchievementEvent);
    
    // Listen for challenge events
    _challengeService.challengeEventStream.listen(_handleChallengeEvent);
    
    // Subscribe to data stream to forward data to other services
    _dataCollectionService.dataStream.listen(_handleCombinedData);
  }
  
  /// Handle combined data from DataCollectionService and forward to other services
  void _handleCombinedData(CombinedDrivingData data) {
    try {
      // Forward to AnalyticsService for behavior analysis
      _analyticsService.triggerAnalysis();
      
      // Forward to TripService for trip metrics
      if (_tripService.currentTrip != null) {
        _tripService.processDataPoint(data);
      }
    } catch (e) {
      _logger.warning('Error handling combined data: $e');
    }
  }
  
  /// Initializes all required services
  Future<bool> _initializeServices() async {
    _logger.info('Initializing all driving services');
    
    try {
      // Initialize sensor service - this is the core requirement
      final sensorInitialized = await _sensorService.initialize();
      if (!sensorInitialized) {
        _setError('Failed to initialize sensor service');
        return false;
      }
      
      // Initialize data collection service - will use fallback mode if OBD is not available
      final dataCollectionInitialized = await _dataCollectionService.initialize();
      // We don't consider OBD failures as critical errors that prevent initialization
      // since we can still collect data using phone sensors
      
      // Mark as initialized even if data collection had OBD errors
      _isInitialized = dataCollectionInitialized;
      
      // Update driving status
      _updateDrivingStatus();
      
      _logger.info('All driving services initialized successfully. OBD connected: ${_obdConnectionService.isConnected}');
      notifyListeners();
      return dataCollectionInitialized;
    } catch (e) {
      _setError('Error initializing services: $e');
      _logger.severe('Error initializing services', e);
      return false;
    }
  }
  
  /// Updates the driving status based on all services' states
  void _updateDrivingStatus() {
    DrivingStatus oldStatus = _drivingStatus;
    
    if (!_isInitialized) {
      _drivingStatus = DrivingStatus.notReady;
      _logger.info('Setting driving status to notReady because service is not initialized');
    } else if (_errorMessage != null) {
      _drivingStatus = DrivingStatus.error;
      _logger.info('Setting driving status to error due to: $_errorMessage');
    } else if (_tripService.currentTrip != null) {
      _drivingStatus = DrivingStatus.recording;
      _logger.info('Setting driving status to recording because a trip is in progress');
    } else {
      _drivingStatus = DrivingStatus.ready;
      _logger.info('Setting driving status to ready - all conditions met');
    }
    
    if (oldStatus != _drivingStatus) {
      _logger.info('Driving status updated from $oldStatus to: $_drivingStatus');
    }
    
    notifyListeners();
  }
  
  /// Handles data collection state changes
  void _handleDataCollectionStateChange() {
    // If data collection throws an error, propagate it
    if (_dataCollectionService.errorMessage != null) {
      _setError('Data collection error: ${_dataCollectionService.errorMessage}');
    }
    
    // Update driving status
    _updateDrivingStatus();
  }
  
  /// Handles OBD connection state changes
  void _handleObdConnectionStateChange() {
    // If OBD connection throws an error, log it but don't stop functionality
    // (since we have sensor fallback)
    if (_obdConnectionService.errorMessage != null) {
      _logger.warning('OBD connection error: ${_obdConnectionService.errorMessage}');
      
      // Send an event for UI notification
      final tripId = _tripService.currentTrip?.id ?? 'no_trip';
      _drivingEventController.add(DrivingEvent(
        id: _uuid.v4(),
        tripId: tripId,
        timestamp: DateTime.now(),
        eventType: 'obd_connection_error',
        severity: 0.5,
        additionalData: {'message': _obdConnectionService.errorMessage},
      ));
    }
    
    notifyListeners();
  }
  
  /// Handles driving behavior events from analytics service
  void _handleDrivingBehaviorEvent(DrivingBehaviorEvent event) {
    try {
      // Convert behavior event to driving event
      final drivingEvent = DrivingEvent(
        id: _uuid.v4(),
        tripId: _tripService.currentTrip?.id ?? 'no_trip',
        timestamp: event.timestamp,
        eventType: event.behaviorType,
        severity: event.severity,
        additionalData: event.details,
      );
      
      // Forward the event to other services
      if (_tripService.currentTrip != null) {
        _tripService.recordDrivingEvent(drivingEvent);
      }
      
      // Forward event to the public event stream
      _drivingEventController.add(drivingEvent);
      
      // Send notification for significant events
      if (['harsh_acceleration', 'harsh_braking', 'excessive_speed', 'excessive_idling']
          .contains(event.behaviorType)) {
        _notificationService.showDrivingEventNotification(drivingEvent);
      }
    } catch (e) {
      _logger.warning('Error handling driving behavior event: $e');
    }
  }
  
  /// Handles achievement events
  void _handleAchievementEvent(AchievementEvent event) {
    try {
      // Create a driving event for the achievement
      final achievementEvent = DrivingEvent(
        id: _uuid.v4(),
        tripId: _tripService.currentTrip?.id ?? 'no_trip',
        timestamp: DateTime.now(),
        eventType: 'achievement_earned',
        severity: 0.0, // Not a negative event
        additionalData: event.toJson(),
      );
      
      // Forward to event stream
      _drivingEventController.add(achievementEvent);
      
      // Send notification for the achievement
      _notificationService.showAchievementNotification(
        title: 'Achievement Unlocked!',
        message: 'You earned the ${event.badgeName} badge',
        badgeType: event.badgeType,
        level: event.level,
      );
    } catch (e) {
      _logger.warning('Error handling achievement event: $e');
    }
  }
  
  /// Handles challenge events
  void _handleChallengeEvent(ChallengeEvent event) {
    try {
      // Create a driving event for the challenge
      final challengeEvent = DrivingEvent(
        id: _uuid.v4(),
        tripId: _tripService.currentTrip?.id ?? 'no_trip',
        timestamp: DateTime.now(),
        eventType: 'challenge_update',
        severity: 0.0, // Not a negative event
        additionalData: event.toJson(),
      );
      
      // Forward to event stream
      _drivingEventController.add(challengeEvent);
      
      // Send notification for completed challenges
      if (event.eventType == 'completed') {
        _notificationService.showNotification(
          title: 'Challenge Completed!',
          body: 'You completed the ${event.challengeTitle} challenge',
          type: NotificationType.achievement,
          priority: NotificationPriority.high,
          data: {'challengeId': event.challengeId},
        );
      }
    } catch (e) {
      _logger.warning('Error handling challenge event: $e');
    }
  }
  
  /// Handles errors by setting error message and updating status
  void _setError(String message) {
    _errorMessage = message;
    _logger.severe(message);
    _updateDrivingStatus();
    notifyListeners();
  }
  
  /// Starts scanning for OBD devices
  Future<bool> startScanningForDevices() async {
    try {
      return await _obdConnectionService.startScan();
    } catch (e) {
      _logger.warning('Error starting device scan', e);
      return false;
    }
  }
  
  /// Stops scanning for OBD devices
  Future<void> stopScanningForDevices() async {
    try {
      _obdConnectionService.stopScan();
    } catch (e) {
      _logger.warning('Error stopping device scan', e);
    }
  }
  
  /// Stream of discovered Bluetooth devices
  Stream<List<BluetoothDevice>> get deviceStream => _obdConnectionService.deviceStream;
  
  /// Connects to an OBD device
  Future<bool> connectToObdDevice(String deviceId) async {
    try {
      final success = await _obdConnectionService.connectToDevice(deviceId);
      if (success) {
        // Send a successful connection event
        final tripId = _tripService.currentTrip?.id ?? 'no_trip';
        _drivingEventController.add(DrivingEvent(
          id: _uuid.v4(),
          tripId: tripId,
          timestamp: DateTime.now(),
          eventType: 'obd_connected',
          severity: 0.0, // Not a negative event
          additionalData: {'deviceId': deviceId},
        ));
        
        // Award the OBD-connected achievement if user exists
        final userId = _tripService.currentTrip?.userId;
        if (userId != null) {
          _logger.info('Awarding OBD-connected achievement to user $userId');
          await _achievementService.awardSpecialBadge(userId, BadgeType.obdConnected);
        } else {
          _logger.info('Cannot award OBD-connected achievement: User not available');
        }
      }
      return success;
    } catch (e) {
      _logger.warning('Error connecting to OBD device', e);
      return false;
    }
  }
  
  /// Disconnects from an OBD device
  Future<bool> disconnectFromObdDevice() async {
    try {
      final success = await _obdConnectionService.disconnect();
      if (success) {
        // Send a disconnection event
        final tripId = _tripService.currentTrip?.id ?? 'no_trip';
        _drivingEventController.add(DrivingEvent(
          id: _uuid.v4(),
          tripId: tripId,
          timestamp: DateTime.now(),
          eventType: 'obd_disconnected',
          severity: 0.0, // Not a negative event
        ));
      }
      return success;
    } catch (e) {
      _logger.warning('Error disconnecting from OBD device', e);
      return false;
    }
  }
  
  /// Starts a new trip recording
  Future<Trip?> startTrip({bool skipPermissionChecks = false}) async {
    _logger.info('Starting new trip');
    
    if (_drivingStatus == DrivingStatus.recording) {
      _logger.warning('Cannot start trip, already recording');
      return null;
    }
    
    try {
      // Check for required permissions (only if not skipped)
      if (!skipPermissionChecks) {
        // First check for required permissions
        bool hasLocationPermission = await _permissionService.areLocationPermissionsGranted();
        if (!hasLocationPermission) {
          _logger.info('Requesting location permissions');
          await _permissionService.requestLocationPermissions();
          
          // Check again if permissions were granted
          hasLocationPermission = await _permissionService.areLocationPermissionsGranted();
          if (!hasLocationPermission) {
            _setError('Location permission required to start trip');
            return null;
          }
        }
        
        // If using OBD, check for bluetooth permissions 
        if (_obdConnectionService.isConnected) {
          bool hasBluetoothPermission = await _permissionService.areBluetoothPermissionsGranted();
          if (!hasBluetoothPermission) {
            _logger.info('Requesting Bluetooth permissions');
            await _permissionService.requestBluetoothPermissions();
            
            // Check again if permissions were granted
            hasBluetoothPermission = await _permissionService.areBluetoothPermissionsGranted();
            if (!hasBluetoothPermission) {
              _setError('Bluetooth permission required to use OBD device');
              return null;
            }
          }
        }
        
        // Check for activity/motion sensor permissions
        await _permissionService.requestActivityRecognitionPermission();
      } else {
        _logger.info('Skipping permission checks as requested');
      }
      
      // Start background service if available
      if (_backgroundService != null) {
        final canRunInBackground = await _backgroundService!.canRunInBackground();
        if (canRunInBackground) {
          _logger.info('Starting background service');
          await _backgroundService!.startBackgroundService();
        } else {
          _logger.warning('Background service cannot run, continuing without it');
        }
      }
      
      // Then ensure analytics is initialized
      await _analyticsService.initialize();
      
      // Then ensure data collection is started
      final collectionStarted = await _dataCollectionService.startCollection();
      if (!collectionStarted) {
        _setError('Failed to start data collection');
        return null;
      }
      
      // Then start the trip
      final trip = await _tripService.startTrip();
      if (trip != null) {
        // Send trip started event
        _drivingEventController.add(DrivingEvent(
          id: _uuid.v4(),
          tripId: trip.id,
          timestamp: DateTime.now(),
          eventType: 'trip_started',
          severity: 0.0, // Not a negative event
          additionalData: {'tripId': trip.id},
        ));
        
        _updateDrivingStatus();
      }
      
      return trip;
    } catch (e) {
      _setError('Error starting trip: $e');
      _logger.severe('Error starting trip', e);
      return null;
    }
  }
  
  /// Ends the current trip recording
  Future<Trip?> endTrip() async {
    _logger.info('Ending trip');
    
    if (_tripService.currentTrip == null) {
      _logger.warning('Cannot end trip: No trip in progress');
      return null;
    }
    
    try {
      // Stop data collection
      await _dataCollectionService.stopCollection();
      
      // Finish trip and get completed trip
      final completedTrip = await _tripService.endTrip();
      
      if (completedTrip != null) {
        _logger.info('Trip ended successfully: ${completedTrip.id}');
        
        // Check if this is the user's first trip and award achievement
        if (completedTrip.userId != null) {
          final tripCount = await _tripService.getUserTripCount(completedTrip.userId!);
          _logger.info('User ${completedTrip.userId} has completed $tripCount trips');
          
          if (tripCount == 1) {
            _logger.info('Awarding first trip achievement to user ${completedTrip.userId}');
            final achievementEvent = await _achievementService.awardSpecialBadge(completedTrip.userId!, BadgeType.firstTrip);
            if (achievementEvent != null) {
              _logger.info('Successfully awarded first trip achievement!');
            } else {
              _logger.warning('Failed to award first trip achievement to user ${completedTrip.userId}');
            }
          }
          
          // Check for other achievements
          await _achievementService.checkAchievementsAfterTrip(completedTrip, completedTrip.userId!);
          await _challengeService.checkChallengesAfterTrip(completedTrip, completedTrip.userId!);
        } else {
          _logger.warning('Cannot award achievements for trip ${completedTrip.id} - userId is null');
        }
        
        // Send trip summary notification
        _notificationService.showTripSummaryNotification(
          tripId: completedTrip.id,
          ecoScore: 85, // Use a placeholder or calculate from analytics service
          distanceKm: completedTrip.distanceKm ?? 0,
          fuelSavedL: completedTrip.fuelUsedL ?? 0,
        );
        
        // Update driving status
        _updateDrivingStatus();
        
        return completedTrip;
      } else {
        _logger.warning('Failed to end trip');
        return null;
      }
    } catch (e) {
      _setError('Error ending trip: $e');
      _logger.severe('Error ending trip', e);
      return null;
    }
  }
  
  /// Gets the combined data stream from the data collection service
  Stream<CombinedDrivingData> get dataStream => _dataCollectionService.dataStream;
  
  /// Gets the current trip metrics stream
  Stream<Map<String, dynamic>> get tripMetricsStream => _tripService.metricsStream;
  
  /// Gets the eco score stream
  Stream<double> get ecoScoreStream => _analyticsService.ecoScoreStream;
  
  /// Gets the latest detailed analysis from the analytics service
  Map<String, dynamic>? get latestAnalysis => _analyticsService.lastDetailedAnalysis;
  
  /// Gets recent driving behavior events
  List<DrivingBehaviorEvent> get recentBehaviorEvents => _analyticsService.recentEvents;
  
  /// Gets trip history from the trip service
  Future<List<Trip>> getTrips({int limit = 10, int offset = 0}) async {
    final allTrips = await _tripService.getTripHistory();
    
    if (allTrips.isEmpty) return [];
    
    final startIndex = offset.clamp(0, allTrips.length - 1);
    final endIndex = (offset + limit).clamp(startIndex, allTrips.length);
    
    return allTrips.sublist(startIndex, endIndex);
  }
  
  /// Gets a specific trip by ID
  Future<Trip?> getTrip(String tripId) async {
    return await _tripService.getTrip(tripId);
  }
  
  /// Force reinitialize all services
  /// This is useful for troubleshooting
  Future<bool> forceReinitializeServices() async {
    _logger.info('Force reinitializing all driving services');
    
    // Reset error state
    _errorMessage = null;
    
    // Reset initialization flag
    _isInitialized = false;
    
    // Notify listeners of state change
    notifyListeners();
    
    // Reinitialize services
    return await _initializeServices();
  }
  
  /// Clean up resources
  @override
  void dispose() {
    _logger.info('Disposing DrivingService');
    
    // Remove listeners
    _dataCollectionService.removeListener(_handleDataCollectionStateChange);
    _obdConnectionService.removeListener(_handleObdConnectionStateChange);
    _tripService.removeListener(_updateDrivingStatus);
    
    // Close stream controller
    _drivingEventController.close();
    
    super.dispose();
  }
  
  /// Setup the background service connection after initialization
  Future<void> setupBackgroundService() async {
    try {
      _backgroundService = serviceLocator<BackgroundService>();
      _logger.info('Background service found and integrated with DrivingService');
    } catch (e) {
      _logger.info('Background service not available, continuing without it: $e');
    }
  }
} 

################################################################################
FILE: lib/services/driving/sensor_service.dart
################################################################################

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:going50/core/utils/device_utils.dart';
import 'package:going50/core_models/phone_sensor_data.dart';
import 'package:going50/sensor_lib/sensor_service.dart' as sensor_lib;
import 'package:going50/services/permission_service.dart';
import 'package:going50/services/service_locator.dart';
import 'package:logging/logging.dart';

/// A service that manages phone sensors for collecting driving data when
/// an OBD device is not available or as supplementary data.
class SensorService extends ChangeNotifier {
  final Logger _logger = Logger('SensorService');
  final sensor_lib.SensorService _sensorService;
  late final PermissionService _permissionService;
  
  // Service state
  bool _isInitialized = false;
  bool _isCollecting = false;
  String? _errorMessage;
  
  // Store the latest sensor data
  PhoneSensorData? _latestSensorData;
  
  // Stream controller for sensor data
  final StreamController<PhoneSensorData> _dataStreamController = 
      StreamController<PhoneSensorData>.broadcast();
  
  // Public getters
  bool get isInitialized => _isInitialized;
  bool get isCollecting => _isCollecting;
  String? get errorMessage => _errorMessage;
  PhoneSensorData? get latestSensorData => _latestSensorData;
  
  /// Stream of sensor data
  Stream<PhoneSensorData> get dataStream => _dataStreamController.stream;
  
  /// Constructor
  SensorService(this._sensorService) {
    _logger.info('SensorService initialized');
    
    // Get the permission service
    _permissionService = serviceLocator<PermissionService>();
    
    // Subscribe to the sensor library's data stream
    _sensorService.dataStream.listen(_handleSensorData);
  }
  
  /// Initialize the sensor service
  Future<bool> initialize() async {
    if (_isInitialized) return true;
    
    _logger.info('Initializing sensor service');
    
    try {
      // Check for required permissions
      final hasLocationPermission = await _permissionService.areLocationPermissionsGranted();
      if (!hasLocationPermission) {
        _logger.info('Requesting location permissions');
        await _permissionService.requestLocationPermissions(background: false);
        
        // Check again if permissions were granted
        final permissionsGranted = await _permissionService.areLocationPermissionsGranted();
        if (!permissionsGranted) {
          _setErrorMessage('Location permission not granted');
          return false;
        }
      }
      
      // Check device capabilities
      final hasSensorCapabilities = await DeviceUtils.hasSensorCapabilities();
      if (!hasSensorCapabilities) {
        _setErrorMessage('Device does not have required sensors');
        return false;
      }
      
      // Initialize the underlying sensor service
      await _sensorService.initialize();
      
      _isInitialized = true;
      _clearErrorMessage();
      notifyListeners();
      return true;
    } catch (e) {
      _setErrorMessage('Failed to initialize: $e');
      _logger.severe('Initialization error: $e');
      return false;
    }
  }
  
  /// Start collecting sensor data
  Future<bool> startCollection({int collectionIntervalMs = 100}) async {
    if (!_isInitialized) {
      final initialized = await initialize();
      if (!initialized) return false;
    }
    
    if (_isCollecting) return true;
    
    _logger.info('Starting sensor data collection');
    
    try {
      // Start collection in the sensor service
      await _sensorService.startCollection(collectionIntervalMs: collectionIntervalMs);
      
      _isCollecting = true;
      _clearErrorMessage();
      notifyListeners();
      return true;
    } catch (e) {
      _setErrorMessage('Failed to start collection: $e');
      _logger.severe('Collection start error: $e');
      return false;
    }
  }
  
  /// Stop collecting sensor data
  void stopCollection() {
    if (!_isCollecting) return;
    
    _logger.info('Stopping sensor data collection');
    
    _sensorService.stopCollection();
    
    _isCollecting = false;
    notifyListeners();
  }
  
  /// Get the latest sensor data point
  Future<PhoneSensorData?> getLatestSensorData() async {
    if (!_isInitialized) {
      final initialized = await initialize();
      if (!initialized) return null;
    }
    
    try {
      final data = await _sensorService.getLatestSensorData();
      _latestSensorData = data;
      return data;
    } catch (e) {
      _logger.warning('Error getting latest sensor data: $e');
      return _latestSensorData;
    }
  }
  
  /// Handle new sensor data from the underlying service
  void _handleSensorData(PhoneSensorData data) {
    _latestSensorData = data;
    _dataStreamController.add(data);
  }
  
  /// Set error message
  void _setErrorMessage(String message) {
    _errorMessage = message;
    _logger.warning(message);
    notifyListeners();
  }
  
  /// Clear error message
  void _clearErrorMessage() {
    _errorMessage = null;
    notifyListeners();
  }
  
  /// Clean up resources
  @override
  void dispose() {
    _logger.info('Disposing sensor service');
    
    // Stop collection if running
    if (_isCollecting) {
      stopCollection();
    }
    
    // Close stream controller
    _dataStreamController.close();
    
    super.dispose();
  }
} 

################################################################################
FILE: lib/services/driving/trip_service.dart
################################################################################

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:logging/logging.dart';

// Local imports
import 'package:going50/core_models/trip.dart';
import 'package:going50/core_models/combined_driving_data.dart';
import 'package:going50/core_models/driving_event.dart';
import 'package:going50/data_lib/data_storage_manager.dart';

/// TripService manages trip recording and completion.
/// 
/// This service is responsible for:
/// - Starting and ending trips
/// - Calculating trip metrics
/// - Saving trip data points
/// - Retrieving trip history
class TripService extends ChangeNotifier {
  final Logger _logger = Logger('TripService');
  
  // Dependencies
  final DataStorageManager _dataStorageManager;
  
  // Service state
  bool _isInitialized = false;
  Trip? _currentTrip;
  String? _errorMessage;
  
  // Trip metrics tracking
  double _totalDistanceKm = 0.0;
  double _maxSpeedKmh = 0.0;
  double _sumSpeed = 0.0;
  int _speedReadingCount = 0;
  double _sumRpm = 0.0;
  int _rpmReadingCount = 0;
  double _estimatedFuelUsedL = 0.0;
  
  // Event counters
  int _idlingEvents = 0;
  int _aggressiveAccelerationEvents = 0;
  int _hardBrakingEvents = 0;
  int _excessiveSpeedEvents = 0;
  int _stopEvents = 0;
  
  // Data points for the current trip
  final List<CombinedDrivingData> _currentTripDataPoints = [];
  
  // Trip metrics stream
  final StreamController<Map<String, dynamic>> _metricsStreamController = 
      StreamController<Map<String, dynamic>>.broadcast();
  
  // Trip state stream
  final StreamController<Trip?> _tripStateController = 
      StreamController<Trip?>.broadcast();
  
  // Public getters
  bool get isInitialized => _isInitialized;
  bool get isOnTrip => _currentTrip != null;
  Trip? get currentTrip => _currentTrip;
  String? get errorMessage => _errorMessage;
  double get totalDistanceKm => _totalDistanceKm;
  double get currentAverageSpeedKmh => _speedReadingCount > 0 ? _sumSpeed / _speedReadingCount : 0;
  double get maxSpeedKmh => _maxSpeedKmh;
  
  /// Stream of trip metrics updates
  Stream<Map<String, dynamic>> get metricsStream => _metricsStreamController.stream;
  
  /// Stream of trip state updates
  Stream<Trip?> get tripStateStream => _tripStateController.stream;
  
  /// Constructor
  TripService(this._dataStorageManager) {
    _logger.info('TripService created');
  }
  
  /// Initialize the trip service
  Future<bool> initialize() async {
    if (_isInitialized) return true;
    
    _logger.info('Initializing trip service');
    
    try {
      // Initialize data storage manager
      await _dataStorageManager.initialize();
      
      _isInitialized = true;
      _clearErrorMessage();
      return true;
    } catch (e) {
      _setErrorMessage('Failed to initialize trip service: $e');
      _logger.severe('Initialization error: $e');
      return false;
    }
  }
  
  /// Start a new trip
  Future<Trip?> startTrip() async {
    if (!_isInitialized) {
      final initialized = await initialize();
      if (!initialized) return null;
    }
    
    if (_currentTrip != null) {
      _logger.warning('Attempted to start a trip while one is already in progress');
      return _currentTrip;
    }
    
    _logger.info('Starting new trip');
    
    try {
      // Create a new trip in the data storage
      final trip = await _dataStorageManager.startNewTrip();
      
      // Set as current trip
      _currentTrip = trip;
      
      // Reset metrics
      _resetMetrics();
      
      // Notify listeners
      notifyListeners();
      _tripStateController.add(trip);
      
      return trip;
    } catch (e) {
      _setErrorMessage('Failed to start trip: $e');
      _logger.severe('Error starting trip: $e');
      return null;
    }
  }
  
  /// End the current trip
  Future<Trip?> endTrip() async {
    if (_currentTrip == null) {
      _logger.warning('Attempted to end a trip when none is in progress');
      return null;
    }
    
    _logger.info('Ending trip ${_currentTrip!.id}');
    
    try {
      // Calculate final metrics
      final averageSpeedKmh = _speedReadingCount > 0 ? _sumSpeed / _speedReadingCount : 0.0;
      final averageRPM = _rpmReadingCount > 0 ? _sumRpm / _rpmReadingCount : 0.0;
      
      // End the trip in the data storage
      final completedTrip = await _dataStorageManager.endTrip(
        _currentTrip!.id,
        distanceKm: _totalDistanceKm,
        averageSpeedKmh: averageSpeedKmh,
        maxSpeedKmh: _maxSpeedKmh,
        fuelUsedL: _estimatedFuelUsedL,
        idlingEvents: _idlingEvents,
        aggressiveAccelerationEvents: _aggressiveAccelerationEvents,
        hardBrakingEvents: _hardBrakingEvents,
        excessiveSpeedEvents: _excessiveSpeedEvents,
        stopEvents: _stopEvents,
        averageRPM: averageRPM,
      );
      
      // Clear current trip
      final endedTrip = _currentTrip;
      _currentTrip = null;
      _currentTripDataPoints.clear();
      
      // Notify listeners
      notifyListeners();
      _tripStateController.add(null);
      
      return completedTrip;
    } catch (e) {
      _setErrorMessage('Failed to end trip: $e');
      _logger.severe('Error ending trip: $e');
      return null;
    }
  }
  
  /// Process a data point for the current trip
  Future<void> processDataPoint(CombinedDrivingData dataPoint) async {
    if (_currentTrip == null) return;
    
    try {
      // Save data point to storage
      await _dataStorageManager.saveTripDataPoint(_currentTrip!.id, dataPoint);
      
      // Add to current trip data points
      _currentTripDataPoints.add(dataPoint);
      
      // Update metrics
      _updateMetricsFromDataPoint(dataPoint);
      
      // Emit updated metrics
      _emitMetricsUpdate();
    } catch (e) {
      _logger.warning('Error processing data point: $e');
    }
  }
  
  /// Record a driving event for the current trip
  Future<void> recordDrivingEvent(DrivingEvent event) async {
    if (_currentTrip == null) return;
    
    try {
      // Save event to storage
      await _dataStorageManager.saveDrivingEvent(_currentTrip!.id, event);
      
      // Update counters based on event type
      switch (event.eventType) {
        case 'idling':
          _idlingEvents++;
          break;
        case 'aggressive_acceleration':
          _aggressiveAccelerationEvents++;
          break;
        case 'hard_braking':
          _hardBrakingEvents++;
          break;
        case 'excessive_speed':
          _excessiveSpeedEvents++;
          break;
        case 'stop':
          _stopEvents++;
          break;
      }
      
      // Emit updated metrics
      _emitMetricsUpdate();
    } catch (e) {
      _logger.warning('Error recording driving event: $e');
    }
  }
  
  /// Get trip history
  Future<List<Trip>> getTripHistory() async {
    try {
      return await _dataStorageManager.getAllTrips();
    } catch (e) {
      _logger.warning('Error getting trip history: $e');
      return [];
    }
  }
  
  /// Get a specific trip by ID
  Future<Trip?> getTrip(String tripId) async {
    try {
      return await _dataStorageManager.getTrip(tripId);
    } catch (e) {
      _logger.warning('Error getting trip $tripId: $e');
      return null;
    }
  }
  
  /// Watch for trip updates
  Stream<List<Trip>> watchTrips() {
    return _dataStorageManager.watchTrips();
  }
  
  /// Get the number of trips a user has completed
  Future<int> getUserTripCount(String userId) async {
    try {
      // Get all trips
      final allTrips = await getTripHistory();
      _logger.info('Retrieved ${allTrips.length} trips from history');
      
      // Filter trips by userId
      final userTrips = allTrips.where((trip) => trip.userId == userId).toList();
      _logger.info('Found ${userTrips.length} trips for user $userId');
      
      // Log user IDs of retrieved trips for debugging
      if (userTrips.isEmpty && allTrips.isNotEmpty) {
        _logger.info('User IDs in trip history: ${allTrips.map((trip) => trip.userId).toSet().join(', ')}');
      }
      
      // Return the count of completed user trips
      return userTrips.length;
    } catch (e) {
      _logger.severe('Error getting user trip count: $e');
      return 0; // Return 0 on error to be safe
    }
  }
  
  /// Reset trip metrics
  void _resetMetrics() {
    _totalDistanceKm = 0.0;
    _maxSpeedKmh = 0.0;
    _sumSpeed = 0.0;
    _speedReadingCount = 0;
    _sumRpm = 0.0;
    _rpmReadingCount = 0;
    _estimatedFuelUsedL = 0.0;
    
    _idlingEvents = 0;
    _aggressiveAccelerationEvents = 0;
    _hardBrakingEvents = 0;
    _excessiveSpeedEvents = 0;
    _stopEvents = 0;
    
    _currentTripDataPoints.clear();
  }
  
  /// Update metrics from a data point
  void _updateMetricsFromDataPoint(CombinedDrivingData dataPoint) {
    // Get speed from best available source
    final speed = dataPoint.obdData?.vehicleSpeed ?? dataPoint.sensorData?.gpsSpeed;
    
    // Update speed metrics
    if (speed != null) {
      _sumSpeed += speed;
      _speedReadingCount++;
      
      if (speed > _maxSpeedKmh) {
        _maxSpeedKmh = speed;
      }
    }
    
    // Update RPM metrics
    if (dataPoint.obdData?.rpm != null) {
      _sumRpm += dataPoint.obdData!.rpm!;
      _rpmReadingCount++;
    }
    
    // Update distance if we have a valid speed
    if (speed != null && _currentTripDataPoints.length > 1) {
      final previousDataPoint = _currentTripDataPoints[_currentTripDataPoints.length - 2];
      final previousSpeed = previousDataPoint.obdData?.vehicleSpeed ?? previousDataPoint.sensorData?.gpsSpeed;
      
      // Calculate time difference in hours
      final timeDiffMs = dataPoint.timestamp.difference(previousDataPoint.timestamp).inMilliseconds;
      final timeDiffHours = timeDiffMs / (1000 * 60 * 60);
      
      // Simple distance calculation (speed * time)
      // Using average of current and previous speed for better accuracy
      double avgSpeed = speed;
      if (previousSpeed != null) {
        avgSpeed = (speed + previousSpeed) / 2;
      }
      
      // Calculate distance for this segment in km
      final segmentDistanceKm = avgSpeed * timeDiffHours;
      _totalDistanceKm += segmentDistanceKm;
      
      // Estimate fuel consumption (very rough estimate)
      // Using a basic approximation of 8L/100km
      const fuelConsumptionRate = 8.0 / 100.0; // L/km
      _estimatedFuelUsedL += segmentDistanceKm * fuelConsumptionRate;
    }
  }
  
  /// Emit metrics update
  void _emitMetricsUpdate() {
    if (!_metricsStreamController.isClosed) {
      _metricsStreamController.add({
        'distanceKm': _totalDistanceKm,
        'averageSpeedKmh': _speedReadingCount > 0 ? _sumSpeed / _speedReadingCount : 0,
        'maxSpeedKmh': _maxSpeedKmh,
        'estimatedFuelUsedL': _estimatedFuelUsedL,
        'idlingEvents': _idlingEvents,
        'aggressiveAccelerationEvents': _aggressiveAccelerationEvents,
        'hardBrakingEvents': _hardBrakingEvents,
        'excessiveSpeedEvents': _excessiveSpeedEvents,
        'stopEvents': _stopEvents,
        'averageRPM': _rpmReadingCount > 0 ? _sumRpm / _rpmReadingCount : 0,
      });
    }
  }
  
  /// Set error message
  void _setErrorMessage(String message) {
    _errorMessage = message;
    notifyListeners();
  }
  
  /// Clear error message
  void _clearErrorMessage() {
    _errorMessage = null;
    notifyListeners();
  }
  
  /// Dispose resources
  @override
  void dispose() {
    _metricsStreamController.close();
    _tripStateController.close();
    super.dispose();
  }
} 

################################################################################
FILE: lib/services/driving/data_collection_service.dart
################################################################################

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:going50/behavior_classifier_lib/managers/eco_driving_manager.dart';
import 'package:going50/core_models/combined_driving_data.dart';
import 'package:going50/core_models/obd_II_data.dart';
import 'package:going50/core_models/phone_sensor_data.dart';
import 'package:going50/services/driving/obd_connection_service.dart';
import 'package:going50/services/driving/sensor_service.dart';
import 'package:logging/logging.dart';

/// A service that coordinates collection of driving data from OBD and sensors.
/// 
/// This service is responsible for:
/// - Combining data from multiple sources (OBD and phone sensors)
/// - Implementing data buffering for continuous operation
/// - Processing data in real-time
/// - Calculating derived metrics
class DataCollectionService extends ChangeNotifier {
  final Logger _logger = Logger('DataCollectionService');
  
  // Dependencies
  final ObdConnectionService _obdConnectionService;
  final SensorService _sensorService;
  final EcoDrivingManager _ecoDrivingManager;
  
  // Service state
  bool _isInitialized = false;
  bool _isCollecting = false;
  String? _errorMessage;
  
  // Buffering system
  final List<CombinedDrivingData> _dataBuffer = [];
  final int _maxBufferSize = 300; // ~5 minutes at 1Hz
  
  // Stream controllers
  final StreamController<CombinedDrivingData> _dataStreamController = 
      StreamController<CombinedDrivingData>.broadcast();
  
  // Background collection
  Timer? _processingTimer;
  Timer? _backgroundCollectionTimer;
  static const _backgroundCollectionIntervalMs = 1000; // 1 second
  
  // Fallback mode tracking
  bool _useFallbackMode = false;
  
  // Public getters
  bool get isInitialized => _isInitialized;
  bool get isCollecting => _isCollecting;
  String? get errorMessage => _errorMessage;
  List<CombinedDrivingData> get dataBuffer => List.unmodifiable(_dataBuffer);
  bool get useFallbackMode => _useFallbackMode;
  
  /// Stream of combined driving data
  Stream<CombinedDrivingData> get dataStream => _dataStreamController.stream;
  
  /// Constructor
  DataCollectionService(
    this._obdConnectionService,
    this._sensorService,
    this._ecoDrivingManager,
  ) {
    _logger.info('DataCollectionService initialized');
    
    // Set up OBD data stream subscription
    _obdConnectionService.dataStream.listen((data) {
      _processObdData(data);
    });
    
    // Set up sensor data stream subscription
    _sensorService.dataStream.listen((data) {
      _processSensorData(data);
    });
  }
  
  /// Initialize the data collection service
  Future<bool> initialize() async {
    if (_isInitialized) return true;
    
    _logger.info('Initializing data collection service');
    
    try {
      // Try to initialize OBD connection service, but don't fail if it doesn't work
      bool obdInitialized = false;
      if (!_obdConnectionService.isInitialized) {
        try {
          obdInitialized = await _obdConnectionService.initialize();
          if (!obdInitialized) {
            _logger.warning('OBD connection service initialization failed, will use sensor fallback mode');
            // Enable fallback mode when OBD is not available
            _useFallbackMode = true;
          }
        } catch (e) {
          _logger.warning('Error initializing OBD connection service: $e, will use sensor fallback mode');
          // Enable fallback mode when OBD is not available
          _useFallbackMode = true;
        }
      }
      
      // Initialize sensor service - this is required
      if (!_sensorService.isInitialized) {
        final sensorInitialized = await _sensorService.initialize();
        if (!sensorInitialized) {
          _setErrorMessage('Failed to initialize sensor service');
          return false;
        }
      }
      
      _isInitialized = true;
      _clearErrorMessage();
      notifyListeners();
      
      _logger.info('Data collection service initialized successfully. Using fallback mode: $_useFallbackMode');
      return true;
    } catch (e) {
      _setErrorMessage('Error initializing data collection service: $e');
      _logger.severe('Error initializing data collection service', e);
      return false;
    }
  }
  
  /// Starts data collection
  Future<bool> startCollection() async {
    if (!_isInitialized) {
      final initialized = await initialize();
      if (!initialized) return false;
    }
    
    if (_isCollecting) return true;
    
    _logger.info('Starting data collection');
    
    try {
      // Start sensor collection
      final sensorStarted = await _sensorService.startCollection();
      if (!sensorStarted) {
        _setErrorMessage('Failed to start sensor collection');
        return false;
      }
      
      // Try to start OBD collection, but don't fail if it doesn't work
      bool obdStarted = false;
      if (_obdConnectionService.isConnected) {
        try {
          await _obdConnectionService.startContinuousQueries();
          obdStarted = true;
        } catch (e) {
          _logger.warning('Failed to start OBD queries: $e');
        }
      }
      _useFallbackMode = !obdStarted;
      
      if (!obdStarted) {
        _logger.warning('OBD data collection failed, using sensor fallback mode');
      }
      
      // Set up data processing timer
      _setupProcessingTimer();
      
      // Set up background collection timer
      _setupBackgroundCollectionTimer();
      
      _isCollecting = true;
      notifyListeners();
      
      _logger.info('Data collection started successfully');
      return true;
    } catch (e) {
      _setErrorMessage('Error starting data collection: $e');
      _logger.severe('Error starting data collection', e);
      return false;
    }
  }
  
  /// Stops data collection
  Future<bool> stopCollection() async {
    if (!_isCollecting) return true;
    
    _logger.info('Stopping data collection');
    
    try {
      // Stop timers
      _processingTimer?.cancel();
      _processingTimer = null;
      
      _backgroundCollectionTimer?.cancel();
      _backgroundCollectionTimer = null;
      
      // Stop sensor collection
      _sensorService.stopCollection();
      
      // Stop OBD collection if connected
      if (_obdConnectionService.isConnected) {
        try {
          await _obdConnectionService.stopQueries();
        } catch (e) {
          _logger.warning('Failed to stop OBD queries: $e');
        }
      }
      
      // Clear buffer
      _dataBuffer.clear();
      
      _isCollecting = false;
      notifyListeners();
      
      _logger.info('Data collection stopped successfully');
      return true;
    } catch (e) {
      _setErrorMessage('Error stopping data collection: $e');
      _logger.severe('Error stopping data collection', e);
      return false;
    }
  }
  
  /// Clear the data buffer
  void clearDataBuffer() {
    _dataBuffer.clear();
    notifyListeners();
  }
  
  /// Process OBD data received from the ObdConnectionService
  void _processObdData(OBDIIData obdData) {
    // If we're not actively collecting, skip processing
    if (!_isCollecting) return;
    
    // If we're in fallback mode, ignore OBD data
    if (_useFallbackMode) return;
    
    // Create combined data point with OBD data and the latest sensor data
    final latestSensorData = _sensorService.latestSensorData;
    if (latestSensorData != null) {
      final timeDifference = DateTime.now().difference(latestSensorData.timestamp).inMilliseconds;
      
      // Only use sensor data if it's fresh (less than 500ms old)
      if (timeDifference < 500) {
        _createCombinedDataPoint(obdData, latestSensorData);
      }
    }
  }
  
  /// Process sensor data received from the SensorService
  void _processSensorData(PhoneSensorData sensorData) {
    // If we're not actively collecting, skip processing
    if (!_isCollecting) return;
    
    // If in fallback mode or OBD not connected, use sensor data only
    if (_useFallbackMode || !_obdConnectionService.isConnected) {
      _createCombinedDataPoint(null, sensorData);
      return;
    }
    
    // If OBD connected, get the latest OBD data and combine with sensor data
    OBDIIData? latestObdData = _obdConnectionService.getLatestOBDData();
    _createCombinedDataPoint(latestObdData, sensorData);
  }
  
  /// Process the latest data
  void _processData() {
    if (!_isCollecting) return;
    
    try {
      // Create a combined data point
      final obdData = _obdConnectionService.isConnected ? _obdConnectionService.getLatestOBDData() : null;
      final sensorData = _sensorService.latestSensorData;
      
      if (sensorData == null) {
        _logger.warning('No sensor data available for processing');
        return;
      }
      
      final combinedData = _createCombinedDataPoint(obdData, sensorData);
      
      // Add to buffer
      _addToDataBuffer(combinedData);
      
      // Emit data point
      _dataStreamController.add(combinedData);
      
      // Add data point to eco driving manager
      _ecoDrivingManager.addDataPoint(combinedData);
    } catch (e) {
      _logger.warning('Error processing data: $e');
    }
  }
  
  /// Collect background data
  Future<void> _collectBackgroundData() async {
    if (!_isCollecting) return;
    
    try {
      // Get the latest sensor data
      final sensorData = await _sensorService.getLatestSensorData();
      if (sensorData == null) return;
      
      // Get latest OBD data if available and not in fallback mode
      OBDIIData? obdData;
      if (!_useFallbackMode && _obdConnectionService.isConnected) {
        obdData = _obdConnectionService.getLatestOBDData();
      }
      
      // Create combined data point
      final combinedData = _createCombinedDataPoint(obdData, sensorData);
      
      // Add to buffer
      _addToDataBuffer(combinedData);
      
      // Add data point to eco driving manager
      _ecoDrivingManager.addDataPoint(combinedData);
    } catch (e) {
      _logger.warning('Error collecting background data: $e');
    }
  }
  
  /// Create combined data point from OBD and sensor data
  CombinedDrivingData _createCombinedDataPoint(OBDIIData? obdData, PhoneSensorData sensorData) {
    // Create and return the combined data
    return CombinedDrivingData.combine(
      timestamp: DateTime.now(),
      obdData: obdData,
      sensorData: sensorData,
    );
  }
  
  /// Setup the timer for processing data
  void _setupProcessingTimer() {
    _processingTimer?.cancel();
    _processingTimer = Timer.periodic(
      const Duration(milliseconds: 200), 
      (_) => _processData()
    );
  }
  
  /// Setup the timer for background collection (when app in background)
  void _setupBackgroundCollectionTimer() {
    _backgroundCollectionTimer?.cancel();
    _backgroundCollectionTimer = Timer.periodic(
      const Duration(milliseconds: _backgroundCollectionIntervalMs), 
      (_) => _collectBackgroundData()
    );
  }
  
  /// Enable fallback mode to use only sensor data
  void enableFallbackMode() {
    if (_useFallbackMode) return;
    
    _logger.info('Enabling sensor fallback mode');
    _useFallbackMode = true;
    notifyListeners();
  }
  
  /// Attempt to use OBD data if available
  Future<bool> tryUseObdMode() async {
    if (!_useFallbackMode) return true;
    
    _logger.info('Attempting to exit fallback mode');
    
    // Check if OBD is connected
    if (!_obdConnectionService.isConnected) {
      _logger.info('OBD not connected, staying in fallback mode');
      return false;
    }
    
    _useFallbackMode = false;
    notifyListeners();
    return true;
  }
  
  /// Add data to the buffer with overflow protection
  void _addToDataBuffer(CombinedDrivingData data) {
    _dataBuffer.add(data);
    
    // Truncate buffer if it's too large
    while (_dataBuffer.length > _maxBufferSize) {
      _dataBuffer.removeAt(0);
    }
  }
  
  /// Set error message
  void _setErrorMessage(String message) {
    _errorMessage = message;
    _logger.warning(message);
    notifyListeners();
  }
  
  /// Clear error message
  void _clearErrorMessage() {
    _errorMessage = null;
  }
  
  /// Clean up resources
  @override
  void dispose() {
    _logger.info('Disposing data collection service');
    
    // Stop collection if running
    if (_isCollecting) {
      stopCollection();
    }
    
    // Close stream controller
    _dataStreamController.close();
    
    super.dispose();
  }
} 

################################################################################
FILE: lib/services/driving/obd_connection_service.dart
################################################################################

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:going50/core/utils/device_utils.dart';
import 'package:going50/core_models/obd_II_data.dart';
import 'package:going50/obd_lib/obd_service.dart';
import 'package:going50/obd_lib/models/bluetooth_device.dart';
import 'package:going50/obd_lib/models/obd_data.dart';
import 'package:going50/obd_lib/protocol/obd_constants.dart';
import 'package:going50/services/permission_service.dart';
import 'package:going50/services/service_locator.dart';
import 'package:logging/logging.dart';

/// A service that manages the connection to the OBD device and provides
/// an interface for retrieving vehicle data.
/// Falls back to sensor data if OBD connection is lost.
class ObdConnectionService extends ChangeNotifier {
  final Logger _logger = Logger('ObdConnectionService');
  final ObdService _obdService;
  late final PermissionService _permissionService;
  
  // Connection state
  bool _isInitialized = false;
  bool _isScanning = false;
  bool _isConnecting = false;
  String? _currentDeviceId;
  String? _errorMessage;
  
  // Store the latest OBD data
  final Map<String, OBDIIData> _latestObdData = {};
  
  // Create stream controllers for observables
  final StreamController<List<BluetoothDevice>> _deviceStreamController = 
      StreamController<List<BluetoothDevice>>.broadcast();
  final StreamController<OBDIIData> _dataStreamController = 
      StreamController<OBDIIData>.broadcast();
  
  // Stale data handling
  DateTime? _lastDataTimestamp;
  static const _dataStaleThresholdMs = 5000; // 5 seconds
  Timer? _staleDataTimer;
  
  // Public getters
  bool get isInitialized => _isInitialized;
  bool get isScanning => _isScanning;
  bool get isConnecting => _isConnecting;
  bool get isConnected => _obdService.isConnected;
  bool get isEngineRunning => _obdService.isEngineRunning;
  String? get currentDeviceId => _currentDeviceId;
  String? get errorMessage => _errorMessage;
  
  /// Stream of discovered Bluetooth devices
  Stream<List<BluetoothDevice>> get deviceStream => _deviceStreamController.stream;
  
  /// Stream of OBD data
  Stream<OBDIIData> get dataStream => _dataStreamController.stream;
  
  /// Constructor
  ObdConnectionService(this._obdService) {
    _logger.info('ObdConnectionService initialized');
    _permissionService = serviceLocator<PermissionService>();
  }
  
  /// Initialize the OBD connection service
  Future<bool> initialize() async {
    if (_isInitialized) return true;
    
    _logger.info('Initializing OBD connection service');
    
    try {
      // Check if device supports Bluetooth
      final hasBluetoothSupport = await DeviceUtils.hasBluetoothSupport();
      if (!hasBluetoothSupport) {
        _setErrorMessage('Device does not support Bluetooth');
        return false;
      }
      
      // Check for required permissions
      final hasBluetoothPermissions = await _permissionService.areBluetoothPermissionsGranted();
      final hasLocationPermissions = await _permissionService.areLocationPermissionsGranted();
      
      if (!hasBluetoothPermissions || !hasLocationPermissions) {
        _logger.info('Requesting Bluetooth and location permissions');
        
        // Request Bluetooth permissions
        if (!hasBluetoothPermissions) {
          await _permissionService.requestBluetoothPermissions();
          
          // Check again if permissions were granted
          final bluetoothGranted = await _permissionService.areBluetoothPermissionsGranted();
          if (!bluetoothGranted) {
            _setErrorMessage('Bluetooth permissions required for OBD connection');
            return false;
          }
        }
        
        // Request location permissions
        if (!hasLocationPermissions) {
          await _permissionService.requestLocationPermissions(background: false);
          
          // Check again if permissions were granted
          final locationGranted = await _permissionService.areLocationPermissionsGranted();
          if (!locationGranted) {
            _setErrorMessage('Location permission required for OBD connection');
            return false;
          }
        }
      }
      
      // Check if Bluetooth is enabled
      final isBluetoothEnabled = await DeviceUtils.isBluetoothEnabled();
      if (!isBluetoothEnabled) {
        _setErrorMessage('Bluetooth is not enabled');
        return false;
      }
      
      _isInitialized = true;
      _clearErrorMessage();
      notifyListeners();
      return true;
    } catch (e) {
      _setErrorMessage('Failed to initialize: $e');
      _logger.severe('Initialization error: $e');
      return false;
    }
  }
  
  /// Start scanning for OBD devices
  Future<bool> startScan() async {
    if (!_isInitialized) {
      final initialized = await initialize();
      if (!initialized) return false;
    }
    
    if (_isScanning) return true;
    
    _logger.info('Starting scan for OBD devices');
    
    try {
      _isScanning = true;
      _clearErrorMessage();
      notifyListeners();
      
      // Clear any previous scan results
      List<BluetoothDevice> discoveredDevices = [];
      
      // Start device scan
      _obdService.scanForDevices().listen(
        (device) {
          _logger.fine('Found device: ${device.name} (${device.id})');
          
          // Add device to list if not already present
          if (!discoveredDevices.any((d) => d.id == device.id)) {
            discoveredDevices.add(device);
            _deviceStreamController.add(List.from(discoveredDevices));
          }
        },
        onError: (e) {
          _setErrorMessage('Error scanning: $e');
          _isScanning = false;
          notifyListeners();
        },
        onDone: () {
          _isScanning = false;
          notifyListeners();
        }
      );
      
      return true;
    } catch (e) {
      _setErrorMessage('Failed to start scan: $e');
      _logger.severe('Scan error: $e');
      _isScanning = false;
      notifyListeners();
      return false;
    }
  }
  
  /// Stop scanning for OBD devices
  void stopScan() {
    if (!_isScanning) return;
    
    _logger.info('Stopping device scan');
    
    // Call the OBD service's method to stop scanning
    try {
      _obdService.stopScan();
    } catch (e) {
      _logger.warning('Error stopping scan: $e');
    }
    
    _isScanning = false;
    notifyListeners();
  }
  
  /// Connect to an OBD device
  Future<bool> connectToDevice(String deviceId) async {
    if (!_isInitialized) {
      final initialized = await initialize();
      if (!initialized) return false;
    }
    
    if (_isConnecting) return false;
    if (_obdService.isConnected && deviceId == _currentDeviceId) return true;
    
    _logger.info('Connecting to OBD device: $deviceId');
    
    try {
      _isConnecting = true;
      _clearErrorMessage();
      notifyListeners();
      
      // Disconnect from current device if connected
      if (_obdService.isConnected) {
        _obdService.disconnect();
      }
      
      // Connect to the new device
      final connected = await _obdService.connect(deviceId);
      
      if (connected) {
        _logger.info('Successfully connected to device: $deviceId');
        _currentDeviceId = deviceId;
        
        // Start continuous queries
        await _obdService.startContinuousQueries();
        
        // Start a timer to check for stale data
        _setupStaleDataTimer();
        
        // Listen for changes in the OBD service
        _obdService.addListener(_onObdServiceChanged);
      } else {
        _setErrorMessage('Failed to connect to device');
        _logger.warning('Failed to connect to device: $deviceId');
      }
      
      _isConnecting = false;
      notifyListeners();
      return connected;
    } catch (e) {
      _setErrorMessage('Connection error: $e');
      _logger.severe('Error connecting to device: $e');
      _isConnecting = false;
      _currentDeviceId = null;
      notifyListeners();
      return false;
    }
  }
  
  /// Disconnect from the current OBD device
  Future<bool> disconnect() async {
    if (!_obdService.isConnected) return true;
    
    _logger.info('Disconnecting from OBD device');
    
    try {
      // Stop the stale data timer
      _cancelStaleDataTimer();
      
      // Remove the OBD service listener
      _obdService.removeListener(_onObdServiceChanged);
      
      // Stop continuous queries
      await _obdService.stopQueries();
      
      // Disconnect from the device
      _obdService.disconnect();
      
      _currentDeviceId = null;
      notifyListeners();
      return true;
    } catch (e) {
      _setErrorMessage('Disconnect error: $e');
      _logger.severe('Error disconnecting: $e');
      return false;
    }
  }
  
  /// Start continuous queries to get OBD data
  Future<bool> startContinuousQueries() async {
    if (!_obdService.isConnected) {
      _logger.warning('Cannot start continuous queries: No OBD device connected');
      return false;
    }
    
    try {
      await _obdService.startContinuousQueries();
      _logger.info('Continuous queries started successfully');
      return true;
    } catch (e) {
      _setErrorMessage('Failed to start continuous queries: $e');
      _logger.severe('Error starting continuous queries', e);
      return false;
    }
  }
  
  /// Stop continuous queries
  Future<bool> stopQueries() async {
    if (!_obdService.isConnected) return true;
    
    try {
      await _obdService.stopQueries();
      _logger.info('Queries stopped successfully');
      return true;
    } catch (e) {
      _setErrorMessage('Failed to stop queries: $e');
      _logger.severe('Error stopping queries', e);
      return false;
    }
  }
  
  /// Get the latest OBD data
  OBDIIData? getLatestOBDData() {
    if (!_obdService.isConnected || _latestObdData.isEmpty) {
      return null;
    }
    
    // Get the most recent data point
    final sortedKeys = _latestObdData.keys.toList()
      ..sort((a, b) => DateTime.parse(b).compareTo(DateTime.parse(a)));
    
    return _latestObdData[sortedKeys.first];
  }
  
  /// Get a list of available adapter profiles
  List<Map<String, String>> getAvailableProfiles() {
    return _obdService.getAvailableProfiles();
  }
  
  /// Set a specific adapter profile to be used
  void setAdapterProfile(String profileId) {
    _obdService.setAdapterProfile(profileId);
  }
  
  /// Clear manual profile selection and enable automatic profile detection
  void enableAutomaticProfileDetection() {
    _obdService.enableAutomaticProfileDetection();
  }
  
  /// Request a specific PID from the OBD adapter
  Future<OBDIIData?> requestPid(String pid) async {
    if (!_obdService.isConnected) {
      return null;
    }
    
    try {
      final data = await _obdService.requestPid(pid);
      if (data != null) {
        final obdIIData = _convertToObdIIData(data);
        return obdIIData;
      }
      return null;
    } catch (e) {
      _logger.warning('Error requesting PID $pid: $e');
      return null;
    }
  }
  
  /// Convert ObdData to OBDIIData
  OBDIIData _convertToObdIIData(ObdData obdData) {
    // Create OBDIIData object with the data from the OBD adapter
    final timestamp = DateTime.now();
    
    // Map specific PIDs to their corresponding fields in OBDIIData
    double? speed;
    int? rpm;
    double? throttlePosition;
    double? engineTemp;
    double? engineLoad;
    double? mafRate;
    
    // Enhance logging for debugging
    _logger.info('Converting OBD data: PID=${obdData.pid}, value=${obdData.value}, rawData=${obdData.rawData}');
    
    // Extract values based on PID type with enhanced error handling and fallbacks
    if (obdData.pid == ObdConstants.pidVehicleSpeed) {
      // Try the normal parsing first
      try {
        speed = double.tryParse(obdData.value.toString());
        
        // Check if we got a valid speed value
        if (speed == null) {
          _logger.warning('Failed to parse speed value: ${obdData.value}');
          
          // If raw data is available, try direct byte extraction
          if (obdData.rawData != null && obdData.rawData!.isNotEmpty) {
            // Use the first byte directly as speed value (standard OBD-II protocol)
            speed = obdData.rawData!.first * 4.0; // Apply 4x multiplier to address scaling issue
            _logger.info('Using raw byte for speed calculation: ${obdData.rawData!.first} * 4 = $speed km/h');
          }
        } else {
          // Apply scaling correction to parsed value too
          speed = speed * 4.0; // Apply 4x multiplier
          _logger.info('Applied 4x scaling to parsed speed: $speed km/h');
        }
      } catch (e) {
        _logger.severe('Error processing speed data: $e');
      }
    } else if (obdData.pid == ObdConstants.pidEngineRpm) {
      // Try normal parsing first
      try {
        rpm = int.tryParse(obdData.value.toString());
        
        // Check if we got a valid RPM value
        if (rpm == null) {
          _logger.warning('Failed to parse RPM value: ${obdData.value}');
          
          // If raw data is available, try direct byte extraction
          if (obdData.rawData != null && obdData.rawData!.length >= 2) {
            // Standard OBD-II formula: ((A * 256) + B) / 4
            final a = obdData.rawData![0];
            final b = obdData.rawData![1];
            rpm = (((a * 256) + b) / 4).round();
            _logger.info('Using raw bytes for RPM calculation: ((${a} * 256) + ${b}) / 4 = $rpm RPM');
          } else if (obdData.rawData != null && obdData.rawData!.length == 1) {
            // Some adapters send single-byte RPM, try a different formula
            rpm = (obdData.rawData!.first * 40).round(); // Alternative calculation for single byte
            _logger.info('Using single raw byte for RPM: ${obdData.rawData!.first} * 40 = $rpm RPM');
          }
        }
        
        // Some adapters report very high RPM values that need to be adjusted
        if (rpm != null && rpm > 16000) {
          _logger.warning('Unreasonably high RPM: $rpm, dividing by 4');
          rpm = (rpm / 4).round(); // Division by 4 works for some adapters
        }
      } catch (e) {
        _logger.severe('Error processing RPM data: $e');
      }
    } else if (obdData.pid == ObdConstants.pidThrottlePosition) {
      throttlePosition = double.tryParse(obdData.value.toString());
    } else if (obdData.pid == ObdConstants.pidCoolantTemp) {
      engineTemp = double.tryParse(obdData.value.toString());
    } else if (obdData.pid == ObdConstants.pidEngineLoad) {
      engineLoad = double.tryParse(obdData.value.toString());
    }
    
    // Emergency fallback for missing RPM
    if (rpm == null && obdData.pid == ObdConstants.pidEngineRpm && obdData.rawData != null) {
      _logger.warning('Emergency RPM parsing from raw bytes: ${obdData.rawData}');
      
      // Try several approaches to extract a sensible RPM value
      if (obdData.rawData!.length >= 2) {
        final rawData = obdData.rawData!;
        
        // Try multiple calculation methods and use the most reasonable
        final options = [
          (((rawData[0] * 256) + rawData[1]) / 4).round(),  // Standard
          (rawData[0] * 40).round(),                        // Alternative A
          (rawData[1] * 40).round(),                        // Alternative B
          ((rawData[0] * 256) + rawData[1]).round(),        // No division
          (((rawData[0] * 256) + rawData[1]) / 16).round(), // Division by 16
        ];
        
        // Find the first value in a reasonable range (500-8000 RPM)
        for (final option in options) {
          if (option >= 500 && option <= 8000) {
            rpm = option;
            _logger.info('Emergency RPM calculation selected value: $rpm');
            break;
          }
        }
        
        // If no reasonable value found, use the first option
        if (rpm == null) {
          rpm = options[0];
          _logger.warning('No reasonable RPM found, using first calculation: $rpm');
        }
      }
    }
    
    // Log the final converted values
    _logger.info('Final conversion results: speed=$speed km/h, rpm=$rpm');
    
    // Create the OBDIIData object
    final obdIIData = OBDIIData(
      timestamp: timestamp,
      vehicleSpeed: speed,
      rpm: rpm,
      throttlePosition: throttlePosition,
      engineRunning: rpm != null && rpm > 0,
      engineTemp: engineTemp,
      engineLoad: engineLoad,
      mafRate: mafRate,
    );
    
    // Store this as the latest data
    _latestObdData[timestamp.toIso8601String()] = obdIIData;
    
    // Update last data timestamp
    _lastDataTimestamp = timestamp;
    
    // Send to the data stream
    _dataStreamController.add(obdIIData);
    
    return obdIIData;
  }
  
  /// Callback for changes in the OBD service
  void _onObdServiceChanged() {
    // Send notification about the OBD service state change
    notifyListeners();
    
    // Get the latest data from the OBD service
    if (_obdService.isConnected) {
      final latestData = _obdService.latestData;
      
      if (latestData.isNotEmpty) {
        // Process each PID data
        for (final entry in latestData.entries) {
          final obdData = entry.value;
          // Call the convert method without using its return value
          _convertToObdIIData(obdData);
        }
      }
    }
  }
  
  /// Set up a timer to check for stale data
  void _setupStaleDataTimer() {
    // Cancel any existing timer
    _cancelStaleDataTimer();
    
    // Create a new timer
    _staleDataTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_lastDataTimestamp != null) {
        final now = DateTime.now();
        final diff = now.difference(_lastDataTimestamp!).inMilliseconds;
        
        if (diff > _dataStaleThresholdMs) {
          _logger.warning('Data is stale (${diff}ms since last update)');
          
          // Optionally, try to recover the connection
          // This could be implemented with a reconnection strategy
        }
      }
    });
  }
  
  /// Cancel the stale data timer
  void _cancelStaleDataTimer() {
    _staleDataTimer?.cancel();
    _staleDataTimer = null;
  }
  
  /// Set an error message
  void _setErrorMessage(String message) {
    _errorMessage = message;
    _logger.warning(message);
  }
  
  /// Clear the error message
  void _clearErrorMessage() {
    _errorMessage = null;
  }
  
  /// Override the dispose method to clean up resources
  @override
  void dispose() {
    _logger.info('Disposing OBD connection service');
    
    // Disconnect if connected
    if (isConnected) {
      disconnect();
    }
    
    // Close stream controllers
    _deviceStreamController.close();
    _dataStreamController.close();
    
    // Cancel stale data timer
    _staleDataTimer?.cancel();
    
    super.dispose();
  }
} 

################################################################################
FILE: lib/services/driving/performance_metrics_service.dart
################################################################################

import 'dart:async';
import 'dart:math' as math;
import 'package:logging/logging.dart';

import '../../core_models/trip.dart';
import '../../data_lib/data_storage_manager.dart';

/// Service responsible for calculating and managing performance metrics
/// for eco-driving behavior analysis over different time periods.
class PerformanceMetricsService {
  final DataStorageManager _dataStorageManager;
  final Logger _logger = Logger('PerformanceMetricsService');
  
  // Cache for recently calculated metrics to reduce database hits
  final Map<String, PerformanceMetrics> _metricsCache = {};
  
  // Constants for savings calculations
  static const double _averageFuelPricePerLiter = 1.5; // Example value in USD
  static const double _kgCO2PerLiterFuel = 2.31; // Average CO2 emissions per liter of gasoline
  
  /// Creates a new PerformanceMetricsService instance
  PerformanceMetricsService(this._dataStorageManager);
  
  /// Gets performance metrics for a specific time period
  /// 
  /// [periodStart] is the start of the period
  /// [periodEnd] is the end of the period
  /// Returns a Future that completes with the calculated performance metrics
  Future<PerformanceMetrics> getMetricsForPeriod(
    DateTime periodStart, 
    DateTime periodEnd,
    {String? userId}
  ) async {
    // Generate a cache key based on period and user
    final cacheKey = '${userId ?? 'default'}_${periodStart.toIso8601String()}_${periodEnd.toIso8601String()}';
    
    // Check if we have cached metrics for this period
    if (_metricsCache.containsKey(cacheKey)) {
      return _metricsCache[cacheKey]!;
    }
    
    try {
      // Get all trips within the period
      final trips = await _dataStorageManager.getAllTrips();
      final periodTrips = trips.where((trip) {
        // Filter trips within the period
        return trip.startTime.isAfter(periodStart) &&
               trip.endTime != null &&
               trip.endTime!.isBefore(periodEnd) &&
               trip.isCompleted == true;
      }).toList();
      
      if (periodTrips.isEmpty) {
        // Return empty metrics if no trips found
        final emptyMetrics = PerformanceMetrics(
          userId: userId,
          generatedAt: DateTime.now(),
          periodStart: periodStart,
          periodEnd: periodEnd,
          totalTrips: 0,
          totalDistanceKm: 0,
          totalDrivingTimeMinutes: 0,
          calmDrivingScore: 0,
          efficientAccelerationScore: 0,
          efficientBrakingScore: 0,
          idlingScore: 0,
          speedOptimizationScore: 0,
          steadySpeedScore: 0,
          overallScore: 0,
          improvementTipsJson: '{"tips":[]}',
        );
        
        _metricsCache[cacheKey] = emptyMetrics;
        return emptyMetrics;
      }
      
      // Calculate metrics based on trips
      final metrics = await _calculateMetricsFromTrips(periodTrips);
      
      // Generate improvement tips based on metrics
      final improvementTips = _generateImprovementTips(metrics);
      
      // Create the final performance metrics object
      final performanceMetrics = PerformanceMetrics(
        userId: userId,
        generatedAt: DateTime.now(),
        periodStart: periodStart,
        periodEnd: periodEnd,
        totalTrips: periodTrips.length,
        totalDistanceKm: metrics['totalDistanceKm'] ?? 0,
        totalDrivingTimeMinutes: metrics['totalDrivingTimeMinutes'] ?? 0,
        calmDrivingScore: metrics['calmDrivingScore'] ?? 0,
        efficientAccelerationScore: metrics['efficientAccelerationScore'] ?? 0,
        efficientBrakingScore: metrics['efficientBrakingScore'] ?? 0,
        idlingScore: metrics['idlingScore'] ?? 0,
        speedOptimizationScore: metrics['speedOptimizationScore'] ?? 0,
        steadySpeedScore: metrics['steadySpeedScore'] ?? 0,
        overallScore: metrics['overallScore'] ?? 0,
        improvementTipsJson: improvementTips,
      );
      
      // Cache the metrics
      _metricsCache[cacheKey] = performanceMetrics;
      
      return performanceMetrics;
    } catch (e, stackTrace) {
      _logger.severe('Error calculating performance metrics', e, stackTrace);
      rethrow;
    }
  }
  
  /// Calculates daily metrics for a specific date
  Future<PerformanceMetrics> getDailyMetrics(DateTime date, {String? userId}) {
    final startOfDay = DateTime(date.year, date.month, date.day);
    final endOfDay = DateTime(date.year, date.month, date.day, 23, 59, 59);
    return getMetricsForPeriod(startOfDay, endOfDay, userId: userId);
  }
  
  /// Calculates weekly metrics for a week containing the specified date
  Future<PerformanceMetrics> getWeeklyMetrics(DateTime date, {String? userId}) {
    // Get the start of the week (assuming Monday is the first day)
    final startOfWeek = date.subtract(Duration(days: date.weekday - 1));
    final normalizedStart = DateTime(startOfWeek.year, startOfWeek.month, startOfWeek.day);
    
    // Get the end of the week (Sunday)
    final endOfWeek = normalizedStart.add(const Duration(days: 6, hours: 23, minutes: 59, seconds: 59));
    
    return getMetricsForPeriod(normalizedStart, endOfWeek, userId: userId);
  }
  
  /// Calculates monthly metrics for a month containing the specified date
  Future<PerformanceMetrics> getMonthlyMetrics(DateTime date, {String? userId}) {
    // First day of the month
    final startOfMonth = DateTime(date.year, date.month, 1);
    
    // Last day of the month
    final lastDay = (date.month < 12) 
        ? DateTime(date.year, date.month + 1, 0)
        : DateTime(date.year + 1, 1, 0);
    
    final endOfMonth = DateTime(lastDay.year, lastDay.month, lastDay.day, 23, 59, 59);
    
    return getMetricsForPeriod(startOfMonth, endOfMonth, userId: userId);
  }
  
  /// Calculates yearly metrics for the year containing the specified date
  Future<PerformanceMetrics> getYearlyMetrics(DateTime date, {String? userId}) {
    final startOfYear = DateTime(date.year, 1, 1);
    final endOfYear = DateTime(date.year, 12, 31, 23, 59, 59);
    
    return getMetricsForPeriod(startOfYear, endOfYear, userId: userId);
  }
  
  /// Gets trend data for a specific metric over time
  /// 
  /// [metricType] is the type of metric to get trend data for
  /// [startDate] is the start of the trend period
  /// [endDate] is the end of the trend period
  /// [interval] defines the granularity (daily, weekly, monthly)
  /// Returns a map of dates to metric values
  Future<Map<DateTime, double>> getTrendData(
    String metricType,
    DateTime startDate,
    DateTime endDate,
    {required String interval, String? userId}
  ) async {
    final result = <DateTime, double>{};
    
    try {
      if (interval == 'daily') {
        // Daily intervals
        var currentDate = DateTime(startDate.year, startDate.month, startDate.day);
        while (currentDate.isBefore(endDate) || currentDate.isAtSameMomentAs(endDate)) {
          final metrics = await getDailyMetrics(currentDate, userId: userId);
          result[currentDate] = _getMetricValueByType(metrics, metricType);
          currentDate = currentDate.add(const Duration(days: 1));
        }
      } else if (interval == 'weekly') {
        // Weekly intervals
        var currentDate = startDate.subtract(Duration(days: startDate.weekday - 1));
        currentDate = DateTime(currentDate.year, currentDate.month, currentDate.day);
        
        while (currentDate.isBefore(endDate)) {
          final metrics = await getWeeklyMetrics(currentDate, userId: userId);
          result[currentDate] = _getMetricValueByType(metrics, metricType);
          currentDate = currentDate.add(const Duration(days: 7));
        }
      } else if (interval == 'monthly') {
        // Monthly intervals
        var currentMonth = DateTime(startDate.year, startDate.month, 1);
        
        while (currentMonth.isBefore(endDate) || 
              (currentMonth.year == endDate.year && currentMonth.month == endDate.month)) {
          final metrics = await getMonthlyMetrics(currentMonth, userId: userId);
          result[currentMonth] = _getMetricValueByType(metrics, metricType);
          
          // Move to next month
          if (currentMonth.month == 12) {
            currentMonth = DateTime(currentMonth.year + 1, 1, 1);
          } else {
            currentMonth = DateTime(currentMonth.year, currentMonth.month + 1, 1);
          }
        }
      }
      
      return result;
    } catch (e, stackTrace) {
      _logger.severe('Error getting trend data', e, stackTrace);
      rethrow;
    }
  }
  
  /// Gets the latest performance metrics for a user
  /// This is used for achievement verification
  Future<Map<String, dynamic>?> getUserPerformanceMetrics(String userId) async {
    _logger.info('Getting performance metrics for user $userId');
    
    try {
      // Get the latest metrics for the user (last 90 days)
      final endDate = DateTime.now();
      final startDate = endDate.subtract(const Duration(days: 90));
      
      final metrics = await getMetricsForPeriod(startDate, endDate, userId: userId);
      
      // Convert to a map for easier use in achievement checking
      final metricsMap = <String, dynamic>{
        'overallScore': metrics.overallScore,
        'calmDrivingScore': metrics.calmDrivingScore,
        'efficientAccelerationScore': metrics.efficientAccelerationScore,
        'efficientBrakingScore': metrics.efficientBrakingScore,
        'idlingScore': metrics.idlingScore,
        'speedOptimizationScore': metrics.speedOptimizationScore,
        'steadySpeedScore': metrics.steadySpeedScore,
        'totalTrips': metrics.totalTrips,
        'totalDistanceKm': metrics.totalDistanceKm,
        'totalDrivingTimeMinutes': metrics.totalDrivingTimeMinutes,
      };
      
      // Get additional metrics from the database
      final additionalMetrics = await _dataStorageManager.getUserMetrics(userId);
      if (additionalMetrics != null) {
        metricsMap.addAll(additionalMetrics);
      }
      
      return metricsMap;
    } catch (e) {
      _logger.severe('Error getting user performance metrics: $e');
      return null;
    }
  }
  
  /// Calculates projected savings based on current performance metrics
  /// 
  /// [currentMetrics] is the current performance metrics
  /// [projectionMonths] is the number of months to project
  /// Returns a map with projected savings values
  Map<String, double> calculateProjectedSavings(
    PerformanceMetrics currentMetrics,
    int projectionMonths,
  ) {
    // No projection if no trips or distance
    if (currentMetrics.totalTrips == 0 || currentMetrics.totalDistanceKm == 0) {
      return {
        'fuelSavingsL': 0,
        'moneySavingsUSD': 0,
        'co2SavingsKg': 0,
      };
    }
    
    // Calculate the time period of the metrics in days
    final periodDays = currentMetrics.periodEnd.difference(currentMetrics.periodStart).inDays + 1;
    
    // Calculate average distance per day
    final averageDistancePerDay = currentMetrics.totalDistanceKm / periodDays;
    
    // Calculate projected distance for the projection period
    final projectedDistanceKm = averageDistancePerDay * 30 * projectionMonths;
    
    // Calculate fuel savings based on eco-score
    // Assuming linear relationship between eco-score and fuel savings
    // 0 eco-score = 0% savings, 100 eco-score = 25% savings
    final potentialSavingsPercentage = (currentMetrics.overallScore / 100) * 0.25;
    
    // Assume average fuel consumption of 7.5L/100km for a typical car
    const baselineFuelConsumption = 7.5; // L/100km
    
    // Calculate baseline fuel usage and potential savings
    final baselineFuelUsage = (projectedDistanceKm / 100) * baselineFuelConsumption;
    final fuelSavingsL = baselineFuelUsage * potentialSavingsPercentage;
    
    // Calculate money savings
    final moneySavingsUSD = fuelSavingsL * _averageFuelPricePerLiter;
    
    // Calculate CO2 savings
    final co2SavingsKg = fuelSavingsL * _kgCO2PerLiterFuel;
    
    return {
      'fuelSavingsL': fuelSavingsL,
      'moneySavingsUSD': moneySavingsUSD,
      'co2SavingsKg': co2SavingsKg,
    };
  }
  
  /// Clears the metrics cache
  void clearCache() {
    _metricsCache.clear();
  }
  
  /// Calculates detailed metrics from a list of trips
  Future<Map<String, double>> _calculateMetricsFromTrips(List<Trip> trips) async {
    final result = <String, double>{};
    
    // Initialize accumulators
    double totalDistanceKm = 0;
    double totalDrivingTimeMinutes = 0;
    int aggressiveAccelerationEventsCount = 0;
    int hardBrakingEventsCount = 0;
    int idlingEventsCount = 0;
    int excessiveSpeedEventsCount = 0;
    double totalAverageRPM = 0;
    
    // Process each trip
    for (final trip in trips) {
      // Accumulate distance
      totalDistanceKm += trip.distanceKm ?? 0;
      
      // Calculate driving time
      if (trip.endTime != null) {
        final drivingTimeMinutes = trip.endTime!.difference(trip.startTime).inMinutes;
        totalDrivingTimeMinutes += drivingTimeMinutes;
      }
      
      // Accumulate events
      aggressiveAccelerationEventsCount += trip.aggressiveAccelerationEvents ?? 0;
      hardBrakingEventsCount += trip.hardBrakingEvents ?? 0;
      idlingEventsCount += trip.idlingEvents ?? 0;
      excessiveSpeedEventsCount += trip.excessiveSpeedEvents ?? 0;
      
      // Accumulate RPM if available
      if (trip.averageRPM != null) {
        totalAverageRPM += trip.averageRPM!;
      }
      
      // Accumulate eco scores (assuming trip.ecoScore exists)
      // If it doesn't, you can adjust this or create a calculation for it
      // We'll skip this for now
    }
    
    // Calculate averages and scores
    final avgRPM = trips.isNotEmpty ? totalAverageRPM / trips.length : 0;
    
    // Calculate events per 100km for normalization
    final eventsPer100Km = totalDistanceKm > 0 ? 100 / totalDistanceKm : 0;
    final aggressiveAccelPer100Km = aggressiveAccelerationEventsCount * eventsPer100Km;
    final hardBrakingPer100Km = hardBrakingEventsCount * eventsPer100Km;
    final idlingPer100Km = idlingEventsCount * eventsPer100Km;
    final excessiveSpeedPer100Km = excessiveSpeedEventsCount * eventsPer100Km;
    
    // Calculate individual scores (inverting event counts, more events = lower score)
    // Using exponential decay function: score = 100 * e^(-k * events_per_100km)
    // where k is a calibration constant
    const kAccel = 0.3;
    const kBraking = 0.3;
    const kIdling = 0.2;
    const kSpeed = 0.15;
    
    final efficientAccelerationScore = 100 * math.exp(-kAccel * aggressiveAccelPer100Km);
    final efficientBrakingScore = 100 * math.exp(-kBraking * hardBrakingPer100Km);
    final idlingScore = 100 * math.exp(-kIdling * idlingPer100Km);
    final speedOptimizationScore = 100 * math.exp(-kSpeed * excessiveSpeedPer100Km);
    
    // Calculate calm driving score (combination of acceleration and braking)
    final calmDrivingScore = (efficientAccelerationScore + efficientBrakingScore) / 2;
    
    // Calculate steady speed score based on speed events and RPM
    // Normalize RPM score (assuming ideal RPM is around 1800)
    const idealRPM = 1800;
    final rpmDeviation = (avgRPM - idealRPM).abs() / idealRPM;
    final rpmScore = 100 * math.exp(-2 * rpmDeviation); // Exponential penalty for deviation
    
    final steadySpeedScore = (rpmScore + speedOptimizationScore) / 2;
    
    // Calculate overall score with weighted components
    const weightCalmDriving = 0.25;
    const weightEfficientAccel = 0.15;
    const weightEfficientBraking = 0.15;
    const weightIdling = 0.15;
    const weightSpeedOpt = 0.15;
    const weightSteadySpeed = 0.15;
    
    final overallScore = 
        calmDrivingScore * weightCalmDriving +
        efficientAccelerationScore * weightEfficientAccel +
        efficientBrakingScore * weightEfficientBraking +
        idlingScore * weightIdling +
        speedOptimizationScore * weightSpeedOpt +
        steadySpeedScore * weightSteadySpeed;
    
    // Store results
    result['totalDistanceKm'] = totalDistanceKm;
    result['totalDrivingTimeMinutes'] = totalDrivingTimeMinutes;
    result['calmDrivingScore'] = calmDrivingScore;
    result['efficientAccelerationScore'] = efficientAccelerationScore;
    result['efficientBrakingScore'] = efficientBrakingScore;
    result['idlingScore'] = idlingScore;
    result['speedOptimizationScore'] = speedOptimizationScore;
    result['steadySpeedScore'] = steadySpeedScore;
    result['overallScore'] = overallScore;
    
    return result;
  }
  
  /// Generates improvement tips based on metrics
  String _generateImprovementTips(Map<String, double> metrics) {
    final tips = <Map<String, dynamic>>[];
    
    // Find the lowest scoring metrics (areas for improvement)
    final scoredMetrics = <String, double>{
      'calmDriving': metrics['calmDrivingScore'] ?? 0,
      'efficientAcceleration': metrics['efficientAccelerationScore'] ?? 0,
      'efficientBraking': metrics['efficientBrakingScore'] ?? 0,
      'idling': metrics['idlingScore'] ?? 0,
      'speedOptimization': metrics['speedOptimizationScore'] ?? 0,
      'steadySpeed': metrics['steadySpeedScore'] ?? 0,
    };
    
    // Sort by score (ascending)
    final sortedMetrics = scoredMetrics.entries.toList()
      ..sort((a, b) => a.value.compareTo(b.value));
    
    // Generate tips for the three lowest scores
    for (var i = 0; i < math.min(3, sortedMetrics.length); i++) {
      final metricKey = sortedMetrics[i].key;
      final score = sortedMetrics[i].value;
      
      // Only generate tips for scores below 80
      if (score >= 80) continue;
      
      // Generate specific tips based on the metric
      switch (metricKey) {
        case 'calmDriving':
          tips.add({
            'area': 'Calm Driving',
            'score': score.round(),
            'tip': 'Try to maintain a more relaxed driving style. Anticipate traffic flow to avoid sudden reactions.',
            'benefit': 'Reduces stress, fuel consumption, and wear on your vehicle.'
          });
          break;
        
        case 'efficientAcceleration':
          tips.add({
            'area': 'Acceleration',
            'score': score.round(),
            'tip': 'Accelerate gently and smoothly. Aim to reach your target speed within 15-20 seconds when possible.',
            'benefit': 'Can improve fuel efficiency by up to 20% in city driving.'
          });
          break;
          
        case 'efficientBraking':
          tips.add({
            'area': 'Braking',
            'score': score.round(),
            'tip': 'Look ahead and anticipate stops. Release the accelerator early and coast when approaching red lights or stop signs.',
            'benefit': 'Reduces fuel waste and extends the life of your brakes.'
          });
          break;
          
        case 'idling':
          tips.add({
            'area': 'Idling',
            'score': score.round(),
            'tip': 'Turn off your engine when stopped for more than 30-60 seconds, except in traffic.',
            'benefit': 'Eliminates unnecessary fuel consumption and emissions.'
          });
          break;
          
        case 'speedOptimization':
          tips.add({
            'area': 'Speed Management',
            'score': score.round(),
            'tip': 'Most vehicles are most efficient between 50-80 km/h (30-50 mph). On highways, reducing speed by 10 km/h can significantly improve efficiency.',
            'benefit': 'Every 10 km/h over 80 km/h can reduce fuel economy by about 10%.'
          });
          break;
          
        case 'steadySpeed':
          tips.add({
            'area': 'Steady Pace',
            'score': score.round(),
            'tip': 'Maintain a consistent speed and avoid unnecessary acceleration and deceleration. Use cruise control on highways when appropriate.',
            'benefit': 'Keeping a steady pace can improve fuel efficiency by 15-30% on highways.'
          });
          break;
      }
    }
    
    return '{"tips": ${tips.isEmpty ? '[]' : tips}}';
  }
  
  /// Gets a specific metric value from a PerformanceMetrics object based on type
  double _getMetricValueByType(PerformanceMetrics metrics, String metricType) {
    switch (metricType) {
      case 'overallScore':
        return metrics.overallScore;
      case 'calmDrivingScore':
        return metrics.calmDrivingScore;
      case 'efficientAccelerationScore':
        return metrics.efficientAccelerationScore;
      case 'efficientBrakingScore':
        return metrics.efficientBrakingScore;
      case 'idlingScore':
        return metrics.idlingScore;
      case 'speedOptimizationScore':
        return metrics.speedOptimizationScore;
      case 'steadySpeedScore':
        return metrics.steadySpeedScore;
      default:
        return 0;
    }
  }
}

/// Performance metrics model
class PerformanceMetrics {
  final String? userId;
  final DateTime generatedAt;
  final DateTime periodStart;
  final DateTime periodEnd;
  final int totalTrips;
  final double totalDistanceKm;
  final double totalDrivingTimeMinutes;
  final double calmDrivingScore;
  final double efficientAccelerationScore;
  final double efficientBrakingScore;
  final double idlingScore;
  final double speedOptimizationScore;
  final double steadySpeedScore;
  final double overallScore;
  final String improvementTipsJson;

  PerformanceMetrics({
    this.userId,
    required this.generatedAt,
    required this.periodStart,
    required this.periodEnd,
    required this.totalTrips,
    required this.totalDistanceKm,
    required this.totalDrivingTimeMinutes,
    required this.calmDrivingScore,
    required this.efficientAccelerationScore,
    required this.efficientBrakingScore,
    required this.idlingScore,
    required this.speedOptimizationScore,
    required this.steadySpeedScore,
    required this.overallScore,
    required this.improvementTipsJson,
  });
} 

================================================================================
DIRECTORY: /Users/jonas/Downloads/Studienarbeit - OBDII-2
================================================================================



################################################################################
FILE: main.tex
################################################################################

% !TEX root = main.tex

%Dokumentklasse
\documentclass[a4paper,12pt]{scrreprt}
\usepackage{url}
\usepackage[numbers]{natbib} % to use plainnat style to cite author

% ===================== TESTING =======================

\usepackage[section]{placeins}
\usepackage{csquotes}
\setquotestyle{english}
\usepackage{enumitem}
% =====================================================

\usepackage{tablefootnote}

\usepackage{booktabs}
\usepackage{lscape}

% ========================= Commands ====================
\newcommand{\ueberschrift}[1]{\paragraph{#1}\mbox{}\\}



% ===== requirement tracing ====
% ===== Thesis Requirement Tracing System =====
\usepackage{etoolbox}  % For list manipulation
\usepackage{longtable} % For multi-page tables
\usepackage{xcolor}    % For colored text
\usepackage{array}     % For better table formatting
\usepackage{colortbl}  % For colored tables

% Initialize storage for different traced items
\newtoggle{tracingstarted}
\togglefalse{tracingstarted}

% Create storage commands for each type - initialize with table header
\newcommand{\limstorage}{ID & Description}
\newcommand{\fastorage}{ID & Description}
\newcommand{\reqstorage}{ID & Description}
\newcommand{\desstorage}{ID & Description}
\newcommand{\evalstorage}{ID & Description}
\newcommand{\implstorage}{ID & Description}

% Create main tracing command
\newcommand{\traced}[3]{%
    \par\noindent\textbf{[#1-#2]:} #3\label{#1:#2}%
    % Add to appropriate storage based on prefix
    \ifstrequal{#1}{LIM}{%
        \gappto{\limstorage}{\\[4pt]\hline #2 & #3}%
    }{}%
    \ifstrequal{#1}{FA}{%
        \gappto{\fastorage}{\\[4pt]\hline #2 & #3}%
    }{}%
    \ifstrequal{#1}{REQ}{%
        \gappto{\reqstorage}{\\[4pt]\hline #2 & #3}%
    }{}%
    \ifstrequal{#1}{DES}{%
        \gappto{\desstorage}{\\[4pt]\hline #2 & #3}%
    }{}%
    \ifstrequal{#1}{EVAL}{%
        \gappto{\evalstorage}{\\[4pt]\hline #2 & #3}%
    }{}%
    \ifstrequal{#1}{IMPL}{%
        \gappto{\implstorage}{\\[4pt]\hline #2 & #3}%
    }{}%
}

% Define specific item types
\newcommand{\limitation}[2]{\traced{LIM}{#1}{#2}}
\newcommand{\focusarea}[2]{\traced{FA}{#1}{#2}}
\newcommand{\requirement}[2]{\traced{REQ}{#1}{#2}}
\newcommand{\design}[2]{\traced{DES}{#1}{#2}}
\newcommand{\evaluation}[2]{\traced{EVAL}{#1}{#2}}
\newcommand{\implementation}[2]{\traced{IMPL}{#1}{#2}}

% Reference command (renamed to avoid conflict)
\newcommand{\traceref}[2]{\hyperref[#1:#2]{[#1-#2]}}

% Command to inline limitation reference without changing text structure
\newcommand{\limref}[1]{\textbf{[LIM-#1]}}
\newcommand{\faref}[1]{\textbf{[FA-#1]}}
\newcommand{\reqref}[1]{\textbf{[REQ-#1]}}
\newcommand{\desref}[1]{\textbf{[DES-#1]}}
\newcommand{\evalref}[1]{\textbf{[EVAL-#1]}}
\newcommand{\impref}[1]{\textbf{[IMPL-#1]}}

% Print a single summary table
\newcommand{\printsummary}[3]{%
    \iftoggle{tracingstarted}{}{%
        \toggletrue{tracingstarted}%
    }%
    \subsection*{Summary of #3}
    \begin{longtable}{|>{\centering\arraybackslash}p{0.15\textwidth}|p{0.75\textwidth}|}
        \hline
        \rowcolor{gray!10}
        \textbf{ID} & \textbf{Description} \\
        \hline
        \endfirsthead
        \hline
        \rowcolor{gray!10}
        \textbf{ID} & \textbf{Description} \\
        \hline
        \endhead
        \hline
        \endfoot
        \hline
        \endlastfoot
        #2
    \end{longtable}
}

% Command to print individual summaries
\newcommand{\printLimitations}{\printsummary{LIM}{\limstorage}{Limitations}}
\newcommand{\printFocusAreas}{\printsummary{FA}{\fastorage}{Focus Areas}}
\newcommand{\printRequirements}{\printsummary{REQ}{\reqstorage}{Requirements}}
\newcommand{\printDesigns}{\printsummary{DES}{\desstorage}{Design Elements}}
\newcommand{\printEvaluations}{\printsummary{EVAL}{\evalstorage}{Evaluation Criteria}}
\newcommand{\printImplementations}{\printsummary{IMPL}{\implstorage}{Implementation Details}}

% Command to print a relationship matrix
\newcommand{\relationshipmatrix}[5]{%
    \subsection*{Relationship Matrix: #5}
    \begin{longtable}{|>{\centering\arraybackslash}p{0.16\textwidth}|>{\centering\arraybackslash}p{0.16\textwidth}|>{\centering\arraybackslash}p{0.16\textwidth}|>{\centering\arraybackslash}p{0.16\textwidth}|>{\centering\arraybackslash}p{0.16\textwidth}|}
        \hline
        \rowcolor{gray!10}
        \textbf{#1} & \textbf{#2} & \textbf{#3} & \textbf{#4} & \textbf{#5} \\
        \hline
        \endfirsthead
        \hline
        \rowcolor{gray!10}
        \textbf{#1} & \textbf{#2} & \textbf{#3} & \textbf{#4} & \textbf{#5} \\
        \hline
        \endhead
        \hline
        \endfoot
        \hline
        \endlastfoot
        % This table must be filled manually with relationships
        [LIM-1] & [FA-I] & [REQ-1.1] & [DES-1.1] & [EVAL-1] \\
        \hline
        % Add more rows as needed
    \end{longtable}
}

% Print all summaries at once (for appendix)
\newcommand{\printAllSummaries}{%
    \section*{Traceability Summaries}
    \printLimitations
    \printFocusAreas
    \printRequirements
    \printDesigns
    \printEvaluations
    \printImplementations
    
    % Optional full traceability matrix
    \relationshipmatrix{Limitation}{Focus Area}{Requirement}{Design}{Evaluation}
}


% =============================


% ================================

\usepackage[left= 2.5cm,right = 2.5cm, bottom = 4 cm]{geometry}
%\usepackage[onehalfspacing]{setspace}
% ============= Packages =============

% Dokumentinformationen
\usepackage[
pdftitle={Enhancing Sustainable Driving Through Offline-First and Privacy-Conscious Gamified Applications},
pdfsubject={},
pdfauthor={Max Stege, Jonas Strabel},
pdfkeywords={},	
%Links nicht einrahmen
%hidelinks
]{hyperref}


% zeilen abstand
\usepackage{setspace}
\onehalfspacing

% Standard Packages
\usepackage[utf8]{inputenc}
\usepackage[english]{babel} %language 
\usepackage[T1]{fontenc}
\usepackage{graphicx, subfig}
\graphicspath{{img/}}
\usepackage{fancyhdr}
\usepackage{lmodern}
\usepackage{color}

% zusätzliche Schriftzeichen der American Mathematical Society
\usepackage{amsfonts}
\usepackage{amsmath}

%nicht einrücken nach Absatz
\setlength{\parindent}{0pt}

% sourcecode /

\usepackage{listings}
\usepackage{xcolor}

\usepackage{todonotes}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
	backgroundcolor=\color{backgroundColour},   
	commentstyle=\color{mGreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{mGray},
	stringstyle=\color{mPurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	language=C
}


\lstset{style=mystyle}

% ============= Kopf- und Fußzeile =============
\pagestyle{fancy}
%
\lhead{}
\chead{\slshape \leftmark}
\rhead{}
%%
\lfoot{}
\cfoot{\thepage}
\rfoot{}
%%
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}

% ============= Package Einstellungen & Sonstiges ============= 
%Besondere Trennungen
\hyphenation{De-zi-mal-tren-nung}


\setlength{\marginparwidth}{2cm}



\usepackage{tocbasic}

\RedeclareSectionCommand[tocbeforeskip=0em]{chapter} % Adjust this value to reduce padding above chapter entries

% ========== Glossary/Acronym/Abbreviations ==========

\usepackage{acro}


\DeclareAcronym{ds}{
	short=DS,
	long=Design Science 
}

\DeclareAcronym{dsrm}{
	short=DSRM,
	long=Design Science Research Methodology
}

\DeclareAcronym{dsr}{
short=DSR,
long=Design Science Research
}


\DeclareAcronym{tfs}{
	short=TFS,
	long=Technical Feasibility Study
}

\DeclareAcronym{obd2}{
    short=OBD-II,
    long=On-board diagnostics II
}

\DeclareAcronym{poc}{
 short=POC,
 long=Proof of Concept
}



% ====================

%todo adjust table of contents, either create fewer chapters and sections or make it bigger so it fits on two pages nicely

% ============= Dokumentbeginn =============


\begin{document}

    %Seiten ohne Kopf- und Fußzeile sowie Seitenzahl
    \pagestyle{empty}
    
    \pagenumbering{roman}
    
    \author{Jonas Strabel}
    \date{\today}
    
    
    % prefix -------------------------------------------
    
    \input{prefix/titel}
    
    \include{prefix/preface}
    
    \include{prefix/abstract}
    
    % glossarys  -------------------------------------------
    
    \cleardoubleoddpage
    
    % pagestyle für gesamtes Dokument aktivieren
    \pagestyle{fancy}
    
    \setcounter{tocdepth}{1} 
    
    \tableofcontents
    
    
    
    %Verzeichnis aller Bilder
    \listoffigures
    
    
    \printacronyms
    
    \clearpage % Start a new page
    
    
    \pagenumbering{arabic} % Set page numbering to normal Arabic numbers
    
    
    % Content -------------------------------------------
	
    \include{chapters/01_Introduction}

    \include{chapters/02_ResearchMethodology}

    \include{chapters/03_LiteratureReview}

    \include{chapters/03_Theoretical_Foundations}

    %\include{chapters/03_Technical_Foundations} %todo do we have to write that? watch feedback hofman

    \include{chapters/04_SystemDesign}

    \include{chapters/05_Implementation}

    \include{chapters/07_Evaluation}

    \include{chapters/08_Conclusion}
		
    % End Content ----------------------------- ^^
    
    
    \clearpage % Start a new page
    
    \pagenumbering{alph} % Set page numbering to letters
    
    
    %Literaturverzeichnis
    \bibliographystyle{abbrvnat}
    \bibliography{literature}
    
    \newpage
    
        \input{suffix/suffix.tex}
    
    \addtocontents{toc}{\protect\vskip25pt}
    \appendix
    \input{appendix}
	
	
\end{document}


################################################################################
FILE: appendix.tex
################################################################################



################################################################################
FILE: chapters/08_Conclusion.tex
################################################################################


\chapter{Conclusion}
    \section{Research Contributions \& Practical implications}
        % What does it mean for research? Does our approach work? Technically feasible to satisfy requirements? Create itended outcome with users? 
        % For developers: Lessongs learned i.e. Offline-first design patterns, OBD2 pitfalls
    \section{Limitations and future Directions}
        % Only small scale test, not finished app, .... 
        % Fully develop app with i.e. more vehicle support, more stable UI, better psychology, ...
        % expert review of Usability or Algorithms could be conducted 
        % Create larger and longer User Studies to accurately asses sucess

    \section{Discussion}

################################################################################
FILE: chapters/07_Evaluation.tex
################################################################################

\chapter{Demonstration and Evaluation}

\section{Introduction}
    Evaluation is a crucial part of \ac{dsr}, as only there the efficacy of a created design artifact is demonstrated \cite[p. 83]{hevnerDesignScienceInformation}. As noted by \citeauthor{venableComprehensiveFrameworkEvaluation2024}, "Ex ante evaluation is possible [...] (at least initially)" \cite[p. 9]{venableComprehensiveFrameworkEvaluation2024}.
    
    For this research, we employ analytical and descriptive evaluation methods from Hevner's Design Evaluation Methods \cite[p. 86]{hevnerDesignScienceInformation}. While empirical evaluation would be essential for definitive improvement assessment, an ex ante evaluation based on logical conclusions and research is valid for our timeframe.
    
    Our evaluation approach follows the matrix presented by \citeauthor{venableComprehensiveFrameworkEvaluation2024} \cite[p. 11]{venableComprehensiveFrameworkEvaluation2024}. While evaluating with real users, real problems, and a real system would be ideal, resource constraints necessitate a more feasible approach. We therefore focus on artificial ex ante evaluation methods, specifically logical proof and criteria-based evaluation.
    
    This chapter is structured as follows:
    \begin{itemize}
        \item First, we demonstrate the implemented proof-of-concept.
        \item Next, we conduct a technical validation of the implementation.
        \item We then verify how the implementation satisfies the requirements derived from our theoretical foundations.
        \item Finally, we present limited user feedback to provide initial empirical insights.
    \end{itemize}

\section{Demonstration}\label{sec:demonstration}
    
    %todo restructre if needed, do!
    
    % Showcase how the implemented system works in a real-world context
    This section demonstrates the implemented proof-of-concept, showing how it addresses the research question of encouraging sustainable driving behavior.
    
    \subsection{Implementation Overview}
        % Provide an overview of what was implemented
        The demonstration includes the following components of our sustainable driving application:
        
        \begin{itemize}
            \item \textbf{Component 1:} [Description of implemented component]
            \item \textbf{Component 2:} [Description of implemented component]
            % Additional components
        \end{itemize}
        
        Some features described in the System Design chapter remain conceptual and are not included in this demonstration due to time constraints. These are clearly noted and will be discussed in the Future Work section.
        
    \subsection{Demonstration Scenario}
        % Describe a typical usage scenario that demonstrates the system
        To illustrate the functionality of the implemented system, we present a demonstration scenario that showcases how a user would interact with the application in a real-world context.
        
        \subsubsection{Scenario Setup}
            % Describe the setup for the demonstration
            
        \subsubsection{User Interaction Flow}
            % Walk through the user interaction step by step
            
        \subsubsection{Outcomes}
            % Describe the outcomes of the demonstration
            
    \subsection{Visual Documentation}
        % Provide screenshots or other visual documentation
        Figures \ref{fig:screenshot1} and \ref{fig:screenshot2} show key screens from the implemented application during the demonstration scenario.
        
        \begin{figure}[h]
            \centering
            % Include screenshot
            % \includegraphics[width=0.8\linewidth]{img/screenshot1.png}
            \caption{Screenshot of [Feature/Screen]}
            \label{fig:screenshot1}
        \end{figure}
        
        \begin{figure}[h]
            \centering
            % Include screenshot
            % \includegraphics[width=0.8\linewidth]{img/screenshot2.png}
            \caption{Screenshot of [Feature/Screen]}
            \label{fig:screenshot2}
        \end{figure}

\section{Requirements Verification}\label{sec:requirementsverification}
    % Verify that the implementation satisfies the requirements
    This section verifies how well the implemented system satisfies the requirements derived from our theoretical foundations.
    
    \subsection{Verification Methodology}
        % Describe the approach to requirements verification
        Each requirement was evaluated against specified acceptance criteria to determine the degree to which it was satisfied by the implementation. The verification was conducted through a combination of demonstration, inspection, and analysis.

    
    \subsection{Detailed Verification of Requirements}  
        \subsubsection{Requirement REQ X: [Requirement Name]}
            \textbf{Acceptance Criteria:} [List the criteria for satisfying this requirement]
            
            \textbf{Implementation:} [Describe how the requirement was implemented]
            
            \textbf{Verification Method:} [Describe how satisfaction was verified]
            
            \textbf{Results:} [Present the verification results]
            
            \textbf{Analysis:} [Analyze whether the requirement was satisfied and why]

        %todo rest... 

        Eco-Driving Feedback (REQ-1.X)

        Normative feedback (REQ-1.1): Implemented in feedback_generator.dart
        Personalized feedback (REQ-1.2): Implemented via personalization_engine.dart
        Detailed feedback (REQ-1.3): Available in trip summary and feedback systems
        Social comparison (REQ-1.4, REQ-1.8): Handled by social_service.dart
        Financial savings (REQ-1.5): Implemented in savings_calculator.dart and visualizations
        Minimal friction (REQ-1.6, REQ-1.7): Supported via sensor fallback and OBD integration
        Multi-time feedback (REQ-1.9): Implemented across real-time, post-trip, and historical views
        Minimal distraction (REQ-1.10): Addressed in focus_drive_screen.dart and split-screen support
        Audio feedback (REQ-1.11): Implemented via audio_service.dart
        
        Social/Hype Features (REQ-2.X)
        
        Social comparison (REQ-2.1): Available in leaderboards with privacy controls
        Visual reinforcement (REQ-2.2): Implemented in UI components
        Achievement sharing (REQ-2.3): Handled by sharing_service.dart
        Intrinsic motivation (REQ-2.4): Supported by personalization engine
        Privacy controls (REQ-2.5): Implemented in privacy_service.dart
        
        Gamification (REQ-3.X)
        
        Performance scoring (REQ-3.1): Implemented in score_calculator.dart
        Challenges (REQ-3.2): Managed by challenge_service.dart
        Adaptive gamification (REQ-3.3): Handled by personalization engine
        Multi-channel feedback (REQ-3.5): Supported across visual, audio, and haptic channels
        Minimal distraction (REQ-3.7): Addressed in UI design and focus mode
        
        Seamless Integration (REQ-4.X)
        
        Background operation (REQ-4.1): Implemented in background_service.dart
        Battery optimization (REQ-4.2): Managed by battery_optimizer.dart
        Audio feedback (REQ-4.6): Handled by audio_service.dart
        Split-screen support (REQ-4.9): Implemented in split_screen_handler.dart
        No account requirement (REQ-4.10): Supported in app flow and storage architecture
        Contextual explanations (REQ-4.12): Implemented in UI components
        
        Privacy by Design (REQ-5.X)
        
        Local data processing (REQ-5.2): Core architecture principle
        Data visualization (REQ-5.3): Implemented in data_visualization.dart
        Privacy controls (REQ-5.4): Managed by privacy_service.dart
        Open-source approach (REQ-5.5): Supported through architecture documentation
        
        
    \subsection{Summary of Requirements Verification}
        %todo let claude summarize based on previouse subsection context
    
        % Summarize the requirements verification results
        The requirements verification results are summarized in Table~\ref{tab:requirementsverification}, which shows each requirement, its priority, implementation status, and verification result.
        
        \begin{table}[h]
            \centering
            \caption{Summary of Requirements Verification Results}
            \begin{tabular}{|l|l|l|l|l|}
                \hline
                \textbf{ID} & \textbf{Requirement} & \textbf{Priority} & \textbf{Status} & \textbf{Verified?} \\
                \hline
                REQ 1,1 & [Requirement description] & Must Have & Core & Fully \\
                REQ-1.2 & [Requirement description] & Should Have & Proof-of-Concept & Partially \\
                % Additional requirements
                \hline
            \end{tabular}
            \label{tab:requirementsverification}
        \end{table}

\section{Limited User Feedback}\label{sec:userfeedback}
    % Present feedback from a limited set of users
    To provide initial empirical insights into the effectiveness and usability of our solution, we collected feedback from a small group of users who interacted with the implemented proof-of-concept.
    
    Because of the limited resources of this study, no independent evaluators were hired. However, the evaluation is still valid, even though it was done by the researchers or acquaintances, because they do not have a vested interest. The aim of this study is to create a good solution and to work scientifically as part of the university program. By altering the evaluation to the worse or better, nothing is gained for the researchers. The goal is to do good science, not to act like it and the goal is to produce a good app, not to act like it is good.
    
    \subsection{Feedback Collection Methodology}
        % Describe how user feedback was collected
        Feedback was collected from [number] users who [describe how they used the system]. Users completed [describe any tasks or scenarios] and then provided feedback through [describe feedback mechanism, e.g., semi-structured interviews, questionnaires].
        
        Given the limitations of this study, the user feedback is not intended to provide comprehensive validation but rather to offer preliminary insights into the potential effectiveness and usability of the solution.
        
    \subsection{Feedback on Overall Concept}
        % Present feedback on the overall concept
        Users' general impressions of the application concept were [summarize feedback]. Key themes that emerged included:
        
        \begin{itemize}
            \item \textbf{Theme 1:} [Description and example quotes]
            \item \textbf{Theme 2:} [Description and example quotes]
            % Additional themes
        \end{itemize}
        
    \subsection{Feedback on Focus Areas}
        % Present feedback specific to each focus area
        
        \subsubsection{Focus Area 1: [Name]}
            Users provided the following feedback on features related to [Focus Area 1]:
            
            \begin{itemize}
                \item \textbf{Positive Aspects:} [Summarize positive feedback]
                \item \textbf{Areas for Improvement:} [Summarize constructive criticism]
                \item \textbf{Suggestions:} [Summarize user suggestions]
            \end{itemize}
            
        % Repeat for other focus areas
        
    \subsection{(limited) Technology Acceptance Model Assessment}
        % Assess user acceptance using the Technology Acceptance Model
        Following the Technology Acceptance Model \cite{TechnologyAcceptanceModel2024}, we assessed users' perceptions of usefulness and ease of use, as these are key predictors of technology adoption.
        
        \subsubsection{Perceived Usefulness}
            Users generally perceived the application as [summarize perceptions of usefulness]. Specific comments included:
            
            \begin{itemize}
                \item Example comment 1
                \item Example comment 2
                % Additional comments
            \end{itemize}
            
        \subsubsection{Perceived Ease of Use}
            Users found the application [summarize perceptions of ease of use]. Key observations included:
            
            \begin{itemize}
                \item Example observation 1
                \item Example observation 2
                % Additional observations
            \end{itemize}
            
    \subsection{Summary of User Feedback}
        % Summarize key insights from user feedback
        The limited user feedback provides initial insights into the potential effectiveness of our solution. Key findings include:
        
        \begin{itemize}
            \item \textbf{Finding 1:} [Description]
            \item \textbf{Finding 2:} [Description]
            % Additional findings
        \end{itemize}
        
        These findings, while preliminary, suggest [summarize implications for the research question].
   
\section{Future Improvements}\label{sec:futureimprovements}
    % Suggest improvements based on the evaluation
    Based on the evaluation results, several improvements and extensions to the current solution have been identified for future work.
    
    \subsection{Technical Improvements}
        % Suggest technical improvements
        The following technical improvements would enhance the effectiveness and robustness of the solution:
        
        \begin{itemize}
            \item \textbf{Improvement 1:} [Description of improvement]
            \item \textbf{Improvement 2:} [Description of improvement]
            % Additional improvements
        \end{itemize}
        
    \subsection{Feature Enhancements}
        % Suggest feature enhancements
        Based on user feedback and our own analysis, the following feature enhancements would improve the solution:
        
        \begin{itemize}
            \item \textbf{Enhancement 1:} [Description of enhancement]
            \item \textbf{Enhancement 2:} [Description of enhancement]
            % Additional enhancements
        \end{itemize}
        
    \subsection{Conceptual Extensions}
        % Suggest conceptual extensions
        Looking beyond the current implementation, the following conceptual extensions represent promising directions for future research and development:
        
        \begin{itemize}
            \item \textbf{Extension 1:} [Description of extension]
            \item \textbf{Extension 2:} [Description of extension]
            % Additional extensions
        \end{itemize}
        
\section{Evaluation Summary}
    % Summarize the evaluation findings
    This chapter has evaluated our sustainable driving application through technical validation, requirements verification, and limited user feedback. The evaluation has demonstrated both the strengths of our approach and areas for future improvement.
    
    Key findings from the evaluation include:
    
    \begin{itemize}
        \item \textbf{Finding 1:} [Description of finding]
        \item \textbf{Finding 2:} [Description of finding]
        % Additional findings
    \end{itemize}
    
    These findings suggest that our approach to encouraging sustainable driving behavior through a mobile application has [assessment of overall effectiveness and potential]. The evaluation also reinforces the importance of [key lessons learned from the evaluation].
    
    In the next chapter, we will conclude by synthesizing our research findings, discussing their implications, and outlining directions for future work.

################################################################################
FILE: chapters/03_Technical_Foundations.tex
################################################################################


\chapter{Technical Foundations}

    This chapter is here for two reasons. Since this thesis is part of a Computer Science Bachelors degree, it makes sense and is often required to include technical foundations. Additionally, it makes sense for the reader to understand the core technical foundations for this work.

    TODO this could be deleted if we have too many pages, hofman doesn't like it or we dont have enough to put here. But since we will be researching these things a big anyway to program our app, we might as well note some things and put them here in case we need it. 
    
    
    \section{\ac{obd2}}


        Difficult to find information, when searching, many using \ac{obd2} but not many describing it. \cite{simOBDIIStandardCar2014} states its purpose is to describe \ac{obd2}, but the paper is partly informally written and doesn't seem completely trustworthy. 

        But information seems to line up with \cite{OBDIIPIDs2025}. This wikipedia entry shows all the different standard modes and PIDs for \ac{obd2} communication. Standard data like Speed can be retrieved in mode 01. the specific command for speed is 0D.

        \cite{OBD2ExplainedSimple} gives a great overview over \ac{obd2}. Notably, it talks about the structure of \ac{obd2} data, the different frames, protocols and pins. 
        
        \paragraph{obd2 protocols}
        There are five different protocols under the \ac{obd2} standard \cite{autopi.ioWhatOBD2How, GettingStartedOBDII}. An overview over these 5 taken from \cite{autopi.ioWhatOBD2How}:
        
        SAE J1850 PWM: Primarily used in Ford vehicles, this protocol communicates at 41.6 kbps, using Pulse Width Modulation to ensure reliable data transmission between the vehicle's systems and diagnostic tools.

        SAE J1850 VPW: Favored by General Motors, it operates at speeds of 10.4/31.6 kbps with a Variable Pulse Width, offering a unique method for data exchange that enhances diagnostic efficiency.

        ISO 9141-2: A choice for Chrysler, European, and Asian vehicles, this protocol facilitates asynchronous serial communication at 10.4 kbps, similar to RS-232, but with automotive-specific signal levels for broad compatibility.

        ISO 14230 KWP2000: Also known as the Keyword Protocol 2000, it extends the capabilities of ISO 9141-2 by offering speeds up to 10.4 kbps and supports a wide range of vehicle diagnostic operations, especially in Chrysler, European, and Asian models.
        
        ISO 15765 CAN: The backbone of modern vehicle diagnostics, this protocol is mandatory for all vehicles sold in the US from 2008 onwards. Operating at 250 kbit/s or 500 kbit/s, it leverages the CAN bus system for high-speed, robust data communication across the vehicle's network

        Nevertheless, the implementation of these protocols can vary between car brands and models \cite{OBD2ExplainedSimple}. 

        \paragraph{ELM327}
        Elm327 is a technical device that translates \ac{obd2} data and provides an interface that abstracts from the low-level protocols. It transmitts data over wifi, bluetooth or usb \cite{ELM327WhatBest2023}. 

        \cite{ELM327WhatBest2023} warns that many cheap adapters are fake, as the ELM327 chip alone costs >20\$. However, true? 


        
        
    
    \section{Mobile-phone sensors}
    
    
    \section{Flutter}
        todo - either flutter if we find out its possible or native android here
        or non if we don't need that. But easy pages and good to know some fundamentals i guess

        Do obd2 section first to know better if flutter would be feasibl
        Test with the android library that I described in script, if that works with my peugeot, then we use native android as apparently its muche easier. 



################################################################################
FILE: chapters/01_Introduction.tex
################################################################################






\todo{Reiterate over when rest is done, to adhere to restructuring}

\chapter{Introduction}
\section{Background and Motivation}
    Transportation is a major contributor to global carbon emissions and environmental degradation. In the United States alone, transportation produces over a quarter of greenhouse gas emissions \cite{usepaInventoryUSGreenhouse2017}. In Germany, transportation accounts for 30\% of total power consumption, with private passenger vehicles contributing 57\% of that figure \cite{wilkeEmissionenVerkehrs2013, CO2EmissionenPkwZahlen2019}.
    
    Despite technological advancements in vehicle efficiency, emissions from cars have not significantly decreased in recent decades. This is largely due to the increasing number of vehicles, higher usage rates, and consumer preferences for larger vehicles \cite{CO2EmissionenPkwZahlen2019, wilkeEmissionenVerkehrs2013}. Technical innovation alone is insufficient; meaningful reduction in environmental impact requires changes in driving behavior \cite{deweerdtImpactDrivingMay2024}.
    
    Research indicates that individual driving behavior can influence fuel consumption by 10-25\% \cite{EcoDrivingEnergypedia, wernerDriverBehaviorFuel}, with some studies suggesting potential reductions of up to 40\% when comparing the most and least efficient driving styles \cite{MoneyFuelDriving}. This presents a significant opportunity for environmental impact through behavior change.
    
    While several mobile applications aimed at promoting eco-driving exist, none have achieved widespread adoption or demonstrated substantial impact at scale. This thesis addresses this gap by exploring how mobile technology can effectively encourage sustainable driving behavior through innovative approaches to user engagement, seamless integration, and social influence.
    
\newpage
\section{Problem Statement} %TODO change if resaech states otherweise
    Despite the clear potential for reducing emissions through improved driving behavior, existing solutions face significant adoption barriers. Current eco-driving applications typically suffer from one or more of the following limitations:
    
    \begin{itemize}
        \item Poor integration with existing driving routines and mobile usage patterns
        \item Limited engagement mechanisms beyond basic dashboards and statistics
        \item Insufficient attention to social factors that could drive adoption
        \item Privacy concerns related to location and driving data collection
        \item Outdated user interfaces that fail to meet contemporary expectations
    \end{itemize}
    
    These limitations result in low adoption rates and minimal real-world impact. Even the most technically sophisticated solution cannot contribute to sustainability goals if it remains unused. This thesis therefore focuses not only on accurate eco-driving measurement and feedback but also on overcoming adoption barriers through user-centered design and contemporary application strategies.
    
    \todo{Add specific examples of failed/limited app adoption if available from your research}

\newpage
\section{Research Question and Objectives}
    This thesis addresses the following primary research question:
    
    \begin{center}
        \textbf{RQ: How can a mobile application effectively encourage sustainable driving behavior at scale?}
    \end{center}
    
    To answer this question comprehensively, the research addresses several sub-questions:
    
    \begin{itemize}
        \item How can engagement mechanisms like gamification and positive reinforcement motivate sustainable driving?
        \item What integration approaches minimize barriers to adoption within existing driving routines?
        \item How can social features and sharing mechanisms expand adoption beyond environmentally-conscious early adopters?
    \end{itemize}
    
    The specific objectives of this research are to:
    
    \begin{enumerate}
        \item Identify key factors that influence the adoption and effectiveness of sustainable driving applications
        \item Design and implement a proof-of-concept application that incorporates these factors
        \item Evaluate the technical feasibility and potential effectiveness of the proposed solution
        \item Contribute design knowledge to future sustainable transportation applications
    \end{enumerate}

\newpage
\section{Thesis Structure Overview} \todo{adjust at the end, and give it acutally valuable information}
    This thesis follows a Design Science Research approach structured in eight chapters:
    
    \textbf{Chapter 1: Introduction} establishes the background, problem, research questions, and objectives.
    
    \textbf{Chapter 2: Research Methodology} describes the Design Science Research methodology employed and outlines the research design.
    
    \textbf{Chapter 3: Literature Review} analyzes the environmental impact of driving behavior, existing solutions, and barriers to adoption.
    
    \textbf{Chapter 4: Theoretical Foundations} examines relevant theories in engagement, integration, social adoption, and privacy.
    
    \textbf{Chapter 5: System Design} details the technical feasibility, requirements, architecture, and user interface design.
    
    \textbf{Chapter 6: Implementation} documents the development process, implementation decisions, and challenges.
    
    \textbf{Chapter 7: Evaluation} presents the evaluation methodology, technical validation, and findings.
    
    \textbf{Chapter 8: Conclusion} summarizes research contributions, limitations, and future directions.

     



################################################################################
FILE: chapters/04_SystemDesign.tex
################################################################################



    % Requirement: Low barrier - Fallback to phone sensors for basic feedback (but would be shown somewhere that user only uses phone sensors, thats a lesser rating than using obd2 also since its less accurate. Phones these days have so many sensors, with gps, gyroscope etc could be possible to detect highest impact values like idling, hard braking, fast acceleration, high speeds with the phone only? This would really make the app very adoption friendly. 

    % DONT create mock-ups or design things like logos, just describe how it should look like and say this takes great ux/ui let but we don’t have one in the team but according to this verbal guidance such a person should’ve able to create it. Like logo on the back shall be simple for Wiedererkennbarkeit, somewhat neutral to fit many cars, modern and grown up to make good for masses, similar to apples design , ….
    % That way, we save soooo much time and don’t create a bad result but rather good potential textual
    
    % ->>> Describe how according to research the UI should look, don't create mock-ups except we have a specfic idea or difficult concept to communicate
    
    % \subsection{Driving Dashboard}

    %     Should have signature look to share
    %     not too much customization, but i.e. fuel consumption offer toggle on or off, as some have it on their cars already so its not double maybe? 
    %     Look if splitscreen is good on all major Android phone companies, then when starting app show tutorial and recommend to use that. Else background mode with cool Ai voices. Or notification, but they cannot interfere with maps then. 
        
    % \subsection{Post-Analytic}
    %     Should have signature look to share
    %     beautiful and modern ui
    %     share button and social features everywhere

    % \subsection{Profile}
    %     The reason this gets a whole subsection alone is, that this is one of the keyparts of the app. The app shall encourage drivers to develop their profile which is then shared on platforms like uber on on social media. This way, the competition and the awareness can become global. 




%todo in each chapter
% - Sum up all requirements related to this section in a table
% - Add reuirements not addressed in research to overcome limitations 


            
\chapter{System Design}

%todo jonas
\section{Technical Feasibility Study}\label{sec:technicalfeasibility}
    Before proceeding with detailed design decisions and development environment choices, a technical feasibility study was conducted to assess the viability of implementing the key features of the app. If i.e. the necessary data for detecting eco-driving couldn't be managed to be gathered, then the complete app concept wouldn't work. Additionally, the study should inform design and development environment choices. If i.e. the \ac{obd2} connection doesn't work with flutter but only native android, then the choice would be clear. 
    
    \subsection{Study Objectives}
        The technical feasibility study aimed to answer the following questions:
        \begin{enumerate}
            \item Is gathering car data from the car via Bluetooth from an \ac{obd2} adapter possible with flutter\footnote{\url{https://flutter.dev}}?
            \item Can RPM, Speed, Fuel consumption, Acceleration and Throttle position data be gathered or calculated from the data available via \ac{obd2}?
            % item [Additional technical questions relevant to focus areas]
        \end{enumerate}
        
    \subsection{Methodology and Process}
        The feasibility study was conducted through prototype development and testing. Flutter was chosen as the framework to evaluate, since its cross-platform capability was desired to be used. Android native was used to test ease of implementation for comparison. A Peugeot 107 from the 2006 series is available for testing for this thesis. \cite{HikityOBD2DiagnosegeratOBD2} was the adapter of choice as a cheap (probably counterfeit) ELM327 Adapter, "OBDCheck BLE" by Veepeak\cite{OBDCheckBLE} the one for the premium sector (probably real ELM327 Chip-set). The app was tested on an iPhone SE 2020 with IOS 17.3 and on a Galaxy S9 with Android 10.

        The flutter setup for Android and IOS platform target wasn't completely straightforward. Some SDK issues occurred and setting up IOS development was cumbersome because of the many security restrictions. XCode needed to be installed and configured in addition to VS Code, the IDE used for development.
        
        Several Libraries for \ac{obd2} handling as well as connecting from scratch has been assessed throughout the testing process. 

        For flutter, not many \ac{obd2} library options are available. \url{https://github.com/begaz/OBDII} is one of the few. It was tested however the library used outdated packages, versions and namespaces had to be adjusted in the cached dependency files, which is a workaround and not a nice solution. The connection with the cheap adapter wasn't successful as well. So the library was disregarded. 

        Looking closer at the promising Android \ac{obd2} library \url{https://github.com/eltonvs/kotlin-obd-api} turns out to not be easy. It still requires input and output stream, so Bluetooth connection logic still needs to be handled separately. The cheap elm adapter requires a special connection sequence and therefore using the library did not really help to fix this. It was also disregarded. 

        The next step was from scratch implementation. From scratch regarding \ac{obd2} specific implementation. Bluetooth was handled via flutter\_reactive\_ble library, which works reliably on both Android and IOS, and is compatible with low power BLE (=Bluetooth Low Energy) standard of bluetooth that the adapters are often using. This allowed complete custom timings, initialization sequences and commands. While more error-prone and cumbersome than using a library, this seemed the only way forward. After a lot of trial and error, the right sequence was finally found, the connection worked. This exact sequence, timings and decoding however did then not work for the premium adapter as well. This shows that implementing such a system is far from easy. The obd\_lib (where the \ac{obd2} and Bluetooth connection logic resides in the POC app) was modified to be very modular and the strategy pattern was introduced to allow different configurations for different adapters. Through configuring support for both adapters separately, both now worked with the created obd\_lib. Data readings sometimes are still unreliable and are lagging behind - especially with the cheap adapter. Nevertheless, the connection and reading of \ac{obd2} data worked and therefore completes the process of this feasibility study. 
        
    \subsection{Findings}
        % Present findings of the technical feasibility study
        \subsubsection{\ac{obd2} and Bluetooth Integration with flutter}
            \begin{itemize}
                \item Libraries turn out to be not flexible enough and do not do 'the whole work' 
                \item Custom implementation is feasible 
                \item Flutter can be used to read \ac{obd2} data from Android as well as IOS
            \end{itemize}
            
        \subsubsection{Data Collection Validation}
            \begin{itemize}
                \item All relevant values can be read and are standardizes in most cars
                \item Reliability and support for many adapters is a challenge
            \end{itemize}
            
            
    \subsection{Implications for Design}
        Based on the technical feasibility study, we have established the following constraints and opportunities that will inform our design decisions:
        
        \begin{itemize}
            \item \textbf{Using Flutter is feasible} Since the critical part of making \ac{obd2} connection functional with flutter on IOS and Android turned out successful, Flutter can safely be used as the platform of choice for the development of this app. This means that the app can be published on both major phone platforms, which is a great advantage. 
            \item \textbf{Future Collaboration with Car-Apps} To make data reading reliable and across many car and adapter models, future development should include partnering with Car-Apps such as Car Scanner which have already implemented all the different configurations for reading \ac{obd2} data from several car models and adapters. This collaboration would save all the additional trial and error of getting the connection to work. 
        \end{itemize}
    
\section{Architecture Design}\label{sec:architecturedesign}
    \subsection{System Overview}
        % Provide a high-level overview of the system architecture
        The architecture of our sustainable driving application is designed to fulfill the requirements identified in the previous section while accounting for the technical constraints and opportunities identified in the feasibility study. Figure~\ref{fig:systemarchitecture} presents a high-level overview of the system architecture.
        
        \begin{figure}[h]
            \centering
            % Include architecture diagram
            % \includegraphics[width=0.8\linewidth]{img/system-architecture.png}
            \caption{High-Level System Architecture}
            \label{fig:systemarchitecture}
        \end{figure}

        \begin{itemize}
            \item \textbf{Decision 1:} [Description and rationale and requirement addressed]
            \item \textbf{Decision 2:} [Description and rationale and requirement addressed]
            % Additional decisions
        \end{itemize}
        
 
        
    \subsection{Data Flow}
        % Describe how data flows through the system
        Figure~\ref{fig:dataflow} illustrates the flow of data through the system, from initial data collection via OBD-II and smartphone sensors through processing to user interface display.
        
        \begin{figure}[h]
            \centering
            % Include data flow diagram
            % \includegraphics[width=0.8\linewidth]{img/data-flow.png}
            \caption{System Data Flow}
            \label{fig:dataflow}
        \end{figure}

        \begin{itemize}
            \item \textbf{Decision 1:} [Description and rationale and requirement addressed]
            \item \textbf{Decision 2:} [Description and rationale and requirement addressed]
            % Additional decisions
        \end{itemize}
        
    \subsection{Technology Stack}
        % Outline the technologies chosen for implementation
        Based on the technical feasibility study and the requirements analysis, the following technology stack has been selected for implementation:
        
        \begin{itemize}
            \item \textbf{Mobile Platform:} [Platform choice with rationale]
            \item \textbf{Development Framework:} [Framework with rationale]
            \item \textbf{Database:} [Database technology with rationale]
            \item \textbf{OBD-II Communication:} [Technology with rationale]
            % Additional technology choices
        \end{itemize}

        \begin{itemize}
            \item \textbf{Decision 1:} [Description and rationale and requirement addressed]
            \item \textbf{Decision 2:} [Description and rationale and requirement addressed]
            % Additional decisions
        \end{itemize}


    \subsection{Component Decomposition}
        % Break down the system into major components
        The system consists of the following major components:
        
        \subsubsection{Component 1: [Component Name]}\label{sec:component1}
            \textbf{Purpose:} [Description of the component's purpose]
            
            \textbf{Responsibilities:} [List key responsibilities]
            
            \textbf{Interfaces:} [Describe interfaces with other components]
            
            \textbf{Requirements Addressed:} This component addresses requirements [list requirements]
            
        % Repeat for other components
  

\section{User Interface Design}\label{sec:uidesign}

    The user interface for the Going50 application has been designed to support mass adoption while effectively promoting sustainable driving behaviors. This section outlines the design principles, user personas, journey mapping, and interface components that directly address the requirements identified in the literature review and theoretical foundations.
    
    \subsection{Design Principles}
    The UI design is guided by the following principles, derived from our research findings and requirements analysis:
    
    \begin{itemize}
        \item \textbf{Minimalist \& Intuitive Design:} Clean interfaces with focused content and clear visual hierarchies reduce cognitive load and make the app approachable to all users regardless of technical proficiency. This addresses \traceref{REQ}{4.3} by following established UI/UX guidelines.
        
        \item \textbf{Progressive Disclosure:} Information is presented in layers, starting with core functionality and revealing advanced features only when needed. This prevents overwhelming users while still providing depth for engaged users, supporting \traceref{REQ}{1.3} and \traceref{REQ}{4.12}.
        
        \item \textbf{Glanceability:} During driving, information is presented in a highly glanceable format to minimize distraction, directly addressing \traceref{REQ}{1.10}.
        
        \item \textbf{Data Visualization:} Complex data is presented through intuitive visualizations rather than raw numbers, addressing \traceref{REQ}{1.15}.
        
        \item \textbf{Social Integration:} The interface incorporates social elements throughout to leverage normative feedback and social comparison, supporting \traceref{REQ}{1.1}, \traceref{REQ}{1.4}, and \traceref{REQ}{1.8}.
        
        \item \textbf{Privacy-First Design:} Data collection and privacy controls are made transparent and accessible, addressing \traceref{REQ}{5.3} and \traceref{REQ}{5.4}.
        
        \item \textbf{Low-Friction Onboarding:} The app provides immediate value before requiring account creation, addressing \traceref{REQ}{4.10} and \traceref{REQ}{4.11}.

        \item \textbf{Gamification and Positive Reinforcement: } The app uses nudges and other strategies throughout the app to engage and motivate the user. %todo welches requirement addressed das genau ? Max
    \end{itemize}
    
    \subsection{User Personas}
    Based on the literature review and theoretical foundations, we have developed the following user personas to guide our design decisions:
    
    \subsubsection{Persona 1: Eco-Conscious Emma}
    \textbf{Demographics:} 28, urban professional, environmentally conscious
    
    \textbf{Goals:} Reduce personal carbon footprint, participate in sustainability initiatives
    
    \textbf{Challenges:} Balancing environmental concerns with daily transportation needs
    
    \textbf{Implications for Design:} Emma will respond well to environmental impact metrics and community challenges. The UI emphasizes CO\textsubscript{2} reduction visuals and environmental metaphors (trees saved) for users like Emma.
    
    \subsubsection{Persona 2: Budget-Minded Brian}
    \textbf{Demographics:} 35, suburban commuter, family-oriented
    
    \textbf{Goals:} Reduce fuel costs, optimize vehicle efficiency
    
    \textbf{Challenges:} Long commute, rising fuel prices
    
    \textbf{Implications for Design:} Brian will engage most with financial savings features. The UI prominently displays monetary savings and projects long-term financial benefits for users with this motivation type, following recommendations from \cite{turrentineCarBuyersFuel2007}.
    
    \subsubsection{Persona 3: Competitive Carlos}
    \textbf{Demographics:} 24, tech-savvy, enjoys gamification
    
    \textbf{Goals:} Compete with friends, earn achievements, improve skills
    
    \textbf{Challenges:} Needs external motivation to maintain interest
    
    \textbf{Implications for Design:} Carlos will respond to leaderboards and achievements. The UI incorporates game elements, badges, and social comparison features for users with competitive tendencies, as suggested by \cite{gimpelSustainableBehaviorMotion2022}.
    
    \subsubsection{Persona 4: Practical Paula}
    \textbf{Demographics:} 45, ride-sharing driver, pragmatic
    
    \textbf{Goals:} Improve driving efficiency, enhance professional profile
    
    \textbf{Challenges:} Balancing passenger experience with efficient driving
    
    \textbf{Implications for Design:} Paula needs integration with work platforms. The UI supports sharing professional eco-driving credentials and focuses on practical skill improvement.
    
    \subsection{User Journey}
    The primary user journey through the application has been designed to minimize friction and provide multiple value touchpoints:
    
    \begin{enumerate}
        \item \textbf{Discovery \& Onboarding}
        \begin{itemize}
            \item Initial screens highlight key benefits: financial savings, environmental impact, and social aspects
            \item Progressive permission requests only when needed \traceref{REQ}{4.13}
            \item Quick start without account creation \traceref{REQ}{4.10}
            \item Contextual tips appear when reaching new screens \traceref{REQ}{4.12}
        \end{itemize}
        
        \item \textbf{First Trip Experience}
        \begin{itemize}
            \item Simple connection options (\ac{obd2}/Phone-only)
            \item Minimalist driving UI to avoid distraction \traceref{REQ}{1.10}
            \item Post-trip feedback on specific behaviors \traceref{REQ}{1.3}
            \item Immediate value demonstration (money/emissions saved) \traceref{REQ}{1.5}
        \end{itemize}
        
        \item \textbf{Engagement \& Growth}
        \begin{itemize}
            \item Insights section shows progress over time \traceref{REQ}{1.9}
            \item Skill breakdown identifies improvement areas \traceref{REQ}{1.3}
            \item Community features encourage continued use \traceref{REQ}{1.4}
            \item Achievements recognize milestones
        \end{itemize}
        
        \item \textbf{Social Integration}
        \begin{itemize}
            \item Leaderboards enable comparison with peers \traceref{REQ}{1.8}
            \item Challenges create shared goals \traceref{REQ}{1.4}
            \item Profile sharing capabilities \traceref{REQ}{4.8}
        \end{itemize}
    \end{enumerate}
    
    \subsection{Interface Components}
    The application interface consists of four primary sections, each addressing specific requirements:
    
    \subsubsection{Drive Screen}
    The Drive screen (Figure \ref{fig:drivescreen}) serves as the primary interface for starting trips and receiving real-time feedback.
    
    \textbf{Purpose:} Enable trip recording and provide minimalist real-time feedback during driving.
    
    \textbf{Design Rationale:} This screen addresses \traceref{REQ}{1.10} by providing a distraction-minimized interface for use while driving. It also supports \traceref{REQ}{4.9} with options that work in split-screen mode.
    
    \textbf{Key Features:}
    \begin{itemize}
        \item Large, prominent "Start Trip" button for easy access
        \item Connection status indicators (Bluetooth/Phone Only)
        \item Audio feedback toggle to support \traceref{REQ}{4.6}
        \item Recent trip summary showing eco-score, distance, and money saved \traceref{REQ}{1.5}
        \item Simple toggle buttons for mode selection
        \item Not forcing to connect to Bluetooth \ac{obd2} adapter immediately for as little starting friction as possible \traceref{REQ}{1.6}\traceref{REQ}{1.7}
    \end{itemize}
    
    \begin{figure}
        \centering
        \includegraphics[width=0.5\linewidth]{DriveScreen.png}
        \caption{Drive Screen Mockup}
        \label{fig:drivescreen}
    \end{figure}
    
    \subsubsection{Insights Screen}
    The Insights screen provides detailed feedback and analysis of driving behavior.
    
    \textbf{Purpose:} Visualize driving performance data and highlight improvement opportunities.
    
    \textbf{Design Rationale:} This screen addresses \traceref{REQ}{1.15} by presenting statistics in graph form and \traceref{REQ}{1.3} by breaking down specific driving skills for improvement.
    
    \textbf{Key Features:}
    \begin{itemize}
        \item Eco-score trend visualization over time
        \item Financial savings metrics with monthly projection \traceref{REQ}{1.5}
        \item Environmental impact metrics with meaningful equivalents (trees)
        \item Driving skills breakdown with percentage scores
        \item Trip history with individual trip scores
    \end{itemize}
    
    \begin{figure}
        \centering
        \includegraphics[width=0.5\linewidth]{insightsscreen.png}
        \caption{Insights Screen Mockup}
        \label{fig:enter-label}
    \end{figure}
    
    \subsubsection{Community Screen}
    The Community screen implements social features to drive engagement and motivation.
    
    \textbf{Purpose:} Leverage social comparison and community engagement to motivate sustainable driving.
    
    \textbf{Design Rationale:} This screen addresses \traceref{REQ}{1.1}, \traceref{REQ}{1.4}, and \traceref{REQ}{1.8} by providing normative feedback through leaderboards and social comparison, as recommended by \cite{gilmanHowSupportFuelefficient2018}.
    
    \textbf{Key Features:}
    \begin{itemize}
        \item Segmented leaderboards (Friends/Local/Global) \traceref{REQ}{1.8}
        \item Visual indication of user ranking among peers
        \item Active challenges with participation counts
        \item Local community initiatives with geographic relevance
        \item Friend activity feed showing recent accomplishments
    \end{itemize}
    
    \begin{figure}
        \centering
        \includegraphics[width=0.5\linewidth]{Community.png}
        \caption{Community screen Mockup}
        \label{fig:enter-label}
    \end{figure}
    
    \subsubsection{Profile Screen}
    The Profile screen displays personal achievements and provides access to settings.
    
    \textbf{Purpose:} Present personalized stats, achievements, and access to account settings.
    
    \textbf{Design Rationale:} This screen addresses \traceref{REQ}{1.2} by showing personalized metrics and \traceref{REQ}{5.3} and \traceref{REQ}{5.4} through accessible privacy controls.
    
    \textbf{Key Features:}
    \begin{itemize}
        \item Account creation as optional (supporting \traceref{REQ}{4.10})
        \item Achievement badges for different eco-driving accomplishments
        \item Comprehensive statistics overview
        \item Level progression system for continued engagement
        \item Access to detailed settings and privacy controls
    \end{itemize}
    
    \begin{figure}
        \centering
        \includegraphics[width=0.5\linewidth]{profilescreenmockup.png}
        \caption{Profile Screen Mockup}
        \label{fig:enter-label}
    \end{figure}
    
    \begin{figure}
        \centering
        \includegraphics[width=0.5\linewidth]{settingsmockup.png}
        \caption{Settings screen Mockup}
        \label{fig:enter-label}
    \end{figure}
    
    \begin{figure}
        \centering
        \includegraphics[width=0.5\linewidth]{settingsmockupprivacy.png}
        \caption{Settings screen Mockup - Privacy Tab} %todo support REQ x y z
        \label{fig:enter-label}
    \end{figure}
    
    \begin{figure}
        \centering
        \includegraphics[width=0.5\linewidth]{settingsscreendevicemockup.png}
        \caption{Settings screen Mockup - Device Tab}
        \label{fig:enter-label}
    \end{figure}
    
    \subsubsection{Onboarding Flow}
    The onboarding flow introduces users to the application and its benefits.
    
    \textbf{Purpose:} Introduce the app's value proposition and core features without creating friction.
    
    \textbf{Design Rationale:} This flow addresses \traceref{REQ}{4.10}, \traceref{REQ}{4.11}, and \traceref{REQ}{4.13} by providing a low-friction introduction and progressive permission requests.
    
    \textbf{Key Features:}
    \begin{itemize}
        \item Value-focused carousel highlighting key benefits
        \item Skip option for immediate app access
        \item Financial savings emphasized early (addressing \traceref{REQ}{1.5})
        \item Progressive permission introduction
        \item No account requirement to start using the app
    \end{itemize}
    
    \begin{figure}
        \centering
        \includegraphics[width=0.5\linewidth]{WelcometoGoing50.png}
        \caption{Onboarding Mockup}
        \label{fig:enter-label}
    \end{figure}
    
    \subsection{Driving Mode Interface}
    The driving mode interface deserves special consideration as it must balance providing actionable feedback with minimizing distraction.
    
    \subsubsection{Design Considerations}
    \begin{itemize}
        \item Information density is deliberately reduced during active driving
        \item Audio feedback supplements visual elements \traceref{REQ}{4.6}
        \item Color coding provides instant status recognition
        \item Typography is large and highly legible at a glance
    \end{itemize}
    
    \subsubsection{Features}
    \begin{itemize}
        \item Real-time eco-score displayed prominently
        \item Focus mode compatible with split-screen navigation apps \traceref{REQ}{4.9}
        \item Audio alerts for significant events or suggestions
        \item Simplified notification system for critical feedback
    \end{itemize}
    \begin{figure}
        \centering
        \includegraphics[width=0.5\linewidth]{indrivescreenmockkup.png}
        \caption{In Drive Screen Basic Mockup (More statistics can be added / customized - but simple according to REQ]} %todo 
        \label{fig:enter-label}
    \end{figure}
    \begin{figure}
        \centering
        \includegraphics[width=0.5\linewidth]{aftertripsummarymockup.png}
        \caption{After Trip Summary Mockup}
        \label{fig:enter-label}
    \end{figure}
    
    \begin{figure}
        \centering
        \includegraphics[width=0.5\linewidth]{notifcationdrivingmodemockup.png}
        \caption{Driving Mode Mockup - Background Notification } %todo describe, ausfuehrlich da kann man mehr zu schreiben
        \label{fig:enter-label}
    \end{figure}
    
    \subsection{Post-Drive Analysis Interface}
    The post-drive analysis interface provides detailed feedback after a trip is completed.
    
    \subsubsection{Design Considerations}
    \begin{itemize}
        \item Comprehensive data presentation without overwhelming the user
        \item Actionable insights highlighted over raw data, as recommended by \cite{rakauskasDeterminingAccuracyAcceptance2010}
        \item Visual hierarchy emphasizing most important metrics
        \item Sharing capabilities for social reinforcement
    \end{itemize}
    
    \subsubsection{Features}
    \begin{itemize}
        \item Trip summary with overall eco-score
        \item Specific event breakdown (hard braking, rapid acceleration, etc.)
        \item Improvement suggestions tied to specific behaviors \traceref{REQ}{1.3}
        \item Financial and environmental impact visualization \traceref{REQ}{1.15}
        \item One-tap sharing to social platforms \traceref{REQ}{1.4}
    \end{itemize}
    
    \subsection{Social Features Integration}
    Social features are integrated throughout the interface to leverage social influence as a motivator for sustainable behavior, following findings from \cite{gonderAnalyzingVehicleFuel2012}.
    
    \subsubsection{Design Considerations}
    \begin{itemize}
        \item Privacy controls are always accessible
        \item Multiple comparison groups (friends, local, global)
        \item Positive reinforcement rather than negative comparison
        \item Meaningful metrics for comparison
    \end{itemize}
    
    \subsubsection{Features}
    \begin{itemize}
        \item Leaderboards with relevant peer groups \traceref{REQ}{1.8}
        \item Challenges with visible participation counts
        \item Achievement sharing capabilities
        \item Integration with ride-sharing platforms \traceref{REQ}{4.8}
        \item Normative feedback messages \traceref{REQ}{1.1}
    \end{itemize}
    
    \subsection{Privacy Controls and Data Visualization}
    In line with the privacy-by-design approach, the interface makes data collection transparent and controllable.
    
    \subsubsection{Design Considerations}
    \begin{itemize}
        \item Privacy controls are accessible and understandable
        \item Data visualization makes collection transparent
        \item Opt-in approach to data sharing, as recommended by \cite{bemmannInfluenceTransparencyControl2022}
    \end{itemize}
    
    \subsubsection{Features}
    \begin{itemize}
        \item Visual representations of data collection \traceref{REQ}{5.3}
        \item Granular privacy toggles for different data types \traceref{REQ}{5.4}
        \item Clear explanations of data usage
        \item Local-first indicators showing when data stays on-device
    \end{itemize}
    
    The Going50 interface design deliberately balances engaging features with ease of use, focusing on the three key areas identified in our research: seamless integration, engaging motivation, and social/hype features. By addressing the specific requirements identified in our research while maintaining a clean, intuitive design, the interface supports both immediate user adoption and long-term engagement with sustainable driving practices.
    

################################################################################
FILE: chapters/02_ResearchMethodology.tex
################################################################################

\chapter{Research Methodology}
\section{Design Science Research Approach}
    This thesis employs \ac{dsr} methodology to address the research question. \ac{dsr} is particularly well-suited for information systems research that aims to develop innovative artifacts to solve identified organizational problems \cite{hevnerDesignScienceInformation}. In this case, the ``problem'' is the environmental impact of inefficient driving behavior, and the ``artifact'' is a mobile application designed to encourage more sustainable driving.
    
    \ac{dsr} is appropriate for this research because:
    \begin{itemize}
        \item It focuses on creating and evaluating IT artifacts designed to solve organizational problems
        \item It emphasizes both rigor (grounding in existing knowledge) and relevance (addressing real-world problems)
        \item It provides a structured approach to developing innovative solutions where existing theories or practices may be insufficient
    \end{itemize}
    
    Although \ac{ds} is not a particularly new discipline, it is still emerging and methodologies are not yet unified and established broadly. A few researchers in particular have tried to propose frameworks for applying \ac{ds} to Information Technology projects. \ac{dsrm}, as proposed by \citeauthor{pfeffersDesignScienceResearch2024}, is such a framework. This framework is the one followed in this thesis, which provides a comprehensive approach for conducting and presenting \ac{dsr} in information systems \cite[p.~48]{pfeffersDesignScienceResearch2024}.
    
    \begin{figure}
        \centering
        \includegraphics[width=1\linewidth]{img/DSRProcess.png}
        \caption{\ac{dsrm} Process Model by \citeauthor{pfeffersDesignScienceResearch2024}}
        \label{fig:DSRMProcess}
    \end{figure}

\newpage
\section{Research Design and Traceability Framework}
    This thesis follows an exploratory research process within the \ac{dsrm} framework. While initially some hypotheses including positive reinforcement, gamification, seamless integration, and privacy-focused design are proposed, these will be critically examined in the literature review. Insights gained will refine the approach, potentially incorporating additional elements such as social engagement and hype-driven strategies.

    The research question is deliberately chosen to be broad to remain flexible in designing a solution with the best results in solving the goal. By examining literature and existing solutions, the best ideas and most important requirements are expected to be identified. These will then influence the design and implementation decisions of the app to create an artifact that best solves the introduced problem.

    To ensure a coherent thread throughout the thesis, we employ a traceability framework that links research findings to design decisions and evaluation criteria:

    \begin{enumerate}
        \item \textbf{Research Gap Identification} \limref{x}: The literature review will systematically identify limitations in existing eco-driving solutions.
        
        \item \textbf{Key Focus Areas}: Based on the identified gaps, we will select key differentiating factors \faref{x} or "edges" that appear crucial for driving adoption of eco-driving applications. These will serve as organizing principles throughout the remainder of the thesis.
        
        \item \textbf{Requirements Derivation} \reqref{x}: Both the literature review and theoretical foundations chapters will derive specific requirements that address the identified gaps.
        
        \item \textbf{Design Elements} \desref{x}: The system design chapter will translate requirements into concrete design decisions.
        
        \item \textbf{Evaluation Criteria} \evalref{x}: The evaluation will assess how effectively the implemented design meets the requirements.
    \end{enumerate}

    This traceability framework ensures that every design decision can be traced back to research-based requirements, and every evaluation criterion directly assesses a specific requirement. Additionally, it allows us to maintain focus on the most promising areas for improving eco-driving application adoption based on the literature review findings.

\newpage
\section{The DSRM Process in This Thesis}
    The research follows the six phases of the \ac{dsrm} with adaptations to fit the specific context of this study:
    
    \paragraph{Problem Identification and Motivation}
    This phase establishes the value of the solution and justifies the research. It is addressed through:
    \begin{itemize}
        \item Literature review on environmental impact of driving
        \item Analysis of existing solutions and their limitations
        \item Identification of barriers to widespread adoption
    \end{itemize}
    
    This is touched on in the introduction and further assessed in the Literature Review chapter, where each limitation will be codified with a \limref{x} identifier.
    
    \paragraph{Definition of Solution Objectives}
    This phase defines what the solution should accomplish based on the problem definition and feasibility. It includes:
    \begin{itemize}
        \item Analysis of effective sustainable driving behaviors
        \item Identification of key factors for application adoption and effectiveness
        \item Definition of measurable outcomes and requirements
    \end{itemize}
    
    These are defined in the introduction and more closely specified in the requirements section of the `System Design' chapter. Each requirement will be codified with a \reqref{x} identifier and linked to specific gaps identified in the literature.
    
    \paragraph{Design and Development}
    This phase creates the artifact based on identified objectives. It encompasses:
    \begin{itemize}
        \item Technical feasibility studies for critical components
        \item Architecture and interface design
        \item Implementation of core functionality and proof-of-concept features
    \end{itemize}
    
    This is covered in the System Design and Implementation chapters, with theoretical foundations established in the Literature Review. Design decisions will be codified with \desref{x} identifiers and explicitly linked to requirements.
    
    \paragraph{Demonstration}
    This phase shows the artifact solving instances of the problem. The System Design chapter will create requirements and architecture as well as design artifacts based on the research conducted in previous chapters. This will ensure that the app will be built in a way that will work. The Implementation chapter will then implement the app according to the requirements and design choices.
    
    Due to time constraints, some aspects may remain conceptual rather than fully implemented, but the demonstration will clearly indicate which elements are implemented in the proof-of-concept and which remain conceptual.
    
    \paragraph{Evaluation}
    This phase observes and measures how well the artifact supports the solution to the problem. Following \citeauthor{venableComprehensiveFrameworkEvaluation2024}, this research employs ex ante evaluation methods including:
    \begin{itemize}
        \item Analytical evaluation against requirements
        \item Technical validation of functionality
        \item Limited user feedback (if feasible)
    \end{itemize}
    
    The Demonstration and Evaluation chapter will attempt to assess empirically if the app reached its goal. This, however, might take a time-span that exceeds that of the research and therefore be a topic for future exploration. Evaluation criteria will be codified with \evalref{x} identifiers and linked directly to requirements.
    
    \paragraph{Communication}
    This phase communicates the problem, solution, and effectiveness to relevant audiences. This thesis itself serves as the primary communication vehicle. The final chapter will draw a conclusion, synthesize the results, discuss practical implications, and suggest future research directions.

\newpage
\section{Research Approach and Objectives}
    The research aims to find novel approaches and solutions to promote the adoption and effectiveness of sustainable driving. For that, the state-of-the-art needs to be assessed and the most promising approaches identified through research and analysis. The thesis therefore only determines the factors that will be examined for efficacy by \ac{ds} after in Literature Review. 

    The Literature Review chapter will be one of the core elements of this thesis. It will examine the proposed problem in more detail, focusing on existing solutions and potential improvements. This chapter will then propose an app idea with properties that are expected to fill a gap in the market and therefore encourage new users to drive sustainably. The following chapter on theoretical foundations will then research these properties to find out how exactly to implement them in an app.

    If the solution is successful, this thesis will thereby answer the research question by providing factors that make an app capable of encouraging sustainable driving behavior. The results will contribute to both theory and practice in the domain of sustainable technology adoption.
    
\section{Limitations}
    Given the compressed timeline, certain limitations apply:
    \begin{itemize}
        \item Focus on \ac{poc} implementation rather than production-quality application
        \item Limited scope of empirical evaluation
        \item Focus on analytical validation supplemented by limited user feedback
        \item Some features may remain conceptual rather than fully implemented
    \end{itemize}
    
    Despite these limitations, the research aims to make a valuable contribution by identifying key design principles for sustainable driving applications and demonstrating their technical feasibility. Future work may expand upon this foundation with more extensive empirical evaluation and refinement of the proposed solution.

################################################################################
FILE: chapters/05_Implementation.tex
################################################################################


\chapter{Implementation} \label{chap:implementation}
    \section{Development Platform and Environment Choices}    
        
        \subsection{Choosing a Development Framework}
            Since this project has a limited time-frame, strong community support and comprehensive pre-existing libraries are essential. We therefore looked at the top three, which are Native Android Development (Android Studio) and two cross-platform development platforms, namely Flutter and React Native \cite{CrossplatformMobileFrameworks}. In terms of maturity and community support, all platforms are mature as of now, with Native android slightly ahead of flutter and flutter slightly ahead of react native. Development speed is faster in cross-platform and higher level abstraction platforms, however, it is not as significant if there is not plan to support multiple platforms. Additionally, this comes at the cost of customization and low-level operations as well as achievable efficiency. In terms of performance, a live dashboard is desired and the app therefore needs to be fast. Again Native android takes the first place here, followed by flutter and react native coming last \cite{FlutterVsReact}. Most of the common capabilities like UI development, database libraries, ... are supported well by all of these options. The only specialty of this project is the connection to \ac{obd2}. This is essential because there is no time for complete custom development. Another important factor in the comparison is therefore the availability of a suited library. When searching terms like 'android app obd2' or 'java obd2' / 'kotlin obd2' on google scholar, results are about 900 in the last five years, where as for 'flutter obd2' it is only about 26 and react native 84 (29.01.2025). Searching on GitHub, 'obd2 language:Kotlin' gets 17 results, similarly Java gets 109 results, dart 10 and JavaScript 71. Having the library open source is essential if the app should be open source all together, this is why GitHub is a great place to search. The library should be well established, therefore only the ones with the most stars are reviewed. 
            The two biggest JavaScript repositories, \url{https://github.com/sipimokus/node-\ac{obd2}?tab=readme-ov-file} and \url{https://github.com/JVital2013/RoadApplePi} both seem a bit low-level, and one is built using a raspberry Pi, which is not planned to be used for this project. Additionally, their last update is 10 and 7 years ago respectively. The Dart repo \url{https://github.com/begaz/OBDII} is fairly recent with three years and the last update 11 months ago, however, the documentation isn't explicit which values are supported and therefore if its suitable for our purposes. The plug-ins for Java have the most stars but are also quite old already. The most starred Kotlin Repository (\url{https://github.com/eltonvs/kotlin-obd-api} has a good documentation and seems to support the data outputs that are needed for this project. It doesn't seem to be maintained anymore, however, with 2 years it is the most recent updated one. 

            This does speak for android and we would've chosen that, but since social and hype features are an essential part of the apps strategy, cross platform is crucial. While native android would have been the primary choice,for an app to be virally successful, being on IOS too is definitely advantageous. The risk is that essential functions like \ac{obd2} won't function probably. For this reason a short \ac{tfs} was conducted. Since the essential functionalities work with flutter, that is the framework of choice.
            
            Flutter doesn't work with android auto - but does with apple carplay. However, android auto is very restricted anyway, so it could only really be used for notification and that can be achieved with the normal app also. Furthermore, most people don't even have access to android auto and use their phones anyway. 
            
            % Usage of split-screen functionality would be good to still achieve integration, then when starting app show tutorial and recommend to use that. Else background mode with cool Ai voices. Or notification, but they cannot interfere with maps then. 
        
        \subsection{Test-vehicle and adapter}
        
            % its all normed so its okay anyway? 
            For testing the app a car and an \ac{obd2} adapter is required. A Peugeot 107 from the 2006 series is available for testing for this thesis. The car supports the normed ISO 9141 standard \cite{PeugeotOBDII}. A potential adapter should support this standard and to be able to be comfortably used, it should support connection via Bluetooth. The \texttt{HIKITY
            \ac{obd2}-Diagnosegerät \ac{obd2} Diagnosegerät ELM327 Bluetooth V2.1 WIFI Profi Auto Scanner} claims to support all \ac{obd2} devices and lists ISO 9141 as a supported standard \cite{HikityOBD2DiagnosegeratOBD2}. Additionally, it lists some values that can be read with this adapter, which has the ones needed for this project. As it also offers Bluetooth and a cheap price, this will be the adapter of choice. However, to test compatibility with multiple adapters for different price categories, another one by a reputable brand is also tested: "OBDCheck BLE" by Veepeak\cite{OBDCheckBLE}
        
        \subsection{Development and Library Choices}
            Google pushes more and more to standardize android development and make it easier for developer to create awesome apps. They work continuously on an app called 'Now in Android' where they showcase the current recommended way of building and architecture \footnote{\url{https://github.com/android/nowinandroid}}. Our implementation will follow a similar structure to ensure a great app design in terms of usability and maintainability. 
            
            For \ac{obd2} communication, libraries were considered and tested, however, it turns out these libraries are not always reliable and connection didn't immediately work. They also required a lot of coding in addition and weren't some all in one solution. Therefore, no specific library will be used for that purpose.
            
            Android API 23 minimum will be chosen and IOS 14 and up, as this will support most devices and is required by some libraries such as Firebase. The fact that it is still available to lower devices is important, since many people still have old devices that they might want to use as a dashboard. If however important features aren't supported, the version will be set up as high as needed, if the benefits outweigh the larger support of devices.

        
    \section{Core Components}
        \subsection{\ac{obd2} and Bluetooth Communication Module}
            % eltonvs/kotlin-obd-api + error handling (timeouts, unsupported PIDs)
        \subsection{Data Processing Pipeline}
        
        % how did we actually measure if a user drives sustainable or not? 
        rest
        
     % 'we did this research, not fundamental anymore since we changed X but it's still beneficial cause of y' 
    
     % ' X and Y took approach A and B, to keep it fast and simple, we will just look at parameters 1 and 2 and simple custom algorithms'

     \section{Key Algorithms and Data Structures}


    \section{User Interface Implementation}
    
    \section{Implementation of Proposed Solutions } %todo find a common name for these 'main themes' 'edges' 'konstrukte aka jenni' ... ?
        This section addressed how each of the edges have been implemented in the app

        % If time doesn't allow to implement them, make it so:
        % \section{Gamification Proof-of-Concept}
        %     \subsection{Design Mockups}
        %     \subsection{Technical Feasibility}
        % For evaluation: Evaluate them more lightweight and use technical feasibility instead of user testing ie.e 
        


        
        \subsection{Gamification Elements and Positive Reinforcement}
            % Simple badge system (e.g., "Eco Driver Level 1")
            % Notifications Reminding User that its valuable that he tries to drive eco-friendly
            % Post-drive summaryies: "You saved 0.3kg CO2 vs. average!"
            % ? HOw did we exactly implement these (try avoid doubling with Design Chapter, rather leave something
      
            % Post-drive summary: "You saved 0.3kg CO2 vs. average!"
            
        \subsection{Integration in Navigation and Android Eco-system}
            % how did we achieve integration / or not? 

        \subsection{Privacy through open sourcing and offline first approach}
            % is our architecture etc privacy and open source focused? If so, how exactly did we implement that? 


    \section{Implementation Challenges and Solutions} 
        Technical limitations encountered
        Adaptations made
        Lessons learned


################################################################################
FILE: chapters/03_LiteratureReview.tex
################################################################################


\chapter{Literature Review}
    \section{Environmental Impact of Driving Behavior}

        % TODO expand on the following 2, Global Problem -> Driver Impact

        \subsection{Global emissions from transportation}
            Transportation is a major factor of air pollution, leading to environmental destruction and health concerns \cite{CarsTrucksBuses}. In the United States, one of the biggest contributors to global warming, transportation produces over a quarter of greenhouse gas emissions \cite{usepaInventoryUSGreenhouse2017}. In Germany, transportation used up 30\% of the total power consumption, and private passenger vehicles contributed most of it at 57\% \cite{wilkeEmissionenVerkehrs2013}\cite{CO2EmissionenPkwZahlen2019}. Although vehicles got more efficient due to regulations \cite{FuelEconomyEuropean2021}, that efficiency was counteracted with the increase in cars, usage of cars and choice of bigger vehicles \cite{TrendsGlobalVehicle}\cite[p.~19]{pardiHeavierFasterLess2022}. While the emissions per kilometer consistently fell since 2005, SUVs replaced more and more small vehicles in the market \cite{TrendsGlobalVehicle}. The emission from the car sector in general therefore was not reduced in the last decades and is still one of the biggest contributors to climate change \cite{CO2EmissionenPkwZahlen2019, wilkeEmissionenVerkehrs2013}. This is why reducing emissions is one of the top priorities of the EU in the coming years \cite{WHITEPAPERRoadmap2011}, which is not however an easy task and regulations often fail to meet goals \cite{pardiHeavierFasterLess2022}. 

        \subsection{Impact of individual driving behaviors}
            The amount of emissions is obviously linked to different kinds of fuel efficiency measures. One being the efficiency of the vehicle itself, which has greatly increased in the last years \cite{FuelEconomyEuropean2021} and is still being worked on. However, this alone might not suffice. If vehicles become more efficient but drivers choose bigger vehicles and drive carelessly, they counteract this efficiency gain. What helps therefore is not only a technical advancement, but a change of mindset in the peoples behavior \cite{CO2EmissionenPkwZahlen2019}\cite{deweerdtImpactDrivingMay2024}. One of the factors that can right now and very easily be implemented is driving behavior. \citeauthor{deweerdtImpactDrivingMay2024} even suggests that \quote{The climate impact of driving may depend less on what car you drive than how you drive it} \cite[Headline]{deweerdtImpactDrivingMay2024}. It doesn't cost any additional money to drive sustainably, on the contrary, it even saves money \cite{MoneyFuelDriving}. 

        \subsection{Driver Demographics and Target Audience}
            To develop an effective solution, understanding the target demographic is essential. According to \cite{ListCountriesTerritories2025}, China, USA, and India have the largest car markets by far, with nearly one billion combined vehicles. While the Chinese market has its own distinct ecosystem, Western markets like the US and Europe share many ecosystems and will be the focus of this research.
            
            Demographics data suggests the largest driver group is middle-aged and older adults \cite{HowManyPeople2024}\cite{driving-tests.org2023DrivingStatistics}. Young people are obtaining driver's licenses at decreasing rates, partly due to ride-sharing services like Uber \cite{HowManyPeople2024}. However, Uber drivers use their vehicles much more intensively than average drivers, making them a potentially high-impact target group. These drivers already use their phones for the Uber app, suggesting potential for integration with eco-driving solutions.
            
            Different demographics have different priorities. Older drivers often prioritize privacy. However, trends that start with younger users often eventually impact older generations as well, as demonstrated by social media platforms. Most Uber users are under 45 \cite{HowManyPeople2024}, potentially making this demographic more receptive to innovative driving applications.

            Those who are environmentally conscious are already trying not to use cars at all or use electric vehicles if possible, so impact when targeting these groups is less. However, some, even though not wanting to use cars have to use them because of lack of alternative. And some, even tho wanting to get an electric vehicle, cannot because they lack the financial means to acquire one. Why used combustion engine cars can often be acquired used for very low prices, that is not yet so with electric vehicles. So then we have some of these environmentally conscious users using these cars also. Its good to give them advice on how to be sustainable then. Those that aren't yet conscious of climate can be hooked through social and hype features and Gamification, and maybe convinced through positive reinforcement. 
    
        \subsection{Potential savings from behavior changes}
            The values provided for overall savings potential differ in literature. The following is a synthesis of existing research:
            
            \begin{itemize}
                \item \cite{laiEffectsEcodrivingMotivation2015} found that without a rewards system the improvement was positive but not significant, with a rewards system the improvement was about 10\%.
                \item \cite{gonderAnalyzingVehicleFuel2012} summarizes the results from the U.S. National Renewable Energy Laboratory when assessing potential fuel saving opportunity from implementing driver feedback. It found a 30\% savings opportunity between worst and best driving behavior in city driving and 20\% in highway driving. 10\% can be attained through reasonably moderate behavior modification \cite[p. 6]{gonderAnalyzingVehicleFuel2012}.
                \item \cite{DidYouKnow} claims that the Ministry of Environment and Forestry found within an eight-year trial an average saving potential of 10-25\%.
                \item \cite{EcoDrivingEnergypedia} states 10\% can be achieved on average, while 20\% are possible with comprehensive eco-driving measures.
                \item \cite{wernerDriverBehaviorFuel} estimated that fuel consumption would fall by 17-26\% if all drivers behaved like the most efficient individuals \cite[abstract]{wernerDriverBehaviorFuel}. \citeauthor{wernerDriverBehaviorFuel} predicts 12-19\% as a more realistic outcome.
                \item \citeauthor{fafoutellisEcoDrivingItsImpacts2021} summarizes the potential savings with 15-25\% in fuel consumption and at least 30\% in Greenhouse Gas Emissions \cite[p.~2]{fafoutellisEcoDrivingItsImpacts2021}.
                \item \citeauthor{zhouReviewVehicleFuel2016} suggests that the impact on advanced engine and vehicle technologies might only be 2-10\%. While it is logical that some inefficiencies are naturally corrected by modern vehicles, this percentage is probably very conservative or for automatic transmission/hybrid vehicles, as there, less can be saved through driving measures such as early shifting.
            \end{itemize}
            
            While exact savings vary based on driving conditions and previous habits, research consistently demonstrates that behavior changes can yield meaningful reductions in fuel consumption and emissions. This establishes the value proposition for eco-driving apps - they have the potential to create significant environmental impact if they are widely adopted and effectively used.

        
    
    \section{Sustainable Driving Practices}

        There are several measures that can be taken by individuals to drive more efficiently. Table \ref{tab:fuelefficiency} attempts to summarize measures drivers can take and their impact on fuel efficiency, based on different recommendation articles from governments and scientific studies. The values of savings are estimated and these estimations vary slightly between different sources. For that reason multiple values are mentioned and cited with the corresponding source.  
        
        \begin{table}[h] 
            \centering
            \renewcommand{\arraystretch}{1.3} 
            \setlength{\tabcolsep}{8pt} 
            \caption{Measures of individuals to improve sustainability of driving\tablefootnote{Some of these apply only to combustion engines, however, they still make up the majority of cars globally \cite{GlobalSalesCombustion}}}
            \begin{tabular}{p{3cm} p{7cm} p{3cm}} 
                \hline
                \textbf{Title} & \textbf{Suggested Behavior Change} & \textbf{Estimated Savings} \\ 
                \hline
                Sensible Driving & Avoiding aggressive acceleration and braking, best accelerate with 4.8 kmh/s \cite[p. 2]{gonderAnalyzingVehicleFuel2012} & 10\% - 40\% \cite{MoneyFuelDriving} \\
                Speed & Avoid higher speeds, stay below 80 km/h \cite{MoneyFuelDriving} or best between 50 and 75 km/h \cite{stradaInnovativeVirtualSensing2024} or 64 km/h \cite[p. 2]{gonderAnalyzingVehicleFuel2012} whenever possible & 7\% - 14\% \cite{MoneyFuelDriving}  \\
                Idling & Avoid idling the engine. Every second above 10 \cite{MoneyFuelDriving} / 30 \cite{KlimabewusstAutofahren2017} seconds uses more fuel than turning off & ~1.5 L/h \cite{MoneyFuelDriving} \\
                Short Distances & Short distances are especially inefficient; avoid them when possible & 50\% \tablefootnote{Estimated for short rides, as cars could use up to twice as much fuel on short distances} \cite{KlimabewusstAutofahren2017} \\
                RPM\tablefootnote{This makes limited sense in automatic transmission vehicles, however, globally manual cars still make up over one third \cite{arthurKeyManualVs2024} } & Drive steadily and at low RPM & 20\% - 25\% \cite{KlimabewusstAutofahren2017} \\
                Stops & Frequency of stops - even faster acceleration is acceptable if a stop is avoided \cite[p. 6]{gonderAnalyzingVehicleFuel2012} & -\tablefootnote{No explicit percentage given.} \\
                Follow Distance & Keeping larger distance to vehicles in front \cite[p. 6]{gonderAnalyzingVehicleFuel2012} & - \\
                \hline
            \end{tabular}
            \label{tab:fuelefficiency}
        \end{table}


        These 7 Criteria have been identified to be create the most impact. They each need to be tracked to detect unsustainable / sustainable behavior.

        Algorithms need to be able to track, detect and classify these behaviors with data from \ac{obd2} and also without it to have a fallback mechanism - if possible. If the accuracy without \ac{obd2} values is expected to be significantly lower, that would need to be reflected in the scores and profiles somehow. These algorithms will be further discussed in the implementation chapter.

        The system could also optionally measure direct emission date generated from the car and compare to other users. This then not only is affected by the driving behavior but also the car. Could differentiate with messages like: 'Your driving behavior is already excellent. To further reduce emissions, try getting a car with lower fuel consumption next time'.

        While sophisticated algorithms can be developed, research suggests that simplicity is crucial for user adoption. Overly complex analyses might be technically impressive but could overwhelm users who simply want to improve their driving efficiency. Therefore, algorithms should primarily focus on detecting behaviors with the highest impact potential, particularly aggressive acceleration/deceleration patterns and speed optimization.
        
        As \cite{wernerDriverBehaviorFuel} notes, to calculate specific metrics like fuel consumption that may not be directly available through \ac{obd2}, formulas can be applied to the available data. Similarly, \cite{yenCombiningUniversalOBDII2021} provides approaches for analyzing collected data to determine overall driving efficiency.
        
        Additional contextual data such as weather conditions and traffic information should also be factored into the algorithms, as these elements significantly impact driving behavior decisions \cite[p. 634]{gilmanHowSupportFuelefficient2018}. This prevents penalizing drivers for inefficient behaviors that may be necessary in certain conditions, such as rapid acceleration to avoid a hazard.

            
            
    \section{Limitations of Existing Eco-Driving Research and Solutions}

        Despite climate change being a widely discussed topic and driving is a significant contributor to it, the authors know of no popular eco-driving application. This section will analyze existing research papers as well as the mobile market in major app stores to analyze if any promising solutions exist, and if not, why.

        \subsection{Overview of Existing Research} 

            It turns out, in Research, many solutions for promoting eco-driving have been developed and tested over the years. These range from built-in vehicle systems to mobile applications and educational programs. Car manufacturers often already include basic feedback systems in their vehicles \cite[p. 632]{gilmanHowSupportFuelefficient2018}, though these vary widely in sophistication and effectiveness. This study will take a closer look at eco-driving solutions in the form of mobile apps.

            \cite{gilmanHowSupportFuelefficient2018} assessed implemented solutions from 2011-2016. His list is comprehensive and compares 61 different feedback systems, many of them are mobile apps. Notably, among those identified, only two incorporated praise, rewards, and suggestion features at the same time, namely \cite{maganaArtemisaPersonalDriving2016} and \cite{orfilaAndroidBasedEcodriving2015}. Only one of these two, and just three in total, implemented Social Support systems. Note that social support systems have been identified to be one of the most important feedback mechanisms. While each of these studies test new possibilities to suggest eco-driving, the comparison table shows that most solutions focus on technical details instead of mechanisms to bring the app to the masses.
            
            \cite{orfilaAndroidBasedEcodriving2015} provides thorough algorithms and implementation approaches. While it features actionable driving tips, its user interface is primarily functional and simplistic, focusing on dashboard-style feedback that does not meet contemporary design standards.
            
            \cite{maganaArtemisaPersonalDriving2016} presents a conceptual approach but lacks detailed user interface specifications for further analysis.
            
            Notably, neither of these solutions appears to be available on major app stores as far as the researchers can tell, suggesting they remained primarily as concept applications rather than commercially deployed products or they did not manage to establish.
            
            More recent research by \cite{trindadeDriverRatingMobile2021} demonstrates a technically sophisticated application that could provide valuable direction in the technical and analytical aspects of eco-driving. However, it lacks modern user interface design, social features, and adoption-focused elements. Similarly, it does not incorporate gamification or positive reinforcement mechanisms.
            
            \cite{gimpelSustainableBehaviorMotion2022} conducted a comprehensive study similar to our approach, also employing Design Science Research methodology to assess the efficacy of different factors. Their findings highlight that social comparison and normative feedback are crucial factors for changing driver behavior. They recommend further research into personalization, acknowledging that different personality types respond differently to various feedback methods. While technically sound, their solution also appears to have remained in the research domain without achieving commercial deployment or mass adoption.
            
            Malekian et al. \cite{malekianDesignImplementationWireless2017} developed software capable of collecting and transmitting relevant driving data, such as location and fuel consumption, to a server over the internet. This showcases the potential of integrating real-time data transmission for vehicle monitoring systems.
            
            Studies like \cite{GamifiedMobileApplications} emphasize the prevalence of driving security apps, which often provide live dashboards \cite[ch. 4.5]{GamifiedMobileApplications}. However, these apps primarily focus on safety rather than sustainability.
            
            Lee-Kan et al. \cite{lee-kanDriveStatsMobilePlatform2024} specifically address sustainable driving through their application. This demonstrates that sustainable driving apps already exist, indicating a growing interest in this area.
            Many solutions have been built and tried over the years. Car manufacturers often already include basic feedback systems in their cars \cite[p. 632]{gilmanHowSupportFuelefficient2018}. In many cars however, that is not yet the case. Additionally, these systems are often less visually appealing than the current UI standard in other sectors that the user is used to. Also, they often focus on in-trip feedback and stats displays as well as simply coded indicators such as color to display sustainability \cite[p. 632]{gilmanHowSupportFuelefficient2018}. However, what is often not addressed are the \textit{specific} and \textit{actionable} tips for high-impact driving behaviors such moderate speed and calm driving. This thesis aims to address exactly that, provide clear, actionable advice nicely presented to the user.

            To summarize, a lot of research exists on advancing eco-driving solutions and they generate a bulk of knowledge for future application development. At the same time, no research in that context seems to have yet focused on creating eco-driving apps that reach the masses.

        \subsection{Market Analysis (App-Stores)} \label{sec:marketanalysis}

            To determine if established eco-driving solutions exist in the market, a systematic analysis of mobile application stores was conducted. Android and IOS are the dominant operating systems. The primary way users install applications in these operating systems is through their app store, 'Play Store' and 'App Store' respectively. To find out if established eco-driving solutions exist, both of these stores are searched.
            
            The following search terms were used to identify existing solutions: 
            \begin{itemize}
                \item ``eco-driving'' 
                \item ``fuel efficiency'' 
                \item ``driving efficiency'' 
                \item ``fuel economy'' 
                \item ``eco driving assistant'' 
                \item ``sustainable driving''
            \end{itemize}
            
            Each term was entered in both app stores, with results recorded and the top applications from each search selected for detailed analysis based on relevance and store ranking. Only those were selected that appeared to be an app that gives feedback to the user while / after driving to improve his driving sustainability. The choice whether that is the case, was done by looking at the screenshots given for each app. Those that appeared off-topic weren't considered. The following shows the search results.
    
        
            
            \begin{itemize}
                \item \textbf{Search Term: ``eco-driving''}
                \begin{itemize}
                    \item \textbf{Android:} 
                    \begin{itemize}
                        \item EcoDrive by Actia Telematics Services
                        \item ECO-Driving Speedometer by East Software Coders - Very basic Dashboard with red to green indicator and sound notifications for behavior like fast acceleration and hard braking
                    \end{itemize}
                    \item \textbf{iOS:} he first 5 apps from the results appear to be off-topic. Then some dashboards are in the results and some apps to promote ride sharing or finding near charging stations. Non however appear to be concerned with the desired topic of eco-driving recommendations.
                    \item \textbf{Note: } T
                \end{itemize}
            
                \item \textbf{Search Term: ``fuel efficiency''}
                \begin{itemize}
                    \item \textbf{Android:} No relevant results, only results related to tracking fuel cost or calculating it.
                    \item \textbf{iOS:} A few fuel calculators and apps tracking fuel consumption. Non however appear to be concerned with the desired topic of eco-driving recommendations.
                \end{itemize}
            
                \item \textbf{Search Term: ``driving efficiency''}
                \begin{itemize}
                    \item \textbf{Android:} No relevant result, mainly driving school apps.
                    \item \textbf{iOS:} Some fleet management systems and many off topic apps again. Non however appear to be concerned with the desired topic of eco-driving recommendations.
                \end{itemize}
            
                \item \textbf{Search Term: ``fuel economy''}
                \begin{itemize}
                    \item \textbf{Android:} A few fuel calculators and apps tracking fuel consumption. Non however appear to be concerned with the desired topic of eco-driving recommendations.
                    \item \textbf{iOS:} A few fuel calculators and apps tracking fuel consumption. Non however appear to be concerned with the desired topic of eco-driving recommendations.
                \end{itemize}
            
                \item \textbf{Search Term: ``eco driving assistant''}
                \begin{itemize}
                    \item \textbf{Android:} Note that some results appeared in this search that were already in the first search, those duplicates aren't included.
                    \begin{itemize}
                        \item EcoDrive by icCar Telematics
                        \item Mercedes-Benz Eco Coach by Mercedes-Benz AG
                    \end{itemize}
                    \item \textbf{iOS:} One HUD Widgets app that appeared in searches before, no relevant app. 
                \end{itemize}
            
                \item \textbf{Search Term: ``sustainable driving''}
                \begin{itemize}
                    \item \textbf{Android:} No novel relevant result.
                    \item \textbf{iOS:} Some non-relevant results and ride-sharing results, but then some relevant apps.
                    \begin{itemize}
                        \item DRIVE COACH by DrivOlution - features look promising, but: 'limited to registered companies and fleet drivers'
                    \end{itemize}
                \end{itemize}
            
            \end{itemize}

            
            An additional search on IOS 'Eco Coach' has been made to check (because its likely) if 'Mercedes-Benz Eco coach' also exists for IOS. The app exists and another relevant app was found: Eqqo.
            An additional search for 'Sustainable Driving Coach' on Android revealed that the DRIVE COACH by DrivOlution is also available on android.
            
            %todo explain which apps were picked here and why 
            The findings are summarized in Table~\ref{tab:eco-apps}, which presents the current state of eco-driving applications in the market.

            \begin{landscape}
            \begin{table}[h]
                \scriptsize
                \centering
                \caption{Summary of Eco-Driving Applications}
                \label{tab:eco-apps}
                \renewcommand{\arraystretch}{1.2}
                \begin{tabular}{p{2.5cm} p{1.5cm} p{4.0cm} p{4.0cm} p{2.0cm} p{1cm} p{1.0cm} p{1cm}}
                    \toprule
                    \textbf{Application} & \textbf{Platform} & \textbf{Key Features} & \textbf{Limitations} & \textbf{Market Focus} & \textbf{Down-loads} & \textbf{Ra-tings} & \textbf{Last Updated} \\
                    \midrule
                    DRIVE COACH by DrivOlution & Both & Sustainability Score, Trip analysis, Gamification and Social Comparison Features, Driver Profiles & Only available for commercial, No live Dashboard & Commercial & 100+ (Play Store), -\tablefootnote{This number isn't shown in App Store - only in Play Store} & NA \tablefootnote{Not shown because the number of ratings is not sufficient} & 03/2025 \\
                    EcoDrive by icCar Telematics & Android & From what can be observed, Driving statistics and scores & Stuck when registering, little information available over features, no social features and driving advice & Personal & 100+ & NA  & 11/2024 \\
                    Mercedes-Benz Eco Coach by Mercedes-Benz AG & Both & Gamification with Points, Scores and Bades. Statistics like Emissions saved and Average consumption, social comparison & Only for EV or Hybrid, Only for Mercedes & Both & 100.000+ & 4.5 Stars  & 01/2025 \\
                    Eqqo & IOS & Simple, Intuitive and modern UI, Scores and Points, Track History, Savings in Money and Co2 & No direct advise on what to change, no social comparison & Personal & - & NA & 2022 \\
                    EcoDrive by Actia Telematics Services & Android & Leaderboards, Post-drive analytics, Trackrecording & Only commercial use, No live dashboard, no actionalbe tips & Commercial & 1000+ & NA & 08/2024 \\
                    ECO-Driving Speedometer by East Software & Android & Simple eco-score dashboards, brake and acceleration speech advice & No post-trip analaytics, no gamifcation or social features & Personal & 10000+ & NA & 12/2024 \\
                    \bottomrule
                \end{tabular}
            \end{table}
            \end{landscape}

            The app store constantly recommending promoted apps, unrelated to search terms. Due to stricter policy and expensive app-publishing, it also contains less apps that aren't profitable. 
            Notably, a lot of apps regarding fuel cost are available. That highlights that people are interested in saving money buy buying cheaper fuel or calculating trip costs.
            It could be that other eco-driving app solutions exist but weren't found by these searches. However, if an app in a specific category is popular, it will be recommended by the App stores to be found in such searches, even if it has a brand name like 'Artemisa'\cite{maganaArtemisaPersonalDriving2016}. The fact that some apps like Eqqo only showed up under specific search terms and not for other terms and the lack of relevant search results suggests that no established eco-driving market exists.
            
            Based on this analysis, several significant gaps were identified in the current eco-driving application market: 
            \begin{itemize}
                \item There are no established and mature driving apps available for the masses. All apps above 1000 Downloads are either bound to a specific brand or to commercial users. This makes social comparison difficult because there is nobody to compare to.
                \item Finding these apps is very difficult. Neither of the app-stores makes it particularly easy to find these solutions not to speak of promoting them (like they promote other apps). 
                \item No solution can be found in the app stores that comes even closed to what the research had in stock years ago. They all implement some features but lack others. No UI that comes close to modern UIs could be found. 
            \end{itemize}
            
            These identified gaps provide clear opportunities in the market for eco-driving applications, which are addressed by the solution proposed in this thesis.
            
        \subsection{Adoption Barriers in Existing Solutions}

            There are two possible explanations for the result of the previous section. Either nobody tried to create an app for the masses yet, then this thesis will address this gap by having that exact goal. The second option is that somebody tried it but failed, otherwise we should have gotten a different result. If the latter is true, then this section will go into why that could have been the case.
            
            \subsubsection{Poor User Interface and User Experience Design}
            \limitation{1}{Poor User Interface and User Experience Design}
            
            Many existing solutions feature interfaces that are primarily functional rather than engaging. They often rely on dashboard-style displays and simple color-coded indicators that fail to convey actionable insights. As \cite{gilmanHowSupportFuelefficient2018} notes, users often see that an indicator is red but aren't provided with specific guidance on what actions to take to improve. While some applications do provide explicit recommendations, they frequently lack other essential features that would encourage continued use.
            
            The contrast between these interfaces and the polished, engaging designs of popular consumer applications is stark. In an era where users expect sophisticated, aesthetically pleasing interfaces, the utilitarian design of many eco-driving applications creates an immediate barrier to adoption.
            
            \subsubsection{Lack of Integration with Existing Driving Routines}
            \limitation{2}{Lack of Integration with Existing Driving Routines}
            
            Most eco-driving applications function as standalone solutions, requiring users to choose between using the eco-driving app or other applications they commonly use while driving, such as navigation or music apps. This forces an unnecessary choice that increases the friction of adoption. As \cite{gonderAnalyzingVehicleFuel2012} notes, the potential for mobile applications as driver feedback devices is high but is limited by adoption barriers, including competing with other phone uses during driving \cite[p. 9]{gonderAnalyzingVehicleFuel2012}.
            
            The requirement to use a dedicated application during driving represents a significant disruption to established habits, which is a known barrier to technology adoption. Solutions that integrate with or complement existing behaviors are more likely to achieve widespread use.
            
            \subsubsection{Insufficient Engagement Mechanisms}
            \limitation{3}{Insufficient Engagement Mechanisms}
            
            In an era where mobile applications frequently employ sophisticated engagement techniques, many eco-driving solutions lack features to maintain user interest over time. Without elements like gamification, social comparison, or positive reinforcement, users may quickly lose interest. \cite{laiEffectsEcodrivingMotivation2015} found that simply providing knowledge about eco-driving without a reward system did not lead to significant behavior changes, highlighting the importance of motivational elements.
            
            The absence of these engagement mechanisms is particularly problematic for eco-driving applications, as the benefits of efficient driving (fuel savings, reduced emissions) are often abstract or delayed, providing limited immediate gratification to the user.
            
            \subsubsection{High Barrier to Entry}
            \limitation{4}{High Barrier to Entry}
            
            Many existing solutions require purchasing additional hardware (such as \ac{obd2} adapters) or following complex setup procedures. \cite{boriboonsomsinEcoDrivingPilotEvaluation2010} found that users were much more likely to use feedback devices that came pre-installed with their vehicles than to purchase separate devices \cite[p.7]{gonderAnalyzingVehicleFuel2012}. The initial investment of time, money, and effort represents a significant barrier to adoption.
            
            While OBD-II adapters have become more affordable, the additional step of purchasing and installing external hardware remains a friction point that many potential users are unwilling to overcome, particularly if they are not already highly motivated to improve their driving efficiency.
            
            Therefore an ideal solution would have the following two edges. For one, falling back to phone sensors instead of \ac{obd2}. Phones these days have so many sensors, with gps, gyroscope etc could be possible to detect highest impact values like idling, hard braking, fast acceleration, high speeds with the phone only? This would really make the app very adoption friendly. The second would be some kind of sponsorship which allowed \ac{obd2} adapters to be shipped for free upon registration. Since these adapters have become quit cheap, this is actually feasible. 
            
            \subsubsection{Privacy and Data Security Concerns}
            \limitation{5}{Privacy and Data Security Concerns}
            
            Modern drivers are increasingly concerned about how their data is collected, stored, and used. Many existing eco-driving solutions require data to be transmitted to servers for processing or analysis, raising privacy concerns among potential users. \cite{gilmanHowSupportFuelefficient2018} identified addressing privacy concerns as a key area for future development in driving coach applications \cite[p. 640]{gilmanHowSupportFuelefficient2018}.
            
            Location data is particularly sensitive, as it can reveal personal information about the user's habits, home location, work location, and other private details. Solutions that require continuous transmission of such data may face resistance from privacy-conscious users.
            
            \subsubsection{Social Sharing}
            \limitation{6}{Lack of Social Sharing Capabilities}
            
            \cite{gilmanHowSupportFuelefficient2018} found that only three studies use social sharing, and the analysis \ref{sec:marketanalysis} in this thesis found similar patterns. While some apps had export options, the social sharing aspect isn't an endorsed feature. 
            
            These days, people share their whole lives in the internet. Sending ones driving stats (modern word for driving statistics, coming from the gaming scene) to friends is a powerful way to stay motivated and help spread the word of the app. Also, this is one of the essential features for the promising semi-integration with ride-sharing apps like Uber. If users can just share their stats in their profile on these ride-sharing platforms to showcase how sustainable they are, this could encourage them to keep using that app and also increases the visibility of the app significantly. And since ride-sharing services have gained great popularity and do so still, this option is essential for widespread adoption. 
            
            \subsubsection{Social Comparison and Normative Feedback}
            \limitation{7}{Insufficient Social Comparison and Normative Feedback}
            
            While Social Sharing as mentioned in the previous point is a part of this, Normative Feedback aims to provide a different set of features. To encourage change of behavior, on of the most powerful ways according to \citeauthor{gimpelSustainableBehaviorMotion2022} is to show the user how other drivers are performing, ideally these in the area or similar social group. Prompts like 'People with your vehicle type / People in your area break more gentle and thus drive more efficiently' go a long way.
            
            \subsubsection{Lack of targeting masses and impracticality}
            \limitation{8}{Lack of Focus on Mass Adoption}
            
            \cite{gonderAnalyzingVehicleFuel2012} found that social norms significantly influence driving behavior. Feedback suggesting behavior different from the majority of other drivers may encounter resistance, and even increase accident risk in some scenarios (e.g., suggesting 55 mph when everyone else is driving 70 mph) \cite[p. 6-7]{gonderAnalyzingVehicleFuel2012}. This social issue highlights the importance of achieving mass adoption - if most drivers used the same recommendations, this problem would be mitigated.
            
            \subsubsection{Hype features}
            \limitation{9}{Absence of Trend-Driven Features}
            
            Today's culture is driven by hype and fear of missing out. Apps need to feel like and communicate that they are what is going on in the world right now. If it seems like everyone is using and talking about an app, other people will follow to download and use it.
            
            \subsubsection{Competing priorities}
            \limitation{10}{Competing User Priorities}
            
            Eco-friendly driving recommendations compete with factors like enjoyment of sporty driving, pressure from tailgating vehicles, and drivers' desire to fully utilize the engine they've paid for \cite[p. 9]{gonderAnalyzingVehicleFuel2012}.
            
            \subsubsection{Opportunity cost perception}
            \limitation{11}{Misperception of Time-Efficiency Tradeoffs}
            
            As noted by \cite{wernerDriverBehaviorFuel}, drivers face a trade-off between fuel costs and time costs. Those who value their time highly may prefer driving faster despite reduced efficiency \cite[p. 12]{wernerDriverBehaviorFuel}. Most drivers don't realize how little time they actually save by driving significantly faster.
            
            \subsubsection{Lack of financial incentives}
            \limitation{12}{Insufficient Financial Motivation}
            
            \cite{turrentineCarBuyersFuel2007} suggests that fuel economy is often not a priority for people unless fuel prices suddenly spike \cite[p.7]{gonderAnalyzingVehicleFuel2012}. Many drivers lack awareness of how much they actually spend on fuel. A feature that encompasses financial motivation by highlighting to the driver how much money he actually saved or will save if he changes his behavior are essential parts of motivation for many. 
            
            \subsubsection{Marketing and discoverability}
            \limitation{13}{Poor Marketing and Discoverability}
            
            Existing eco-driving apps have low download rates and are difficult to find when searching app stores, suggesting issues with naming, description, or overall marketing approach.
            
            % Print a summary of limitations at the end of this section
            \printLimitations

    \section{Research Gap and Proposed Adoption Framework}
    % This section synthesizes findings and proposes the framework that bridges technical implementation with adoption
        
        The literature review reveals a significant gap: while extensive research exists on the technical aspects of eco-driving applications (what to measure, how to measure it, and how to provide feedback), there is limited research specifically addressing mass adoption strategies for eco-driving apps. Most studies focus on "if the user uses an app, how then can we improve sustainable driving" rather than "how to get users to adopt the app in the first place."
        
        While many existing solutions have incorporated gamification, actionable tips, and other technically sound features, none have created a comprehensive package that achieved widespread adoption. We propose that combining solid technical eco-driving principles with mass adoption strategies from other domains could produce significantly greater environmental impact.
        
        Based on our research, we identify three key focus areas to address the limitations of existing eco-driving solution approaches and that may be critical for driving mass adoption:
        
        \focusarea{I}{Seamless Integration}
        \focusarea{II}{Engaging Motivation}
        \focusarea{III}{Social \& Hype Features}
        
        These three are explained in \ref{tab:features_research}
        
        Additionally, we identify \textbf{Privacy by Design} as a supporting principle that, while not directly driving adoption, removes a significant barrier by addressing privacy concerns through an open-source, offline-first approach. This aligns with \cite{gilmanHowSupportFuelefficient2018}'s identification of privacy as a key area for future development in driving coach applications and addresses \traceref{LIM}{5}.
        
        \begin{table}[h]
        \centering
        \renewcommand{\arraystretch}{1.3}
        \begin{tabular}{|p{2cm}|p{4cm}|p{6cm}|p{3cm}|}
            \hline
            \textbf{No} &\textbf{Feature} & \textbf{Description} & \textbf{Research Limitations Addressed} \\ 
            \hline
            \faref{I} & Seamless Integration & Aligning with natural phone usage patterns during driving for intuitive adoption, eliminating the choice between using the eco-driving app and other essential driving apps. Great UI/UX Design will also be a part of this focus area.  & \traceref{LIM}{1}, \traceref{LIM}{2} \\ 
            \hline
            \faref{II} & Engaging Motivation & Leveraging gamification with positive reinforcement mechanisms to enhance user engagement, making sustainable driving not only beneficial but enjoyable. & \traceref{LIM}{3}\tablefootnote{This focus Area seems to not address limitations, however, this is due to the fact that existing solutions already established these patterns partly. And they correctly did so, because it is crucial. Therefore, in the combination with the other areas, this will also be a focus of this implementation. Additionally, while only being one limitation, it is a major one.}\\ 
            \hline
            \faref{III} & Social \& Hype Features & Incorporating social comparison, normative feedback, hype-features, sharing capabilities, and modern design elements that align with contemporary app expectations. & \traceref{LIM}{1}, \traceref{LIM}{6}, \traceref{LIM}{7}, \traceref{LIM}{8}, \traceref{LIM}{9} \\ 
            \hline
            \end{tabular}
            \caption{Key Features and Their Impact on Research Limitations}
            \label{tab:features_research}
        \end{table}
        
        The remaining limitations are addressed as follows:
        
        \traceref{LIM}{4} is something that can be solved in two ways. Either a publisher with a budget can just provide these \ac{obd2} adapters for free (more hardware isn't needed for our proposed software), or, the app shall rely mainly on phone sensors. This limitation isn't a key area because there is not much research needed to address this. The app should have fallback mechanisms to use phone sensors for tracking and not require additional hardware. With that, this limitation is overcome.
        
        \traceref{LIM}{10} is not an immediate limitation of implementation specifics. This is a social issue that cannot be solved 100\%. However, through developing great motivation features and social competition, the priorities of eco-driving might rise over others. Addionally, if mass adoption is reached, social motivations to drive i.e. faster because of tailgaiting will be mitigated. Therefore this point is addressed through the three key areas already.
        
        \traceref{LIM}{11} is also something that isn't completely solvable. A good mitigation is to show the user how much he actually saves, factoring in fuel savings and extrapolating them over long timespans. This might set it into a favorable perspective for eco-driving. This feature doesn't need much additional research either and is therefore not part of the key focus areas.
        
        \traceref{LIM}{13} poses a fundamental issue with existing solutions. However the topic of how to reach a broad user-base and achieve high visibility in online app stores is already well researched with big publishers and producers knowing exactly what to do to overcome this issue. Regrettably the solution to this limitation is almost exclusively relying on large budgets, which we don't have access to in this research. The solution to this limitation being theoretically known should therefore suffice for our purposes.
        While we don't address this limitation further in our thesis, this is one of the main identified gaps and should be addressed by publishers looking to build a successful eco-driving application. Adding this to our proposed framework will overcome all the limitations addressed in this thesis. 
        
        This framework acknowledges an important reality: an app that produces 90\% improvement but reaches only 1\% of drivers has less environmental impact than an app that produces 40\% improvement but reaches 20\% of drivers. The most technically sophisticated eco-driving solution has zero impact if it remains unused.
        
        The following chapter will explore these three key areas in detail, examining the theoretical foundations for each and how they can be applied to create an eco-driving application with both technical excellence and mass adoption potential.
        
        This framework addresses the fundamental challenge identified in our literature review: creating an eco-driving solution that people will actually use. Rather than focusing solely on maximizing the technical effectiveness of eco-driving feedback, we aim to optimize for adoption while maintaining sufficient technical capability to deliver meaningful environmental benefits.
        
        Our hypothesis is that an application implementing these principles will achieve greater adoption than existing solutions, even if it offers similar or even slightly less sophisticated technical capabilities. The environmental impact of an application used by many drivers with moderate efficiency improvements would far exceed that of a technically superior application used by only a few.
        
        In the following chapter, we will explore the theoretical foundations of each component of our framework, examining how they can be effectively implemented to drive both adoption and behavior change in the context of eco-driving applications.
        
        % Print a summary of focus areas at the end of this section
        \printFocusAreas

################################################################################
FILE: chapters/03_Theoretical_Foundations.tex
################################################################################


% renamed to Research and Analysis since analysis is usually the biggest part in student thesis, not just theoretical foundations... right?  and we are already adding some kind of ananlysis here... 
\chapter{Research and Analysis of Key Areas for Improvements} \label{sec:theoreticalfoundationsproposedsolutions} 

    %todo put inline \requirements numbered after section
    %todo at end of each chapter, summarize with table
    % -> an erster section orientieren

    \section{How to encourage sustainable behavior - lessons learned from existing eco-driving research}    

        
        While not one of the proposed Focus Areas, this section collects requirements based on the lessons learned and research results from existing eco-driving research. 
        
        The improvement depends on the willingness the driver has to change his behavior. While an app cannot directly modify the willingness, it can do a lot to be compelling in making the driver change his behavior. Existing research and solutions will be analyzed in how far they get people to change their behavior. 
        
        \cite{gimpelSustainableBehaviorMotion2022} created a fairly recent and comprehensive study similar to this one. It also uses the \ac{dsr} methodology and assess the efficacy of different factors. What they found is that social comparison - normative feedback is a big factor for making changes in the drivers behavior possible. So this is an essential feature. A research question they recommended for future research is in how far personalization can improve it even, as different personalities react differently to certain kind of feedback. Therefore we have following requirements: %The research is sound and well made, however, the app also wasn't published or wasn't adopted. The UI again looks functional but not well done for mass adoption. 
        \requirement{1.1}{The app shall provide normative feedback regarding ecological driving behavior} % show feedback like 
        \requirement{1.2}{The app should personalize feedback according to the user profile } % have onboarding preference / vlaue questions
        
        

        \cite{gonderAnalyzingVehicleFuel2012} interestingly found that the social norm is essential to driving behavior. This aligns with \reqref{1.1}.
        

        Give the user detailed feedback after the journey to tell him exactly what he did wrong, why it is wrong and how he can improve it seems important \cite[p. 638, p. 640]{gilmanHowSupportFuelefficient2018}.
        \requirement{1.3}{The app should tell the user exactly what he did wrong, why it is wrong and how he can improve it}

        \cite{gonderAnalyzingVehicleFuel2012} also found that social comparison can motivate people to reduce energy consumption \cite[p. 7]{gonderAnalyzingVehicleFuel2012}. 
        \requirement{1.4}{The app shall encompass social comparison features such as leaderboards, sharing of scores and adding friends where scores are shared}

        \cite{turrentineCarBuyersFuel2007} suggests that fuel economy is often not an issue for people unless the fuel prices suddenly spikes \cite[p.7]{gonderAnalyzingVehicleFuel2012}. But another reason is the lack of knowledge how much they actually spend on fuel. 
        \requirement{1.5}{The app shall clearly tell the user how much he actually spends and how much he would save with better driving. The app may even extrapolate the savings to monthly or even yearly savings in the users currency.}

        \cite{boriboonsomsinEcoDrivingPilotEvaluation2010} found that users were much more likely to use a feedback device when it came with the car than to buy one \cite[p.7]{gonderAnalyzingVehicleFuel2012}. This means friction of additional purchases or configuration is a limitation.
        \requirement{1.6}{The app should minimize initial friction by being free or cheap and may even ship \ac{obd2} adapters upon registration to further lower the barrier}
        \requirement{1.7}{The app should include a Fallback to phone sensors measuring for basic usage}
        
        \cite{gonderAnalyzingVehicleFuel2012} lists some additional considerations such as providing feedback at different time scales such as live and also after every drive, when refueling or getting an oil change. It also states that positive feedback is better than punishment. Additionally, the study found that normative feedback is especially strong when compared with the users peers, i.e. people in the neighborhood. Prompts like \enquote{People in your area usually drive slower and save more Co2} are extra effective. 
        This aligns with \reqref{1.1}. Additionally:
        \requirement{1.8}{The app should have social comparisons and normative feedback to peers, i.e. drivers in the same area}
        \requirement{1.9}{The app should provide feedback at different time scales, such as live feedback, post-drive feedback and longer historic analysis}

        \cite{rakauskasDeterminingAccuracyAcceptance2010} found that it might be more effective to use binary 'yes/no' indications to tell the user if his driving behavior is efficient than a simple gauge, as this changes rapidly especially when city driving and the user might not be able to interpret it and especially not know how to improve his behavior \cite[p.8]{gonderAnalyzingVehicleFuel2012}. The app should therefore make sure that it gives clear exceptionable instructions on how exactly the user should improve his driving behavior and not just display the current fuel consumption of a vehicle. The exception to this would be highway driving, as the user can easily interpret that at higher speeds the current fuel consumption is higher than cruising with lower speed. 
        This aligns with \reqref{1.3}

        \cite{gene@pbwebdev.com.auDriverDistractionReview} examined driver distraction through devices such as mobile phones or navigation systems. They concluded that information given should be simple to understand and preferably audibly \cite[p.8]{gonderAnalyzingVehicleFuel2012}. Therefore the app shall try to keep feedback simple and use audio instructions where possible.
        \requirement{1.10}{The app should keep visual feedback and interaction on-drive minimal to not distract the driver}
        \requirement{1.11}{The app may use audio feedback on-drive}

        Eco-friendly driving recommendations compete with strong factors such as enjoyment of sporty driving, pressure from tailgating vehicles and using the engine one has paid for \cite[p. 9]{gonderAnalyzingVehicleFuel2012}. It is therefore essential for the app to give realistic recommendations and to be very psychologically convincing. A driver who is pressured by cars behind him might need a lot of encouragement to not give in to peer pressure. The psychological features of the app will therefore be essential in changing driving behavior.
        This is mitigated with mass adoption of the app, as more people try to drive slower. It is also addressed with higher motivation, which section \ref{theoreticalengagingmotivation} analyzes further and creates requirements. Additionally, a holistic approach could do following:
        \requirement{1.12}{The app may ship trendy stickers for the back of the car to indicate that driver is driving slower to save the climate}
        \requirement{1.13}{The app may include a 'I am in a hurry' or 'I want to enjoy some sporty driving a bit' buttons, to sometimes give in to higher competing priorities and not annoy with feedback, so that the rest of time the driver will accept the eco-driving feedback better. The statistics of how often the user did this should be reflected in his profile, to encourage him to not do it often. }

        \cite{wernerDriverBehaviorFuel} also suggests that transportation is the main goal of drivers and it comes at two costs, which are at a trade off: Fuel costs and time. An individual which values their time very high and also earns a lot might choose to drive higher speeds \cite[p. 12]{wernerDriverBehaviorFuel}. This means that cost effectiveness is not always sufficient to get people to change their behavior. The appeal to sustainability is one factor that will help there, but also, the issue with the additional time spend needs to be addressed to fully convince the driver. Most cars' efficient top speed is less than the maximum speed allowed on highways. This means that in order to drive sustainably, the driver will progress slower than he could otherwise. However, what many don't realize is that the benefit of driving fast has little returns on the time won. Driving 130 km/h instead of 90 km/h for a whole hour will only save you about 18 minutes in the very best case. Usually, this number isn't realistic due to traffic. So the app should give the user approximations of how little he will save if he chooses to drive fast now. Usually, 1\% of speed reduction will get 1.1\% in fuel savings, noted that highway driving is above the most efficient speed and city driving below it \cite[p. 16]{wernerDriverBehaviorFuel}. 
        \requirement{1.14}{The app should show convey to the user (with transparent calculations) that faster or more aggressive driving doesn't save significant time. i.e. when user is driving 130 kmh: 'driving 130 instead of 80 will only save you 5 min on your journey but 10 trees need one week to make up for the surplus Co2'}. 
        

        Drivers might have different motivations for more efficient driving, therefore not every 'nudge' will be equally effective \cite[p. 631]{gilmanHowSupportFuelefficient2018}. For example, a driver who is motivated by saving the climate but has enough money will not change his behavior if the app tells him that he will save money by driving in a certain way. Therefore, personalization might be required \cite{brouwerPersonalisedFeedbackEcodriving2015}. % is the following already analysis?:
        The app could question the user at the beginning to assess his motivations and then target the users motivation more effectively based on that. The app should also allow the user to some degree customize his feedback experience \cite[p. 632]{gilmanHowSupportFuelefficient2018}. 
        This aligns with \reqref{1.2}.

        Money savings, fuel consumption, and CO2 emissions are the top things users want to see \cite[p. 639]{gilmanHowSupportFuelefficient2018}. So these have to be implemented to be shown to the user. Additionally, graphs work better than text \cite[p. 639]{gilmanHowSupportFuelefficient2018}. 
        \requirement{1.15}{The app shall provide statistics in graph form of money savings in local currency, fuel consumption in L, Co2 emissions in KG and helpful reference values (i.e. tree a day).}

        Even though it doesn't directly help to promote sustainability, driver safety is an important factor to consider \cite{gilmanHowSupportFuelefficient2018}. The app should therefore not be to cognitively challenging and distracting.
        This aligns with \reqref{1.10}

        \citeauthor{fafoutellisEcoDrivingItsImpacts2021} compared studies over their findings of most significant factors, speed and acceleration where found in most of them, making these the top priorities \cite[p.~8]{fafoutellisEcoDrivingItsImpacts2021}. This means that measures have to be found to encourage people to drive more relaxed. This might include prompting them to enjoy the beautiful views (depending on the location, obviously :)) or practicing mindfulness while driving. This might also include prompting them to leave in time to not have to hurry, as this can create a perceived necessity for inefficient driving behavior. Definitely, the behavior needs to be rewarded and positively reinforced to counteract the temptation to drive faster.
        This aligns with previously defined requirements and requirements that will follow in the motivation chapter. Additionally:
        \requirement{1.16}{The app may nudge the user to remember to leave in time to not have to hurry}
        
        Table \ref{tab:requirements_summary} summarizes the requirements gathered from this section:
        
        \begin{table}[htbp]
        	\small
        	\centering
        	\caption{Summary of Requirements from Eco-Driving Research}
        	\begin{tabular}{|p{2.3cm}|p{9cm}|p{2.5cm}|}
        		\hline
        		\textbf{Requirement} & \textbf{Description} & \textbf{Priority} \\
        		\hline
        		\traceref{REQ}{1.1} & The app shall provide normative feedback regarding ecological driving behavior & Mandatory \\
        		\hline
        		\traceref{REQ}{1.2} & The app should personalize feedback according to the user profile & Recommended \\
        		\hline
        		\traceref{REQ}{1.3} & The app should tell the user exactly what he did wrong, why it is wrong and how he can improve it & Recommended \\
        		\hline
        		\traceref{REQ}{1.4} & The app shall encompass social comparison features such as leaderboards, sharing of scores and adding friends where scores are shared & Mandatory \\
        		\hline
        		\traceref{REQ}{1.5} & The app shall clearly tell the user how much he actually spends and how much he would save with better driving. The app may even extrapolate the savings to monthly or yearly savings in the users currency & Mandatory \\
        		\hline
        		\traceref{REQ}{1.6} & The app should minimize initial friction by being free or cheap and may even ship OBD2 adapters upon registration to further lower the barrier & Recommended \\
        		\hline
        		\traceref{REQ}{1.7} & The app should include a fallback to phone sensors measuring for basic usage & Recommended \\
        		\hline
        		\traceref{REQ}{1.8} & The app should have social comparisons and normative feedback to peers, i.e. drivers in the same area & Recommended \\
        		\hline
        		\traceref{REQ}{1.9} & The app should provide feedback at different time scales, such as live feedback, post-drive feedback and longer historic analysis & Recommended \\
        		\hline
        		\traceref{REQ}{1.10} & The app should keep visual feedback and interaction on-drive minimal to not distract the driver & Recommended \\
        		\hline
        		\traceref{REQ}{1.11} & The app may use audio feedback on-drive & Optional \\
        		\hline
        		\traceref{REQ}{1.12} & The app may ship trendy stickers for the back of the car to indicate that driver is driving slower to save the climate & Optional \\
        		\hline
        		\traceref{REQ}{1.13} & The app may include 'I am in a hurry' or 'I want to enjoy some sporty driving a bit' buttons, to sometimes give in to higher competing priorities and not annoy with feedback, so that the rest of time the driver will accept the eco-driving feedback better. The statistics of how often the user did this should be reflected in his profile, to encourage him to not do it often & Optional \\
        		\hline
        		\traceref{REQ}{1.14} & The app should show convey to the user (with transparent calculations) that faster or more aggressive driving doesn't save significant time & Recommended \\
        		\hline
        		\traceref{REQ}{1.15} & The app shall provide statistics in graph form of money savings in local currency, fuel consumption in L, CO2 emissions in KG and helpful reference values (i.e. tree a day) & Mandatory \\
        		\hline
        		\traceref{REQ}{1.16} & The app may nudge the user to remember to leave in time to not have to hurry & Optional \\
        		\hline
        	\end{tabular}
        	\label{tab:requirements_summary}
        \end{table}
        

        
    %todo max
        
    \section{Hype and Social}

        While not one of the main focus areas identified in previous eco-driving research, incorporating social and hype elements into eco-driving applications can significantly increase user adoption and long-term engagement. This section analyzes existing research and implementation examples to identify effective strategies for leveraging social psychology to promote sustainable driving behavior.
        
        \subsection{Profile Sharing and Social Comparison}
        
        A key motivator in eco-driving apps is the ability to compare one's performance with others. Social comparison features such as leaderboards, public statistics, and user profiles contribute significantly to behavioral change by leveraging social norms and peer motivation \cite{schultzConstructiveDestructiveReconstructive2007}.
        
        \citeauthor{maganaGAFUGameFuel2013} developed the \textit{GAFU} system, where users could share fuel efficiency performance in a social network. Results showed that these features increased both engagement and measurable fuel savings \cite{maganaGAFUGameFuel2013, corcobamaganaGAFUUsingGamification2015}. Similarly, \citeauthor{stephensReviewGamifiedApproaches2022a} notes that leaderboards and peer comparison were among the most cited mechanisms in successful gamified eco-driving applications \cite{stephensReviewGamifiedApproaches2022a}.
        
        However, social comparison must be applied thoughtfully. \citeauthor{rappGamificationToolEncourage2016} reports that some users found public leaderboards demotivating if they perceived the comparison as unfair \cite{rappGamificationToolEncourage2016}. Therefore, personalization and opt-in mechanisms are essential.
        
        \requirement{2.1}{The app shall offer social comparison features such as leaderboards, but allow users to opt-in and filter comparisons by vehicle type, geography or friend groups.}
        
        \subsection{Hype Mechanics and Visual Aesthetics}
        
        Hype features refer to visual, emotional, and aesthetic design elements that amplify user engagement. These include animations, sound effects, badges, and celebratory messages after achievements. Such features serve as positive reinforcement, providing users with immediate gratification and motivating continued use.
        
        \citeauthor{mcgonigalRealityBrokenWhy2011} argues that game-like interfaces make digital tools more fun and emotionally engaging, fulfilling psychological needs such as competence and purpose \cite{mcgonigalRealityBrokenWhy2011}. In eco-driving, \citeauthor{reinerCollectiveDataSharing2014} found that positive visual cues such as a "clapping" sound or bright indicators after eco-friendly driving increased user satisfaction and engagement \cite{reinerCollectiveDataSharing2014}.
        
        The visual and auditory aspects of feedback systems have been empirically validated. \cite{mcilroyEncouragingEcoDrivingVisual2017} found that multisensory feedback, including visual, auditory, and vibrotactile stimuli, effectively discouraged harsh accelerations and supported greater coasting distances—behaviors that are critical for eco-driving. Similarly, \cite{azziEcoDrivingPerformanceAssessment2011} showed that visual and haptic feedback could reduce emissions when properly designed.
        
        \requirement{2.2}{The app shall implement multisensory hype features, including visual animations and auditory sound effects, to positively reinforce efficient driving behavior.}
        
        \subsection{Social Proof and Virality}
        
        Social proof refers to the psychological phenomenon where people copy the actions of others to behave correctly. Sharing one's performance or receiving validation (e.g., "likes") can lead to increased motivation and behavior consistency \cite{hamariWorkingOutLikes2015}.
        
        In the fitness domain, \citeauthor{frankenKudosMakeYou2023a} found that athletes receiving more kudos (likes) on Strava were more likely to repeat the activity \cite{frankenKudosMakeYou2023a}. Similarly, \citeauthor{hamariWorkingOutLikes2015} found that visibility of actions and peer interaction positively impacted continued app use \cite{hamariWorkingOutLikes2015}. For eco-driving, allowing users to share their stats, badges, or milestones (e.g., "100kg CO$_2$ saved") could leverage similar dynamics.
        
        Additionally, displaying aggregate impact statistics, such as total CO$_2$ saved by all users, can provide social proof and motivate users through collective achievement. Research on pro-environmental behavior shows that collective efficacy, enhanced by seeing community impact, positively influences individual actions \cite{cuadradoModeratingEffectCollective2022}.
        
        \requirement{2.3}{The app shall support sharing of achievements and eco-driving statistics to social media or within the app's community.}
        
        \requirement{2.10}{The app should display aggregate impact statistics to provide social proof and motivate users through collective achievement.}
        
        \subsection{Motivation Models: FBM and SDT}
        
        Fogg's Behavior Model (FBM) states that behavior change requires motivation, ability, and a trigger \cite{foggBehaviorModelPersuasive2009}. Gamification and hype features can serve as motivational triggers, especially when users receive timely notifications or feedback.
        
        Meanwhile, Self-Determination Theory (SDT) emphasizes autonomy, competence, and relatedness as the drivers of intrinsic motivation \cite{ryanSelfdeterminationTheoryFacilitation2000a}. Badges and leaderboards support competence; sharing and team challenges support relatedness; and opt-in settings preserve autonomy \cite{brouwerPersonalisedFeedbackEcodriving2015a}.
        
        \requirement{2.4}{The app should support intrinsic motivation by enabling users to track progress, connect with others, and customize their experience.}
        
        \subsection{Additional Social Features for Engagement}
        
        Research on social fitness platforms provides valuable insights applicable to eco-driving apps. \cite{huExaminingImpactsFitness2023} found that social-oriented features significantly improve engagement and adherence to fitness programs, suggesting similar benefits for eco-driving applications.
        
        \requirement{2.5}{The app shall allow users to connect with friends or follow other users within the app.}
        
        Team-based approaches have also shown promise in motivating behavior change. Studies of workplace wellness programs found that team challenges fostered both collaboration and competition, leading to increased engagement \cite{schoechGamificationBehaviorChange2013, morfordGamificationIntersectionBehavior2014}.
        
        \requirement{2.6}{The app should support team-based challenges where groups of users can compete against each other in eco-driving metrics.}
        
        Community features that enable users to interact beyond competition also contribute to engagement. \cite{coutureReflectionsStravasphereKudos2021} analyzed how community feeds in fitness apps create spaces for social interaction and motivation, which could help build a supportive eco-driving community.
        
        \requirement{2.7}{The app should have a community feed where users can see updates, achievements, and tips from other users, with options to like and comment.}
        
        Positive reinforcement from peers can significantly impact behavior maintenance. The "kudos" system on Strava exemplifies this effect, with users who receive positive feedback more likely to continue their activities \cite{frankenKudosMakeYou2023a}.
        
        \requirement{2.8}{The app should allow users to give positive feedback (e.g., 'eco-kudos') to other users for their eco-driving achievements.}
        
        Social learning theory suggests that people learn by observing others' behaviors and outcomes \cite{banduraSocialLearningTheory1977}. \cite{liangInfluenceVariousRole2022} demonstrated that role models can significantly influence pro-environmental behaviors, suggesting that highlighting exemplary users could promote adoption of eco-driving practices.
        
        \requirement{2.9}{The app may feature user highlights or stories to showcase exemplary eco-driving behavior and inspire other users.}
        
        Finally, periodic events and challenges can help maintain engagement over time. \cite{stephensReviewGamifiedApproaches2022b} identified this as a common and effective gamification strategy across multiple eco-driving applications.
        
        \requirement{2.11}{The app should host periodic community challenges or events to engage users and create a sense of collective participation.}
        
        \subsection{Privacy and Control}
        
        With increased data sharing comes the need for robust privacy settings. Users must feel in control over what data is visible and to whom. \citeauthor{vaezipourDesignGamifiedInterface2016} found that privacy concerns were among the top barriers to adoption of gamified driving tools \cite{vaezipourDesignGamifiedInterface2016}. Ensuring transparency and user control is essential.
        
        \requirement{2.12}{The app must provide privacy settings to allow users to control what aspects of their driving data are shared and with whom.}
        
        \begin{table}[htbp]
        \small
        \centering
        \caption{Summary of Requirements from Hype and Social Features}
        \begin{tabular}{|p{2.3cm}|p{9cm}|p{2.5cm}|}
        \hline
        \textbf{Requirement} & \textbf{Description} & \textbf{Priority} \\
        \hline
        \traceref{REQ}{2.1} & The app shall offer social comparison features such as leaderboards, but allow users to opt-in and filter comparisons by vehicle type, geography or friend groups & Mandatory \\
        \hline
        \traceref{REQ}{2.2} & The app shall implement multisensory hype features, including visual animations and auditory sound effects, to positively reinforce efficient driving behavior & Recommended \\
        \hline
        \traceref{REQ}{2.3} & The app shall support sharing of achievements and eco-driving statistics to social media or within the app's community & Recommended \\
        \hline
        \traceref{REQ}{2.4} & The app should support intrinsic motivation by enabling users to track progress, connect with others, and customize their experience & Recommended \\
        \hline
        \traceref{REQ}{2.5} & The app shall allow users to connect with friends or follow other users within the app & Mandatory \\
        \hline
        \traceref{REQ}{2.6} & The app should support team-based challenges where groups of users can compete against each other in eco-driving metrics & Recommended \\
        \hline
        \traceref{REQ}{2.7} & The app should have a community feed where users can see updates, achievements, and tips from other users, with options to like and comment & Recommended \\
        \hline
        \traceref{REQ}{2.8} & The app should allow users to give positive feedback (e.g., 'eco-kudos') to other users for their eco-driving achievements & Recommended \\
        \hline
        \traceref{REQ}{2.9} & The app may feature user highlights or stories to showcase exemplary eco-driving behavior and inspire other users & Optional \\
        \hline
        \traceref{REQ}{2.10} & The app should display aggregate impact statistics to provide social proof and motivate users through collective achievement & Recommended \\
        \hline
        \traceref{REQ}{2.11} & The app should host periodic community challenges or events to engage users and create a sense of collective participation & Recommended \\
        \hline
        \traceref{REQ}{2.12} & The app must provide privacy settings to allow users to control what aspects of their driving data are shared and with whom & Mandatory \\
        \hline
        \end{tabular}
        \label{tab:hype_social_requirements}
        \end{table}
        %todo max
    \section{Engaging Motivation: Gamification with Positive Reinforcement}
    
        The long-term adoption of an eco-driving application fundamentally depends on its ability to engage user motivation. Without a compelling motivational mechanism, sustained interaction with the app is unlikely. Users may engage with the system due to intrinsic motivation—such as a personal commitment to environmental sustainability—or extrinsic factors like enjoyment, achievement, or social comparison. To maximize impact across diverse user profiles, the application should incorporate multiple motivational strategies, tailored to individual preferences and behavioral tendencies.
        
        This section focuses on two key strategies with demonstrated effectiveness in behavior change literature: \textit{Gamification} and \textit{Positive Reinforcement}. These approaches are not only well-supported by psychological theory but are also operationalizable through persuasive system design principles.
        
        User motivation is not monolithic; different individuals respond to different stimuli. As shown in \cite{brouwerPersonalisedFeedbackEcodriving2015}, personalized feedback enhances effectiveness by aligning app interactions with the user's motivational drivers. Therefore, a key component of the app's architecture should involve an adaptive personalization engine. This could involve initial assessments (e.g., personality type, environmental values) and ongoing behavioral analysis (e.g., responsiveness to prompts), enabling dynamic adjustment of the motivational framing. For instance, competitive users may benefit from features such as performance scores, rankings, and progress graphs, whereas altruistic users may be more influenced by visualizing their positive environmental impact (e.g., CO$_2$ saved or trees preserved).
        
        These design decisions align with persuasive design principles as identified in multiple sources. \citeauthor{zhangPersuasiveDesignPrinciples2016} emphasize the need for systems to be adaptive and context-aware, while \citeauthor{gilmanHowSupportFuelefficient2018} synthesizes a framework of principles that includes \textit{Praise} (positive reinforcement), \textit{Rewards} (gamification), and \textit{Social Role}—each of which can be effectively integrated into the eco-driving context \cite[p.~633]{gilmanHowSupportFuelefficient2018}. The principles of \textit{Competition} and \textit{Social Comparison}—frequently used in gamified applications—can further enhance engagement by tapping into users’ extrinsic motivational systems \cite{oinas-kukkonenPersuasiveSystemsDesign2009}. 
        
        Accordingly, this section will explore how these motivational techniques can be systematically applied to improve both the adoption and behavioral impact of the eco-driving app.
        
        
        
        Gamification---the integration of game design elements into non-game contexts---has been extensively validated as a mechanism for motivating behavior change, particularly in sustainability and health domains \cite{deterdingGameDesignElements2011, cugelmanGamificationWhatIt2013}. In the context of eco-driving, gamification helps transform energy-efficient driving from a passive or abstract task into an engaging, goal-oriented activity. Drawing on principles from Self-Determination Theory (SDT), effective gamified interventions fulfill users’ psychological needs for competence, autonomy, and relatedness \cite{ryanSelfDeterminationTheoryFacilitation2000}. Game mechanics such as point systems, real-time feedback, and social interaction serve to operationalize these motivational constructs \cite{hamariDoesGamificationWork2014}.
        
        Persuasive design elements such as feedback, rewards, goal setting, and social influence reinforce gamification's effectiveness \cite{cugelmanGamificationWhatIt2013}. Applications that incorporate these principles often achieve higher engagement and greater behavioral impact. As demonstrated in empirical studies, eco-driving applications leveraging gamified elements show measurable reductions in fuel consumption and increased user satisfaction \cite{maganaReducingEnergyConsumption2015, stephensReviewGamifiedApproaches2022}.
        
        \begin{itemize}
        \item \requirement{3.1}{The app must implement a performance-based eco-score that reflects driving efficiency.}
        \item \requirement{3.2}{The app shall include both short-term challenges and long-term progress tracking mechanisms.}
        \item \requirement{3.3}{The app shall adapt gamification strategies to user-specific motivation profiles.}
        \item \requirement{3.4}{The app should dynamically adjust challenge difficulty to user performance trends.}
        \end{itemize}
        
        \subsection{Eco-Driving Gamification in Practice}
        
        Field implementations have validated the practical utility of gamification. The Eco-Drive app by Maga~na and Mu~noz-Organero showed that gamified feedback can reduce fuel consumption by approximately 6\% \cite{maganaReducingEnergyConsumption2015}. Visual and auditory cues, achievement systems, and social comparisons were positively associated with behavior change \cite{stephensReviewGamifiedApproaches2022}. Notably, visual metaphors and emotive cues (e.g., growing leaves or facial expressions) were found to enhance user experience and comprehension.
        
        \requirement{3.5}{The app should include social comparison features (e.g., leaderboards).}
        
        \subsection{Effective Strategies and Design Considerations}
        
        Achievement-oriented mechanics---such as progress bars, performance scores, and milestone badges---have demonstrated superior impact compared to fictional or purely social elements \cite{walliusFictionalRealReview2024}. Personalization increases the relevance of these mechanisms by tailoring game dynamics to individual user types \cite{seecharanGamifiedEcodrivingYoung2024}. Moreover, minimizing real-time cognitive load is essential for safety and sustained use, particularly during live driving \cite{rodriguesGamificationSuffersNovelty2022}.
        
        \begin{itemize}
        \item \requirement{3.6}{The app must minimize visual and cognitive distraction during active driving.}
        \item \requirement{3.7}{The app should integrate both intrinsic and extrinsic motivators to support long-term engagement.}
        \item \requirement{3.8}{The app may offer customizable themes or visual metaphors aligned with user motivation.}
        \end{itemize}
        
        \subsection{Sustaining Engagement and Avoiding Pitfalls}
        
        Gamified apps often face the challenge of declining engagement after initial novelty wears off. This "novelty effect" has been documented as a common issue in longitudinal studies \cite{rodriguesGamificationSuffersNovelty2022}. However, findings also show a "familiarization effect," where users may regain engagement once gamified behavior becomes routine. To sustain long-term use, gamification strategies must introduce periodic novelty, adjust difficulty levels, and reinforce intrinsic motivators over time.
        
        Furthermore, over-reliance on extrinsic rewards may risk undermining intrinsic motivation, leading to decreased adherence once rewards are removed. Gamification must therefore maintain a balance between reward-driven and value-driven engagement. Additionally, care must be taken to prevent negative social dynamics, such as discouragement from consistently low leaderboard positions or perceived unfairness.
        
        \begin{itemize}
        \item \requirement{3.9}{The app shall incorporate mechanisms to re-engage users after periods of inactivity.}
        \item \requirement{3.10}{The app should allow users to opt-out of social comparison features to reduce competitive pressure.}
        \end{itemize}
        
    
    
    
                
                
    
    \subsection{Requirement Summary}
    
        \begin{table}[h]
        \small
        \centering
        \caption{Summary of Gamification Requirements}
        \begin{tabular}{|p{2.3cm}|p{9cm}|p{2.5cm}|}
        \hline
        \textbf{Requirement} & \textbf{Description} & \textbf{Priority} \\
        \hline
        \traceref{REQ}{3.1} & The app must implement a performance-based eco-score that reflects driving efficiency. & Mandatory \\
        \hline
        \traceref{REQ}{3.2} & The app shall include both short-term challenges and long-term progress tracking mechanisms. & Mandatory \\
        \hline
        \traceref{REQ}{3.3} & The app shall adapt gamification strategies to user-specific motivation profiles. & Mandatory \\
        \hline
        \traceref{REQ}{3.4} & The app should dynamically adjust challenge difficulty to user performance trends. & Recommended \\
        \hline
        \traceref{REQ}{3.5} & The app should include social comparison features (e.g., leaderboards). & Recommended \\
        \hline
        \traceref{REQ}{3.6} & The app must minimize visual and cognitive distraction during active driving. & Mandatory \\
        \hline
        \traceref{REQ}{3.7} & The app should integrate both intrinsic and extrinsic motivators to support long-term engagement. & Recommended \\
        \hline
        \traceref{REQ}{3.8} & The app may offer customizable themes or visual metaphors aligned with user motivation. & Optional \\
        \hline
        \traceref{REQ}{3.9} & The app shall incorporate mechanisms to re-engage users after periods of inactivity. & Mandatory \\
        \hline
        \traceref{REQ}{3.10} & The app should allow users to opt-out of social comparison features to reduce competitive pressure. & Recommended \\
        \hline
        \end{tabular}
        \label{tab:gamification_requirements}
        \end{table}

    %todo jonas
    \section{Seamless Integration} \label{sec:seamlessintegration}


       \subsection{Defining Seamless Integration in Eco-Driving Context and the Problem of Application Friction}
	       The literature review identified several limitations in existing eco-driving solutions, including \traceref{LIM}{1} (Poor User Interface) and \traceref{LIM}{2} (Lack of Integration with Existing Driving Routines). Most eco-driving applications require users to make a choice between their preferred driving apps (navigation, music, etc.) and the eco-driving app, creating unnecessary friction that hinders adoption \cite{gonderAnalyzingVehicleFuel2012}. This section examines how seamless integration can address these limitations.

	       \citeauthor{gonderAnalyzingVehicleFuel2012} noted that while mobile applications have high potential as driver feedback devices, their adoption is limited by competition with other phone uses during driving \cite[p. 9]{gonderAnalyzingVehicleFuel2012}. This observation aligns with broader findings in technology adoption research, where requiring users to drastically change their habits often leads to abandonment 
	       
	       Research on app friction and adoption rates reveals that user experience significantly impacts app retention. A study by Localytics found that 21\% of users abandon an app after one use\cite{ramelMobileAnalyticsFirm}, and 70\% of users stop using apps within 100 days \cite[Results]{kidmanWhenWhyAdults2024}.

           \cite{perezUseSmartphoneApps2024} found that 2016, almost half of people surveyed answered texts on their phones or used GPS. This means that people want to have the option to use messaging and navigation apps while driving. Based on this usage behavior, a fundamental requirement emerges:

           Seamless integration in the context of eco-driving applications refers to the ability of an eco-driving solution to coexist with and complement the user's existing driving routines and apps, rather than competing with them. For an eco-driving application, seamless integration means operating alongside (or within) the driver's existing technology ecosystem without requiring the driver to choose between eco-driving feedback and other essential driving applications.
	       
	       \requirement{4.1}{The app shall be capable of collecting driving data while running in the background while other applications are in use}
	       
	       This ensures that individuals who are used to using other apps while driving can still use the app without additional changing behavior friction. They will get their feedback through post-drive and long term analytics. Additionally, those that use the on-drive display can safely switch apps if they need to use navigation while using the app because the data collection continues in the background.

           Toe be able to use other apps, another requirement also seems important:

           \requirement{4.2}{The app shall minimize battery impact while running in the background}
           
           Seamless integration also means aligning with established usability principles, particularly Nielsen's Heuristics \cite{nielsenEnhancingExplanatoryPower1994}. Learning to use new systems requires effort and therefore produces friction. To counter that, the following requirement is essential:

           \requirement{4.3}{The app shall follow established UI/UX guidelines to reduce adoption friction}
	       
	       
       \subsection{Integration Approaches and Technical Possibilities}
       		Several technical approaches exist for integrating eco-driving functionality with existing driver routines. Each offers different benefits and limitations:
       
	       \subsubsection{Background Service with Notifications}
		       Modern mobile operating systems allow applications to run background services that can collect sensor data and provide notifications without requiring the app to be in the foreground. This approach allows an eco-driving app to monitor driving behavior while the user interacts with navigation or music apps.
		       
		       Background services face several technical challenges:
		       \begin{itemize}
		       	\item Battery optimization restrictions on Android and iOS
		       	\item Limited notification visibility during active navigation
		       	\item Potential data collection gaps when the device enters doze mode
		       \end{itemize}
		       
		       % todo: Research and document specific Android/iOS APIs and limitations for background services that collect sensor data
		       % Research keywords: "Android foreground service limitations", "iOS background app refresh limitations", 
		       % "motion activity recognition background", "Android doze mode workarounds", "battery efficient background services"
		       % Key APIs to investigate: Android JobScheduler, WorkManager, ForegroundService; iOS Background App Refresh, Core Motion
		       % Look for Google and Apple developer documentation, as well as academic papers on mobile sensing frameworks
		       
		       Despite these challenges, background services offer the most widely compatible approach for seamless integration, as they work on virtually all modern smartphones without requiring special permissions or system modifications.
		       
		       Based on this understanding, an additional requirement emerges:
		       
		       \requirement{4.4}{The app shall store drive data locally to allow detailed post-drive feedback without requiring constant user attention during driving}
	       
	       \subsubsection{Vehicle Infotainment System Integration}
		       Modern vehicles increasingly support smartphone integration through platforms like Android Auto and Apple CarPlay. These platforms potentially allow eco-driving apps to display information alongside navigation and media controls in the vehicle's native interface.
		       
		       % todo: Research current Android Auto and Apple CarPlay policies for third-party apps - what categories can be published? Are eco-driving apps permitted?
		       % Research keywords: "Android Auto third-party app categories", "Apple CarPlay app approval process", 
		       % "automotive infotainment app guidelines", "Android Auto custom UI limits"
		       % Look at Google's Android for Cars App Library documentation, Apple's CarPlay developer guidelines
		       % Check automotive industry forums and developer communities for real-world experience with these platforms
		       
		       The primary advantage of this approach is deep integration with the vehicle's interface, potentially including steering wheel controls and larger displays. However, limitations include:
		       \begin{itemize}
		       	\item Restricted app categories allowed on these platforms \cite{AndroidAppsFuerAutos}\cite[p. 3]{CarPlayAppProgramming2024}, and eco-driving applications are not one of them
		       	\item Compatibility limited to newer vehicles with these systems (since older vehicles usually if at all don't have large enough screens to support Android Auto or Apple CarPlay)
		       	\item Strictly controlled UI guidelines limit custom visualizations\cite[p. 5]{CarPlayAppProgramming2024}
		       \end{itemize}
		       
		       This suggests a more cautious requirement:
		       
		       \requirement{4.5}{The app should integrate with Android Auto and/or Apple CarPlay if technically feasible}
		       
	       \subsubsection{Voice User Interface}
		       Voice interfaces offer a promising approach for eco-driving feedback without visual distraction. This aligns with requirement \reqref{1.11} which suggests using audio feedback during driving.
		       
		       % todo: Research studies on effectiveness of voice feedback for driving behavior modification
		       % Research keywords: "voice feedback driver behavior change", "auditory feedback driving efficiency", 
		       % "speech interface driver distraction", "voice UI driving safety"
		       % Look for papers in journals like Human Factors, Transportation Research Part F, and Accident Analysis & Prevention
		       % Key researchers: David Sirkin (Stanford), Paul Green (University of Michigan), John Lee (University of Wisconsin)
		       
		       Voice feedback could include:
		       \begin{itemize}
		       	\item Real-time coaching ("Try gentler acceleration")
		       	\item Achievement notifications ("Great job maintaining efficient speed")
		       	\item Summary feedback at trip milestones ("You've been driving efficiently for 10 minutes")
		       \end{itemize}
		       
		       Implementation could leverage platform capabilities like Android's TextToSpeech API or more sophisticated voice assistants through integration with Google Assistant or Siri Shortcuts.
		       
		       % todo: Research and document specific voice UI frameworks and their capabilities/limitations
		       % Research keywords: "Android TextToSpeech API limitations", "iOS AVSpeechSynthesizer capabilities", 
		       % "Google Assistant App Actions", "Siri Shortcuts integration", "voice UI frameworks comparison"
		       % Look at platform documentation and developer forums for real-world implementation experiences
		       
		       This approach suggests another requirement:
		       
		       \requirement{4.6}{The app should provide audio feedback options that don't require looking at the screen}
	       
	       \subsubsection{Widget and Overlay Approaches}
		       Some mobile platforms support widgets or floating overlays that can display information on top of other applications. This approach could potentially allow eco-driving information to be displayed alongside navigation apps.
		       
		       % todo: Research technical possibilities and limitations of overlay approaches on Android and iOS
		       % Research keywords: "Android overlay API restrictions", "Android quick settings tile implementation", 
		       % "home screen widget development", "Android SYSTEM_ALERT_WINDOW permission", "iOS widget capabilities"
		       % Look at platform developer documentation and forums discussing overlay implementation challenges
		       % Check for any recent policy changes regarding overlay permissions in Android 12+ and iOS
		       
		       While technically feasible on some platforms (particularly Android), this approach faces several challenges:
		       \begin{itemize}
		       	\item Increasing restrictions on overlay permissions in modern Android versions
		       	\item Complete lack of overlay support in iOS
		       	\item Potential distraction and safety concerns
		       \end{itemize}
		       
		       Given these challenges, a more modest requirement is appropriate:
		       
		       \requirement{4.7}{The app may provide a simplified widget or quick settings tile for users who prefer visual indicators}
	       
	       \subsubsection{Integration with Ride-Sharing Platforms}
		       As identified in the literature review, integration with platforms like Uber represents a promising avenue for adoption. Drivers who already use their phones for ride-sharing may be receptive to eco-driving features that complement these applications.
		       
		       % todo: Research APIs and integration possibilities with major ride-sharing platforms
		       % Research keywords: "Uber API developer access", "Lyft third-party integration", 
		       % "ride-sharing platform partnerships", "driver-partner app integration"
		       % Look for developer documentation from major ride-sharing companies and case studies of successful integrations
		       % Check for academic papers on ride-sharing platform economics and driver behavior incentives
		       
		       Integration options might include:
		       \begin{itemize}
		       	\item Profile badges or ratings for eco-driving performance which can be displayed in the ride-sharing apps 
		       	\item Passenger-visible eco-driver status to indicate if a driver is ecological or not
		       	\item Data sharing between the eco-driving app and ride-sharing platforms
		       	\item Direct integration of the eco-driving tracker inside the ride-sharing app (this would require collaboration with these apps)
		       	\item Most simply and initially: Giving the user a link which leads viewers to his profile of the eco-driving application in the web browser, where stats about this driver can be seen
		       \end{itemize}
		       
		       This analysis suggests the following requirement:
		       
		       \requirement{4.8}{The app should offer link-based access to a users profile and may provide an API for potential integration with ride-sharing platforms }
		       
	       \subsection{Driver Distraction and Safety Considerations}
		       Any integration approach must prioritize driver safety by minimizing distraction. This aligns with requirement \reqref{1.10}, which states that the app should keep visual feedback and interaction during driving minimal. \cite{cairdDoesTalkingCell2018} found that activities like dialing on the phone are likely to increase crash risk. The study also analyses the affect of other behaviors such as conversing with the Passenger.
		       
		       Research on driver distraction provides clear guidelines for interface design during driving:
		       
		       \begin{itemize}
		       	\item Information should be glanceable, requiring less than 2 seconds to comprehend
		       	\item Interactions should require minimal manual input
		       	\item Critical functions should be accessible with minimal cognitive load
		       	\item Visual elements should be large, high-contrast, and easily distinguishable
		       \end{itemize}
		       
		       For eco-driving applications, this suggests:
		       \begin{itemize}
		       	\item Favoring audio feedback over visual displays when possible
		       	\item Using simple, color-coded visual indicators rather than detailed displays
		       	\item Providing more detailed feedback only before or after driving
		       	\item Avoiding interactions that require precision tapping during driving
		       \end{itemize}
		       
	       
	       \subsection{User Experience and Adoption Impact}
		       The concept of seamless integration directly addresses the adoption barriers identified in the literature review. By reducing friction, an eco-driving application can achieve higher adoption rates and greater long-term usage.
		       
		       
		       Seamless integration contributes to adoption through several mechanisms:
		       \begin{itemize}
		       	\item \textbf{Reduced switching costs:} Users don't have to give up preferred applications
		       	\item \textbf{Lower cognitive burden:} Integration with existing routines requires less learning
		       	\item \textbf{Increased visibility:} Background operation ensures the app is "present" during more drives
		       	\item \textbf{Contextual relevance:} Feedback appears when it's most relevant and actionable
		       \end{itemize}
		       
		       
		       To reduce switching costs, the following requirement addressed at the responsiveness of the UI emerges: 
		       \requirement{4.9}{The app should support to be used in split-screen modes by adapting the UI elements accordingly to be able to be used alongside other driving apps}
		       
	       
	       \subsection{Integration Challenges and Considerations}
		       % todo: Research these topics further using keywords such as "background service limitations android", "foreground service battery impact", "notification visibility during navigation", "android auto app categories", etc.
		       
		       \subsubsection{Background Services and Data Collection}
			       Several challenges exist for background data collection that must be considered in the theoretical design:
			       
			       \begin{itemize}
			       	\item Modern mobile operating systems restrict background operations to conserve battery
			       	\item Sensor access often requires foreground service notifications
			       	\item Apps may be suspended during extended periods of non-interaction
			       	\item Continuous detection of driving state can impact battery life
			       \end{itemize}
			       
			       % todo: Research papers on mobile sensing frameworks like "MobiSense", "SensorManager background collection android", "continuous sensing mobile applications", and "battery-efficient mobile sensing"
			       
		       \subsubsection{Notification Systems}
			       Effective notification design must balance visibility with non-intrusiveness:
			       
			       \begin{itemize}
			       	\item Different notification priority levels have varying degrees of visibility
			       	\item Navigation apps often take notification priority during driving
			       	\item Audio feedback must be balanced with other audio sources (music, navigation)
			       	\item User preferences for notification frequency vary widely
			       \end{itemize}
			       
			       % todo: Research using keywords like "driver notification design", "audio UI driving context", "non-intrusive driving alerts", and papers in journals like "Transportation Research Part F: Traffic Psychology and Behaviour"
			       
		       \subsubsection{Vehicle System Integration}
			       Integration with vehicle systems presents unique design considerations:
			       
			       \begin{itemize}
			       	\item Platform guidelines control what information can be displayed and how
			       	\item Information density is often limited for safety reasons
			       	\item Integration approaches vary significantly between vehicle manufacturers
			       	\item Feature compatibility depends on vehicle age and model
			       \end{itemize}
			       
			       % todo: Research using "Android Auto design guidelines", "Apple CarPlay third-party integration", "vehicle infotainment system integration", and publications from the Association for Computing Machinery's automotive UI conferences
			       
		\subsection{Reducing friction in On-boarding and feature discovery. }
		
      		Because 21\% of users abandon an app after one use\cite{ramelMobileAnalyticsFirm} and users abandoned the app because they needed an account before using the app \cite[Table 3]{kidmanWhenWhyAdults2024}, it clear that the initial user interaction is \textit{key} for making sure the user stays with the app. Therefore, we shall have the following requirement:
      		
      		\requirement{4.10}{The app shall allow the user to use its main features (except of course social) without creating an account first}
			
			Additionally, the step to guiding the user to full app usage is crucial:
		
			\cite{UserFrictionProduct} explains how a good on-boarding would look like by replacing bad friction with good friction:
			\begin{itemize}
				\item Self-service Support\cite{UserFrictionProduct} : Give the user some kind of checklist so that he can complete the on-boarding step by step, in the pace that he wants: \requirement{4.11}{The app should give the user a checklist to complete the on-boarding and explore all functionality step by step in his own pace}
				\item  Place user guidance in the right places\cite{UserFrictionProduct}: When teaching the user everything at the beginning, he might become overwhelmed and exit the app, however, when he lands at a point where he does not know how to use a certain feature, this might also cause him to exit the app. Therefore, the app should place user guidance where it is needed. For example, when the user visits the profile screen for the first time, then and only then should the app explain features related to the user profile to the user. This could also mean that little question-mark boxes are in more complex features to explain the right usage to the user when needs it.:
				\requirement{4.12}{The app should explain features not at the beginning but when the user first lands on them and have help boxes for complex features}
				\item On-boarding should happen step by step. The user shouldn't have to configure everything at the start. For example, the user should have the option to start a trip without connecting to an \ac{obd2} adapter immediately. However, some guidance should exist telling the user it would be good if he connected to an adapter for better tracking accuracy. Also, permissions should only be asked in that moment. Before, Bluetooth permission is not necessary, only when the use want to connect his adapter it will be necessary. Asking permissions only then will remove initial friction and make sense to the user immediately.
				\requirement{4.13}{The app should ask permissions only at the point which they are needed}
			\end{itemize}
			
			
			
			
	       
       \subsection{Requirement Summary}
	       
	       Table \ref{tab:seamless_integration_requirements} summaries the requirements which emerge from this section: 
	       
	       % Summarize requirements in a table at the end
	       \begin{table}[h]
	       	\small
	       	\centering
	       	\caption{Summary of Seamless Integration Requirements}
	       	\begin{tabular}{|p{2.3cm}|p{9cm}|p{2.5cm}|}
	       		\hline
	       		\textbf{Requirement} & \textbf{Description} & \textbf{Priority} \\
	       		\hline
	       		\traceref{REQ}{4.1} & The app shall be capable of collecting driving data while running in the background while other applications are in use & Mandatory \\
	       		\hline
	       		\traceref{REQ}{4.2} & The app shall minimize battery impact while running in the background & Mandatory \\
	       		\hline
	       		\traceref{REQ}{4.3} & The app shall follow established UI/UX guidelines to reduce adoption friction  & Mandatory \\
	       		\hline
	       		\traceref{REQ}{4.4} & The app should provide audio feedback options that don't require looking at the screen & Recommended \\
	       		\hline
	       		\traceref{REQ}{4.5} & The app should integrate with Android Auto and/or Apple CarPlay if technically feasible & Recommended \\
	       		\hline
	       		\traceref{REQ}{4.6} & The app shall store drive data locally to allow detailed post-drive feedback without requiring constant user attention during driving & Mandatory \\
	       		\hline
	       		\traceref{REQ}{4.7} & The app may provide a simplified widget or quick settings tile for users who prefer visual indicators & Optional \\
	       		\hline
	       		\traceref{REQ}{4.8} & The app should offer link-based access to a users profile and may provide an API for potential integration with ride-sharing platforms & Recommended \\
	       		\hline
	       		\traceref{REQ}{4.9} & The app should support to be used in split-screen modes by adapting the UI elements accordingly to be able to be used alongside other driving apps & Recommended \\
                \hline
                \traceref{REQ}{4.10} & The app shall allow the user to use its main features (except of course, social ones) without creating an account first & Mandatory \\
                \hline
                \traceref{REQ}{4.11} & The app should give the user a checklist to complete the on-boarding and explore all functionality step by step in his own pace & Recommended \\
                \hline
                \traceref{REQ}{4.12} & The app should explain features not at the beginning, but when the user first lands on them and have help boxes for complex features & Recommended \\
                \hline
                \traceref{REQ}{4.13} & The app should ask permissions only at the point which they are needed & Recommended \\
	       		
	       		%todo at rest of requirements here
	       		\hline
	       	\end{tabular}
	       	\label{tab:seamless_integration_requirements}
	       \end{table}
	
	
	\section{Privacy by Design: Open-source \& Offline-first Approach} \label{sec:privacydesign}
	
		\subsection{Privacy as an Adoption Enabler}
			While not identified as a primary focus area, privacy considerations represent a significant enabling factor for eco-driving application adoption. The literature review highlighted \traceref{LIM}{5} (Privacy and Data Security Concerns) as a potential barrier to user adoption. As \citeauthor{gilmanHowSupportFuelefficient2018} noted, addressing privacy concerns is a key area for future development in driving coach applications \cite[p. 640]{gilmanHowSupportFuelefficient2018}.
			
			% todo: Research privacy attitudes specifically in driving applications context
			% Research keywords: "location privacy concerns drivers", "vehicle data privacy attitudes", 
			% "driver monitoring privacy perceptions", "privacy-preserving vehicle sensing"
			% Look for papers in privacy journals, transportation journals with privacy sections, and surveys of driver attitudes
			
			Driving data is inherently sensitive, as it can reveal:
			\begin{itemize}
				\item Home, work, and frequently visited locations
				\item Daily routines and patterns
				\item Driving behavior that could potentially affect insurance rates
				\item Travel habits that might have other commercial value
			\end{itemize}
			
			Because Users value keeping this data private\cite[Table 3]{kidmanWhenWhyAdults2024}, this understanding suggests an important requirement:
			
			\requirement{5.1}{The app should follow privacy-by-design principles, minimizing data collection to only what is necessary for its core functionality and keeping it protected}
		
		\subsection{Offline-First Architecture}
			An offline-first approach means designing applications to function primarily without internet connectivity, with online features as enhancements rather than requirements. This architecture aligns perfectly with eco-driving applications, as the core functionality of tracking and providing feedback on driving behavior does not inherently require cloud connectivity.
			
			% todo: Research offline-first architectural patterns and their privacy benefits
			% Research keywords: "offline-first application architecture", "local-first software patterns", 
			% "privacy-preserving mobile sensing", "edge computing privacy benefits"
			% Look for technical papers from database conferences, privacy workshops, and mobile computing literature
			
			The key principles of an offline-first architecture include:
			\begin{itemize}
				\item Local data processing and storage as the default
				\item Syncing to cloud services only when explicitly requested by the user
				\item Functioning without internet connectivity, although some features might not be accessible
				\item Prioritizing on-device computation over server-side analysis
			\end{itemize}
			
			These principles lead to an additional requirement:
			
			\requirement{5.2}{The app shall process and store all driving data locally on the device by default, with cloud synchronization only as an opt-in feature}
		
		\subsection{Data Control and Transparency}
			Beyond the technical architecture, how privacy is communicated to users significantly impacts their trust and willingness to adopt an application. The concept of "privacy as control" suggests that users feel more comfortable when they have explicit control over their data and understand how it is being used.
			
			\citeauthor{kidmanWhenWhyAdults2024} found that users abandoned the app because they did not like sharing data with the app \cite[Table 3]{kidmanWhenWhyAdults2024}. This shows that it is essential to communicate to the user that their data is safe with the app, as some users might otherwise abandon the app because of privacy concerns.
			
			% todo: Research effective privacy communication strategies in mobile applications
			% Research keywords: "privacy communication UX patterns", "user-friendly privacy controls", 
			% "privacy transparency mobile apps", "GDPR privacy by design case studies"
			% Look for papers on usable privacy and security, HCI privacy research, and privacy policy effectiveness studies
			
			Effective privacy communication includes:
			\begin{itemize}
				\item Clear, non-technical explanations of data collection and usage
				\item Granular controls over what data is collected and shared
				\item Contextual privacy information provided at relevant moments
				\item Visual representations of data flows and privacy status
			\end{itemize}
			
			These considerations suggest further requirements:
			
			\requirement{5.3}{The app should provide clear, simple visualizations of what data is being collected and how it is being used}

            \cite{bemmannInfluenceTransparencyControl2022} found that data transparency without data controllability actually leads to less users[p. 18]\cite{bemmannInfluenceTransparencyControl2022}. When users find out how much data is actually being collected, they want to be able to control it. Data transparency should always come with data control options.Therefore the following requirement is essential:
			
			\requirement{5.4}{The app should offer privacy controls, allowing users to selectively enable or disable data collection and sharing features}
		
		\subsection{Open Source as a Trust Mechanism}
			Open-source development can serve as both a technical approach and a trust-building mechanism for privacy-conscious applications. By making code publicly available, developers create transparency that allows independent verification of privacy claims.
			
			% todo: Research the relationship between open source and user trust in privacy-sensitive applications
			% Research keywords: "open source privacy trust", "code transparency user perception", 
			% "open source as privacy guarantee", "verifiable privacy through open source"
			% Look for studies on open source adoption motivations, user trust factors, and privacy verification mechanisms
			
			Advantages of open-source development for privacy include:
			\begin{itemize}
				\item Independent code review possibilities
				\item Community verification of privacy claims
				\item Transparent evolution of privacy measures
				\item Reduced concerns about hidden data collection
			\end{itemize}
			
			This suggests a final requirement:
			
			\requirement{5.5}{The app should be developed as open-source software to provide transparency and enable verification of privacy claims}
			
			\subsection{Balancing Privacy with Social Features}
			A unique challenge for eco-driving applications is balancing privacy with the social and gamification features identified as key motivators in previous sections. Social comparison, leaderboards, and sharing accomplishments all involve some degree of data sharing.
			
			% todo: Research privacy-preserving approaches to social features in applications
			% Research keywords: "privacy-preserving social comparison", "anonymous leaderboards implementation", 
			% "differential privacy social features", "pseudonymous social interaction"
			% Look for papers on privacy in social computing, anonymization techniques, and social gaming privacy
			
			Potential approaches include:
			\begin{itemize}
				\item Using differential privacy techniques for leaderboards and statistics
				\item Offering pseudonymous profiles for social features
				\item Providing clear, contextual privacy controls for each social interaction
				\item Creating "local" social comparisons that don't require centralized data 
				
			\end{itemize}
			
			\requirement{5.6}{The app may implement privacy-preserving versions of social features, using techniques like differential privacy and pseudonymous profiles}
		
		\subsection{Implementation Considerations}
			From a technical perspective, several implementation choices can support the privacy-by-design approach:
			
			\begin{itemize}
				\item Local databases (like SQLite or Room DB on Android) for secure, on-device storage
				\item On-device machine learning for behavior analysis without data transmission
				\item Secure export mechanisms for user-controlled data sharing
				\item Local computation of comparative statistics where possible
				\item Only sharing aggregated data to the server, not the granular source
			\end{itemize}
			
			% todo: Research specific technologies and libraries for privacy-preserving local analytics
			% Research keywords: "on-device machine learning libraries", "private analytics implementation", 
			% "secure local storage mobile", "privacy-preserving sensing frameworks"
			% Look for technical documentation, mobile development guides, and privacy engineering papers
			
			To fully implement the privacy-by-design approach while supporting the social features necessary for user engagement, a hybrid architecture is likely optimal. This would involve primarily local processing with optional, clearly disclosed, and user-controlled data sharing for specific social features.
			
			\begin{table}[h]
				\small
				\centering
				\caption{Summary of Privacy by Design Requirements}
				\begin{tabular}{|p{2.3cm}|p{9cm}|p{2.5cm}|}
					\hline
					\textbf{Requirement} & \textbf{Description} & \textbf{Priority} \\
					\hline
					\traceref{REQ}{5.1} & The app should follow privacy-by-design principles, minimizing data collection to only what is necessary for its core functionality & Recommended \\
					\hline
					\traceref{REQ}{5.2} & The app shall process and store all driving data locally on the device by default, with cloud synchronization only as an opt-in feature & Mandatory \\
					\hline
					\traceref{REQ}{5.3} & The app should provide clear, simple visualizations of what data is being collected and how it is being used & Recommended \\
					\hline
					\traceref{REQ}{5.4} & The app should offer granular privacy controls, allowing users to selectively enable or disable specific data collection features & Recommended \\
					\hline
					\traceref{REQ}{5.5} & The app should be developed as open-source software to provide transparency and enable verification of privacy claims & Recommended \\
					\hline
					\traceref{REQ}{5.6} & The app may implement privacy-preserving versions of social features, using techniques like differential privacy and pseudonymous profiles & Optional \\
					\hline
				\end{tabular}
				\label{tab:privacy_requirements}
			\end{table}
			
	


################################################################################
FILE: prefix/titel.tex
################################################################################

\begin{center}
	\begin{tabular}{p{\textwidth}}
		\noindent
		
				\includegraphics[scale=0.05]{img/logo_dh.png}
		
		\\
		
		\vspace{1cm}
		
		\begin{center}
			\LARGE{\textsc{
					Enhancing Sustainable Driving Through Offline-First and Privacy-Conscious Gamified Applications
					\\
			}}
		\end{center}
		\\
		
		
		\begin{center}
			\large{Dualen Hochschule  \\
				Baden-Württemberg Mannheim \\}
		\end{center}
		
		\\
		
		
		\begin{center}
		\textbf{\Large{Studienarbeit}} \\ by \\ \large{\textbf{Max Stege \& Jonas Strabel}}	
		\end{center}
		
		
		\begin{center}
			\large{todo}
		\end{center}
		
		\\
		
		\begin{center}
			\begin{tabular}{lll}
				\textbf{Period}         &  & Kurz vor Abgabe           \\
				\textbf{Matriculation number, course}         &  & todo wie dein template hier?, TINF22AI2               \\
				\textbf{Dual Partner}               &  & Roche Diagnostics GmbH, Mannheim \\
				\textbf{Supervisor} &  & Holger Hofmann                   \\
				\textbf{Supervisor's signature}        &  & \hrulefill                       \\
			\end{tabular}
		\end{center}
	\end{tabular}
\end{center}

################################################################################
FILE: prefix/abstract.tex
################################################################################



\addsec{Abstract} %todo dont focus too much on 'inconsistency'
\label{sec:abstract}


################################################################################
FILE: prefix/preface.tex
################################################################################


\minisec{Declaration of Academic Integrity}


I hereby confirm that I have independently written this final thesis and have only used the sources and tools that I have indicated. Both the content and any directly quoted material have been clearly identified as such. This work has not been presented to any other examination committee in this or a similar form. \\
\\[1.5cm]
Datum:	\hrulefill\enspace Signature: \hrulefill
\\[3.5cm]


I hereby confirm that I have independently written this final thesis and have only used the sources and tools that I have indicated. Both the content and any directly quoted material have been clearly identified as such. This work has not been presented to any other examination committee in this or a similar form. \\
\\[1.5cm]
Datum:	\hrulefill\enspace Signature: \hrulefill
\\[3.5cm]

\newpage




% gender explaimer not necessary cause its in english 


################################################################################
FILE: suffix/suffix.tex
################################################################################


\minisec{Primary Authorship}

    This section highlights the primary Authorship of each Section / Chapter (This does not mean that the author is the \textit{only} contributor to this Section / Chapter.

    \begin{itemize}
        
        \item \textbf{Chapter 1} Jonas Strabel
        \item \textbf{Chapter 2} Jonas Strabel \& Max Stege
        \item \textbf{Chapter 3} Jonas Strabel
        \item \textbf{Section 4.1} Jonas Strabel
        \item \textbf{Section 4.2} Max Stege
        \item \textbf{Section 4.3} Max Stege
        \item \textbf{Section 4.4} Jonas Strabel
        \item \textbf{Section 4.5} Jonas Strabel
        %\item \textbf{Chapter 5 - Technical Foundations} Max Stege %todo ? Or kick out
        \item \textbf{Chapter 5} Jonas Strabel
        \item \textbf{Chapter 6} Jonas Strabel \& Max Stege
        \item \textbf{Chapter 7} Max Stege
        \item \textbf{Chapter 8} Max Stege \& Jonas Strabel
        
    \end{itemize}


\newpage

\minisec{Utilized Tools}
	
    During the research and writing process of this thesis, several tools were utilized to enhance productivity and facilitate various tasks. The tools include:
    
    \begin{itemize} 
        \item Google, Perplexity, ChatGPT, Grok, DHBW Library and Google Scholar: These search engines / tools were used to gather relevant information and conduct research on the topic.  
        \item Zotero: Zotero was used for source management and citation, ensuring proper referencing throughout the thesis. 
        \item Overleaf: Overleaf, a LaTeX editor, was used for writing and formatting the thesis. 
        \item LLM's: LLM's such as Claude or Gemini were utilized for brainstorming and refining text grammar and word choices. 
        \item V0: V0 was used to create Mock-Ups for the application.
        \item Linguee: Linguee, a dictionary tool, was used for translating words as needed. 
        
    \end{itemize}
	
    These tools served specific purposes in the research and writing process, enabling efficient information gathering, source management, collaboration, and language refinement. The ideas and the development of this thesis are however the original work of the authors.



\newpage





================================================================================
SUMMARY
================================================================================

Total files found: 219
Files processed: 219
Files skipped: 0
